<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<link href="https://i.postimg.cc/CMZqNMRh/IMG-6497.jpg" rel="apple-touch-icon"/>
<meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/>
<title>EPhone</title>
<script src="https://unpkg.com/dexie/dist/dexie.js"></script>
<script>// === 内嵌压缩版 pp.js 开始 ===
(function (window) { ('use strict'); function injectStyles() { const styleId = 'x-social-app-styles'; if (document.getElementById(styleId)) return; const style = document.createElement('style'); style.id = styleId; style.textContent = ` #x-social-screen { --x-bg-primary: #000; --x-bg-secondary: #1a1a1a; --x-bg-hover: rgba(255,255,255,0.03); --x-border-color: #2f3336; --x-text-primary: #fff; --x-text-secondary: #71767b; --x-text-tertiary: #8b98a5; --x-accent: #1d9bf0; --x-input-bg: #1a1a1a; --x-modal-overlay: rgba(91, 112, 131, 0.4); } #x-social-screen.x-theme-light { --x-bg-primary: #fff; --x-bg-secondary: #f7f9f9; --x-bg-hover: rgba(0,0,0,0.03); --x-border-color: #eff3f4; --x-text-primary: #0f1419; --x-text-secondary: #536471; --x-text-tertiary: #5b7083; --x-accent: #1d9bf0; --x-input-bg: #f7f9f9; --x-modal-overlay: rgba(0, 0, 0, 0.4); } .tab-content::-webkit-scrollbar, #x-comments-page::-webkit-scrollbar, .comments-container::-webkit-scrollbar, .settings-content::-webkit-scrollbar, .profile-content::-webkit-scrollbar, .tweets-container::-webkit-scrollbar, #detail-comments-container::-webkit-scrollbar, .modal-body::-webkit-scrollbar, #identity-characters-list::-webkit-scrollbar, #characters-list::-webkit-scrollbar, #x-presets-list::-webkit-scrollbar, .tweet-media-scrollable::-webkit-scrollbar { width: 3px; } .tab-content::-webkit-scrollbar-track, #x-comments-page::-webkit-scrollbar-track, .comments-container::-webkit-scrollbar-track, .settings-content::-webkit-scrollbar-track, .profile-content::-webkit-scrollbar-track, .tweets-container::-webkit-scrollbar-track, #detail-comments-container::-webkit-scrollbar-track, .modal-body::-webkit-scrollbar-track, #identity-characters-list::-webkit-scrollbar-track, #characters-list::-webkit-scrollbar-track, #x-presets-list::-webkit-scrollbar-track, .tweet-media-scrollable::-webkit-scrollbar-track { background: transparent; } .tab-content::-webkit-scrollbar-thumb, #x-comments-page::-webkit-scrollbar-thumb, .comments-container::-webkit-scrollbar-thumb, .settings-content::-webkit-scrollbar-thumb, .profile-content::-webkit-scrollbar-thumb, .tweets-container::-webkit-scrollbar-thumb, #detail-comments-container::-webkit-scrollbar-thumb, .modal-body::-webkit-scrollbar-thumb, #identity-characters-list::-webkit-scrollbar-thumb, #characters-list::-webkit-scrollbar-thumb, #x-presets-list::-webkit-scrollbar-thumb, .tweet-media-scrollable::-webkit-scrollbar-thumb { background-color: color-mix(in srgb, var(--x-accent) 50%, transparent); border-radius: 10px; min-height: 30px; max-height: 80px; } .tab-content::-webkit-scrollbar-thumb:hover, #x-comments-page::-webkit-scrollbar-thumb:hover, .comments-container::-webkit-scrollbar-thumb:hover, .settings-content::-webkit-scrollbar-thumb:hover, .profile-content::-webkit-scrollbar-thumb:hover, .tweets-container::-webkit-scrollbar-thumb:hover, #detail-comments-container::-webkit-scrollbar-thumb:hover, .modal-body::-webkit-scrollbar-thumb:hover, #identity-characters-list::-webkit-scrollbar-thumb:hover, #characters-list::-webkit-scrollbar-thumb:hover, #x-presets-list::-webkit-scrollbar-thumb:hover, .tweet-media-scrollable::-webkit-scrollbar-thumb:hover { background-color: color-mix(in srgb, var(--x-accent) , 0.8); } .tab-content::-webkit-scrollbar-thumb:active, #x-comments-page::-webkit-scrollbar-thumb:active, .comments-container::-webkit-scrollbar-thumb:active, .settings-content::-webkit-scrollbar-thumb:active, .profile-content::-webkit-scrollbar-thumb:active, .tweets-container::-webkit-scrollbar-thumb:active, #detail-comments-container::-webkit-scrollbar-thumb:active, .modal-body::-webkit-scrollbar-thumb:active, #identity-characters-list::-webkit-scrollbar-thumb:active, #characters-list::-webkit-scrollbar-thumb:active, #x-presets-list::-webkit-scrollbar-thumb:active, .tweet-media-scrollable::-webkit-scrollbar-thumb:active { background-color: var(--x-accent); } #x-social-screen { height: 100vh !important; overflow: hidden !important; background-color:var(--x-bg-primary) !important; color:var(--x-text-primary) !important; } #x-social-screen .x-pages-container { min-height: 0 !important; background-color:var(--x-bg-primary) !important; } #x-social-screen .x-page { min-height: 0 !important; background-color:var(--x-bg-primary) !important; } #x-social-screen .x-bottom-nav { flex-shrink: 0 !important; background-color:var(--x-bg-primary) !important; border-top: 1px solid var(--x-border-color) !important; } #x-home-page, #x-search-page, #x-notifications-page, #x-messages-page, #x-comments-page, #x-settings-page, #x-tweet-detail-page, #x-profile-page, #account-profile-page { background-color:var(--x-bg-primary) !important; } #x-social-screen .x-top-bar, #x-social-screen .comments-header, #x-social-screen .settings-header, #x-social-screen .profile-header, #x-social-screen .tweet-detail-header { background-color:var(--x-bg-primary) !important; border-bottom: 1px solid var(--x-border-color) !important; } #x-social-screen .x-home-tabs, #x-social-screen .search-tabs, #x-social-screen .profile-tabs { background-color:var(--x-bg-primary) !important; border-bottom: 1px solid var(--x-border-color) !important; } #x-social-screen .comment-input-area, #x-social-screen .detail-comment-input-area { background-color:var(--x-bg-primary) !important; border-top: 1px solid var(--x-border-color) !important; } #x-social-screen .settings-content { background-color:var(--x-bg-primary) !important; } #x-social-screen .search-header { background-color:var(--x-bg-primary) !important; border-bottom: 1px solid var(--x-border-color) !important; } #x-social-screen .search-box { background-color: var(--x-input-bg) !important; } #trending-view, #x-social-screen .trending-list { background-color:var(--x-bg-primary) !important; } #search-results-content { background-color:var(--x-bg-primary) !important; } #x-social-screen .modal-content, #x-social-screen .compose-modal-content, #x-social-screen #edit-profile-modal .modal-content, #x-social-screen #compose-tweet-modal .compose-modal-content, #character-x-profile-modal > div > div, #relationship-modal > div > div, #category-manager-modal > div, #character-relationship-graph-modal > div > div, #edit-relationship-detail-modal > div > div, #npc-edit-modal > div > div { background-color:var(--x-bg-primary) !important; } #x-social-screen .modal-header, #x-social-screen .compose-header { background-color:var(--x-bg-primary) !important; border-bottom: 1px solid var(--x-border-color) !important; } #x-social-screen .modal-body, #x-social-screen .compose-body { background-color:var(--x-bg-primary) !important; } #x-social-screen input[type="text"], #x-social-screen input[type="url"], #x-social-screen input[type="email"], #x-social-screen textarea, #x-social-screen select { background-color: var(--x-input-bg) !important; border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; } #x-social-screen input[type="text"]:focus, #x-social-screen input[type="url"]:focus, #x-social-screen input[type="email"]:focus, #x-social-screen textarea:focus, #x-social-screen select:focus { border-color: var(--x-accent) !important; } #x-social-screen .quoted-tweet { border-color: var(--x-border-color) !important; background-color: var(--x-bg-hover) !important; } #x-social-screen .comment-item.has-replies::after, #x-social-screen .reply-item::before { background-color: var(--x-border-color) !important; border-color: var(--x-border-color) !important; } #character-info-display, #character-relationships-list, #identity-characters-list, #characters-list, #npcs-list, #npc-bind-users { background-color: var(--x-input-bg) !important; border-color: var(--x-border-color) !important; } #x-social-screen .tab-content, #x-social-screen .tweets-container, #x-social-screen .comments-container, #detail-comments-container, #tweet-detail-container, #x-profile-tweets-container, #account-tweets-container, #x-social-screen .profile-content { background-color:var(--x-bg-primary) !important; } #x-social-screen .tweet-item:hover, #x-social-screen .comment-item:hover, #x-social-screen .trending-item:hover { background-color: var(--x-bg-hover) !important; } #x-social-screen .user-info-section, #x-social-screen .edit-avatar-section, #x-social-screen .edit-form-section { background-color:var(--x-bg-primary) !important; } #character-binding-area > div, #relationship-binding-area > div, #npc-binding-area > div { background-color: var(--x-input-bg) !important; border-color: var(--x-border-color) !important; } #x-social-screen .trending-item { background-color:var(--x-bg-primary) !important; } #x-social-screen .tweet-detail-content { background-color:var(--x-bg-primary) !important; } #x-social-screen span, #x-social-screen div:not(.tweet-action):not(.comment-action) { color: inherit; } #x-social-screen .x-tab { color:var(--x-text-secondary) !important; } #x-social-screen .x-tab.active { color:var(--x-text-primary) !important; } #x-social-screen .x-back-btn svg, #x-social-screen .x-settings svg, #x-social-screen .x-refresh-btn svg, #x-social-screen .settings-back-btn svg, #x-social-screen .comments-back-btn svg, #x-social-screen .profile-back-btn svg, #x-social-screen .tweet-detail-back-btn svg { fill: var(--x-text-primary) !important; } #x-social-screen .tweet-more { color:var(--x-text-secondary) !important; } #x-social-screen button { color: inherit; } #x-social-screen ::placeholder { color:var(--x-text-secondary) !important; } .tweet-time, .tweet-user-handle, .comment-time, .quoted-user-handle, .quoted-user-time { color:var(--x-text-secondary) !important; } .tweet-user-name, .tweet-content, .comment-content, .quoted-user-name, .quoted-content { color:var(--x-text-primary) !important; } .trending-title { color:var(--x-text-primary) !important; } .trending-category, .trending-count { color:var(--x-text-secondary) !important; } #relationship-preview { background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; } #relationship-graph-canvas { background-color:var(--x-bg-primary) !important; } #account-tweets-container span[style*="color: #fff"], #account-tweets-container span[style*="color:#fff"], #account-tweets-container span[style*="color: rgb(255, 255, 255)"] { color:var(--x-text-primary) !important; } #account-tweets-container span[style*="color: #71767b"], #account-tweets-container span[style*="color:#71767b"] { color:var(--x-text-secondary) !important; } #account-tweets-container div[style*="color: #fff"], #account-tweets-container div[style*="color:#fff"], #account-tweets-container div[style*="color: #e7e9ea"], #account-tweets-container div[style*="color:#e7e9ea"] { color:var(--x-text-primary) !important; } #account-tweets-container div[style*="color: #71767b"], #account-tweets-container div[style*="color:#71767b"] { color:var(--x-text-secondary) !important; } #account-tweets-container > div[style*="border-bottom"] { border-bottom-color: var(--x-border-color) !important; } #account-tweets-container div[style*="background-color: #202327"], #account-tweets-container div[style*="background-color:#202327"] { background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; } #account-tweets-container svg[style*="fill: currentColor"] { fill: currentColor !important; } #account-tweets-container svg[style*="fill: #71767b"], #account-tweets-container svg[style*="fill:#71767b"] { fill: var(--x-text-secondary) !important; } #detail-comments-container span[style*="color: #fff"], #detail-comments-container span[style*="color:#fff"] { color:var(--x-text-primary) !important; } #detail-comments-container span[style*="color: #71767b"], #detail-comments-container span[style*="color:#71767b"] { color:var(--x-text-secondary) !important; } #detail-comments-container div[style*="color: #fff"], #detail-comments-container div[style*="color:#fff"] { color:var(--x-text-primary) !important; } #detail-comments-container div[style*="color: #71767b"], #detail-comments-container div[style*="color:#71767b"] { color:var(--x-text-secondary) !important; } #detail-comments-container div[style*="border-bottom"] { border-bottom-color: var(--x-border-color) !important; } #detail-comments-container div[style*="background-color: #2f3336"], #detail-comments-container div[style*="background-color:#2f3336"] { background-color: var(--x-border-color) !important; } #detail-comments-container div[style*="background-color: #202327"], #detail-comments-container div[style*="background-color:#202327"], #detail-comments-container div[style*="background-color: #1a1a1a"], #detail-comments-container div[style*="background-color:#1a1a1a"] { background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; } #tweet-detail-container span[style*="color: #fff"], #tweet-detail-container span[style*="color:#fff"] { color:var(--x-text-primary) !important; } #tweet-detail-container span[style*="color: #71767b"], #tweet-detail-container span[style*="color:#71767b"] { color:var(--x-text-secondary) !important; } #tweet-detail-container div[style*="color: #fff"], #tweet-detail-container div[style*="color:#fff"] { color:var(--x-text-primary) !important; } #tweet-detail-container div[style*="color: #71767b"], #tweet-detail-container div[style*="color:#71767b"] { color:var(--x-text-secondary) !important; } #tweet-detail-container div[style*="border-bottom"], #tweet-detail-container div[style*="border-top"] { border-color: var(--x-border-color) !important; } #account-tweets-container div[style*="cursor: pointer"], #detail-comments-container div[style*="cursor: pointer"], #tweet-detail-container div[style*="cursor: pointer"] { color: inherit !important; } span[style*="color: var(--x-accent)"], span[style*="color:#1d9bf0"], div[style*="color: var(--x-accent)"], div[style*="color:#1d9bf0"] { color: var(--x-accent) !important; } #account-tweets-container span[style*="color: #71767b"][style*="font-size: 13px"][style*="font-weight: 700"] { color:var(--x-text-secondary) !important; } #account-tweets-container span[style*="font-size: 13px"]:not([style*="font-weight"]) { color:var(--x-text-secondary) !important; } #character-x-profile-modal[style*="background-color: rgba(0,0,0,0.8)"], #relationship-modal[style*="background-color: rgba(0,0,0,0.8)"] { background-color: rgba(0,0,0,0.6) !important; } #character-x-profile-modal > div > div[style*="background-color:#000"], #relationship-modal > div > div[style*="background-color:#000"] { background-color:var(--x-bg-primary) !important; border-color: var(--x-border-color) !important; } #character-x-profile-modal h2, #character-x-profile-modal h3, #relationship-modal h3 { color:var(--x-text-primary) !important; } #character-x-profile-modal button[onclick*="close"] svg, #relationship-modal button[onclick*="close"] svg { fill: var(--x-text-secondary) !important; } #character-x-profile-modal div[style*="border-bottom: 1px solid #333"], #character-x-profile-modal div[style*="border: 1px solid #333"], #relationship-modal div[style*="border-bottom: 1px solid #333"] { border-color: var(--x-border-color) !important; } #character-info-display[style*="background-color: #0a0a0a"] { background-color:var(--x-bg-secondary) !important; } #character-x-profile-modal label, #relationship-modal label { color:var(--x-text-primary) !important; } #character-x-profile-modal div[style*="color: #71767b"], #relationship-modal div[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #character-x-profile-modal input[type="text"], #character-x-profile-modal input[type="url"], #character-x-profile-modal textarea, #character-x-profile-modal select, #relationship-modal input[type="text"], #relationship-modal textarea, #relationship-modal select { background-color: var(--x-input-bg) !important; border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; } #character-x-profile-modal input:focus, #character-x-profile-modal textarea:focus, #character-x-profile-modal select:focus, #relationship-modal input:focus, #relationship-modal textarea:focus, #relationship-modal select:focus { border-color: var(--x-accent) !important; } #character-x-avatar, #character-x-cover-preview { border-color: var(--x-border-color) !important; } #character-x-avatar { object-fit: cover !important; overflow: hidden !important; box-sizing: border-box !important; } #character-x-profile-modal span[style*="color: #fff"], #relationship-modal span[style*="color: #fff"] { color:var(--x-text-primary) !important; } #character-x-profile-modal span[style*="color: #71767b"], #relationship-modal span[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #character-x-profile-modal div[style*="background-color: color-mix(in srgb, var(--x-accent) , 0.1)"] { background-color: color-mix(in srgb, var(--x-accent) , 0.1) !important; border-color: var(--x-accent) !important; } #character-x-profile-modal div[style*="color: var(--x-accent)"] { color: var(--x-accent) !important; } #character-x-profile-modal button[type="button"][style*="background-color: transparent"], #relationship-modal button[type="button"][style*="background-color: transparent"] { border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; } .settings-header[style*="background-color:#000"] { background-color:var(--x-bg-primary) !important; border-bottom-color: var(--x-border-color) !important; } .settings-header span[style*="color: #fff"] { color:var(--x-text-primary) !important; } .settings-back-btn svg[style*="fill: #fff"] { fill: var(--x-text-primary) !important; } #theme-icon-dark[style*="fill: #fff"] { fill: var(--x-text-primary) !important; } #theme-icon-light[style*="fill: #000"] { fill: var(--x-text-primary) !important; } #x-settings-page label { color:var(--x-text-primary) !important; } #x-settings-page p[style*="color: #71767b"], #x-settings-page div[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #x-settings-page textarea, #x-settings-page input[type="text"] { background-color: var(--x-input-bg) !important; border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; } #x-settings-page textarea:focus, #x-settings-page input:focus { border-color: var(--x-accent) !important; } #x-settings-page div[style*="background-color: #1a1a1a"] { background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; } #x-settings-page div[style*="border: 1px solid #333"], #x-settings-page div[style*="border-bottom: 1px solid #333"], #x-settings-page div[style*="border-top: 1px solid #333"] { border-color: var(--x-border-color) !important; } #relationship-preview[style*="background-color: #0a0a0a"] { background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; } #relationship-preview-placeholder { color:var(--x-text-secondary) !important; } #relationship-stats[style*="background-color: color-mix(in srgb, var(--x-accent) , 0.1)"] { background-color: color-mix(in srgb, var(--x-accent) , 0.1) !important; } #relationship-stats div[style*="color: var(--x-accent)"] { color: var(--x-accent) !important; } #x-social-screen .toggle-switch[style*="background-color: #333"] { background-color: var(--x-border-color) !important; } #x-social-screen .toggle-circle[style*="background-color:#fff"] { background-color:var(--x-text-primary) !important; } #x-settings-page div[style*="color: #fff"] { color:var(--x-text-primary) !important; } #x-social-screen .preset-management h3 { color:var(--x-text-primary) !important; } #npcs-list, #characters-list { background-color: transparent !important; } #x-social-screen .x-nav-item svg { fill: var(--x-text-secondary) !important; } #x-social-screen .x-nav-item.active svg { fill: var(--x-accent) !important; } #x-social-screen .x-nav-item .nav-highlight { background-color: var(--x-accent) !important; } #x-social-screen .compose-btn { background-color: var(--x-accent) !important; } #x-profile-main-avatar { border: 5px solid var(--x-bg-primary) !important; object-fit: cover !important; background-color:var(--x-bg-primary) !important; box-sizing: border-box !important; overflow: hidden !important; } #edit-main-avatar { border: 4px solid var(--x-bg-primary) !important; object-fit: cover !important; background-color:var(--x-bg-primary) !important; box-sizing: border-box !important; overflow: hidden !important; } #account-avatar-image { border: 4px solid var(--x-bg-primary) !important; object-fit: cover !important; background-color:var(--x-bg-primary) !important; box-sizing: border-box !important; overflow: hidden !important; } #x-profile-user-name, #x-profile-following-count, #x-profile-followers-count { color:var(--x-text-primary) !important; } #x-profile-bio { color:var(--x-text-primary) !important; } .user-info-section button { color:var(--x-text-primary) !important; border-color: var(--x-border-color) !important; } #character-info-display div[style*="color: #fff"] { color:var(--x-text-primary) !important; } #character-info-display div[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #search-results-content > div[style*="border-bottom: 1px solid #2f3336"] { border-bottom-color: var(--x-border-color) !important; } #search-results-content span[style*="color: #fff"] { color:var(--x-text-primary) !important; } #search-results-content div[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #search-results-content div[style*="color: #e7e9ea"] { color:var(--x-text-primary) !important; } #npc-edit-modal > div[style*="background-color:#000"] { background-color:var(--x-bg-primary) !important; } #npc-edit-modal div[style*="border-bottom: 1px solid #2f3336"] { border-bottom-color: var(--x-border-color) !important; } #npc-modal-title { color:var(--x-text-primary) !important; } #npc-edit-modal svg[style*="fill: #fff"] { fill: var(--x-text-primary) !important; } #npc-edit-modal label { color:var(--x-text-secondary) !important; } #npc-edit-modal input, #npc-edit-modal textarea { background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; } #npc-edit-modal input:focus, #npc-edit-modal textarea:focus { border-color: var(--x-accent) !important; } #npc-bind-users { background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; } #npcs-list > div[style*="background-color: #0a0a0a"] { background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; } #npcs-list div[style*="color: #fff"] { color:var(--x-text-primary) !important; } #npcs-list div[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #npcs-list > div[style*="border: 1px solid #2f3336"] { border-color: var(--x-border-color) !important; } #npcs-list p[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #relationship-binding-area > div[style*="background-color: #1a1a1a"] { background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; } #relationship-binding-area div[style*="color: #fff"] { color:var(--x-text-primary) !important; } #relationship-binding-area div[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #relationship-links-list > div[style*="background-color: #1a1a1a"] { background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; } #relationship-links-list span[style*="color: #fff"] { color:var(--x-text-primary) !important; } #relationship-links-list span[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #relationship-links-list div[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #relationship-links-list div[style*="border-top: 1px solid #2f3336"] { border-top-color: var(--x-border-color) !important; } #relationship-links-list > div[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #relationship-detail-modal > div > div[style*="background-color:#000"] { background-color:var(--x-bg-primary) !important; border-color: var(--x-border-color) !important; } #relationship-detail-modal h3, #relationship-detail-modal label { color:var(--x-text-primary) !important; } #relationship-detail-modal div[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #relationship-detail-modal input, #relationship-detail-modal textarea, #relationship-detail-modal select { background-color: var(--x-input-bg) !important; border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; } #relationship-detail-modal input:focus, #relationship-detail-modal textarea:focus, #relationship-detail-modal select:focus { border-color: var(--x-accent) !important; } #relationship-detail-modal div[style*="border: 1px solid #333"], #relationship-detail-modal div[style*="border-bottom: 1px solid #333"] { border-color: var(--x-border-color) !important; } #relationship-detail-modal button[onclick*="close"] svg { fill: var(--x-text-secondary) !important; } #character-relationship-graph-modal > div[style*="background-color:#000"] { background-color:var(--x-bg-primary) !important; border-color: var(--x-border-color) !important; } #character-relationship-graph-modal h2 { color:var(--x-text-primary) !important; } #character-relationship-graph-modal div[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #character-relationship-graph-modal svg[style*="fill: #fff"] { fill: var(--x-text-primary) !important; } #character-relationship-graph-modal div[style*="background-color: #0a0a0a"] { background-color:var(--x-bg-secondary) !important; } #character-relationship-graph-modal > div > div:nth-child(2) div[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #character-relationship-graph-modal div[style*="height: 500px"][style*="background-color:#000"] { background-color:var(--x-bg-primary) !important; } #graph-empty-state svg { fill: var(--x-border-color) !important; } #character-relationship-graph-modal > div > div:last-child[style*="background-color:#000"] { background-color:var(--x-bg-primary) !important; } #character-relationship-graph-modal button[onclick*="closeCharacter"] { border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; } #character-relationship-graph-modal div[style*="padding: 12px 20px"] div[style*="color: #fff"] { color:var(--x-text-primary) !important; } #character-relationship-graph-modal div[style*="border: 1px solid #333"], #character-relationship-graph-modal div[style*="border-bottom: 1px solid #333"] { border-color: var(--x-border-color) !important; } #character-relationship-graph-modal > div[style*="border: 1px solid #333"] { border-color: var(--x-border-color) !important; } #graph-empty-state div[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #relationship-links-list-container h3 { color:var(--x-text-primary) !important; } #relationship-links-list div[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #edit-relationship-detail-modal[style*="background-color: rgba(0, 0, 0"] { background-color: rgba(0, 0, 0, 0.85) !important; } #edit-relationship-detail-modal > div > div[style*="background-color:#000"] { background-color:var(--x-bg-primary) !important; border-color: var(--x-border-color) !important; } #edit-relationship-detail-modal h3 { color:var(--x-text-primary) !important; } #edit-relationship-detail-modal label { color:var(--x-text-primary) !important; } #edit-relationship-detail-modal div[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #relationship-characters-info { background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; } #char-a-name, #char-b-name { color:var(--x-text-primary) !important; } #relationship-characters-info div[style*="color: #71767b"] { color:var(--x-text-secondary) !important; } #edit-relationship-detail-modal svg[style*="fill: #fff"] { fill: var(--x-text-primary) !important; } #edit-relationship-detail-modal input, #edit-relationship-detail-modal textarea { background-color: var(--x-input-bg) !important; border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; } #edit-relationship-detail-modal input:focus, #edit-relationship-detail-modal textarea:focus { border-color: var(--x-accent) !important; } #edit-relationship-detail-modal div[style*="border: 1px solid #333"], #edit-relationship-detail-modal div[style*="border-bottom: 1px solid #333"] { border-color: var(--x-border-color) !important; } #edit-relationship-detail-modal button[onclick*="close"] svg { fill: var(--x-text-secondary) !important; } #x-social-screen .profile-tab.active { color:var(--x-text-primary) !important; font-weight: 700 !important; } #x-social-screen .profile-tab:not(.active) { color:var(--x-text-secondary) !important; } #x-profile-header-name { color:var(--x-text-primary) !important; } #x-social-screen .profile-header svg { fill: var(--x-text-primary) !important; } #x-social-screen .profile-back-btn svg { fill: var(--x-text-primary) !important; } #x-profile-page .profile-header > div > div svg { fill: var(--x-text-primary) !important; } .tweet-detail-header { background-color:var(--x-bg-primary) !important; border-bottom: 1px solid var(--x-border-color) !important; } .tweet-detail-header span { color:var(--x-text-primary) !important; } .tweet-detail-header svg, .tweet-detail-back-btn svg { fill: var(--x-text-primary) !important; } #x-tweet-detail-page { background-color:var(--x-bg-primary) !important; } #tweet-detail-container { background-color:var(--x-bg-primary) !important; } .tweet-detail-content { background-color:var(--x-bg-primary) !important; } #tweet-detail-container .tweet-user-name, #tweet-detail-container .tweet-content, #x-tweet-detail-page .tweet-user-name, #x-tweet-detail-page .tweet-content { color:var(--x-text-primary) !important; } #detail-comments-container { background-color:var(--x-bg-primary) !important; } #detail-comments-container .comment-content, #detail-comments-container .tweet-user-name, #x-tweet-detail-page .comment-user-name { color:var(--x-text-primary) !important; } #tweet-detail-container .tweet-time, #tweet-detail-container .tweet-user-handle, #detail-comments-container .tweet-user-handle, #detail-comments-container .comment-time, #x-tweet-detail-page .tweet-time, #x-tweet-detail-page .tweet-user-handle { color:var(--x-text-secondary) !important; } .detail-comment-input-area { background-color:var(--x-bg-primary) !important; border-top: 1px solid var(--x-border-color) !important; } .detail-comment-input-area textarea { background-color: var(--x-input-bg) !important; color:var(--x-text-primary) !important; border-color: var(--x-border-color) !important; } #reroll-replies-btn svg, .refresh-btn svg, #x-tweet-detail-page .refresh-btn svg { fill: var(--x-text-primary) !important; } #x-tweet-detail-page span, #tweet-detail-container span { color: inherit; } .comments-container, .settings-content, .profile-content, .tab-content { min-height: 0 !important; } .tweets-container { overflow-y: auto; min-height: 0; } .comment-user-info { display: flex !important; align-items: center !important; gap: 4px !important; } .comment-delete-btn:hover { background-color: rgba(239, 68, 68, 0.1) !important; } .comment-delete-btn svg { transition: fill 0.2s ease; } .comment-delete-btn:hover svg { fill: #dc2626 !important; } .persona-setting-btn { box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); } .persona-setting-btn:hover { box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); } .persona-setting-btn:active { transform: scale(0.95) !important; } #x-social-screen .tweet-item { padding: 15px; border-bottom: 1px solid var(--x-border-color); display: flex; gap: 12px; background-color:var(--x-bg-primary); } #x-social-screen .tweet-avatar { width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0; } #x-social-screen .tweet-main { flex: 1; min-width: 0; } #x-social-screen .tweet-user-info { display: flex; align-items: center; gap: 5px; margin-bottom: 5px; } #x-social-screen .tweet-user-name { font-weight: 700; color:var(--x-text-primary); font-size: 15px; } #x-social-screen .tweet-verified { width: 18px; height: 18px; fill: var(--x-accent); } #x-social-screen .tweet-user-handle { color:var(--x-text-secondary); font-size: 15px; } #x-social-screen .tweet-time { color:var(--x-text-secondary); font-size: 15px; } #x-social-screen .tweet-more { margin-left: auto; color: #71767b; cursor: pointer; padding: 5px; border-radius: 50%; } #x-social-screen .tweet-more:hover { background-color: color-mix(in srgb, var(--x-accent) , 0.1); color: var(--x-accent); } #x-social-screen .tweet-content { color:var(--x-text-primary); font-size: 15px; line-height: 1.3; margin-bottom: 12px; word-wrap: break-word; } #x-social-screen .hashtag, #x-social-screen .mention { color: var(--x-accent); text-decoration: none; cursor: pointer; } #x-social-screen .hashtag:hover, #x-social-screen .mention:hover { text-decoration: underline; } #x-social-screen .tweet-media { margin-bottom: 12px; border-radius: 16px; overflow: hidden; position: relative; } #x-social-screen .tweet-image { width: 100%; max-height: 300px; object-fit: cover; display: block; } #x-social-screen .sensitive-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; color: #fff; cursor: pointer; } #x-social-screen .sensitive-text { font-size: 15px; font-weight: 700; margin-bottom: 8px; } #x-social-screen .sensitive-description { font-size: 13px; color: #71767b; text-align: center; padding: 0 20px; } #x-social-screen .tweet-actions { display: flex; justify-content: space-between; max-width: 425px; margin-top: 5px; } #x-social-screen .tweet-action { display: flex; align-items: center; gap: 5px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; font-size: 13px; transition: all 0.2s; } #x-social-screen .tweet-action:hover { background-color: color-mix(in srgb, var(--x-accent) , 0.1); } #x-social-screen .tweet-action.comment:hover { color: var(--x-accent); } #x-social-screen .tweet-action.retweet:hover { color: #00ba7c; } #x-social-screen .tweet-action.like:hover, #x-social-screen .tweet-action.like.liked { color: #f91880; } #x-social-screen .tweet-action.bookmark:hover { color: var(--x-accent); } #x-social-screen .tweet-action.share:hover { color: var(--x-accent); } #x-social-screen .action-icon { width: 18px; height: 18px; } #x-social-screen .like-animation { animation: likeHeartbeat 0.6s ease-in-out; } @keyframes likeHeartbeat { 0% { transform: scale(1); } 25% { transform: scale(1.2); } 50% { transform: scale(1.4); } 75% { transform: scale(1.2); } 100% { transform: scale(1); } } #x-social-screen .tweet-action.like.liked .like-icon { fill: #f91880; } #x-social-screen .tweet-action.like.liked .like-count { color: #f91880; } #x-social-screen .comment-item { padding: 15px; border-bottom: 1px solid var(--x-border-color); display: flex; gap: 12px; position: relative; background-color:var(--x-bg-primary); } #x-social-screen .comment-item.has-replies::after { content: ''; position: absolute; left: 35px; bottom: -1px; width: 1px; height: 28px; background-color: #2f3336; } #x-social-screen .comment-main { flex: 1; min-width: 0; } #x-social-screen .comment-user-info { display: flex; align-items: center; gap: 5px; margin-bottom: 5px; } #x-social-screen .comment-content { color:var(--x-text-primary); font-size: 15px; line-height: 1.3; margin-bottom: 8px; word-wrap: break-word; } #x-social-screen .comment-actions { display: flex; justify-content: flex-start; gap: 60px; margin-top: 5px; } #x-social-screen .comment-action { display: flex; align-items: center; gap: 5px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; font-size: 13px; transition: all 0.2s; } #x-social-screen .reply-item { margin-left: 50px; padding-left: 0; padding-top: 8px; padding-bottom: 8px; border-left: none; position: relative; display: flex; align-items: flex-start; gap: 12px; } #x-social-screen .reply-item::before { content: ''; position: absolute; left: -30px; top: 16px; width: 14px; height: 14px; border-left: 1px solid #2f3336; border-bottom: 1px solid #2f3336; border-bottom-left-radius: 6px; } #x-social-screen .reply-to { color: var(--x-accent); margin-right: 5px; font-weight: 400; } #x-social-screen .reply-item .tweet-avatar { width: 32px; height: 32px; } #x-social-screen .quoted-tweet { border: 1px solid #2f3336; border-radius: 16px; margin: 12px 0; padding: 12px; background-color: rgba(0, 0, 0, 0.3); transition: background-color 0.2s ease; cursor: pointer; } #x-social-screen .quoted-tweet:hover { background-color: rgba(255, 255, 255, 0.03); } #x-social-screen .quoted-user-info { display: flex; align-items: center; gap: 5px; margin-bottom: 8px; } #x-social-screen .quoted-user-avatar { width: 20px; height: 20px; border-radius: 50%; flex-shrink: 0; } #x-social-screen .quoted-user-name { font-weight: 600; color: #fff; font-size: 13px; } #x-social-screen .quoted-user-handle { color: #71767b; font-size: 13px; } #x-social-screen .quoted-user-time { color: #71767b; font-size: 13px; } #x-social-screen .quoted-content { color: #fff; font-size: 14px; line-height: 1.3; word-wrap: break-word; } #x-social-screen .quote-indicator { color: #71767b; font-size: 13px; margin-bottom: 8px; display: flex; align-items: center; gap: 4px; } #x-social-screen .quote-indicator svg { width: 16px; height: 16px; fill: currentColor; } #x-social-screen .search-header { padding: 12px 16px; background: #000; border-bottom: 1px solid #2f3336; } #x-social-screen .search-box { display: flex; align-items: center; background: #202327; border-radius: 20px; padding: 10px 16px; gap: 12px; } #x-social-screen .search-box svg { width: 20px; height: 20px; fill: #71767b; flex-shrink: 0; } #x-social-screen .search-box input { flex: 1; background: transparent; border: none; outline: none; color: #fff; font-size: 15px; } #x-social-screen .search-box input::placeholder { color: #71767b; } #x-social-screen .search-tabs { display: flex; align-items: center; padding: 0 16px; border-bottom: 1px solid #2f3336; gap: 24px; overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; } #x-social-screen .search-tabs::-webkit-scrollbar { display: none; } #x-social-screen .search-tab { padding: 16px 0; cursor: pointer; color: #71767b; font-weight: 500; font-size: 15px; white-space: nowrap; position: relative; transition: color 0.2s; } #x-social-screen .search-tab.active { color: #fff; font-weight: 700; } #x-social-screen .search-tab.active::after { content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 4px; background: var(--x-accent); border-radius: 2px 2px 0 0; } #x-social-screen .search-tab:hover { color: #fff; } #x-social-screen .add-category-btn { display: flex; align-items: center; justify-content: center; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; transition: background 0.2s; } #x-social-screen .add-category-btn svg { width: 20px; height: 20px; fill: #71767b; } #x-social-screen .add-category-btn:hover { background: color-mix(in srgb, var(--x-accent) , 0.1); } #x-social-screen .add-category-btn:hover svg { fill: var(--x-accent); } #x-social-screen .trending-list { flex: 1; overflow-y: auto; } #x-social-screen .trending-item { padding: 12px 16px; cursor: pointer; transition: background 0.2s; position: relative; } #x-social-screen .trending-item:hover { background: rgba(255, 255, 255, 0.03); } #x-social-screen .trending-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 2px; } #x-social-screen .trending-category { color: #71767b; font-size: 14px; font-weight: 800; line-height: 16px; } #x-social-screen .trending-more { padding: 4px; border-radius: 50%; cursor: pointer; transition: background 0.2s; } #x-social-screen .trending-more:hover { background: color-mix(in srgb, var(--x-accent) , 0.1); } #x-social-screen .trending-more svg { width: 18px; height: 18px; fill: #71767b; } #x-social-screen .trending-title { color: #fff; font-size: 15px; font-weight: 700; line-height: 20px; margin-bottom: 2px; } #x-social-screen .trending-count { color: #71767b; font-size: 13px; line-height: 16px; font-weight: 400; } #x-social-screen .refresh-trends-btn { position: fixed; right: 20px; bottom: 80px; width: 56px; height: 56px; background: var(--x-accent); border-radius: 50%; border: none; cursor: pointer; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4); display: none; align-items: center; justify-content: center; transition: transform 0.2s, background 0.2s; z-index: 100; } #x-social-screen .refresh-trends-btn:hover { background: #1a8cd8; transform: scale(1.05); } #x-social-screen .refresh-trends-btn:active { transform: scale(0.95); } #x-social-screen .refresh-trends-btn svg { width: 24px; height: 24px; fill: #fff; } #x-social-screen .refresh-trends-btn.spinning svg { animation: spin 1s linear infinite; } @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } } @keyframes pulse { 0% { opacity: 1; transform: scale(1); } 50% { opacity: 0.6; transform: scale(1.2); } 100% { opacity: 1; transform: scale(1); } } @keyframes walletSuccessIn { from { opacity: 0; transform: scale(0.7) translateY(30px); } to { opacity: 1; transform: scale(1) translateY(0); } } @keyframes walletSuccessCheck { 0% { opacity: 0; transform: scale(0.3); } 50% { opacity: 1; transform: scale(1.1); } 100% { opacity: 1; transform: scale(1); } } @keyframes walletActivating { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } } `; document.head.appendChild(style); console.log('✅ X Social App: 样式已注入'); } function createXSocialHTML() { if (document.getElementById('x-social-screen')) { console.log('⚠️ X Social Screen 已存在，跳过创建'); return; } const container = document.createElement('div'); container.id = 'x-social-screen'; container.className = 'screen'; container.style.cssText = 'background-color:var(--x-bg-primary); color:var(--x-text-primary); display: flex; flex-direction: column; height: 100vh; overflow: hidden;'; container.innerHTML = ` <div class="x-top-bar" style="display: flex; justify-content: space-between; align-items: center; padding: 55px 15px 15px 15px; border-bottom: 1px solid #333; position: relative;"> <div style="display: flex; align-items: center; gap: 12px;"> <div class="x-back-btn" onclick="showScreen('home-screen')" style="cursor: pointer;"> <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 20px; height: 20px; fill: #fff;"> <g> <path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path> </g> </svg> </div> <!-- 添加直播按钮 --> <div class="x-live-btn" onclick="switchXPage('live')" style="cursor: pointer;"> <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 20px; height: 20px; fill: none; stroke: #fff; stroke-width: 1; stroke-linecap: round; stroke-linejoin: round;"> <path d="M10.5 20h-5.5a2 2 0 0 1 -2 -2v-9a2 2 0 0 1 2 -2h1a2 2 0 0 0 2 -2a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1a2 2 0 0 0 2 2h1a2 2 0 0 1 2 2v2.5" /> <path d="M14.569 11.45a3 3 0 1 0 -4.518 3.83" /> <path d="M17.8 20.817l-2.172 1.138a.392 .392 0 0 1 -.568 -.41l.415 -2.411l-1.757 -1.707a.389 .389 0 0 1 .217 -.665l2.428 -.352l1.086 -2.193a.392 .392 0 0 1 .702 0l1.086 2.193l2.428 .352a.39 .39 0 0 1 .217 .665l-1.757 1.707l.414 2.41a.39 .39 0 0 1 -.567 .411l-2.172 -1.138z" /> </svg> </div> </div> <div class="x-profile-pic" style="display: flex; justify-content: center; align-items: center; position: absolute; left: 50%; transform: translateX(-50%);"> <img id="top-bar-avatar" src="https: alt="Profile" onclick="switchXPage('profile')" style="width: 36px; height: 36px; border-radius: 50%; cursor: pointer; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'"> </div> <div style="display: flex; align-items: center; gap: 15px;"> <div class="x-refresh-btn" onclick="refreshXTweets()" style="cursor: pointer;"> <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 22px; height: 22px; fill: #fff;"> <g> <path d="M19 8l-4 4h3c0 3.31-2.69 6-6 6-1.01 0-1.97-.25-2.8-.7l-1.46 1.46C8.97 19.54 10.43 20 12 20c4.42 0 8-3.58 8-8h3l-4-4zM6 12c0-3.31 2.69-6 6-6 1.01 0 1.97.25 2.8.7l1.46-1.46C15.03 4.46 13.57 4 12 4c-4.42 0-8 3.58-8 8H1l4 4 4-4H6z"> </path> </g> </svg> </div> <div class="x-settings" onclick="switchXPage('settings')" style="cursor: pointer;"> <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 24px; height: 24px; fill: #fff;"> <g> <path d="M10.54 1.75h2.92l1.57 2.36c.11.17.32.25.53.21l2.53-.59 2.17 2.17-.58 2.54c-.05.2.04.41.21.53l2.36 1.57v2.92l-2.36 1.57c-.17.12-.26.33-.21.53l.58 2.54-2.17 2.17-2.53-.59c-.21-.04-.42.04-.53.21l-1.57 2.36h-2.92l-1.58-2.36c-.11-.17-.32-.25-.52-.21l-2.54.59-2.17-2.17.58-2.54c.05-.2-.03-.41-.21-.53l-2.35-1.57v-2.92L4.1 8.97c.18-.12.26-.33.21-.53L3.73 5.9 5.9 3.73l2.54.59c.2.04.41-.04.52-.21l1.58-2.36zm1.07 2l-.98 1.47C10.05 6.08 9 6.5 7.99 6.27l-1.46-.34-.6.6.33 1.46c.24 1.01-.18 2.07-1.05 2.64l-1.46.98v.78l1.46.98c.87.57 1.29 1.63 1.05 2.64l-.33 1.46.6.6 1.46-.34c1.01-.23 2.06.19 2.64 1.05l.98 1.47h.78l.97-1.47c.58-.86 1.63-1.28 2.65-1.05l1.45.34.61-.6-.34-1.46c-.23-1.01.18-2.07 1.05-2.64l1.47-.98v-.78l-1.47-.98c-.87-.57-1.28-1.63-1.05-2.64l.34-1.46-.61-.6-1.45.34c-1.02.23-2.07-.19-2.65-1.05l-.97-1.47h-.78zM12 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5c.82 0 1.5-.67 1.5-1.5s-.68-1.5-1.5-1.5zM8.5 12c0-1.93 1.56-3.5 3.5-3.5 1.93 0 3.5 1.57 3.5 3.5s-1.57 3.5-3.5 3.5c-1.94 0-3.5-1.57-3.5-3.5z"> </path> </g> </svg> </div> </div> </div> <div class="x-pages-container" style="flex: 1; display: flex; flex-direction: column; overflow: hidden; min-height: 0; position: relative;"> <div id="x-home-page" class="x-page active" style="flex: 1; display: flex; flex-direction: column; overflow: hidden; min-height: 0;"> <div class="x-home-tabs" style="display: flex; border-bottom: 1px solid #333;"> <div class="x-tab active" onclick="switchHomeTab('for-you')" style="flex: 1; text-align: center; padding: 15px 0; font-weight: 600; cursor: pointer; position: relative;"> <span data-i18n="homeForYou">为你推荐</span> <div class="tab-indicator" style="position: absolute; bottom: 0; left: 10%; width: 80%; height: 2px; background-color: var(--x-accent); border-radius: 2px;"> </div> </div> <div class="x-tab" onclick="switchHomeTab('following')" style="flex: 1; text-align: center; padding: 15px 0; font-weight: 600; cursor: pointer; position: relative; color: #71767b;"> <span data-i18n="homeFollowing">正在关注</span> <div class="tab-indicator" style="position: absolute; bottom: 0; left: 10%; width: 80%; height: 2px; background-color: var(--x-accent); border-radius: 2px; display: none;"> </div> </div> </div> <div id="for-you-content" class="tab-content active" style="flex: 1; display: flex; flex-direction: column; overflow-y: auto; min-height: 0;"> <div class="tweets-container" style="padding: 0;"> </div> </div> <div id="following-content" class="tab-content" style="flex: 1; display: none; flex-direction: column; overflow-y: auto; min-height: 0;"> <div class="tweets-container" style="padding: 0;"> </div> </div> <div class="compose-btn" onclick="openComposeTweetModal()" style="position: fixed; bottom: 80px; right: 20px; width: 56px; height: 56px; background-color: var(--x-accent); border-radius: 50%; display: flex; justify-content: center; align-items: center; box-shadow: 0 2px 10px rgba(0,0,0,0.3); cursor: pointer;"> <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 24px; height: 24px; fill: #fff; stroke-width: 2;"> <g> <path d="M12 4L12 20M4 12L20 12" stroke="white" stroke-linecap="round"></path> </g> </svg> </div> </div> <div id="character-x-profile-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); z-index: 30; backdrop-filter: blur(8px);"> <div style="display: flex; justify-content: center; align-items: center; height: 100%; padding: 20px;"> <div style="background-color:#000; border: 1px solid #333; border-radius: 16px; width: 100%; max-width: 600px; max-height: 90vh; overflow-y: auto;"> <div style="display: flex; align-items: center; justify-content: space-between; padding: 20px 20px 16px 20px; border-bottom: 1px solid #333;"> <h2 style="color: #fff; font-size: 20px; font-weight: 700; margin: 0;">设置X资料</h2> <button onclick="closeCharacterXProfileModal()" style="background: none; border: none; color: #71767b; cursor: pointer; padding: 8px;"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <path d="M18.36 6.64c.39.39.39 1.02 0 1.41L13.41 12l4.95 4.95c.39.39.39 1.02 0 1.41-.39.39-1.02.39-1.41 0L12 13.41l-4.95 4.95c-.39.39-1.02.39-1.41 0-.39-.39-.39-1.02 0-1.41L10.59 12 5.64 7.05c-.39-.39-.39-1.02 0-1.41.39-.39 1.02-.39 1.41 0L12 10.59l4.95-4.95c.39-.39 1.02-.39 1.41 0z" /> </svg> </button> </div> <div id="character-info-display" style="padding: 20px; border-bottom: 1px solid #333; background-color: #0a0a0a;"> </div> <div style="padding: 20px;"> <form id="character-x-profile-form"> <div style="margin-bottom: 24px;"> <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 12px;">X头像</label> <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 12px;"> <img id="character-x-avatar" src="" alt="X头像" style="width: 80px; height: 80px; border-radius: 50%; border: 3px solid #333; object-fit: cover; overflow: hidden; box-sizing: border-box;"> <div style="flex: 1;"> <div style="color: #71767b; font-size: 13px; margin-bottom: 8px;">头像链接</div> <input type="url" id="character-x-avatar-url" placeholder="https: style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; outline: none;" oninput="updateCharacterXAvatar(this.value)" onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"> </div> </div> <div style="color: #71767b; font-size: 12px;"> 请输入图片链接URL，支持JPG、PNG、GIF格式 </div> </div> <div style="margin-bottom: 20px;"> <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">X用户名</label> <input type="text" id="character-x-name" placeholder="显示名称" style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none;" maxlength="50"> </div> <div style="margin-bottom: 20px;"> <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">X句柄</label> <div style="position: relative;"> <span style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: #71767b; font-size: 15px;">@</span> <input type="text" id="character-x-handle" placeholder="username" style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px 12px 12px 30px; font-size: 15px; outline: none;" maxlength="15"> </div> </div> <div style="margin-bottom: 20px;"> <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;"> <input type="checkbox" id="character-x-verified" style="width: 18px; height: 18px; accent-color: var(--x-accent);"> <span style="color: #fff; font-size: 15px; font-weight: 600;">认证用户</span> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);"> <path d="M22.5 12.5c0-1.58-.875-2.95-2.148-3.6.154-.435.238-.905.238-1.4 0-2.21-1.71-3.998-3.818-3.998-.47 0-.92.084-1.336.25C14.818 2.415 13.51 1.5 12 1.5s-2.816.917-3.437 2.25c-.415-.165-.866-.25-1.336-.25-2.11 0-3.818 1.79-3.818 4 0 .494.083.964.237 1.4-1.272.65-2.147 2.018-2.147 3.6 0 1.495.782 2.798 1.942 3.486-.02.17-.032.34-.032.514 0 2.21 1.708 4 3.818 4 .47 0 .92-.086 1.335-.25.62 1.334 1.926 2.25 3.437 2.25 1.512 0 2.818-.916 3.437-2.25.415.163.865.248 1.336.248 2.11 0 3.818-1.79 3.818-4 0-.174-.012-.344-.033-.513 1.158-.687 1.943-1.99 1.943-3.484zm-6.616-3.334l-4.334 6.5c-.145.217-.382.334-.625.334-.143 0-.288-.04-.416-.126l-2.5-1.668c-.326-.217-.413-.656-.196-.982.217-.326.656-.414.982-.196l1.875 1.25 3.75-5.625c.22-.33.66-.418.99-.196.33.22.418.66.196.99z" /> </svg> </label> </div> <div style="margin-bottom: 24px;"> <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 12px;">背景图（封面图）</label> <div style="margin-bottom: 12px;"> <img id="character-x-cover-preview" src="https: style="width: 100%; height: 120px; border-radius: 8px; object-fit: cover; border: 1px solid #333;"> </div> <div style="color: #71767b; font-size: 13px; margin-bottom: 8px;">背景图链接</div> <input type="url" id="character-x-cover-url" placeholder="https: style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; outline: none;" oninput="updateCharacterXCover(this.value)" onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"> <div style="color: #71767b; font-size: 12px; margin-top: 4px;"> 请输入图片链接URL，支持JPG、PNG、GIF格式 </div> </div> <div style="margin-bottom: 24px;"> <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">自定义标签1</label> <div style="display: flex; gap: 8px; margin-bottom: 8px;"> <input type="text" id="character-tag1-icon" placeholder="✨" maxlength="2" style="width: 50px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; text-align: center; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"> <input type="text" id="character-custom-tag1" placeholder="例如：科技博主" maxlength="30" style="flex: 1; background-color: #1a1a1a; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 15px; outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"> </div> <div style="display: flex; gap: 8px; align-items: center;"> <label style="color: #71767b; font-size: 12px; min-width: 40px;">颜色:</label> <input type="color" id="character-tag1-color" value="#71767b" style="width: 40px; height: 32px; border: 1px solid #333; border-radius: 4px; background: transparent; cursor: pointer; outline: none; "> </div> </div> <div style="margin-bottom: 24px;"> <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">自定义标签2</label> <div style="display: flex; gap: 8px; margin-bottom: 8px;"> <input type="text" id="character-tag2-icon" placeholder="📅" maxlength="2" style="width: 50px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; text-align: center; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"> <input type="text" id="character-custom-tag2" placeholder="例如：2024年加入" maxlength="30" style="flex: 1; background-color: #1a1a1a; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 15px; outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"> </div> <div style="display: flex; gap: 8px; align-items: center;"> <label style="color: #71767b; font-size: 12px; min-width: 40px;">颜色:</label> <input type="color" id="character-tag2-color" value="#71767b" style="width: 40px; height: 32px; border: 1px solid #333; border-radius: 4px; background: transparent; cursor: pointer; outline: none; "> </div> </div> <div style="margin-bottom: 20px;"> <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">正在关注数量</label> <input type="text" id="character-following-count" placeholder="156, 1.2K, 2.5M等" maxlength="20" style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"> <div style="color: #71767b; font-size: 12px; margin-top: 4px;">可输入任意数字、字母、符号组合</div> </div> <div style="margin-bottom: 20px;"> <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">关注者数量</label> <input type="text" id="character-followers-count" placeholder="89, 1.5K, 3.2M等" maxlength="20" style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"> <div style="color: #71767b; font-size: 12px; margin-top: 4px;">可输入任意数字、字母、符号组合</div> </div> <div style="margin-bottom: 20px;"> <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">X简介</label> <textarea id="character-x-bio" placeholder="介绍一下这个角色在X上的身份..." style="width: 100%; min-height: 80px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; resize: vertical; outline: none; font-family: inherit;" maxlength="160"></textarea> <div style="text-align: right; color: #71767b; font-size: 13px; margin-top: 4px;"> <span id="character-bio-count">0</span>/160 </div> </div> <div style="margin-bottom: 20px;"> <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">公众身份</label> <div style="color: #71767b; font-size: 13px; margin-bottom: 8px; line-height: 1.4;"> 描述角色在X平台的公众身份（如明星、网红、博主等）。这将影响其他用户对该角色的讨论几率，身份越知名可能引起更多关注和讨论。此信息完全公开。 </div> <div style="background-color: color-mix(in srgb, var(--x-accent) , 0.1); border: 1px solid var(--x-accent); border-radius: 8px; padding: 12px; margin-bottom: 12px;"> <div style="color: var(--x-accent); font-size: 13px; line-height: 1.4;"> <strong>📌 重要提醒：</strong>角色将根据完整人设进行扮演，但<strong style="color: var(--x-accent);">X平台其他用户无法读取角色人设</strong>，仅能看到此公众身份信息。如需让其他用户了解的角色特点、背景故事等内容，请全部详细填写至公众身份中。 </div> </div> <textarea id="character-public-identity" placeholder="例如：知名演员、歌手、网络红人、专业博主等... 可详细描述角色的公开背景、成就、特点等，无字数限制" style="width: 100%; min-height: 120px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; resize: vertical; outline: none; font-family: inherit;"></textarea> <div style="color: #71767b; font-size: 12px; margin-top: 4px;"> 💡 无字数限制，可详细描述角色的公开信息 </div> </div> <div style="margin-bottom: 20px;"> <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">真名设置</label> <div style="color: #71767b; font-size: 13px; margin-bottom: 12px; line-height: 1.4;"> 选择是否公开角色的真实姓名。公开后，其他用户都能看到角色真名，情侣认证时也会显示双方真名。 </div> <div style="margin-bottom: 12px;"> <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;"> <input type="checkbox" id="character-show-real-name" style="width: 16px; height: 16px; accent-color: var(--x-accent); " onchange="toggleCharacterRealNameInput()"> <span style="color: #fff; font-size: 15px;">公开真实姓名</span> </label> </div> <div id="character-real-name-input-container" style="display: none;"> <input type="text" id="character-real-name" placeholder="请输入角色的真实姓名" style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none;" maxlength="50"> <div style="text-align: right; color: #71767b; font-size: 13px; margin-top: 4px;"> <span id="character-real-name-count">0</span>/50 </div> </div> </div> <div style="margin-bottom: 20px;"> <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;"> <label style="color: #fff; font-size: 15px; font-weight: 600;">NPC关系绑定</label> <button type="button" onclick="openAddRelationshipModal()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 16px; padding: 6px 12px; font-size: 12px; cursor: pointer;"> + 添加关系 </button> </div> <div style="color: #71767b; font-size: 13px; margin-bottom: 12px;"> 绑定NPC角色作为朋友、亲人等，让角色能够识别和互动 </div> <div id="character-relationships-list" style="max-height: 200px; overflow-y: auto;"> </div> </div> <div style="margin-bottom: 20px; border-top: 1px solid #333; padding-top: 20px;"> <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">🤖 后台自动活动</label> <div style="color: #71767b; font-size: 13px; margin-bottom: 12px; line-height: 1.4;"> 启用后，当与该角色在X平台私信达到设定的无互动时间后，角色将主动在后台发送消息和推文 </div> <div style="margin-bottom: 16px;"> <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;"> <input type="checkbox" id="character-auto-message-enabled" style="width: 16px; height: 16px; accent-color: var(--x-accent); " onchange="toggleAutoMessageSettings()"> <span style="color: #fff; font-size: 15px;">启用后台自动发消息</span> </label> </div> <div id="auto-message-time-settings" style="display: none;"> <label style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">无互动触发时间</label> <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;"> <input type="number" id="character-auto-message-interval" placeholder="60" min="10" max="3600" style="width: 100px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 8px 12px; font-size: 14px; outline: none; "> <span style="color:var(--x-text-primary); font-size: 14px;">秒</span> </div> <div style="color: #71767b; font-size: 12px; line-height: 1.4;"> 设置无互动多少秒后角色会主动发消息（建议60-300秒，最少10秒，最多3600秒） </div> </div> </div> <div style="display: flex; gap: 12px; margin-top: 32px;"> <button type="button" onclick="closeCharacterXProfileModal()" style="flex: 1; background-color: transparent; color: #fff; border: 1px solid #536471; border-radius: 20px; padding: 12px 24px; font-size: 15px; font-weight: 700; cursor: pointer;"> 取消 </button> <button type="submit" style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 12px 24px; font-size: 15px; font-weight: 700; cursor: pointer;"> 保存X资料 </button> </div> </form> </div> </div> </div> </div> <div id="relationship-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); z-index: 40; backdrop-filter: blur(8px);"> <div style="display: flex; justify-content: center; align-items: center; height: 100%; padding: 20px;"> <div style="background-color:#000; border: 1px solid #333; border-radius: 16px; width: 100%; max-width: 500px;"> <div style="display: flex; align-items: center; justify-content: space-between; padding: 20px 20px 16px 20px; border-bottom: 1px solid #333;"> <h3 id="relationship-modal-title" style="color: #fff; font-size: 18px; font-weight: 700; margin: 0;"> 添加NPC关系</h3> <button onclick="closeRelationshipModal()" style="background: none; border: none; color: #71767b; cursor: pointer; padding: 8px;"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <path d="M18.36 6.64c.39.39.39 1.02 0 1.41L13.41 12l4.95 4.95c.39.39.39 1.02 0 1.41-.39.39-1.02.39-1.41 0L12 13.41l-4.95 4.95c-.39.39-1.02.39-1.41 0-.39-.39-.39-1.02 0-1.41L10.59 12 5.64 7.05c-.39-.39-.39-1.02 0-1.41.39-.39 1.02-.39 1.41 0L12 10.59l4.95-4.95c.39-.39 1.02-.39 1.41 0z" /> </svg> </button> </div> <div style="padding: 20px;"> <form id="relationship-form"> <div style="margin-bottom: 16px;"> <label style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">NPC名称</label> <input type="text" id="relationship-npc-name" placeholder="输入NPC的名称" style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; outline: none;" maxlength="30"> </div> <div style="margin-bottom: 16px;"> <label style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">NPC句柄</label> <div style="position: relative;"> <span style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: #71767b; font-size: 14px;">@</span> <input type="text" id="relationship-npc-handle" placeholder="npc_username" style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px 12px 12px 30px; font-size: 14px; outline: none;" maxlength="15"> </div> </div> <div style="margin-bottom: 16px;"> <label style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">关系类型</label> <select id="relationship-type" style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; outline: none;"> <option value="朋友">朋友</option> <option value="亲人">亲人</option> <option value="恋人">恋人</option> <option value="同事">同事</option> <option value="同学">同学</option> <option value="邻居">邻居</option> <option value="其他">其他</option> </select> </div> <div style="margin-bottom: 20px;"> <label style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">关系描述</label> <textarea id="relationship-description" placeholder="详细描述两人的关系，如何认识的，相处模式等..." style="width: 100%; min-height: 80px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; resize: vertical; outline: none; font-family: inherit;" maxlength="200"></textarea> <div style="text-align: right; color: #71767b; font-size: 12px; margin-top: 4px;"> <span id="relationship-desc-count">0</span>/200 </div> </div> <div style="display: flex; gap: 12px;"> <button type="button" onclick="closeRelationshipModal()" style="flex: 1; background-color: transparent; color: #fff; border: 1px solid #536471; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 700; cursor: pointer;"> 取消 </button> <button type="submit" style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 700; cursor: pointer;"> 保存关系 </button> </div> </form> </div> </div> </div> </div> <div id="x-search-page" class="x-page" style="flex: 1; display: none; flex-direction: column; overflow: hidden; min-height: 0;"> <div class="search-header"> <button id="search-back-btn" onclick="backToTrending()" style="display: none; background: none; border: none; padding: 8px; cursor: pointer; margin-right: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;"> <g><path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path></g> </svg> </button> <div class="search-box"> <svg viewBox="0 0 24 24" aria-hidden="true"> <g><path d="M10.25 3.75c-3.59 0-6.5 2.91-6.5 6.5s2.91 6.5 6.5 6.5c1.795 0 3.419-.726 4.596-1.904 1.178-1.177 1.904-2.801 1.904-4.596 0-3.59-2.91-6.5-6.5-6.5zm-8.5 6.5c0-4.694 3.806-8.5 8.5-8.5s8.5 3.806 8.5 8.5c0 1.986-.682 3.815-1.824 5.262l4.781 4.781-1.414 1.414-4.781-4.781c-1.447 1.142-3.276 1.824-5.262 1.824-4.694 0-8.5-3.806-8.5-8.5z"></path></g> </svg> <input type="text" placeholder="搜索 X" id="search-input" oninput="toggleSearchButton()" onkeydown="if(event.key==='Enter') performSearch()"> <button id="search-submit-btn" onclick="performSearch()" style="display: none; background: none; border: none; padding: 8px; cursor: pointer; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);"> <g><path d="M2.504 21.866l.526-2.108C3.04 19.719 4 15.823 4 12s-.96-7.719-.97-7.757l-.527-2.109L22.236 12 2.504 21.866zM5.981 13c-.072 1.962-.34 3.833-.583 5.183L17.764 12 5.398 5.818c.242 1.349.51 3.221.583 5.183H10v2H5.981z"></path></g> </svg> </button> </div> </div> <div id="trending-view" style="display: flex; flex-direction: column; flex: 1; overflow: hidden;"> <div class="search-tabs"> <div class="search-tab active" onclick="switchSearchTab('recommended')">为你推荐</div> <div class="search-tab" onclick="switchSearchTab('trending')">当前趋势</div> <div class="add-category-btn" onclick="openAddCategoryModal()" title="添加自定义分类"> <svg viewBox="0 0 24 24" aria-hidden="true"> <g><path d="M19.5 12.75h-6.75V19.5h-1.5v-6.75H4.5v-1.5h6.75V4.5h1.5v6.75h6.75v1.5z"></path></g> </svg> </div> </div> <div class="trending-list" id="trending-list"> </div> </div> <div id="search-results-view" style="display: none; flex-direction: column; flex: 1; overflow: hidden;"> <div class="search-tabs"> <div class="search-tab active" onclick="switchSearchResultTab('top')">热门</div> <div class="search-tab" onclick="switchSearchResultTab('latest')">最新</div> <div class="search-tab" onclick="switchSearchResultTab('users')">用户</div> </div> <div id="search-results-content" style="flex: 1; overflow-y: auto; background: #000; "> </div> </div> <button class="refresh-trends-btn" onclick="refreshTrends()" title="刷新热搜"> <svg viewBox="0 0 24 24" aria-hidden="true"> <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g> </svg> </button> </div> <div id="category-manager-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 30; overflow-y: auto; backdrop-filter: blur(8px); " onclick="closeCategoryModal(event)"> <div style="background-color:#000; margin: 40px auto; border-radius: 16px; max-width: 600px; width: calc(100% - 40px); border: 1px solid #333; " onclick="event.stopPropagation()"> <div style="display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid #333; "> <h2 style="color: #fff; font-size: 20px; font-weight: 700; margin: 0;">管理热搜分类</h2> <div onclick="closeCategoryModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </div> </div> <div style="padding: 20px; max-height: calc(100vh - 200px); overflow-y: auto;"> <div style="background-color: color-mix(in srgb, var(--x-accent) , 0.1); border: 1px solid var(--x-accent); border-radius: 8px; padding: 12px; margin-bottom: 20px; "> <p style="color: var(--x-accent); font-size: 13px; line-height: 1.4; margin: 0;"> 💡 自定义分类将在刷新热搜时生成相应内容。可以添加任意分类（如"动漫"、"二次元"等），并描述该分类下的内容类型。 </p> </div> <div style="margin-bottom: 20px;"> <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; "> <h3 style="color: #fff; font-size: 16px; font-weight: 600; margin: 0;">自定义分类</h3> <button onclick="addNewCategory()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 6px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'"> + 添加分类 </button> </div> <div id="custom-categories-list" style="display: flex; flex-direction: column; gap: 12px;"> </div> </div> <button onclick="saveCustomCategories()" style="width: 100%; background-color: var(--x-accent); color: #fff; border: none; border-radius: 25px; padding: 14px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'"> 保存设置 </button> </div> </div> </div> <div id="x-notifications-page" class="x-page" style="flex: 1; display: none; flex-direction: column; overflow: hidden; min-height: 0;"> <div class="notifications-tabs" style="display: flex; border-bottom: 1px solid var(--x-border-color); background-color:var(--x-bg-primary);"> <div class="notification-tab active" onclick="switchNotificationTab('all')" style="flex: 1; text-align: center; padding: 15px 0; font-weight: 700; font-size: 15px; cursor: pointer; position: relative; color:var(--x-text-primary); transition: background-color 0.2s; "> <span data-i18n="notificationsTabAll">全部</span> <div class="tab-indicator" style="position: absolute; bottom: 0; left: 0; right: 0; height: 4px; background-color: var(--x-accent); border-radius: 2px; "></div> </div> <div class="notification-tab" onclick="switchNotificationTab('mentions')" style="flex: 1; text-align: center; padding: 15px 0; font-weight: 700; font-size: 15px; cursor: pointer; position: relative; color:var(--x-text-secondary); transition: background-color 0.2s; "> <span data-i18n="notificationsTabMentions">提及</span> <div class="tab-indicator" style="position: absolute; bottom: 0; left: 0; right: 0; height: 4px; background-color: var(--x-accent); border-radius: 2px; display: none; "></div> </div> </div> <div id="notifications-all-content" class="notification-content" style="flex: 1; overflow-y: auto; background-color:var(--x-bg-primary); "> <div id="notifications-all-list" class="notifications-list"> </div> </div> <div id="notifications-mentions-content" class="notification-content" style="flex: 1; overflow-y: auto; background-color:var(--x-bg-primary); display: none; "> <div id="notifications-mentions-list" class="notifications-list"> </div> </div> <div id="refresh-messages-btn" class="refresh-messages-btn" onclick="refreshStrangerMessages()" style="position: fixed; bottom: 80px; right: 16px; width: 56px; height: 56px; background-color: var(--x-accent); border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); transition: all 0.2s; z-index: 100; " onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'"> <svg viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: #fff;"> <g><path d="M8.8 7.2H5.6V3.9c0-.4-.3-.8-.8-.8s-.7.4-.7.8v3.3H.8c-.4 0-.8.3-.8.8s.3.8.8.8h3.3v3.3c0 .4.3.8.8.8s.8-.3.8-.8V8.7H9c.4 0 .8-.3.8-.8s-.5-.7-1-.7zm15-4.9v-.1h-.1c-.1 0-9.2 1.2-14.4 11.7-3.8 7.6-3.6 9.9-3.3 9.9.3.1 3.4-6.5 6.7-9.2 5.2-1.1 6.6-3.6 6.6-3.6s-1.5.2-2.1.2c-.8 0-1.4-.2-1.7-.3 1.3-1.2 2.4-1.5 3.5-1.7.9-.2 1.8-.4 3-1.2 2.2-1.6 1.9-5.5 1.8-5.7z"></path></g> </svg> </div> </div> <div id="x-messages-page" class="x-page" style="flex: 1; display: none; flex-direction: column; overflow: hidden; min-height: 0;"> <div id="messages-list-container" class="messages-list-container" style="flex: 1; overflow-y: auto; background-color:var(--x-bg-primary); "> </div> <div id="compose-message-btn" class="compose-message-btn" onclick="openNewMessageModal()" style="position: fixed; bottom: 80px; right: 16px; width: 56px; height: 56px; background-color: var(--x-accent); border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); transition: all 0.2s; z-index: 100; " onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'"> <svg viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: #fff;"> <g><path d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v2.764l8 3.638 8-3.636V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.463l-8 3.636-8-3.638V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.037z"></path></g> </svg> </div> </div> <div id="x-message-detail-page" class="x-page" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; display: none; flex-direction: column; overflow: hidden; z-index: 20; background-color:var(--x-bg-primary);"> <div class="message-detail-header" style="display: flex; align-items: center; padding: 55px 16px 12px 16px; background-color:var(--x-bg-primary); "> <div onclick="closeMessageDetail()" style="cursor: pointer; margin-right: 20px; display: flex; align-items: center; justify-content: center; width: 34px; height: 34px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);"> <g><path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path></g> </svg> </div> <div style="flex: 1; display: flex; align-items: center; gap: 12px; min-width: 0;"> <img id="message-detail-top-avatar" src="https: alt="User" style="width: 32px; height: 32px; border-radius: 50%; cursor: pointer; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'" onclick="handleMessageDetailAvatarClick()"> <span id="message-detail-top-name" style="font-size: 16px; font-weight: 700; color:var(--x-text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">用户名</span> </div> <div style="display: flex; gap: 8px;"> <div style="width: 34px; height: 34px; display: flex; align-items: center; justify-content: center; border-radius: 50%; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);"> <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h6C12.881 3 14 4.119 14 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-6C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v13c0 .276.224.5.5.5h6c.276 0 .5-.224.5-.5v-13c0-.276-.224-.5-.5-.5h-6zM15.5 6l5.5-3v18l-5.5-3v-12z"></path></g> </svg> </div> <div style="width: 34px; height: 34px; display: flex; align-items: center; justify-content: center; border-radius: 50%; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);"> <g><path d="M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z"></path></g> </svg> </div> </div> </div> <div id="message-detail-scrollable" style="flex: 1; overflow-y: auto; background-color:var(--x-bg-primary); "> <div style="display: flex; flex-direction: column; align-items: center; padding: 20px 16px; background-color:var(--x-bg-primary); border-bottom: 1px solid var(--x-border-color); "> <img id="message-detail-avatar" src="https: alt="User" style="width: 64px; height: 64px; border-radius: 50%; margin-bottom: 12px;"> <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 4px;"> <span id="message-detail-name" style="font-size: 20px; font-weight: 700; color:var(--x-text-primary); ">用户名</span> </div> <div id="message-detail-handle" style="font-size: 15px; color:var(--x-text-secondary); margin-bottom: 12px; ">@handle</div> <div id="message-detail-bio" style="font-size: 15px; color:var(--x-text-primary); text-align: center; line-height: 1.4; margin-bottom: 12px; display: none; "></div> <div id="message-detail-followers" style="font-size: 14px; color:var(--x-text-secondary); " data-i18n-template="messageFollowers">0 位关注者</div> </div> <div id="message-detail-content" class="message-detail-content" style="padding: 16px; background-color:var(--x-bg-primary); min-height: 300px; "> </div> </div> <div class="message-input-area" style="padding: 12px 16px; background-color:var(--x-bg-primary); "> <div style="display: flex; align-items: center; gap: 8px; background-color:var(--x-bg-secondary); border-radius: 20px; padding: 8px 12px; position: relative; "> <div style="position: relative;"> <div id="message-add-btn" onclick="toggleMessageFunctionMenu()" style="cursor: pointer; padding: 4px; border-radius: 50%; transition: all 0.2s; display: flex; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent); transition: transform 0.2s;"> <g><path d="M12 4C11.4477 4 11 4.44772 11 5V11H5C4.44772 11 4 11.4477 4 12C4 12.5523 4.44772 13 5 13H11V19C11 19.5523 11.4477 20 12 20C12.5523 20 13 19.5523 13 19V13H19C19.5523 13 20 12.5523 20 12C20 11.4477 19.5523 11 19 11H13V5C13 4.44772 12.5523 4 12 4Z"></path></g> </svg> </div> <div id="message-function-menu" style="position: absolute; bottom: 100%; left: 0; margin-bottom: 8px; background-color:var(--x-bg-primary); border: 1px solid var(--x-border-color); border-radius: 12px; padding: 4px; display: none; flex-direction: row; gap: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 100; "> <div onclick="openImageTypeSelector(); toggleMessageFunctionMenu();" style="cursor: pointer; padding: 8px; border-radius: 8px; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);"> <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z"></path></g> </svg> </div> <div onclick="openStickerPicker(); toggleMessageFunctionMenu();" style="cursor: pointer; padding: 8px; border-radius: 8px; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);"> <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"></path></g> </svg> </div> <div onclick="regenerateAIResponse(); toggleMessageFunctionMenu();" style="cursor: pointer; padding: 8px; border-radius: 8px; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: none; stroke: var(--x-accent); stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;"> <path d="M20 11a8.1 8.1 0 0 0 -15.5 -2m-.5 -4v4h4" /> <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4" /> </svg> </div> <div onclick="openVoiceMessageDialog(); toggleMessageFunctionMenu();" style="cursor: pointer; padding: 8px; border-radius: 8px; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);"> <g><path d="M12 3c-1.66 0-3 1.34-3 3v6c0 1.66 1.34 3 3 3s3-1.34 3-3V6c0-1.66-1.34-3-3-3zm0 2c.55 0 1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V6c0-.55.45-1 1-1zm5 7c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-2.08c3.39-.49 6-3.39 6-6.92h-2z"></path></g> </svg> </div> <div onclick="openTransferDialog(); toggleMessageFunctionMenu();" style="cursor: pointer; padding: 8px; border-radius: 8px; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);"> <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM6.64 15.748L12 10.388l5.36 5.36c-.48.32-1.04.56-1.68.72L12 12.78l-3.68 3.69c-.64-.16-1.2-.4-1.68-.72zM12 4c4.41 0 8 3.59 8 8 0 1.85-.63 3.55-1.69 4.9L12 10.59 5.69 16.9C4.63 15.55 4 13.85 4 12c0-4.41 3.59-8 8-8z"></path></g> </svg> </div> <div id="fangroup-announcement-btn" onclick="openFanGroupAnnouncementModal(); toggleMessageFunctionMenu();" style="cursor: pointer; padding: 8px; border-radius: 8px; transition: background-color 0.2s; display: none; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg xmlns="http: <path d="M3 3m0 2a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2z" /> <path d="M9 15h-2" /> <path d="M13 12h-6" /> <path d="M11 9h-4" /> </svg> </div> <div id="fangroup-files-btn" onclick="openFanGroupFilesModal(); toggleMessageFunctionMenu();" style="cursor: pointer; padding: 8px; border-radius: 8px; transition: background-color 0.2s; display: none; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg xmlns="http: <path d="M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2" /> </svg> </div> </div> </div> <textarea id="message-input" placeholder="开始写私信" data-i18n-placeholder="messageInputPlaceholder" style="flex: 1; min-height: 36px; max-height: 100px; background-color: transparent; border: none; color:var(--x-text-primary); font-size: 15px; resize: none; outline: none; font-family: inherit; padding: 4px 0; line-height: 1.4; " oninput="autoResizeMessageInput(this)" onkeydown="handleMessageInputKeydown(event)"></textarea> <button id="fangroup-auto-reaction-btn" onclick="triggerFanGroupAutoReaction()" style="display: none; background-color:var(--x-bg-secondary); color: var(--x-accent); border: 1px solid var(--x-accent); border-radius: 50%; width: 32px; height: 32px; cursor: pointer; transition: all 0.2s; padding: 0; align-items: center; justify-content: center; flex-shrink: 0; margin-right: 4px; " onmouseover="this.style.backgroundColor='var(--x-accent)'; this.style.color='#fff'; this.querySelector('svg').style.stroke='#fff'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'; this.style.color='var(--x-accent)'; this.querySelector('svg').style.stroke='var(--x-accent)'"> <svg xmlns="http: <path d="M3 12h4.5l1.5 -6l4 12l2 -9l1.5 3h4.5" /> </svg> </button> <button id="message-send-btn" onclick="getAIResponse()" style="display: flex; background-color: var(--x-accent); color: #fff; border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; transition: opacity 0.2s; padding: 0; align-items: center; justify-content: center; flex-shrink: 0; "> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #fff;"> <g><path d="M2.504 21.866l.526-2.108C3.04 19.719 4 15.823 4 12s-.96-7.719-.97-7.757l-.527-2.109L22.236 12 2.504 21.866zM5.981 13c-.072 1.962-.34 3.833-.583 5.183L17.764 12 5.398 5.818c.242 1.349.51 3.221.583 5.183H10v2H5.981z"></path></g> </svg> </button> </div> <input type="file" id="message-image-input" accept="imagei, '') .replace(/```\s*[\s\S]*$/i, '') .replace(/^[^{\[]*/, '') .replace(/[^}\]]*$/, '') .trim(); const trailingCommaPattern = /,(\s*[}\]])/g; if (trailingCommaPattern.test(repairedString)) { repairedString = repairedString.replace(trailingCommaPattern, '$1'); fixCount++; console.log('✅ [JSON修复] 已移除末尾多余逗号'); } const unescapedNewlinePattern = /("(?:\\.|[^"\\])*?")/g; repairedString = repairedString.replace(unescapedNewlinePattern, match => { if (match.includes('\n') && !match.includes('\\n')) { fixCount++; return match.replace(/\n/g, '\\n'); } return match; }); const unquotedKeyPattern = /([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g; if (unquotedKeyPattern.test(repairedString)) { repairedString = repairedString.replace(unquotedKeyPattern, '$1"$2":'); fixCount++; console.log('✅ [JSON修复] 已为键名添加引号'); } const singleQuotePattern = /'/g; if (repairedString.includes("'")) { repairedString = repairedString.replace(/:\s*'([^']*?)'/g, ': "$1"'); repairedString = repairedString.replace(/{\s*'([^']*?)'\s*:/g, '{"$1":'); fixCount++; console.log('✅ [JSON修复] 已替换部分单引号为双引号'); } repairedString = repairedString.replace(/"([^"]*)":\s*"([^"]*)"/g, (match, key, value) => { const escapedQuotes = (value.match(/\\"/g) || []).length; const totalQuotes = (value.match(/"/g) || []).length; if (totalQuotes > escapedQuotes) { const fixedValue = value.replace(/(?<!\\)"/g, '\\"'); fixCount++; return `"${key}": "${fixedValue}"`; } return match; }); try { JSON.parse(repairedString); if (fixCount > 0) { console.log(`✅ [JSON修复] 成功修复 ${fixCount} 处错误，JSON现在有效`); } else { console.log('ℹ️ [JSON修复] JSON原本就是有效的，无需修复'); } return repairedString; } catch (parseError) { console.warn('⚠️ [JSON修复] 基础修复后仍无法解析，尝试深度修复...'); repairedString = repairedString.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, ''); const openBraces = (repairedString.match(/{/g) || []).length; const closeBraces = (repairedString.match(/}/g) || []).length; const openBrackets = (repairedString.match(/\[/g) || []).length; const closeBrackets = (repairedString.match(/\]/g) || []).length; if (openBraces > closeBraces) { repairedString += '}'.repeat(openBraces - closeBraces); console.log(`✅ [JSON修复] 添加了 ${openBraces - closeBraces} 个缺失的 }`); fixCount++; } if (openBrackets > closeBrackets) { repairedString += ']'.repeat(openBrackets - closeBrackets); console.log(`✅ [JSON修复] 添加了 ${openBrackets - closeBrackets} 个缺失的 ]`); fixCount++; } try { JSON.parse(repairedString); console.log(`✅ [JSON修复] 深度修复成功，共修复 ${fixCount} 处错误`); return repairedString; } catch (finalError) { console.error('❌ [JSON修复] 修复失败，JSON仍然无效:', finalError.message); console.error('修复后的内容:', repairedString.substring(0, 500) + '...'); return null; } } } catch (error) { console.error('❌ [JSON修复] 修复过程中发生错误:', error); return null; } }, async getApplicableWorldBooks(scene, options = {}) { try { const xDB = getXDB(); const globalSettings = await xDB.xSettings.get('globalWorldBooks'); if (!globalSettings || !globalSettings.worldBooks || globalSettings.worldBooks.length === 0) { console.log(`🔍 [世界书] 未找到全局世界书数据`); return ''; } console.log(`🔍 [世界书] 当前场景: ${scene}, 总世界书数: ${globalSettings.worldBooks.length}`); const { boundCharacters = [] } = options; const applicableBooks = globalSettings.worldBooks.filter(book => { const hasSceneBinding = book.scenes && book.scenes.length > 0; const hasTargetBinding = book.targetType && book.targetType !== 'none'; const isTrulyIdle = !hasSceneBinding && !hasTargetBinding; if (isTrulyIdle) { console.log(`⏸️ [世界书] "${book.name}" - 闲置状态，跳过应用`); return false; } const isMessagesScene = scene === 'messages'; if (book.targetType === 'specific' && book.selectedCharacters) { const applicable = boundCharacters && boundCharacters.some(charId => book.selectedCharacters.includes(charId)); console.log( `${applicable ? '✅' : '❌'} [世界书] "${book.name}" - 指定角色 (当前: [${boundCharacters.join( ', ', )}], 需要: [${book.selectedCharacters.join(', ')}])`, ); return applicable; } if (isMessagesScene) { if (hasSceneBinding && !book.scenes.includes('global')) { console.log(`❌ [世界书] "${book.name}" - 私信场景但绑定了其他场景 (${book.scenes.join(', ')})`); return false; } if (book.scenes && book.scenes.includes('global')) { console.log(`✅ [世界书] "${book.name}" - 全局场景，适用于所有场景`); return true; } if (book.targetType === 'all') { console.log(`✅ [世界书] "${book.name}" - 全局对话，适用于所有私信`); return true; } if (book.targetType === 'characterOnly') { const applicable = boundCharacters && boundCharacters.length > 0; console.log( `${applicable ? '✅' : '❌'} [世界书] "${book.name}" - 仅角色对话 (当前角色数: ${ boundCharacters.length })`, ); return applicable; } console.log(`❌ [世界书] "${book.name}" - 私信场景但目标类型不适用`); return false; } if (!hasSceneBinding) { console.log(`❌ [世界书] "${book.name}" - 非私信场景且未绑定场景`); return false; } const sceneMatches = book.scenes.includes('global') || book.scenes.includes(scene); if (!sceneMatches) { console.log(`❌ [世界书] "${book.name}" - 场景不匹配 (需要: ${book.scenes.join(', ')}, 当前: ${scene})`); return false; } console.log(`✅ [世界书] "${book.name}" - 场景匹配 (${book.scenes.join(', ')})`); if (book.scenes.includes('global')) { console.log(`✅ [世界书] "${book.name}" - 全局场景，无需检查目标类型`); return true; } if (book.targetType === 'all') { console.log(`✅ [世界书] "${book.name}" - 目标: 全局对话，适用`); return true; } else if (book.targetType === 'characterOnly') { const applicable = boundCharacters && boundCharacters.length > 0; console.log( `${applicable ? '✅' : '❌'} [世界书] "${book.name}" - 目标: 仅角色 (角色数: ${boundCharacters.length})`, ); return applicable; } else if (book.targetType === 'none') { console.log(`✅ [世界书] "${book.name}" - 场景绑定，无特定目标限制`); return true; } console.log(`❌ [世界书] "${book.name}" - 未知目标类型: ${book.targetType}`); return false; }); if (applicableBooks.length === 0) { console.log(`🔍 [世界书] 没有适用的世界书`); return ''; } console.log( `✅ [世界书] 找到 ${applicableBooks.length} 个适用的世界书: ${applicableBooks.map(b => b.name).join(', ')}`, ); let worldBooksContent = '\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n📚 世界书（额外知识库）📚\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n'; applicableBooks.forEach(book => { worldBooksContent += `\n【${book.name}】\n${book.content}\n`; }); return worldBooksContent; } catch (error) { console.error('获取世界书内容失败:', error); return ''; } }, async buildCharacterRelationships(boundCharacters, currentAccountId) { if (!boundCharacters || boundCharacters.length === 0) return ''; try { const xDB = getXDB(); const currentAccount = currentAccountId || 'main'; const dataId = `xCharacterRelationships_${currentAccount}`; const relationshipRecord = await xDB.xCharacterRelationships.get(dataId); if (!relationshipRecord || !relationshipRecord.data) { return ''; } const relationshipData = relationshipRecord.data; const links = relationshipData.links || []; if (links.length === 0) { return ''; } const mainDB = getDB(); const allChats = await mainDB.chats.toArray(); const allXProfiles = await xDB.xCharacterProfiles.toArray(); const charMap = new Map(); const xProfileMap = new Map(); allChats.forEach(chat => { if (!chat.isGroup) { charMap.set(chat.id, chat.name); } }); allXProfiles.forEach(profile => { xProfileMap.set(profile.characterId, profile); }); let relationshipsInfo = ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 💞 角色关系网络（角色之间的关系） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🚨 重要提示：以下是已绑定角色彼此之间的关系，这些关系与用户无关！ - 用户是独立的个体，不要将任何角色误认为用户 - 这些关系描述的是角色A与角色B之间的互动，而非用户参与的关系 `; links.forEach((link, index) => { const charAName = charMap.get(link.charA) || '未知角色A'; const charBName = charMap.get(link.charB) || '未知角色B'; const xProfileA = xProfileMap.get(link.charA); const xProfileB = xProfileMap.get(link.charB); relationshipsInfo += `【角色关系 ${index + 1}】（角色之间的关系，与用户无关）\n`; relationshipsInfo += `- 角色A：${charAName}\n`; if (xProfileA) { relationshipsInfo += ` X平台身份：${xProfileA.xName} (${xProfileA.xHandle})\n`; } relationshipsInfo += `- 角色B：${charBName}\n`; if (xProfileB) { relationshipsInfo += ` X平台身份：${xProfileB.xName} (${xProfileB.xHandle})\n`; } relationshipsInfo += `- ${charAName}对${charBName}的关系：${link.relationshipAtoB || '未设置'}\n`; relationshipsInfo += `- ${charBName}对${charAName}的关系：${link.relationshipBtoA || '未设置'}\n`; if (link.story && link.story.trim()) { relationshipsInfo += `- 关系情节：${link.story}\n`; } relationshipsInfo += `\n`; }); relationshipsInfo += ` 【角色关系互动规则】： 🚨 核心原则：这些是角色之间的关系，不要与用户关系混淆！ 1. 角色互动对象识别： - 当角色A与角色B互动时，使用上述列出的X平台身份（xName和xHandle） - 绝对不要将角色B误认为用户 - 用户有独立的用户名和句柄，不要与角色身份混淆 2. 互动频率和类型根据关系亲密度决定： - 亲密关系（情侣、挚友、家人等）：互动频率较高（30-50%），可以亲昵称呼、开玩笑 - 普通关系（朋友、同事、熟人等）：互动频率中等（15-30%），保持礼貌友好 - 紧张关系（竞争、冷战、敌对等）：互动频率较低（5-15%），可能带有暗讽、针锋相对 3. 互动内容要符合关系设定和情节背景 4. 避免强行制造互动，保持自然真实 5. 如果关系情节中有具体故事，可以在互动中体现相关细节 6. 🚨 再次强调：所有上述关系都是"角色↔角色"的关系，不是"角色↔用户"的关系！ `; return relationshipsInfo; } catch (error) { console.error('构建角色关系信息失败:', error); return ''; } }, }; const TemplateBuilders = { buildCharacterItem(character, isChecked = false) { const itemId = `character-item-${character.id}`; const avatarId = `character-avatar-${character.id}`; setTimeout(() => { const item = document.getElementById(itemId); const avatar = document.getElementById(avatarId); if (item) { EventUtils.addHoverEffect( item, { backgroundColor: 'rgba(255,255,255,0.05)' }, { backgroundColor: 'transparent' }, ); EventUtils.safeAddEventListener(item, 'click', () => toggleCharacterSelection(character.id)); } if (avatar) { EventUtils.safeAddEventListener(avatar, 'contextmenu', e => { e.preventDefault(); openCharacterXProfile(character.id); return false; }); let longPressTimer; EventUtils.safeAddEventListener(avatar, 'mousedown', () => { longPressTimer = setTimeout(() => openCharacterXProfile(character.id), 500); }); EventUtils.safeAddEventListener(avatar, 'mouseup', () => clearTimeout(longPressTimer)); EventUtils.safeAddEventListener(avatar, 'mouseleave', () => clearTimeout(longPressTimer)); EventUtils.safeAddEventListener(avatar, 'touchstart', () => { longPressTimer = setTimeout(() => openCharacterXProfile(character.id), 500); }); EventUtils.safeAddEventListener(avatar, 'touchend', () => clearTimeout(longPressTimer)); } }, 0); return ` <div id="${itemId}" class="character-item" style="display: flex; align-items: center; gap: 12px; padding: 12px; border: 1px solid #333; border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s;"> <img id="${avatarId}" src="${character.settings.aiAvatar}" alt="${character.name}" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0; cursor: pointer;" title="长按设置X资料"> <div style="flex: 1; min-width: 0;"> <div style="color: #fff; font-weight: 600; font-size: 15px; margin-bottom: 2px;">${character.name}</div> <div style="color: #71767b; font-size: 13px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;"> ${character.originalName} </div> <div style="color: var(--x-accent); font-size: 11px; margin-top: 2px;"> 长按头像设置X资料 </div> </div> ${this.buildCheckbox(character.id, isChecked)} </div> `; }, buildCheckbox(characterId, isChecked) { return ` <div class="character-checkbox" data-character-id="${characterId}" style="width: 20px; height: 20px; border: 2px solid ${ isChecked ? 'var(--x-accent)' : '#71767b' }; border-radius: 4px; display: flex; align-items: center; justify-content: center; background-color: ${ isChecked ? 'var(--x-accent)' : '#71767b' }; transition: all 0.2s; "> ${ isChecked ? '<svg viewBox="0 0 24 24" style="width: 12px; height: 12px; fill: #fff;"><path d="M9 16.17L5.53 12.7l-1.06 1.06L9 18.3l9.54-9.54-1.06-1.06L9 16.17z"/></svg>' : '' } </div> `; }, buildCharacterInfoDisplay(character) { return ` <div style="display: flex; align-items: center; gap: 16px;"> <img src="${character.settings.aiAvatar}" alt="${character.name}" style="width: 60px; height: 60px; border-radius: 50%;"> <div> <div style="color: #fff; font-size: 18px; font-weight: 600; margin-bottom: 4px;">${character.name}</div> <div style="color: #71767b; font-size: 14px;">本名：${character.originalName}</div> <div style="color: #71767b; font-size: 14px;">设置该角色在X平台的专属身份资料</div> </div> </div> `; }, buildEmptyState(message) { return `<p style="color: #71767b; text-align: center; padding: 20px;">${message}</p>`; }, buildErrorState(message) { return `<p style="color: #f4212e; text-align: center; padding: 20px;">${message}</p>`; }, }; const ValidationUtils = { validateRequired(fields) { const missing = []; for (const [key, value] of Object.entries(fields)) { if (!value || value.trim() === '') { missing.push(key); } } return { isValid: missing.length === 0, missing: missing, }; }, validateHandle(handle) { if (!handle) return { isValid: false, error: '句柄不能为空' }; if (handle.length > 15) return { isValid: false, error: '句柄长度不能超过15个字符' }; if (!/^[a-zA-Z0-9_]+$/.test(handle)) return { isValid: false, error: '句柄只能包含字母、数字和下划线' }; return { isValid: true }; }, validateName(name, maxLength = 30) { if (!name) return { isValid: false, error: '名称不能为空' }; if (name.length > maxLength) return { isValid: false, error: `名称长度不能超过${maxLength}个字符` }; return { isValid: true }; }, safeParseJSON(jsonString, defaultValue = null) { try { return JSON.parse(jsonString); } catch (error) { console.error('JSON解析失败:', error); return defaultValue; } }, safeGetElement(id) { const element = document.getElementById(id); if (!element) { console.warn(`未找到元素: ${id}`); } return element; }, handleError(error, context = '') { console.error(`${context} 错误:`, error); showXToast(`${context}失败: ${error.message}`, 'error'); }, }; const TokenUtils = { estimateTokens(text) { if (!text) return 0; const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length; const otherChars = text.length - chineseChars; return Math.ceil(chineseChars / 2 + otherChars / 4); }, logTokenUsage(sceneName, step, content, cumulativeTokens = 0) { const tokens = this.estimateTokens(content); const newTotal = cumulativeTokens + tokens; console.log( `📊 [${sceneName}] ${step}: ${tokens.toLocaleString()} tokens | 累计: ${newTotal.toLocaleString()} tokens`, ); return newTotal; }, logFinalPrompt(sceneName, systemPrompt, userMessage = '', contextInfo = '') { const systemTokens = this.estimateTokens(systemPrompt); const userTokens = this.estimateTokens(userMessage); const contextTokens = this.estimateTokens(contextInfo); const totalTokens = systemTokens + userTokens + contextTokens; console.log(` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📊 [${sceneName}] Token使用统计 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 系统提示词: ${systemTokens.toLocaleString()} tokens 用户消息: ${userTokens.toLocaleString()} tokens 上下文信息: ${contextTokens.toLocaleString()} tokens ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 总计: ${totalTokens.toLocaleString()} tokens ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `); return { systemTokens, userTokens, contextTokens, totalTokens, }; }, }; const EventUtils = { addHoverEffect(element, hoverStyle = {}, defaultStyle = {}) { if (!element) return; element.addEventListener('mouseover', () => { Object.assign(element.style, hoverStyle); }); element.addEventListener('mouseout', () => { Object.assign(element.style, defaultStyle); }); }, addHoverEffectBatch(selector, hoverStyle = {}, defaultStyle = {}) { document.querySelectorAll(selector).forEach(element => { this.addHoverEffect(element, hoverStyle, defaultStyle); }); }, addButtonHover(element) { this.addHoverEffect( element, { backgroundColor: 'rgba(255,255,255,0.1)', }, { backgroundColor: 'transparent', }, ); }, addLinkUnderlineHover(element, targetSelector = 'span') { if (!element) return; element.addEventListener('mouseover', () => { const target = targetSelector ? element.querySelector(targetSelector) : element; if (target) target.style.textDecoration = 'underline'; }); element.addEventListener('mouseout', () => { const target = targetSelector ? element.querySelector(targetSelector) : element; if (target) target.style.textDecoration = 'none'; }); }, safeAddEventListener(element, event, handler) { if (element && typeof handler === 'function') { element.addEventListener(event, handler); } }, debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func(...args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; }, throttle(func, limit) { let inThrottle; return function executedFunction(...args) { if (!inThrottle) { func.apply(this, args); inThrottle = true; setTimeout(() => (inThrottle = false), limit); } }; }, }; const APIUtils = { _getGeminiResponseText(data) { if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) { return data.candidates[0].content.parts[0].text || ''; } return ''; }, async loadConfigAndSettings(accountId = null) { const db = getDB(); const xDb = getXDB(); const apiConfig = await db.apiConfig.get('main'); if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey || !apiConfig.model) { throw new Error('请先配置API设置'); } const settingsId = `xSettings_${accountId || currentAccountId || 'main'}`; const xSettings = await xDb.xSettings.get(settingsId); return { db, xDb, apiConfig, xSettings: { userPrompt: xSettings?.systemPrompt || '', worldSetting: xSettings?.worldSetting || '', boundCharacters: xSettings?.boundCharacters || [], }, }; }, async loadBoundNPCs(accountId = null) { const xDb = getXDB(); const npcDataId = 'xNPCs_global'; const npcData = await xDb.xNPCs.get(npcDataId); const allNPCs = npcData?.npcs || []; const currentAccount = accountId || currentAccountId || 'main'; const boundNPCs = allNPCs.filter(npc => npc.boundUsers && npc.boundUsers.includes(currentAccount)); if (boundNPCs.length > 0) { console.log( `📋 已加载 ${boundNPCs.length} 个绑定NPC:`, boundNPCs.map(n => `${n.name}(${n.handle})`).join(', '), ); } return boundNPCs; }, async sendAIRequest({ apiConfig, systemPrompt, messages, temperature = 0.8 }) { const { proxyUrl, apiKey, model } = apiConfig; const isGemini = proxyUrl.includes('generativelanguage'); let response; if (isGemini) { const GEMINI_API_URL = 'https: const geminiConfig = { url: `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`, data: { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [ { parts: [ { text: systemPrompt + '\n\n' + messages .map(m => Array.isArray(m.content) ? m.content.map(c => c.text || '[图片]').join(' ') : m.content, ) .join('\n'), }, ], }, ], generationConfig: { temperature, }, }), }, }; response = await fetch(geminiConfig.url, geminiConfig.data); } else { const openAiPayload = { model: model, messages: [{ role: 'system', content: systemPrompt }, ...messages], temperature, stream: false, }; response = await fetch(`${proxyUrl}/v1/chat/completions`, { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${apiKey}`, }, body: JSON.stringify(openAiPayload), }); } if (!response.ok) { const errorData = await response.json(); throw new Error(`API错误: ${response.status} - ${errorData.error?.message || response.statusText}`); } const data = await response.json(); let aiResponseContent; if (isGemini) { aiResponseContent = this._getGeminiResponseText(data); } else { aiResponseContent = data.choices?.[0]?.message?.content || ''; } console.log('AI原始响应:', aiResponseContent); return aiResponseContent; }, parseJSONResponse(aiResponseContent) { const cleanedResponse = aiResponseContent .replace(/```json\s*/i, '') .replace(/```\s*$/, '') .trim(); if (!cleanedResponse) { throw new Error('AI返回了空的响应内容'); } try { return JSON.parse(cleanedResponse); } catch (parseError) { console.warn('⚠️ [JSON解析] 直接解析失败，尝试使用修复工具...'); console.error('原始错误:', parseError.message); console.error('尝试解析的内容:', cleanedResponse.substring(0, 500) + '...'); const repairedJSON = StringBuilders.repairJSON(cleanedResponse); if (repairedJSON) { try { const parsedData = JSON.parse(repairedJSON); console.log('✅ [JSON解析] 使用修复工具成功解析'); return parsedData; } catch (repairError) { console.error('❌ [JSON解析] 修复后仍然无法解析:', repairError.message); throw new Error(`AI返回的数据无法修复: ${repairError.message}`); } } else { console.error('❌ [JSON解析] JSON修复工具无法修复'); throw new Error(`AI返回的数据不是有效的JSON格式: ${parseError.message}`); } } }, async postProcessData(data, userProfileInfo) { data = StringBuilders.filterUserImpersonation(data, userProfileInfo.handle, userProfileInfo.name); await StringBuilders.enforceAvatarRules(data, userProfileInfo.handle); return data; }, }; const DataUtils = { formatNumber(num) { if (num === undefined || num === null) return '0'; if (num < 1000) return num.toString(); if (num < 1000000) return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K'; if (num < 1000000000) return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M'; return (num / 1000000000).toFixed(1).replace(/\.0$/, '') + 'B'; }, formatTime(dateString) { const date = new Date(dateString); const now = new Date(); const diffInSeconds = Math.floor((now - date) / 1000); if (diffInSeconds < 60) return '刚刚'; if (diffInSeconds < 3600) return Math.floor(diffInSeconds / 60) + '分钟前'; if (diffInSeconds < 86400) return Math.floor(diffInSeconds / 3600) + '小时前'; if (diffInSeconds < 2592000) return Math.floor(diffInSeconds / 86400) + '天前'; return date.toLocaleDateString('zh-CN', { year: 'numeric', month: 'short', day: 'numeric', }); }, generateId(prefix = 'id') { return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; }, deepClone(obj) { if (obj === null || typeof obj !== 'object') return obj; if (obj instanceof Date) return new Date(obj.getTime()); if (obj instanceof Array) return obj.map(item => this.deepClone(item)); if (typeof obj === 'object') { const clonedObj = {}; for (const key in obj) { if (obj.hasOwnProperty(key)) { clonedObj[key] = this.deepClone(obj[key]); } } return clonedObj; } }, uniqueArray(arr, key = null) { if (key) { const seen = new Set(); return arr.filter(item => { const keyValue = item[key]; if (seen.has(keyValue)) { return false; } seen.add(keyValue); return true; }); } return [...new Set(arr)]; }, safeGet(obj, path, defaultValue = null) { const keys = path.split('.'); let result = obj; for (const key of keys) { if (result === null || result === undefined || !result.hasOwnProperty(key)) { return defaultValue; } result = result[key]; } return result; }, sortBy(arr, key, ascending = true) { return arr.sort((a, b) => { const aVal = this.safeGet(a, key); const bVal = this.safeGet(b, key); if (aVal < bVal) return ascending ? -1 : 1; if (aVal > bVal) return ascending ? 1 : -1; return 0; }); }, paginate(arr, page = 1, limit = 10) { const offset = (page - 1) * limit; return { data: arr.slice(offset, offset + limit), pagination: { page, limit, total: arr.length, totalPages: Math.ceil(arr.length / limit), hasNext: offset + limit < arr.length, hasPrev: page > 1, }, }; }, }; const PerformanceUtils = { cache: new Map(), setCache(key, value, ttl = 300000) { this.cache.set(key, { value, expiry: Date.now() + ttl, }); }, getCache(key) { const item = this.cache.get(key); if (!item) return null; if (Date.now() > item.expiry) { this.cache.delete(key); return null; } return item.value; }, cleanExpiredCache() { const now = Date.now(); for (const [key, item] of this.cache.entries()) { if (now > item.expiry) { this.cache.delete(key); } } }, batchDOMUpdate(updates) { const fragment = document.createDocumentFragment(); updates.forEach(update => { if (typeof update === 'function') { update(fragment); } }); return fragment; }, defer(callback, delay = 0) { return setTimeout(callback, delay); }, idle(callback) { if (window.requestIdleCallback) { return window.requestIdleCallback(callback); } else { return setTimeout(callback, 1); } }, measurePerformance(name, fn) { return async (...args) => { const start = performance.now(); try { const result = await fn(...args); const end = performance.now(); console.log(`Performance [${name}]: ${(end - start).toFixed(2)}ms`); return result; } catch (error) { const end = performance.now(); console.error(`Performance [${name}] Error: ${(end - start).toFixed(2)}ms`, error); throw error; } }; }, }; setInterval(() => PerformanceUtils.cleanExpiredCache(), 60000); function switchXPage(pageType) { const mainPages = ['home', 'notifications', 'messages', 'settings', 'profile']; if (mainPages.includes(pageType) && isInSearchResults) { console.log('📖 [导航] 切换到其他页面，清除搜索结果标记'); isInSearchResults = false; currentSearchQuery = ''; } if (pageType === 'home') { hideNavNotificationDot('home'); } else if (pageType === 'notifications') { hideNavNotificationDot('notifications'); } else if (pageType === 'messages') { hideNavNotificationDot('messages'); } DOMUtils.hide('.x-page'); const targetPage = document.getElementById('x-' + pageType + '-page'); if (targetPage) targetPage.style.display = 'flex'; const topBar = document.querySelector('.x-top-bar'); const bottomNav = document.querySelector('.x-bottom-nav'); const refreshBtn = document.querySelector('.refresh-trends-btn'); if (pageType === 'askbox' || pageType === 'live') { if (topBar) topBar.style.display = 'none'; if (bottomNav) bottomNav.style.display = 'none'; if (refreshBtn) refreshBtn.style.display = 'none'; } else { if (topBar) topBar.style.display = 'flex'; if (bottomNav) bottomNav.style.display = 'flex'; if (refreshBtn) { refreshBtn.style.display = pageType === 'search' ? 'flex' : 'none'; } } DOMUtils.removeClass('.x-nav-item', 'active'); DOMUtils.setStyle('.x-nav-item svg', 'fill', '#fff'); DOMUtils.hide('.nav-highlight'); const pageIndexMap = { home: 0, search: 1, notifications: 2, messages: 3, settings: -1, profile: -1, askbox: -1, live: -1, }; const targetIndex = pageIndexMap[pageType]; if (pageType === 'profile') { setTimeout(() => { loadUserProfileToUI(); loadUserProfileTweets(); }, 100); } else if (pageType === 'askbox') { setTimeout(() => { loadAskboxData(); }, 100); } else if (pageType === 'live') { setTimeout(async () => { await initLivePage(); }, 100); } else if (pageType === 'search') { setTimeout(() => { initSearchPage(); }, 100); } else if (pageType === 'notifications') { setTimeout(async () => { await loadNotifications(); }, 100); } else if (pageType === 'messages') { setTimeout(async () => { await loadMessagesList(); }, 100); } if (pageType === 'settings') { setTimeout(async () => { await initializeXSettings(); await loadLanguagePreference(); await loadAccentColorPreference(); console.log('✅ 已加载当前账号的X设置'); }, 100); } const navItems = document.querySelectorAll('.x-nav-item'); if (navItems[targetIndex] && targetIndex >= 0) { navItems[targetIndex].classList.add('active'); navItems[targetIndex].querySelector('svg').style.fill = 'var(--x-accent)'; navItems[targetIndex].querySelector('.nav-highlight').style.display = 'block'; } } function switchHomeTab(tabName) { DOMUtils.removeClass('.x-tab', 'active'); DOMUtils.setStyle('.x-tab', 'color', '#71767b'); DOMUtils.hide('.tab-indicator'); DOMUtils.hide('.tab-content'); const tabs = document.querySelectorAll('.x-tab'); const tabIndex = tabName === 'for-you' ? 0 : 1; const contentId = tabName === 'for-you' ? 'for-you-content' : 'following-content'; if (tabs[tabIndex]) { tabs[tabIndex].classList.add('active'); tabs[tabIndex].style.color = '#fff'; tabs[tabIndex].querySelector('.tab-indicator').style.display = 'block'; } const content = document.getElementById(contentId); if (content) content.style.display = 'flex'; } let currentSearchTab = 'recommended'; let trendingData = { recommended: [ { id: 't1', category: '娱乐 · 热门话题', title: '流行电影讨论', count: 125600, }, { id: 't2', category: '体育 · 实时', title: '篮球比赛精彩瞬间', count: 89200, }, { id: 't3', category: '科技 · 趋势', title: 'AI技术新突破', count: 256700, }, { id: 't4', category: '音乐 · 流行', title: '新专辑发布', count: 67800, }, { id: 't5', category: '游戏 · 热门', title: '年度游戏评选', count: 145300, }, ], trending: [ { id: 't6', category: '全球 · 趋势', title: '国际新闻热点', count: 892300, }, { id: 't7', category: '商业 · 财经', title: '股市最新动态', count: 234500, }, { id: 't8', category: '社会 · 讨论', title: '社会话题关注', count: 456700, }, { id: 't9', category: '文化 · 热议', title: '传统文化传承', count: 178900, }, { id: 't10', category: '健康 · 生活', title: '养生健康小贴士', count: 123400, }, ], }; let customCategories = []; let currentSearchQuery = ''; let currentSearchResultTab = 'top'; let isInSearchResults = false; let searchResultsData = { top: [], latest: [], users: [], }; function switchSearchTab(tabName) { currentSearchTab = tabName; const tabs = document.querySelectorAll('.search-tab'); tabs.forEach(tab => { tab.classList.remove('active'); }); const activeTab = Array.from(tabs).find(tab => tab.onclick && tab.onclick.toString().includes(tabName)); if (activeTab) { activeTab.classList.add('active'); } renderTrendingList(); } function renderTrendingList() { const container = document.getElementById('trending-list'); if (!container) return; const trends = trendingData[currentSearchTab] || []; if (trends.length === 0) { container.innerHTML = ` <div style="display: flex; justify-content: center; align-items: center; padding: 40px 20px; color: #71767b;"> 暂无热搜内容 </div> `; return; } container.innerHTML = trends .map( trend => ` <div class="trending-item" onclick="handleTrendingClick('${trend.id}')"> <div class="trending-header"> <div class="trending-category">${trend.category}</div> <div class="trending-more" onclick="event.stopPropagation(); handleTrendingMore('${trend.id}')"> <svg viewBox="0 0 24 24" aria-hidden="true"> <g><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g> </svg> </div> </div> <div class="trending-title">${trend.title}</div> <div class="trending-count">${formatNumber(trend.count)} 条帖子</div> </div> `, ) .join(''); } async function refreshTrends() { const refreshBtn = document.querySelector('.refresh-trends-btn'); if (!refreshBtn) return; refreshBtn.classList.add('spinning'); try { const { apiConfig, xSettings, xDb } = await APIUtils.loadConfigAndSettings(); const { userPrompt, worldSetting, boundCharacters } = xSettings; const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); const publicIdentity = userXProfileInfo.publicIdentity || ''; const bio = userXProfileInfo.bio || ''; const isPublicFigure = /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test( publicIdentity + ' ' + bio, ); console.log('🎭 用户公众身份检测:', { isPublicFigure, publicIdentity, bio, }); let tokenCount = 0; let systemPrompt = StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting, }); tokenCount = TokenUtils.logTokenUsage('热搜生成器', '基础系统提示词', systemPrompt, tokenCount); const worldBooksContent = await StringBuilders.getApplicableWorldBooks('trending', { boundCharacters, }); if (worldBooksContent) { systemPrompt += worldBooksContent; tokenCount = TokenUtils.logTokenUsage('热搜生成器', '世界书内容', worldBooksContent, tokenCount); } const enabledCustomCategories = customCategories.filter(cat => cat.enabled && cat.name); systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务说明 🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的热搜生成器。请生成当前的热门话题列表。 【生成要求】： - 为"为你推荐"和"当前趋势"各生成5条热搜 ${ enabledCustomCategories.length > 0 ? `- 同时为以下自定义分类各生成5条热搜：${enabledCustomCategories.map(c => `"${c.name}"`).join('、')}` : '' } - 热搜话题要多样化，涵盖不同领域和分类 - 热搜数量（帖子数）要符合真实社交平台规模（1万到100万之间） - 话题标题要简洁有力，符合社交媒体特点 ${ isPublicFigure ? '- 用户或绑定角色是公众人物，可以适当生成1-2条相关热搜（占比约20%）' : '- 用户和角色不是公众人物，生成通用热门话题即可，不要涉及用户或角色' } 【热搜分类示例】： - 娱乐 · 热门话题：电影、音乐、综艺、明星动态 - 体育 · 实时：比赛、运动员、体育赛事 - 科技 · 趋势：新技术、产品发布、科技新闻 - 社会 · 讨论：时事、民生、社会话题 - 游戏 · 热门：游戏更新、电竞、游戏新闻 - 文化 · 热议：艺术、文学、传统文化 - 音乐 · 流行：新歌、演唱会、音乐人动态 - 美食 · 推荐：美食探店、烹饪技巧 - 旅游 · 探索：旅行目的地、旅游攻略 - 时尚 · 潮流：穿搭、时装周、潮流单品 - 健康 · 生活：养生、健身、生活方式 - 全球 · 趋势：国际新闻、全球热点 - 商业 · 财经：经济动态、商业新闻 - 教育 · 学习：学习方法、教育资讯 ${ enabledCustomCategories.length > 0 ? ` 【自定义分类详细说明】：${enabledCustomCategories .map( cat => ` - ${cat.name}：${cat.description || '生成该分类下的热门话题'}`, ) .join('')} ` : '' } `; if (isPublicFigure) { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📋 公众人物信息（可用于生成相关热搜） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 【用户公开信息】： - 用户名：${userXProfileInfo.name} - 用户句柄：${userXProfileInfo.handle} - 公众身份：${userXProfileInfo.publicIdentity} ${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ''} ${ userXProfileInfo.verificationType !== 'none' ? `- 认证状态：${StringBuilders.getUserVerificationTypeDescription(userXProfileInfo)}` : '' } ${ userXProfileInfo.verificationType === 'couple' && userXProfileInfo.coupleCharacterName ? `- 情侣关系：与${userXProfileInfo.coupleCharacterName}为公开情侣` : '' } `; const publicFigureProfiles = []; if (boundCharacters.length > 0) { const allXProfiles = await xDb.xCharacterProfiles.toArray(); for (const charId of boundCharacters) { const xProfile = allXProfiles.find(p => p.characterId === charId); if (xProfile && xProfile.publicIdentity) { const isCharPublicFigure = /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test( xProfile.publicIdentity, ); if (isCharPublicFigure) { publicFigureProfiles.push({ type: 'character', name: xProfile.xName, handle: xProfile.xHandle, publicIdentity: xProfile.publicIdentity, bio: xProfile.xBio || '', }); } } } } const npcDataId = 'xNPCs_global'; const npcData = await xDb.xNPCs.get(npcDataId); const allNPCs = npcData?.npcs || []; const currentAccount = currentAccountId || 'main'; const boundNPCs = allNPCs.filter(npc => npc.boundUsers && npc.boundUsers.includes(currentAccount)); for (const npc of boundNPCs) { const npcTexts = [npc.personality || '', npc.homepage || ''].join(' '); const isNpcPublicFigure = /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test( npcTexts, ); if (isNpcPublicFigure) { publicFigureProfiles.push({ type: 'npc', name: npc.name, handle: npc.handle, publicIdentity: '公众人物', bio: npc.personality || '', }); } } if (publicFigureProfiles.length > 0) { systemPrompt += ` 【绑定公众人物信息】： `; for (const profile of publicFigureProfiles) { systemPrompt += ` 【${profile.name}】（${profile.type === 'character' ? '角色' : 'NPC'}） - X姓名：${profile.name} - X句柄：${profile.handle} - 公众身份：${profile.publicIdentity} ${profile.bio ? `- 简介/人设：${profile.bio}` : ''} `; try { const cleanHandle = profile.handle.replace('@', ''); const accountProfile = await xDb.xAccountProfiles.get(cleanHandle); const recentTweets = accountProfile?.tweets?.slice(0, 5) || []; if (recentTweets.length > 0) { systemPrompt += ` ${profile.name} 的近期推文（${recentTweets.length}条）： `; recentTweets.forEach((tweet, index) => { systemPrompt += ` ${index + 1}. "${tweet.content}" - 时间：${tweet.time || '最近'} - 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发 ${tweet.media && tweet.media.length > 0 ? ` - 媒体：${tweet.media[0].description.substring(0, 50) + '...'}\n` : ''}`; }); } } catch (error) { console.warn(`热搜生成器：读取 ${profile.name} 的推文失败:`, error); } systemPrompt += `\n`; } } try { const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || []; if (recentUserTweets.length > 0) { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📰 用户近期推文（公众人物） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ${userXProfileInfo.name} 的近期推文（${recentUserTweets.length}条）： `; recentUserTweets.forEach((tweet, index) => { systemPrompt += ` ${index + 1}. "${tweet.content}" - 时间：${tweet.time || '最近'} - 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发，${tweet.stats?.comments || 0}评论 ${ tweet.image ? ` - 媒体：${tweet.image.type === 'description' ? tweet.image.content.substring(0, 50) + '...' : '包含图片'}\n` : '' }`; }); systemPrompt += ` 【使用说明】： - 可以基于用户和角色的近期推文内容生成相关的热搜话题 - 热搜可以反映他们最近的活动、作品、或引起的讨论 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } } catch (error) { console.warn('热搜生成器：读取用户推文失败:', error); } systemPrompt += ` 【公众人物热搜规则】： - 可以生成与用户或角色相关的热搜话题（1-2条，占比约20%） - 话题应该基于公众身份信息和近期推文内容，符合其领域和形象 - 可以围绕他们的近期动态、作品、或引起的热议生成热搜 - 不要泄露私密人设、聊天记忆等非公开信息 - 热搜内容要真实可信，像真正的社交平台热搜 - 其余80%的热搜应该是与用户/角色无关的通用热门话题 `; const publicFigureSection = systemPrompt.substring(systemPrompt.indexOf('📋 公众人物信息')); tokenCount = TokenUtils.logTokenUsage('热搜生成器', '公众人物信息与近期推文', publicFigureSection, tokenCount); } let jsonFormat = `{ "recommended": [ { "category": "分类 · 标签", "title": "热搜话题标题", "count": 数字（帖子数量，1万-100万之间） } ], "trending": [ { "category": "分类 · 标签", "title": "热搜话题标题", "count": 数字（帖子数量，1万-100万之间） } ]`; if (enabledCustomCategories.length > 0) { enabledCustomCategories.forEach(cat => { jsonFormat += `, "${cat.id}": [ { "category": "分类 · 标签", "title": "热搜话题标题", "count": 数字（帖子数量，1万-100万之间） } ]`; }); } jsonFormat += ` }`; systemPrompt += ` 【返回格式】：严格JSON格式，不要添加任何其他文字说明 ${jsonFormat} **注意事项**： 1. category格式：分类 · 标签（例如："娱乐 · 热门话题"） 2. title要简洁有力，不超过20个字 3. count必须是纯数字，不带引号，范围在10000-1000000之间 4. 每个数组包含5个热搜项 5. 话题要多样化，不要集中在某一领域 6. 确保返回纯JSON，不要有markdown代码块标记 ${enabledCustomCategories.length > 0 ? `7. 自定义分类的热搜要紧密围绕分类主题和描述，确保内容相关性` : ''} 【最终检查】：确认话题真实可信，分类准确，数量合理，${worldSetting.trim() ? '严格遵守世界观设定，' : ''}格式正确。 `; const requirementsSection = systemPrompt.substring(systemPrompt.indexOf('🎯 核心任务说明 🎯')); tokenCount = TokenUtils.logTokenUsage('热搜生成器', '任务说明与格式要求', requirementsSection, tokenCount); const messages = [{ role: 'user', content: '请生成最新的X平台热搜话题列表' }]; TokenUtils.logFinalPrompt('热搜生成器', systemPrompt, messages[0].content); const aiResponseContent = await APIUtils.sendAIRequest({ apiConfig, systemPrompt, messages, temperature: 0.9, }); const newTrendsData = APIUtils.parseJSONResponse(aiResponseContent); if (!newTrendsData.recommended || !newTrendsData.trending) { throw new Error('AI返回的数据格式不正确，缺少必要字段'); } if (!Array.isArray(newTrendsData.recommended) || !Array.isArray(newTrendsData.trending)) { throw new Error('热搜数据格式错误：recommended和trending必须是数组'); } if (enabledCustomCategories.length > 0) { for (const category of enabledCustomCategories) { if (!newTrendsData[category.id]) { console.warn(`⚠️ AI未返回自定义分类"${category.name}"的数据`); } else if (!Array.isArray(newTrendsData[category.id])) { console.warn(`⚠️ 自定义分类"${category.name}"的数据格式错误`); } } } const timestamp = Date.now(); newTrendsData.recommended = newTrendsData.recommended.map((trend, index) => ({ ...trend, id: `rec_${timestamp}_${index}`, })); newTrendsData.trending = newTrendsData.trending.map((trend, index) => ({ ...trend, id: `trend_${timestamp}_${index}`, })); enabledCustomCategories.forEach(category => { if (newTrendsData[category.id] && Array.isArray(newTrendsData[category.id])) { newTrendsData[category.id] = newTrendsData[category.id].map((trend, index) => ({ ...trend, id: `${category.id}_${timestamp}_${index}`, })); } }); trendingData.recommended = newTrendsData.recommended; trendingData.trending = newTrendsData.trending; enabledCustomCategories.forEach(category => { if (newTrendsData[category.id]) { trendingData[category.id] = newTrendsData[category.id]; } }); try { const saveData = { id: 'trends', recommended: newTrendsData.recommended, trending: newTrendsData.trending, lastUpdated: new Date().toISOString(), }; enabledCustomCategories.forEach(category => { if (newTrendsData[category.id]) { saveData[category.id] = newTrendsData[category.id]; } }); await xDb.xTweetsData.put(saveData); console.log('✅ 热搜数据已保存到数据库', { 默认分类: 2, 自定义分类: enabledCustomCategories.length, }); } catch (saveError) { console.error('⚠️ 保存热搜数据失败:', saveError); } renderTrendingList(); showXToast('热搜已刷新', 'success'); } catch (error) { console.error('❌ 刷新热搜失败:', error); showXToast(`刷新失败: ${error.message}`, 'error'); } finally { if (refreshBtn) { refreshBtn.classList.remove('spinning'); } } } function handleTrendingClick(trendId) { console.log('点击热搜:', trendId); let trendItem = null; for (const category in trendingData) { const found = trendingData[category].find(t => t.id === trendId); if (found) { trendItem = found; break; } } if (!trendItem) { console.error('未找到热搜数据:', trendId); return; } const searchInput = document.getElementById('search-input'); if (searchInput) { searchInput.value = trendItem.title; toggleSearchButton(); } performSearch(); } function handleTrendingMore(trendId) { console.log('热搜更多选项:', trendId); showXToast('更多选项功能待开发', 'info'); } function toggleSearchButton() { const input = document.getElementById('search-input'); const button = document.getElementById('search-submit-btn'); if (input && button) { if (input.value.trim()) { button.style.display = 'flex'; } else { button.style.display = 'none'; } } } function switchSearchResultTab(tabName) { currentSearchResultTab = tabName; const tabs = document.querySelectorAll('#search-results-view .search-tab'); tabs.forEach((tab, index) => { const tabNames = ['top', 'latest', 'users']; if (tabNames[index] === tabName) { tab.classList.add('active'); } else { tab.classList.remove('active'); } }); renderSearchResults(); } function renderSearchResults() { const container = document.getElementById('search-results-content'); if (!container) return; const results = searchResultsData[currentSearchResultTab] || []; if (results.length === 0) { container.innerHTML = ` <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px 20px; color: #71767b; "> <svg viewBox="0 0 24 24" style="width: 80px; height: 80px; fill: #71767b; margin-bottom: 20px;"> <g><path d="M10.25 3.75c-3.59 0-6.5 2.91-6.5 6.5s2.91 6.5 6.5 6.5c1.795 0 3.419-.726 4.596-1.904 1.178-1.177 1.904-2.801 1.904-4.596 0-3.59-2.91-6.5-6.5-6.5zm-8.5 6.5c0-4.694 3.806-8.5 8.5-8.5s8.5 3.806 8.5 8.5c0 1.986-.682 3.815-1.824 5.262l4.781 4.781-1.414 1.414-4.781-4.781c-1.447 1.142-3.276 1.824-5.262 1.824-4.694 0-8.5-3.806-8.5-8.5z"></path></g> </svg> <div style="font-size: 20px; font-weight: 600; margin-bottom: 8px;">没有找到结果</div> <div style="font-size: 14px;">尝试搜索其他内容</div> </div> `; return; } if (currentSearchResultTab === 'users') { container.innerHTML = results .map( user => ` <div style="padding: 16px; border-bottom: 1px solid #2f3336; display: flex; align-items: center; gap: 12px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'" onmouseout="this.style.backgroundColor='transparent'"> <img src="${user.avatar}" alt="${user.name}" onclick="event.stopPropagation(); openAccountProfile('${user.name.replace(/'/g, "\\'")}', '${ user.handle.startsWith('@') ? user.handle : '@' + user.handle }', '${user.avatar}', { source: 'search', searchQuery: '${currentSearchQuery.replace(/'/g, "\\'")}', userBio: '${(user.bio || '').replace(/'/g, "\\'")}', verified: ${user.verified || false} })" style="width: 48px; height: 48px; border-radius: 50%; flex-shrink: 0; cursor: pointer; transition: opacity 0.2s; " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'"> <div style="flex: 1; min-width: 0;"> <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px;"> <span style="color: #fff; font-weight: 700; font-size: 15px;">${user.name}</span> ${ user.verified ? `<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"> <g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.26 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.45 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g> </svg>` : '' } </div> <div style="color: #71767b; font-size: 15px; margin-bottom: 4px;">@${user.handle}</div> ${user.bio ? `<div style="color: #e7e9ea; font-size: 14px;">${user.bio}</div>` : ''} </div> </div> `, ) .join(''); } else { container.innerHTML = ''; results.forEach(tweet => { const tweetElement = createTweetElement(tweet); container.appendChild(tweetElement); const commentAction = tweetElement.querySelector('.tweet-action.comment'); if (commentAction) { commentAction.removeAttribute('onclick'); commentAction.addEventListener('click', async e => { e.stopPropagation(); console.log('📖 [搜索结果] 点击评论按钮，显示详情:', tweet.id); await showSearchTweetDetail(tweet.id); }); } }); } } window.showSearchTweetDetail = async function (tweetId) { console.log('📖 [搜索结果] 显示推文详情:', tweetId); const allSearchTweets = [...(searchResultsData.top || []), ...(searchResultsData.latest || [])]; const tweet = allSearchTweets.find(t => t.id === tweetId); if (!tweet) { showXToast('未找到该推文', 'error'); return; } if (!tweet._source) { tweet._source = 'search'; } await showTweetDetail(tweet); }; async function performSearch() { const input = document.getElementById('search-input'); const query = input?.value?.trim(); if (!query) { showXToast('请输入搜索内容', 'info'); return; } currentSearchQuery = query; isInSearchResults = true; document.getElementById('trending-view').style.display = 'none'; document.getElementById('search-results-view').style.display = 'flex'; const backBtn = document.getElementById('search-back-btn'); if (backBtn) backBtn.style.display = 'flex'; const refreshBtn = document.querySelector('.refresh-trends-btn'); if (refreshBtn) refreshBtn.style.display = 'none'; const container = document.getElementById('search-results-content'); container.innerHTML = ` <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px 20px; color: #71767b; "> <div style="width: 40px; height: 40px; border: 3px solid var(--x-accent); border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; "></div> <div style="margin-top: 20px; font-size: 15px;">正在搜索"${query}"...</div> </div> `; try { const { apiConfig, xSettings, xDb } = await APIUtils.loadConfigAndSettings(); const { userPrompt, worldSetting, boundCharacters } = xSettings; const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); const allXProfiles = await xDb.xCharacterProfiles.toArray(); const characterXProfiles = []; for (const charId of boundCharacters) { const xProfile = allXProfiles.find(p => p.characterId === charId); if (xProfile) { characterXProfiles.push(xProfile); } } const userPublicIdentity = userXProfileInfo.publicIdentity || ''; const userBio = userXProfileInfo.bio || ''; const isUserPublicFigure = /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test( userPublicIdentity + ' ' + userBio, ); let tokenCount = 0; let systemPrompt = StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting, }); tokenCount = TokenUtils.logTokenUsage('搜索生成器', '基础系统提示词', systemPrompt, tokenCount); const worldBooksContent = await StringBuilders.getApplicableWorldBooks('search', { boundCharacters, }); if (worldBooksContent) { systemPrompt += worldBooksContent; tokenCount = TokenUtils.logTokenUsage('搜索生成器', '世界书内容', worldBooksContent, tokenCount); } const worldBookCharacterIds = new Set(); if (worldBooksContent) { for (const charId of boundCharacters) { const xProfile = allXProfiles.find(p => p.characterId === charId); if (xProfile) { const charName = xProfile.xName || ''; const charHandle = xProfile.xHandle || ''; if ( (charName && worldBooksContent.includes(charName)) || (charHandle && worldBooksContent.includes(charHandle)) ) { worldBookCharacterIds.add(charId); console.log(`🔍 世界书中提到角色: ${charName} (${charHandle})`); } } } } const allowedProfiles = []; const queryLower = query.toLowerCase(); for (const xProfile of characterXProfiles) { let allowInSearch = false; const charPublicIdentity = xProfile.publicIdentity || ''; const isCharPublicFigure = /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test( charPublicIdentity, ); if (isCharPublicFigure) { const charName = xProfile.xName || ''; const charHandle = xProfile.xHandle || ''; const charBio = xProfile.xBio || ''; if ( charName.toLowerCase().includes(queryLower) || queryLower.includes(charName.toLowerCase()) || charHandle.toLowerCase().includes(queryLower) || queryLower.includes(charHandle.toLowerCase()) || charPublicIdentity.toLowerCase().includes(queryLower) || queryLower.includes(charPublicIdentity.toLowerCase()) || (charBio && (charBio.toLowerCase().includes(queryLower) || queryLower.includes(charBio.toLowerCase()))) ) { allowInSearch = true; } } if (xProfile.showRealName && xProfile.realName) { const realNameLower = xProfile.realName.toLowerCase(); if (realNameLower.includes(queryLower) || queryLower.includes(realNameLower)) { allowInSearch = true; } } if (allowInSearch) { allowedProfiles.push({ type: 'character', characterId: xProfile.characterId, xProfile: xProfile, name: xProfile.xName, handle: xProfile.xHandle, avatar: xProfile.xAvatar, verified: xProfile.xVerified || false, publicIdentity: charPublicIdentity, bio: xProfile.xBio || '', reason: '公众人物或真名搜索', }); } } const npcDataId = 'xNPCs_global'; const npcData = await xDb.xNPCs.get(npcDataId); const allNPCs = npcData?.npcs || []; const currentAccount = currentAccountId || 'main'; const boundNPCs = allNPCs.filter(npc => npc.boundUsers && npc.boundUsers.includes(currentAccount)); for (const npc of boundNPCs) { const npcName = npc.name || ''; const npcHandle = npc.handle || ''; const npcPersonality = npc.personality || ''; const npcHomepage = npc.homepage || ''; if ( npcName.toLowerCase().includes(queryLower) || queryLower.includes(npcName.toLowerCase()) || npcHandle.toLowerCase().includes(queryLower) || queryLower.includes(npcHandle.toLowerCase()) || npcPersonality.toLowerCase().includes(queryLower) || npcHomepage.toLowerCase().includes(queryLower) ) { allowedProfiles.push({ type: 'npc', npc: npc, name: npcName, handle: npcHandle, avatar: npc.avatar, verified: false, publicIdentity: '', bio: '', reason: 'NPC账户匹配', }); } } for (const xProfile of allXProfiles) { if (xProfile.relationships && xProfile.relationships.length > 0) { for (const relationship of xProfile.relationships) { const relNpcName = relationship.npcName || ''; const relNpcHandle = relationship.npcHandle || ''; const relType = relationship.relationshipType || ''; const relDesc = relationship.description || ''; if ( relNpcName.toLowerCase().includes(queryLower) || queryLower.includes(relNpcName.toLowerCase()) || relNpcHandle.toLowerCase().includes(queryLower) || queryLower.includes(relNpcHandle.toLowerCase()) || relType.toLowerCase().includes(queryLower) || relDesc.toLowerCase().includes(queryLower) ) { allowedProfiles.push({ type: 'relationshipNpc', relationship: relationship, ownerXProfile: xProfile, name: relNpcName, handle: relNpcHandle, avatar: 'https: verified: false, publicIdentity: '', bio: '', reason: '关系NPC匹配', }); } } } } console.log('🔍 搜索匹配检查:', { query, 角色: allowedProfiles.filter(p => p.type === 'character').length, NPC: allowedProfiles.filter(p => p.type === 'npc').length, 关系NPC: allowedProfiles.filter(p => p.type === 'relationshipNpc').length, 总计: allowedProfiles.length, }); for (const charId of worldBookCharacterIds) { if (!allowedProfiles.find(p => p.type === 'character' && p.characterId === charId)) { const xProfile = allXProfiles.find(p => p.characterId === charId); if (xProfile) { allowedProfiles.push({ type: 'character', characterId: xProfile.characterId, xProfile: xProfile, name: xProfile.xName, handle: xProfile.xHandle, avatar: xProfile.xAvatar, verified: xProfile.xVerified || false, publicIdentity: xProfile.publicIdentity || '', bio: xProfile.xBio || '', reason: '世界书提及', }); } } } console.log('🔍 搜索隐私检查（优化后）:', { query, isUserPublicFigure, totalCharacters: boundCharacters.length, totalNPCs: boundNPCs.length, worldBookMentioned: worldBookCharacterIds.size, allowedTotal: allowedProfiles.length, allowedList: allowedProfiles.map(p => `${p.name} (${p.reason})`), }); systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务说明 🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的搜索结果生成器。用户搜索了关键词："${query}" 这是全局搜索，需要生成符合搜索关键词的X平台内容。 请生成与搜索关键词相关的结果： - 热门：3-8条与关键词高度相关的热门推文 - 最新：3-5条与关键词相关的最新推文 - 用户：2-6个与关键词相关的X用户账号 【重要隐私规则】： ${ allowedProfiles.length === 0 && !isUserPublicFigure ? `- **禁止出现绑定身份**：用户和所有绑定身份都不符合搜索条件 - 生成的所有内容必须是虚构的陌生用户，不能使用任何绑定角色/NPC的信息 - 这是全局搜索，应该展示与关键词相关的公众内容，而非私人关系` : '' } ${ isUserPublicFigure && queryLower.includes(userXProfileInfo.name.toLowerCase()) ? `- **用户是公众人物且搜索了用户相关关键词**：可以生成少量与用户相关的内容（1-2条）` : '' } ${ allowedProfiles.length > 0 ? `- **允许出现以下身份**（仅限这些）：${allowedProfiles.map(p => `${p.name}[${p.reason}]`).join('、')} - 原因说明： * "公众人物或真名搜索"：该角色是公众人物且搜索关键词与他们相关，或搜索了他们公开的真名 * "世界书提及"：该角色在世界书中被提及，可以根据世界书的上下文在搜索结果中出现 * "NPC账户匹配"：该NPC的名称、句柄或人设与搜索关键词匹配 * "关系NPC匹配"：该关系NPC的名称、句柄或关系描述与搜索关键词匹配 - 其他未列出的身份严禁出现` : `- **禁止出现任何绑定身份**：没有身份符合出现条件（非公众人物、搜索关键词不相关、且未在世界书中提及）` } 【生成要求】： - 所有内容必须与搜索关键词"${query}"高度相关 - 热门推文应该有较高的互动数据（点赞、转发、评论） - 最新推文时间较近（几分钟到几小时前） - 推文内容要多样化，从不同角度体现搜索关键词 - 每条推文2-5条评论即可 - 用户账号要有相关性（用户名、简介、或身份与关键词相关） - 除已绑定角色外，其他用户头像统一：https: - 这是全局搜索，应展示多样化的陌生用户内容，而非私人社交圈 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const taskSection = systemPrompt.substring(systemPrompt.indexOf('🎯 核心任务说明 🎯')); tokenCount = TokenUtils.logTokenUsage('搜索生成器', '搜索任务说明', taskSection, tokenCount); if (allowedProfiles.length > 0) { const profileSectionStart = systemPrompt.length; systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📋 允许出现的身份信息 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 以下是符合搜索条件、可以在结果中出现的身份： `; for (const profile of allowedProfiles) { systemPrompt += ` 【${profile.name}】（${profile.type === 'character' ? '角色' : profile.type === 'npc' ? 'NPC' : '关系NPC'}） - X姓名：${profile.name} - X句柄：${profile.handle} - X头像：${profile.avatar} - 认证状态：${profile.verified ? '已认证' : '未认证'} ${profile.publicIdentity ? `- 公众身份：${profile.publicIdentity}` : ''} ${profile.bio ? `- X简介：${profile.bio}` : ''} - 出现原因：${profile.reason} `; if (profile.type === 'character' && profile.xProfile) { if (profile.xProfile.showRealName && profile.xProfile.realName) { systemPrompt += `- 真实姓名：${profile.xProfile.realName}（已公开）\n`; } } else if (profile.type === 'npc' && profile.npc) { if (profile.npc.personality) { systemPrompt += `- 人设：${profile.npc.personality}\n`; } if (profile.npc.postingHabits) { systemPrompt += `- 发帖习惯：${profile.npc.postingHabits}\n`; } } else if (profile.type === 'relationshipNpc' && profile.relationship) { systemPrompt += `- 关系类型：与 ${profile.ownerXProfile.xName} (${profile.ownerXProfile.xHandle}) 的 ${profile.relationship.relationshipType}\n`; if (profile.relationship.description) { systemPrompt += `- 关系描述：${profile.relationship.description}\n`; } } try { const cleanHandle = profile.handle.replace('@', ''); const accountProfile = await xDb.xAccountProfiles.get(cleanHandle); const recentTweets = accountProfile?.tweets?.slice(0, 5) || []; if (recentTweets.length > 0) { systemPrompt += ` ${profile.name} 的近期推文（${recentTweets.length}条）： `; recentTweets.forEach((tweet, index) => { systemPrompt += ` ${index + 1}. "${tweet.content}" - 时间：${tweet.time || '最近'} - 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发 ${tweet.media && tweet.media.length > 0 ? ` - 媒体：${tweet.media[0].description.substring(0, 50) + '...'}\n` : ''}`; }); } } catch (error) { console.warn(`搜索生成器：读取 ${profile.name} 的推文失败:`, error); } systemPrompt += `\n`; } systemPrompt += ` 【使用规则】： - 只能使用上述列出的身份信息 - 必须严格使用其X姓名、句柄、头像、认证状态 - 如果他们与搜索关键词相关，可以作为推文发布者或出现在用户列表中 - 可以基于他们的近期推文内容生成相关的搜索结果 - 标注为"世界书提及"的角色，说明他们在世界书中被提及 - 标注为"公众人物或真名搜索"的角色，说明他们是公众人物且与搜索关键词相关 - 标注为"NPC账户匹配"的NPC，说明其信息与搜索关键词匹配 - 标注为"关系NPC匹配"的关系NPC，说明其关系信息与搜索关键词匹配 - 其他未列出的身份严禁出现 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const profileSection = systemPrompt.substring(profileSectionStart); tokenCount = TokenUtils.logTokenUsage('搜索生成器', '允许身份信息与推文', profileSection, tokenCount); } const userConstraintsStart = systemPrompt.length; systemPrompt += StringBuilders.buildUniversalConstraints(userXProfileInfo); if (isUserPublicFigure && queryLower.includes(userXProfileInfo.name.toLowerCase())) { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📰 用户近期推文（公众人物） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; try { const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || []; if (recentUserTweets.length > 0) { systemPrompt += `${userXProfileInfo.name} 的近期推文（${recentUserTweets.length}条）： `; recentUserTweets.forEach((tweet, index) => { systemPrompt += ` ${index + 1}. "${tweet.content}" - 时间：${tweet.time || '最近'} - 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发，${tweet.stats?.comments || 0}评论 ${ tweet.image ? ` - 媒体：${tweet.image.type === 'description' ? tweet.image.content.substring(0, 50) + '...' : '包含图片'}\n` : '' }`; }); systemPrompt += ` 【使用说明】： - 可以基于用户的近期推文生成相关的搜索结果 - 用户是公众人物，可以在搜索结果中适度出现（1-2条推文） - 但仍然禁止在评论区假扮用户身份 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } else { systemPrompt += `暂无近期推文数据 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } } catch (error) { console.warn('搜索生成器：读取用户推文失败:', error); systemPrompt += `暂无近期推文数据 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } } const userConstraints = systemPrompt.substring(userConstraintsStart); tokenCount = TokenUtils.logTokenUsage('搜索生成器', '用户资料约束与推文', userConstraints, tokenCount); systemPrompt += ` 【JSON返回格式】： \`\`\`json { "top": [热门推文数组(3-5条)], "latest": [最新推文数组(3-5条)], "users": [用户数组(2-4个)] } \`\`\` 推文对象结构： - user: {name, handle, avatar, verified} - content: 推文文本（必须与"${query}"相关） - time: 时间描述 - stats: {comments, retweets, likes, views} (纯数字) - media: [{type:"description", description:"描述，至少20字", sensitive:false}] (可选，30-50%推文包含) - comments: [评论数组(2-5条，必须生成)] 评论对象结构： - id: 评论唯一ID（可留空，系统自动生成） - user: {name, handle, avatar, verified} - content: 评论文本 - time: 时间描述 - image: {type: "description", content: "图片文字描述"} (可选，10-20%的评论带图) - replies: [楼中楼回复数组] (可选，0-2条) 楼中楼回复对象结构： - id: 回复唯一ID（可留空，系统自动生成） - user: {name, handle, avatar, verified} - content: 回复文本 - time: 时间描述 - image: {type: "description", content: "图片文字描述"} (可选) - replyTo: "@被回复者句柄" (必填) 用户对象结构： - name: 用户姓名 - handle: 用户句柄（不带@） - avatar: 头像URL - verified: 布尔值 - bio: 个人简介（体现与"${query}"的关联） 关键规则： 1. 所有内容必须围绕搜索关键词"${query}"展开 2. 热门推文stats高（1万-50万），最新推文stats低（100-5千） 3. 最新推文时间近（刚刚、几分钟前、1小时前等） 4. verified字段必须是布尔值(true/false) 5. stats中所有数字必须是纯数字 6. 每条推文必须包含2-5条评论，10-20%的评论可带图 7. 评论可以包含楼中楼回复（replies数组），形成对话链${worldSetting.trim() ? '\n8. 严格遵守世界观设定' : ''} 【🔒 隐私保护规则】： 🚨 搜索结果中的评论者（非绑定角色/关系NPC的路人）只能基于X平台公开信息： ✅ 可以使用：X姓名、X句柄、X简介、公开身份 ❌ 禁止提及：真实姓名、真实职业、私人关系、未公开的身份信息 ❌ 禁止使用：只有亲密关系才知道的称呼（如"老师"、"同学"等，除非是公开身份） ⚠️ 只有已绑定的关系NPC才能在评论中提及私密信息（因为他们是角色的私人关系） `; const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】')); tokenCount = TokenUtils.logTokenUsage('搜索生成器', 'JSON格式要求', formatSection, tokenCount); const messages = [{ role: 'user', content: `请生成关键词"${query}"的搜索结果` }]; TokenUtils.logFinalPrompt('搜索生成器', systemPrompt, messages[0].content); const aiResponseContent = await APIUtils.sendAIRequest({ apiConfig, systemPrompt, messages, temperature: 0.8, }); let searchResults = APIUtils.parseJSONResponse(aiResponseContent); searchResults = await APIUtils.postProcessData(searchResults, userXProfileInfo); if (!searchResults.top || !searchResults.latest || !searchResults.users) { throw new Error('AI返回的数据格式不正确，缺少必要字段'); } const timestamp = Date.now(); searchResults.top = searchResults.top.map((tweet, index) => ({ ...tweet, id: `search_top_${timestamp}_${index}`, _source: 'search', comments: tweet.comments?.map((comment, cIndex) => { const commentWithId = { ...comment, id: `search_top_${timestamp}_${index}_c${cIndex}`, }; if (comment.replies && comment.replies.length > 0) { commentWithId.replies = comment.replies.map((reply, rIndex) => ({ ...reply, id: `search_top_${timestamp}_${index}_c${cIndex}_r${rIndex}`, })); } return commentWithId; }) || [], })); searchResults.latest = searchResults.latest.map((tweet, index) => ({ ...tweet, id: `search_latest_${timestamp}_${index}`, _source: 'search', comments: tweet.comments?.map((comment, cIndex) => { const commentWithId = { ...comment, id: `search_latest_${timestamp}_${index}_c${cIndex}`, }; if (comment.replies && comment.replies.length > 0) { commentWithId.replies = comment.replies.map((reply, rIndex) => ({ ...reply, id: `search_latest_${timestamp}_${index}_c${rIndex}`, })); } return commentWithId; }) || [], })); searchResultsData.top = searchResults.top; searchResultsData.latest = searchResults.latest; searchResultsData.users = searchResults.users; try { await xDb.xTweetsData.put({ id: `search_${query}`, query: query, results: searchResults, timestamp: new Date().toISOString(), }); console.log('✅ 搜索结果已保存到数据库'); } catch (saveError) { console.error('⚠️ 保存搜索结果失败:', saveError); } renderSearchResults(); showXToast(`找到 ${searchResults.top.length + searchResults.latest.length} 条相关推文`, 'success'); } catch (error) { console.error('❌ 搜索失败:', error); showXToast(`搜索失败: ${error.message}`, 'error'); const container = document.getElementById('search-results-content'); container.innerHTML = ` <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px 20px; color: #f4212e; "> <svg viewBox="0 0 24 24" style="width: 80px; height: 80px; fill: #f4212e; margin-bottom: 20px;"> <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path></g> </svg> <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">搜索出错</div> <div style="font-size: 14px; color: #71767b;">${error.message}</div> </div> `; } } function backToTrending() { isInSearchResults = false; document.getElementById('search-results-view').style.display = 'none'; document.getElementById('trending-view').style.display = 'flex'; const backBtn = document.getElementById('search-back-btn'); if (backBtn) backBtn.style.display = 'none'; const refreshBtn = document.querySelector('.refresh-trends-btn'); if (refreshBtn) refreshBtn.style.display = 'flex'; const input = document.getElementById('search-input'); if (input) { input.value = ''; toggleSearchButton(); } currentSearchQuery = ''; } async function openAddCategoryModal() { const modal = document.getElementById('category-manager-modal'); if (modal) { modal.style.display = 'flex'; await loadCustomCategories(); renderCustomCategoriesList(); } } function closeCategoryModal(event) { if (event && event.target !== event.currentTarget) return; const modal = document.getElementById('category-manager-modal'); if (modal) { modal.style.display = 'none'; } } async function loadCustomCategories() { try { const xDb = getXDB(); const accountId = currentAccountId || 'main'; const settingsId = `customCategories_${accountId}`; const savedData = await xDb.xTweetsData.get(settingsId); if (savedData && savedData.categories) { customCategories = savedData.categories; console.log('✅ 已加载自定义分类:', customCategories.length, '个'); } else { customCategories = []; } } catch (error) { console.error('⚠️ 加载自定义分类失败:', error); customCategories = []; } } async function saveCustomCategories() { try { const xDb = getXDB(); const accountId = currentAccountId || 'main'; const settingsId = `customCategories_${accountId}`; await xDb.xTweetsData.put({ id: settingsId, categories: customCategories, lastUpdated: new Date().toISOString(), }); console.log('✅ 自定义分类已保存'); showXToast('分类设置已保存', 'success'); updateSearchTabs(); closeCategoryModal(); } catch (error) { console.error('❌ 保存自定义分类失败:', error); showXToast('保存失败: ' + error.message, 'error'); } } function renderCustomCategoriesList() { const container = document.getElementById('custom-categories-list'); if (!container) return; if (customCategories.length === 0) { container.innerHTML = ` <div style="text-align: center; padding: 40px 20px; color: #71767b; font-size: 14px; "> 还没有自定义分类，点击"添加分类"按钮创建 </div> `; return; } container.innerHTML = customCategories .map( (category, index) => ` <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 16px; "> <div style="display: flex; align-items: flex-start; gap: 12px;"> <label style="display: flex; align-items: center; cursor: pointer; margin-top: 4px; "> <input type="checkbox" ${category.enabled ? 'checked' : ''} onchange="toggleCategory(${index})" style="width: 18px; height: 18px; accent-color: var(--x-accent); cursor: pointer; "> </label> <div style="flex: 1; min-width: 0;"> <div style="margin-bottom: 12px;"> <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 4px; ">分类名称 *</label> <input type="text" value="${category.name || ''}" placeholder="例如：动漫" onchange="updateCategoryName(${index}, this.value)" style="width: 100%; background-color:#000; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 8px 12px; font-size: 15px; outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"> </div> <div style="margin-bottom: 12px;"> <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 4px; ">分类内容/类型（可选）</label> <textarea placeholder="例如：动画、漫画、声优、番剧相关内容" onchange="updateCategoryDescription(${index}, this.value)" style="width: 100%; min-height: 60px; background-color:#000; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 8px 12px; font-size: 14px; resize: vertical; outline: none; font-family: inherit; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">${category.description || ''}</textarea> </div> <div style="display: flex; align-items: center; justify-content: space-between; color:${ category.enabled ? 'var(--x-accent)' : '#71767b' }; font-size: 12px; "> <span>${category.enabled ? '✅ 已启用' : '❌ 已禁用'}</span> <button onclick="deleteCategory(${index})" style="background: transparent; color: #f4212e; border: 1px solid #f4212e; border-radius: 16px; padding: 4px 12px; font-size: 12px; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'" onmouseout="this.style.backgroundColor='transparent'"> 删除 </button> </div> </div> </div> </div> `, ) .join(''); } function addNewCategory() { customCategories.push({ id: `custom_${Date.now()}`, name: '', description: '', enabled: true, }); renderCustomCategoriesList(); } function deleteCategory(index) { if (confirm('确定要删除这个分类吗？')) { customCategories.splice(index, 1); renderCustomCategoriesList(); } } function toggleCategory(index) { if (customCategories[index]) { customCategories[index].enabled = !customCategories[index].enabled; renderCustomCategoriesList(); } } function updateCategoryName(index, name) { if (customCategories[index]) { customCategories[index].name = name.trim(); } } function updateCategoryDescription(index, description) { if (customCategories[index]) { customCategories[index].description = description.trim(); } } function updateSearchTabs() { const tabsContainer = document.querySelector('.search-tabs'); if (!tabsContainer) return; const addBtn = tabsContainer.querySelector('.add-category-btn'); tabsContainer.innerHTML = ''; const recommendedTab = document.createElement('div'); recommendedTab.className = 'search-tab' + (currentSearchTab === 'recommended' ? ' active' : ''); recommendedTab.textContent = '为你推荐'; recommendedTab.onclick = () => switchSearchTab('recommended'); tabsContainer.appendChild(recommendedTab); const trendingTab = document.createElement('div'); trendingTab.className = 'search-tab' + (currentSearchTab === 'trending' ? ' active' : ''); trendingTab.textContent = '当前趋势'; trendingTab.onclick = () => switchSearchTab('trending'); tabsContainer.appendChild(trendingTab); customCategories .filter(cat => cat.enabled && cat.name) .forEach(category => { const customTab = document.createElement('div'); customTab.className = 'search-tab' + (currentSearchTab === category.id ? ' active' : ''); customTab.textContent = category.name; customTab.onclick = () => switchSearchTab(category.id); tabsContainer.appendChild(customTab); }); if (addBtn) { tabsContainer.appendChild(addBtn); } } async function initSearchPage() { await loadCustomCategories(); updateSearchTabs(); if (isInSearchResults && currentSearchQuery) { document.getElementById('trending-view').style.display = 'none'; document.getElementById('search-results-view').style.display = 'flex'; const backBtn = document.getElementById('search-back-btn'); if (backBtn) backBtn.style.display = 'flex'; const refreshBtn = document.querySelector('.refresh-trends-btn'); if (refreshBtn) refreshBtn.style.display = 'none'; } else { document.getElementById('trending-view').style.display = 'flex'; document.getElementById('search-results-view').style.display = 'none'; const refreshBtn = document.querySelector('.refresh-trends-btn'); if (refreshBtn) refreshBtn.style.display = 'flex'; const backBtn = document.getElementById('search-back-btn'); if (backBtn) backBtn.style.display = 'none'; } try { const xDb = getXDB(); const savedTrends = await xDb.xTweetsData.get('trends'); if (savedTrends) { if (savedTrends.recommended && savedTrends.trending) { trendingData.recommended = savedTrends.recommended; trendingData.trending = savedTrends.trending; } customCategories.forEach(category => { if (savedTrends[category.id]) { trendingData[category.id] = savedTrends[category.id]; } }); console.log('✅ 已从数据库加载热搜数据'); } } catch (error) { console.log('⚠️ 加载热搜数据失败，使用默认数据:', error); } renderTrendingList(); } const forYouTweets = [ { id: '1', user: { name: '热门推荐用户', handle: '@trending_user', avatar: 'https: verified: true, }, content: '🔥 今日热门话题！大家都在讨论的新技术趋势 #AI #科技 #未来', time: '3小时', media: [], stats: { comments: 567, retweets: 1200, likes: 5600, views: 89000, }, comments: [ { id: 'c1-1', user: { name: '科技达人', handle: '@tech_expert', avatar: 'https: verified: true, }, content: '确实，AI技术发展太快了，每天都有新突破', time: '2小时', replies: [ { id: 'c1-1-1', user: { name: '学生小王', handle: '@student_wang', avatar: 'https: verified: false, }, content: '请问有什么推荐的学习资源吗？', time: '1小时', replyTo: '@tech_expert', }, ], }, ], }, ]; const followingTweets = [ { id: '2', user: { name: '我的朋友', handle: '@my_friend', avatar: 'https: verified: false, }, content: '今天天气真不错，和朋友们一起出去玩了！😊 #美好时光', time: '30分钟', media: [ { type: 'image', description: '阳光明媚的公园里，几个朋友在草地上野餐的温馨场景', sensitive: false, }, ], stats: { comments: 8, retweets: 2, likes: 24, views: 156, }, comments: [ { id: 'c2-1', user: { name: '好友A', handle: '@friend_a', avatar: 'https: verified: false, }, content: '看起来很棒！下次叫上我 😊', time: '25分钟', replies: [], }, ], }, { id: '3', user: { name: '数码达人', handle: '@digital_expert', avatar: 'https: verified: true, }, content: '完全同意这个观点！AI确实正在改变我们的生活方式，每个人都应该学会拥抱这种变化 🤖✨', time: '45分钟', media: [], quotedTweet: { type: 'tweet', user: { name: '科技前沿', handle: '@tech_frontier', avatar: 'https: verified: true, }, content: 'AI技术的快速发展正在重塑各行各业，从自动驾驶到智能助手，我们正生活在一个科技革命的时代 #AI #未来科技', time: '2小时', }, stats: { comments: 15, retweets: 32, likes: 89, views: 1250, }, comments: [ { id: 'c3-1', user: { name: '科技爱好者', handle: '@tech_lover', avatar: 'https: verified: false, }, content: '是的，特别是在工作效率提升方面，AI工具帮助很大', time: '40分钟', replies: [], }, ], }, ]; function formatNumber(num) { if (num >= 1000000) { return (num / 1000000).toFixed(1) + '万'; } else if (num >= 10000) { return (num / 10000).toFixed(1) + '万'; } else if (num >= 1000) { return (num / 1000).toFixed(1) + 'K'; } return num.toString(); } function processContent(content, options = {}) { if (!content) return ''; const isOwn = options.isOwn || false; const highlightColor = isOwn ? 'rgba(255, 255, 255, 0.9)' : 'var(--x-accent)'; content = content.replace( /#([^\s#@]+)/g, `<span class="hashtag" style="color: ${highlightColor}; font-weight: 600;">#$1</span>`, ); content = content.replace( /@([^\s#@]+)/g, `<span class="mention" style="color: ${highlightColor}; font-weight: 600;">@$1</span>`, ); return content; } function cleanReplyContent(content, replyTo) { if (!content) return ''; if (replyTo) { content = content.replace(/^回复\s*@[^\s:：]+[：:]\s*/, ''); const replyHandle = replyTo.replace('@', ''); content = content.replace(new RegExp(`^@${replyHandle}\\s*[：:]?\\s*`, 'i'), ''); content = content.replace(new RegExp(`@${replyHandle}(?=\\s|$|[^\\w])`, 'gi'), ''); } return content; } function createTweetElement(tweet) { const tweetEl = document.createElement('div'); tweetEl.className = 'tweet-item'; tweetEl.dataset.tweetId = tweet.id; tweetEl.innerHTML = ` <img class="tweet-avatar" src="${tweet.user.avatar}" alt="${tweet.user.name}"> <div class="tweet-main"> <div class="tweet-user-info"> <span class="tweet-user-name">${tweet.user.name}</span> ${ tweet.user.verified ? '<svg class="tweet-verified" viewBox="0 0 24 24"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>' : '' } <span class="tweet-user-handle">${tweet.user.handle}</span> <span class="tweet-time">·${tweet.time}</span> <div class="tweet-more"> <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"> <g><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g> </svg> </div> </div> ${tweet.content ? `<div class="tweet-content">${processContent(tweet.content)}</div>` : ''} ${ tweet.quotedTweet ? ` <div class="quoted-tweet" onclick="handleQuotedTweetClick('${tweet.quotedTweet.user.handle}')"> <div class="quote-indicator"> <svg viewBox="0 0 24 24"> <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g> </svg> ${tweet.quotedTweet.type === 'comment' ? '引用评论' : '引用推文'} </div> <div class="quoted-user-info"> <img class="quoted-user-avatar" src="${tweet.quotedTweet.user.avatar}" alt="${tweet.quotedTweet.user.name}"> <span class="quoted-user-name">${tweet.quotedTweet.user.name}</span> ${ tweet.quotedTweet.user.verified ? '<svg class="tweet-verified" style="width: 14px; height: 14px;" viewBox="0 0 24 24"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>' : '' } <span class="quoted-user-handle">${tweet.quotedTweet.user.handle}</span> <span class="quoted-user-time">·${tweet.quotedTweet.time}</span> </div> <div class="quoted-content">${processContent(tweet.quotedTweet.content)}</div> ${ tweet.quotedTweet.image ? ` <div class="quoted-media" style="margin-top: 8px;"> ${ tweet.quotedTweet.image.type === 'description' ? ` <div style="background-color: rgba(255,255,255,0.05); border: 1px solid #333; border-radius: 8px; padding: 8px;"> <div style="color: #fff; font-size: 12px; line-height: 1.4;">${tweet.quotedTweet.image.content}</div> </div> ` : '' } ${ tweet.quotedTweet.image.type === 'upload' ? ` <div style="border-radius: 8px; overflow: hidden;"> <img src="${tweet.quotedTweet.image.content}" style="width: 100%; max-height: 100px; object-fit: cover; display: block;" alt="引用图片"> </div> ` : '' } </div> ` : '' } </div> ` : '' } ${ tweet.media && tweet.media.length > 0 ? ` <div class="tweet-media"> <div style="width: 100%; max-height: 200px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 16px; color:var(--x-text-primary); position: relative; overflow: hidden;" id="media-${ tweet.id }"> ${ tweet.media[0].sensitive ? ` <div class="sensitive-overlay" onclick="showSensitiveContent('${tweet.id}')"> <div class="sensitive-text">敏感内容</div> <div class="sensitive-description">此推文可能包含敏感内容</div> </div> ` : '' } <div class="tweet-media-scrollable" style="width: 100%; max-height: 200px; padding: 16px; overflow-y: auto; box-sizing: border-box; ${ tweet.media[0].sensitive ? 'filter: blur(20px);' : '' }" id="content-${tweet.id}"> <div style="font-size: 14px; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${ tweet.media[0].description }</div> </div> </div> </div> ` : '' } <div class="tweet-actions"> <div class="tweet-action comment" onclick="showTweetComments('${tweet.id}')"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor"> <g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g> </svg> <span>${formatNumber(tweet.stats.comments)}</span> </div> <div class="tweet-action retweet" onclick="handleQuoteRetweetFromData('tweet', '${tweet.id}')"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor"> <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g> </svg> <span>${DataUtils.formatNumber(tweet.stats.retweets)}</span> </div> <div class="tweet-action like" onclick="toggleLike('${tweet.id}', this)" data-liked="false" data-likes="${ tweet.stats.likes }"> <svg class="action-icon like-icon" viewBox="0 0 24 24" fill="currentColor"> <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g> </svg> <span class="like-count">${DataUtils.formatNumber(tweet.stats.likes)}</span> </div> <div class="tweet-action view"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor"> <g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10H6v10H4zm9.248 0v-7h2v7h-2z"></path></g> </svg> <span>${DataUtils.formatNumber(tweet.stats.views)}</span> </div> <div class="tweet-action bookmark" onclick="toggleBookmark('${tweet.id}', this)" data-bookmarked="false"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor"> <g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g> </svg> </div> <div class="tweet-action share"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor"> <g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.29 3.3-1.42-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g> </svg> </div> </div> </div> `; (async () => { const bookmarked = await isBookmarked(tweet.id); const bookmarkBtn = tweetEl.querySelector('.bookmark'); if (bookmarkBtn) { bookmarkBtn.setAttribute('data-bookmarked', bookmarked ? 'true' : 'false'); if (bookmarked) { const svg = bookmarkBtn.querySelector('svg'); if (svg) { svg.innerHTML = '<g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5z"></path></g>'; } } } })(); (async () => { const liked = await isLiked(tweet.id); const likeBtn = tweetEl.querySelector('.tweet-action.like'); if (likeBtn) { likeBtn.setAttribute('data-liked', liked ? 'true' : 'false'); if (liked) { const svg = likeBtn.querySelector('svg'); if (svg) { svg.innerHTML = '<g><path d="M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>'; } } } })(); return tweetEl; } function handleQuotedTweetClick(userHandle) { showXToast(`点击了引用的 ${userHandle} 的内容`, 'info'); } window.toggleBookmark = async function (tweetId, buttonElement) { try { const isBookmarked = buttonElement.getAttribute('data-bookmarked') === 'true'; if (isBookmarked) { await removeBookmark(tweetId); buttonElement.setAttribute('data-bookmarked', 'false'); const svg = buttonElement.querySelector('svg'); if (svg) { svg.innerHTML = '<g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g>'; } showXToast('已取消收藏', 'info'); console.log(`📌 [书签] 已取消收藏推文: ${tweetId}`); } else { await saveBookmark(tweetId); buttonElement.setAttribute('data-bookmarked', 'true'); const svg = buttonElement.querySelector('svg'); if (svg) { svg.innerHTML = '<g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5z"></path></g>'; } showXToast('已添加到书签', 'success'); console.log(`📌 [书签] 已收藏推文: ${tweetId}`); } const highlightsContent = document.getElementById('profile-highlights-content'); if (highlightsContent && highlightsContent.style.display === 'block') { await loadHighlights(); } } catch (error) { console.error('❌ [书签] 切换书签状态失败:', error); showXToast('操作失败', 'error'); } }; async function saveBookmark(tweetId) { try { const accountId = currentAccountId || 'main'; const xDb = getXDB(); let tweetData = null; const allTweets = [...(window.xTweetsData?.forYouTweets || []), ...(window.xTweetsData?.followingTweets || [])]; tweetData = allTweets.find(t => t.id === tweetId); if (!tweetData) { const tweetsData = await xDb.xTweetsData.get('tweets'); if (tweetsData) { tweetData = tweetsData.forYouTweets?.find(t => t.id === tweetId) || tweetsData.followingTweets?.find(t => t.id === tweetId); } } if (!tweetData && tweetId.startsWith('user_')) { const userTweetsId = `userTweets_${accountId}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); if (userTweetsData && userTweetsData.tweets) { tweetData = userTweetsData.tweets.find(t => t.id === tweetId); } } if (!tweetData && currentViewingAccount && currentViewingAccount.tweets) { tweetData = currentViewingAccount.tweets.find(t => t.id === tweetId); } if (!tweetData) { const tweetElement = document.querySelector(`[data-tweet-id="${tweetId}"]`); if (tweetElement) { console.log('📝 [书签] 从DOM中提取推文数据'); tweetData = extractTweetDataFromDOM(tweetElement); } } if (!tweetData) { console.warn('⚠️ [书签] 未找到推文数据:', tweetId); showXToast('无法收藏该推文', 'error'); return; } const bookmarkId = `bookmark_${accountId}_${tweetId}`; await xDb.xBookmarks.put({ id: bookmarkId, accountId: accountId, tweetId: tweetId, tweetData: tweetData, bookmarkedAt: Date.now(), }); console.log(`✅ [书签] 账户 ${accountId} 已保存书签: ${tweetId}`); } catch (error) { console.error('❌ [书签] 保存书签失败:', error); throw error; } } function extractTweetDataFromDOM(tweetElement) { try { const avatar = tweetElement.querySelector('.tweet-avatar')?.src || ''; const userName = tweetElement.querySelector('.tweet-user-name')?.textContent || ''; const userHandle = tweetElement.querySelector('.tweet-user-handle')?.textContent || ''; const verified = !!tweetElement.querySelector('.tweet-verified'); const content = tweetElement.querySelector('.tweet-content')?.textContent || ''; const time = tweetElement.querySelector('.tweet-time')?.textContent?.replace('·', '').trim() || ''; const commentCount = tweetElement.querySelector('.tweet-action.comment span')?.textContent || '0'; const retweetCount = tweetElement.querySelector('.tweet-action.retweet span')?.textContent || '0'; const likeCount = tweetElement.querySelector('.like-count')?.textContent || '0'; const viewCount = tweetElement.querySelector('.tweet-action.view span')?.textContent || '0'; return { id: tweetElement.dataset.tweetId, user: { name: userName, handle: userHandle, avatar: avatar, verified: verified, }, content: content, time: time, stats: { comments: parseStatNumber(commentCount), retweets: parseStatNumber(retweetCount), likes: parseStatNumber(likeCount), views: parseStatNumber(viewCount), }, comments: [], }; } catch (error) { console.error('❌ [书签] 从DOM提取推文数据失败:', error); return null; } } function parseStatNumber(str) { if (!str) return 0; str = str.trim().toUpperCase(); if (str.endsWith('K')) { return Math.round(parseFloat(str) * 1000); } else if (str.endsWith('M')) { return Math.round(parseFloat(str) * 1000000); } return parseInt(str) || 0; } async function removeBookmark(tweetId) { try { const accountId = currentAccountId || 'main'; const xDb = getXDB(); const bookmarkId = `bookmark_${accountId}_${tweetId}`; await xDb.xBookmarks.delete(bookmarkId); console.log(`✅ [书签] 账户 ${accountId} 已删除书签: ${tweetId}`); } catch (error) { console.error('❌ [书签] 删除书签失败:', error); throw error; } } async function loadBookmarks() { try { const accountId = currentAccountId || 'main'; const xDb = getXDB(); const bookmarks = await xDb.xBookmarks.where('accountId').equals(accountId).sortBy('bookmarkedAt'); bookmarks.reverse(); console.log(`📚 [书签] 账户 ${accountId} 已加载 ${bookmarks.length} 个书签`); return bookmarks; } catch (error) { console.error('❌ [书签] 加载书签失败:', error); return []; } } async function isBookmarked(tweetId) { try { const accountId = currentAccountId || 'main'; const xDb = getXDB(); const bookmarkId = `bookmark_${accountId}_${tweetId}`; const bookmark = await xDb.xBookmarks.get(bookmarkId); return !!bookmark; } catch (error) { console.error('❌ [书签] 检查收藏状态失败:', error); return false; } } window.loadHighlights = async function () { try { console.log('🌟 [亮点] 开始加载亮点内容'); const highlightsContent = document.getElementById('profile-highlights-content'); if (!highlightsContent) { console.warn('⚠️ [亮点] 未找到亮点容器'); return; } const bookmarks = await loadBookmarks(); if (bookmarks.length === 0) { const config = languageConfig[currentLanguage] || languageConfig.zh; highlightsContent.innerHTML = ` <div style="padding: 60px 32px; text-align: center;"> <div style="color:var(--x-text-secondary); font-size: 31px; font-weight: 800; margin-bottom: 8px;">${config.profileNoHighlights}</div> <div style="color:var(--x-text-secondary); font-size: 15px;">${config.profileNoHighlightsDesc}</div> </div> `; return; } highlightsContent.innerHTML = ''; bookmarks.forEach(bookmark => { if (bookmark.tweetData) { const tweetElement = createTweetElement(bookmark.tweetData); highlightsContent.appendChild(tweetElement); const bookmarkBtn = tweetElement.querySelector('.bookmark'); if (bookmarkBtn) { bookmarkBtn.setAttribute('data-bookmarked', 'true'); const svg = bookmarkBtn.querySelector('svg'); if (svg) { svg.innerHTML = '<g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5z"></path></g>'; } } } }); console.log(`✅ [亮点] 已显示 ${bookmarks.length} 个收藏的推文`); } catch (error) { console.error('❌ [亮点] 加载亮点内容失败:', error); showXToast('加载失败', 'error'); } }; window.toggleLike = async function (tweetId, buttonElement) { try { const isLiked = buttonElement.getAttribute('data-liked') === 'true'; const likeCountSpan = buttonElement.querySelector('.like-count'); let currentLikes = parseInt(buttonElement.getAttribute('data-likes')) || 0; if (isLiked) { await removeLike(tweetId); buttonElement.setAttribute('data-liked', 'false'); currentLikes = Math.max(0, currentLikes - 1); buttonElement.setAttribute('data-likes', currentLikes); if (likeCountSpan) { likeCountSpan.textContent = DataUtils.formatNumber(currentLikes); } const svg = buttonElement.querySelector('svg'); if (svg) { svg.innerHTML = '<g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>'; } console.log(`💔 [喜欢] 已取消喜欢推文: ${tweetId}`); } else { await saveLike(tweetId); buttonElement.setAttribute('data-liked', 'true'); currentLikes += 1; buttonElement.setAttribute('data-likes', currentLikes); if (likeCountSpan) { likeCountSpan.textContent = DataUtils.formatNumber(currentLikes); } const svg = buttonElement.querySelector('svg'); if (svg) { svg.innerHTML = '<g><path d="M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>'; } console.log(`💖 [喜欢] 已喜欢推文: ${tweetId}`); await checkAutoMessageTrigger(); } const likesContent = document.getElementById('profile-likes-content'); if (likesContent && likesContent.style.display === 'block') { await loadLikes(); } } catch (error) { console.error('❌ [喜欢] 切换喜欢状态失败:', error); showXToast('操作失败', 'error'); } }; async function saveLike(tweetId) { try { const accountId = currentAccountId || 'main'; const xDb = getXDB(); let tweetData = null; const allTweets = [...forYouTweets, ...followingTweets]; tweetData = allTweets.find(t => t.id === tweetId); if (!tweetData) { const tweetsData = await xDb.xTweetsData.get('tweets'); if (tweetsData) { tweetData = tweetsData.forYouTweets?.find(t => t.id === tweetId) || tweetsData.followingTweets?.find(t => t.id === tweetId); } } if (!tweetData && tweetId.startsWith('user_')) { const userTweetsId = `userTweets_${accountId}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); if (userTweetsData && userTweetsData.tweets) { tweetData = userTweetsData.tweets.find(t => t.id === tweetId); } } if (!tweetData && currentViewingAccount && currentViewingAccount.tweets) { tweetData = currentViewingAccount.tweets.find(t => t.id === tweetId); } if (!tweetData) { const tweetElement = document.querySelector(`[data-tweet-id="${tweetId}"]`); if (tweetElement) { console.log('📝 [喜欢] 从DOM中提取推文数据'); tweetData = extractTweetDataFromDOM(tweetElement); } } if (!tweetData) { console.warn('⚠️ [喜欢] 未找到推文数据:', tweetId); showXToast('无法喜欢该推文', 'error'); return; } const likeId = `like_${accountId}_${tweetId}`; await xDb.xLikes.put({ id: likeId, accountId: accountId, tweetId: tweetId, tweetData: tweetData, likedAt: Date.now(), }); console.log(`✅ [喜欢] 账户 ${accountId} 已保存喜欢: ${tweetId}`); } catch (error) { console.error('❌ [喜欢] 保存喜欢失败:', error); throw error; } } async function removeLike(tweetId) { try { const accountId = currentAccountId || 'main'; const xDb = getXDB(); const likeId = `like_${accountId}_${tweetId}`; await xDb.xLikes.delete(likeId); console.log(`✅ [喜欢] 账户 ${accountId} 已删除喜欢: ${tweetId}`); } catch (error) { console.error('❌ [喜欢] 删除喜欢失败:', error); throw error; } } async function loadLikesData() { try { const accountId = currentAccountId || 'main'; const xDb = getXDB(); const likes = await xDb.xLikes.where('accountId').equals(accountId).sortBy('likedAt'); likes.reverse(); console.log(`💖 [喜欢] 账户 ${accountId} 已加载 ${likes.length} 个喜欢`); return likes; } catch (error) { console.error('❌ [喜欢] 加载喜欢失败:', error); return []; } } async function isLiked(tweetId) { try { const accountId = currentAccountId || 'main'; const xDb = getXDB(); const likeId = `like_${accountId}_${tweetId}`; const like = await xDb.xLikes.get(likeId); return !!like; } catch (error) { console.error('❌ [喜欢] 检查喜欢状态失败:', error); return false; } } window.loadLikes = async function () { try { console.log('💖 [喜欢] 开始加载喜欢内容'); const likesContent = document.getElementById('profile-likes-content'); if (!likesContent) { console.warn('⚠️ [喜欢] 未找到喜欢容器'); return; } const likes = await loadLikesData(); if (likes.length === 0) { const config = languageConfig[currentLanguage] || languageConfig.zh; likesContent.innerHTML = ` <div style="padding: 60px 32px; text-align: center;"> <div style="color:var(--x-text-secondary); font-size: 31px; font-weight: 800; margin-bottom: 8px;">${config.profileNoLikes}</div> <div style="color:var(--x-text-secondary); font-size: 15px;">${config.profileNoLikesDesc}</div> </div> `; return; } likesContent.innerHTML = ''; likes.forEach(like => { if (like.tweetData) { const tweetElement = createTweetElement(like.tweetData); likesContent.appendChild(tweetElement); const likeBtn = tweetElement.querySelector('.tweet-action.like'); if (likeBtn) { likeBtn.setAttribute('data-liked', 'true'); const svg = likeBtn.querySelector('svg'); if (svg) { svg.innerHTML = '<g><path d="M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>'; } } } }); console.log(`✅ [喜欢] 已显示 ${likes.length} 个喜欢的推文`); } catch (error) { console.error('❌ [喜欢] 加载喜欢内容失败:', error); showXToast('加载失败', 'error'); } }; let lastLikeTriggerTime = 0; const LIKE_TRIGGER_COOLDOWN = 5 * 60 * 1000; async function checkAutoMessageTrigger() { try { const accountId = currentAccountId || 'main'; const xDb = getXDB(); const likesCount = await xDb.xLikes.where('accountId').equals(accountId).count(); console.log(`📊 [喜欢触发] 当前喜欢总数: ${likesCount}`); if (likesCount > 0 && likesCount % 5 === 0) { const now = Date.now(); const timeSinceLastTrigger = now - lastLikeTriggerTime; if (timeSinceLastTrigger < LIKE_TRIGGER_COOLDOWN) { const remainingSeconds = Math.ceil((LIKE_TRIGGER_COOLDOWN - timeSinceLastTrigger) / 1000); console.log(`⏳ [喜欢触发] 冷却中，还需等待 ${remainingSeconds} 秒`); return; } console.log('🎯 [喜欢触发] 达到触发条件，准备随机选择一条喜欢的推文'); lastLikeTriggerTime = now; const recentLikes = await xDb.xLikes.where('accountId').equals(accountId).sortBy('likedAt'); const last5Likes = recentLikes.slice(-5); if (last5Likes.length > 0) { const randomLike = last5Likes[Math.floor(Math.random() * last5Likes.length)]; const tweetData = randomLike.tweetData; console.log(`🎲 [喜欢触发] 随机选中推文:`, tweetData); const tweetAuthorHandle = tweetData.user.handle.replace('@', ''); await triggerAutoMessageFromLikedTweet(tweetAuthorHandle, tweetData); } } } catch (error) { console.error('❌ [喜欢触发] 检查触发条件失败:', error); } } async function triggerAutoMessageFromLikedTweet(authorHandle, tweetData) { try { console.log(`🤖 [喜欢触发AI] 开始处理推文作者: ${authorHandle}`); const xDb = getXDB(); const accountId = currentAccountId || 'main'; const allXProfiles = await xDb.xCharacterProfiles.toArray(); const characterProfile = allXProfiles.find( p => p.xHandle && p.xHandle.replace('@', '').toLowerCase() === authorHandle.toLowerCase(), ); if (characterProfile) { console.log(`✅ [喜欢触发AI] 找到角色: ${characterProfile.xName}`); const messageData = { id: characterProfile.characterId ? `msg_${characterProfile.characterId}` : 'msg_001', user: { name: characterProfile.xName, handle: characterProfile.xHandle, avatar: characterProfile.xAvatar, verified: characterProfile.xVerified || false, }, preview: `看到你喜欢了我的推文`, time: '刚刚', }; const result = await generateMessageConversation(messageData, true, { isAutoMessage: true, timeSinceLastMessage: 0, likedTweetContext: tweetData, }); if (result && result.length > 0) { const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`; let savedConversation = await xDb.xAccountProfiles.get(conversationId); if (!savedConversation) { savedConversation = { handle: conversationId, name: 'messageConversation', data: { messages: [] }, messageId: messageData.id, accountId: currentAccountId || 'main', updatedAt: new Date().toISOString(), }; } savedConversation.data.messages.push(...result); savedConversation.updatedAt = new Date().toISOString(); await xDb.xAccountProfiles.put(savedConversation); const isEnglish = currentLanguage === 'en'; showPhoneNotification({ title: 'X', message: isEnglish ? `${characterProfile.xName} noticed you liked their tweet and sent you a message!` : `${characterProfile.xName} 看到你喜欢了TA的推文，发来了私信！`, avatar: characterProfile.xAvatar, leftIcon: 'x', }); console.log(`✅ [喜欢触发AI] 已触发${characterProfile.xName}的主动私信`); } } else { console.log(`ℹ️ [喜欢触发AI] ${authorHandle} 不是绑定角色，跳过触发`); } } catch (error) { console.error('❌ [喜欢触发AI] 触发失败:', error); } } function renderTweets(tweets, containerId) { const container = document.querySelector(`#${containerId} .tweets-container`); container.innerHTML = ''; tweets.forEach((tweet, index) => { const tweetElement = createTweetElement(tweet); if (tweet.isNew) { tweetElement.style.opacity = '0'; tweetElement.style.transform = 'translateY(-20px)'; tweetElement.style.transition = 'opacity 0.4s ease, transform 0.4s ease'; setTimeout(() => { tweetElement.style.opacity = '1'; tweetElement.style.transform = 'translateY(0)'; tweet.isNew = false; }, index * 50); } container.appendChild(tweetElement); const avatar = tweetElement.querySelector('.tweet-avatar'); if (avatar) { avatar.style.cursor = 'pointer'; avatar.addEventListener('click', e => { e.stopPropagation(); openAccountProfile(tweet.user.name, tweet.user.handle, tweet.user.avatar, { source: 'feed', tweetContent: tweet.content, tweetMedia: tweet.media, tweetStats: tweet.stats, tweetTime: tweet.time, }); }); } const quotedAvatar = tweetElement.querySelector('.quoted-user-avatar'); if (quotedAvatar && tweet.quotedTweet) { quotedAvatar.style.cursor = 'pointer'; quotedAvatar.addEventListener('click', e => { e.stopPropagation(); openAccountProfile( tweet.quotedTweet.user.name, tweet.quotedTweet.user.handle, tweet.quotedTweet.user.avatar, { source: 'feed', tweetContent: tweet.quotedTweet.content, tweetTime: tweet.quotedTweet.time, }, ); }); } let longPressTimer = null; let touchStarted = false; tweetElement.addEventListener('touchstart', e => { if (isFeedMultiSelectMode) { return; } touchStarted = true; longPressTimer = setTimeout(() => { if (touchStarted) { e.preventDefault(); enterFeedMultiSelectMode(containerId); selectFeedTweet(tweet.id, tweetElement); } }, 500); }); tweetElement.addEventListener('touchmove', () => { touchStarted = false; if (longPressTimer) clearTimeout(longPressTimer); }); tweetElement.addEventListener('touchend', () => { touchStarted = false; if (longPressTimer) clearTimeout(longPressTimer); }); tweetElement.addEventListener('mousedown', e => { if (isFeedMultiSelectMode) { return; } if (e.button !== 0) return; longPressTimer = setTimeout(() => { enterFeedMultiSelectMode(containerId); selectFeedTweet(tweet.id, tweetElement); }, 500); }); tweetElement.addEventListener('mouseup', () => { if (longPressTimer) clearTimeout(longPressTimer); }); tweetElement.addEventListener('mouseleave', () => { if (longPressTimer) clearTimeout(longPressTimer); }); tweetElement.addEventListener('click', e => { if (isFeedMultiSelectMode) { e.preventDefault(); e.stopPropagation(); selectFeedTweet(tweet.id, tweetElement); } }); }); } let isFeedMultiSelectMode = false; let selectedFeedTweetIds = new Set(); let currentFeedContainer = null; function enterFeedMultiSelectMode(containerId) { if (isFeedMultiSelectMode) return; isFeedMultiSelectMode = true; currentFeedContainer = containerId; selectedFeedTweetIds.clear(); showFeedMultiSelectToolbar(); const container = document.querySelector(`#${containerId} .tweets-container`); if (container) { const tweetElements = container.querySelectorAll('.tweet-item'); tweetElements.forEach(el => { el.style.transition = 'transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease'; el.style.cursor = 'pointer'; }); } console.log('📱 [首页多选] 已进入多选模式'); } function selectFeedTweet(tweetId, tweetElement) { if (!isFeedMultiSelectMode) return; if (selectedFeedTweetIds.has(tweetId)) { selectedFeedTweetIds.delete(tweetId); tweetElement.style.transform = ''; tweetElement.style.boxShadow = ''; tweetElement.style.backgroundColor = ''; } else { selectedFeedTweetIds.add(tweetId); tweetElement.style.transform = 'scale(0.98)'; tweetElement.style.boxShadow = '0 0 0 3px var(--x-accent)'; tweetElement.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) 10%, transparent)'; } updateFeedMultiSelectToolbar(); } function showFeedMultiSelectToolbar() { const oldToolbar = document.getElementById('feed-multi-select-toolbar'); if (oldToolbar) oldToolbar.remove(); const toolbar = document.createElement('div'); toolbar.id = 'feed-multi-select-toolbar'; toolbar.style.cssText = ` position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%); background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 24px; padding: 12px 20px; display: flex; align-items: center; gap: 16px; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); animation: feedSlideUp 0.3s ease; `; toolbar.innerHTML = ` <span id="feed-selected-count" style="color:var(--x-text-primary); font-size: 14px; font-weight: 600;">已选择 0 条</span> <button onclick="selectAllFeedTweets()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 16px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'"> 全选 </button> <button onclick="deleteFeedSelectedTweets()" style="background-color: #f4212e; color: #fff; border: none; border-radius: 16px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#d91b2a'" onmouseout="this.style.backgroundColor='#f4212e'"> 删除 </button> <button onclick="exitFeedMultiSelectMode()" style="background-color: transparent; color:var(--x-text-primary); border: 1px solid var(--x-border-color); border-radius: 16px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> 取消 </button> `; document.body.appendChild(toolbar); if (!document.getElementById('feed-multiselect-animation-style')) { const style = document.createElement('style'); style.id = 'feed-multiselect-animation-style'; style.textContent = ` @keyframes feedSlideUp { from { transform: translateX(-50%) translateY(20px); opacity: 0; } to { transform: translateX(-50%) translateY(0); opacity: 1; } } @keyframes feedSlideDown { from { transform: translateX(-50%) translateY(0); opacity: 1; } to { transform: translateX(-50%) translateY(20px); opacity: 0; } } `; document.head.appendChild(style); } } function updateFeedMultiSelectToolbar() { const countElement = document.getElementById('feed-selected-count'); if (countElement) { countElement.textContent = `已选择 ${selectedFeedTweetIds.size} 条`; } } window.selectAllFeedTweets = function () { if (!isFeedMultiSelectMode || !currentFeedContainer) return; const container = document.querySelector(`#${currentFeedContainer} .tweets-container`); if (!container) return; const isForYou = currentFeedContainer === 'for-you-content'; const tweets = isForYou ? forYouTweets : followingTweets; const tweetElements = container.querySelectorAll('.tweet-item'); tweets.forEach((tweet, index) => { selectedFeedTweetIds.add(tweet.id); const tweetElement = tweetElements[index]; if (tweetElement) { tweetElement.style.transform = 'scale(0.98)'; tweetElement.style.boxShadow = '0 0 0 3px var(--x-accent)'; tweetElement.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) 10%, transparent)'; } }); updateFeedMultiSelectToolbar(); }; window.exitFeedMultiSelectMode = function () { if (!isFeedMultiSelectMode) return; isFeedMultiSelectMode = false; selectedFeedTweetIds.clear(); currentFeedContainer = null; const toolbar = document.getElementById('feed-multi-select-toolbar'); if (toolbar) { toolbar.style.animation = 'feedSlideDown 0.3s ease'; setTimeout(() => toolbar.remove(), 300); } document.querySelectorAll('.tweet-item').forEach(el => { el.style.transform = ''; el.style.boxShadow = ''; el.style.backgroundColor = ''; el.style.cursor = ''; }); console.log('📱 [首页多选] 已退出多选模式'); }; window.deleteFeedSelectedTweets = async function () { if (selectedFeedTweetIds.size === 0) { showXToast('请先选择要删除的推文', 'info'); return; } if (!confirm(`确定要删除 ${selectedFeedTweetIds.size} 条推文吗？`)) { return; } try { const isForYou = currentFeedContainer === 'for-you-content'; const tweetsArray = isForYou ? forYouTweets : followingTweets; const remainingTweets = tweetsArray.filter(tweet => !selectedFeedTweetIds.has(tweet.id)); if (isForYou) { forYouTweets.length = 0; forYouTweets.push(...remainingTweets); } else { followingTweets.length = 0; followingTweets.push(...remainingTweets); } const xDb = getXDB(); await xDb.xTweetsData.put({ id: 'tweets', forYouTweets: forYouTweets, followingTweets: followingTweets, lastUpdated: new Date().toISOString(), }); renderTweets(isForYou ? forYouTweets : followingTweets, currentFeedContainer); showXToast(`已删除 ${selectedFeedTweetIds.size} 条推文`, 'success'); exitFeedMultiSelectMode(); } catch (error) { console.error('删除推文失败:', error); showXToast('删除失败', 'error'); } }; async function initializeTweets() { try { const db = getXDB(); const savedData = await db.xTweetsData.get('tweets'); if (savedData && savedData.forYouTweets && savedData.followingTweets) { forYouTweets.length = 0; followingTweets.length = 0; forYouTweets.push(...savedData.forYouTweets); followingTweets.push(...savedData.followingTweets); console.log('已加载保存的推文数据，最后更新时间:', savedData.lastUpdated); } } catch (error) { console.error('加载推文数据失败，使用默认数据:', error); } renderTweets(forYouTweets, 'for-you-content'); renderTweets(followingTweets, 'following-content'); } function getRelativeTime(createdAt) { const now = Date.now(); const diff = now - createdAt; const seconds = Math.floor(diff / 1000); const minutes = Math.floor(seconds / 60); const hours = Math.floor(minutes / 60); const days = Math.floor(hours / 24); if (seconds < 60) return '刚刚'; if (minutes < 60) return `${minutes}分钟前`; if (hours < 24) return `${hours}小时前`; if (days < 7) return `${days}天前`; const date = new Date(createdAt); const month = date.getMonth() + 1; const day = date.getDate(); return `${month}月${day}日`; } function updateAllTweetTimes() { forYouTweets.forEach(tweet => { if (tweet.createdAt) { tweet.time = getRelativeTime(tweet.createdAt); } }); followingTweets.forEach(tweet => { if (tweet.createdAt) { tweet.time = getRelativeTime(tweet.createdAt); } }); document.querySelectorAll('.tweet-time[data-timestamp]').forEach(timeEl => { const timestamp = parseInt(timeEl.dataset.timestamp); if (timestamp && !isNaN(timestamp)) { timeEl.textContent = getRelativeTime(timestamp); } }); document.querySelectorAll('.tweet-time').forEach(timeEl => { const tweetEl = timeEl.closest('.tweet-item'); if (tweetEl && tweetEl.dataset.tweetId && !timeEl.dataset.timestamp) { const tweetId = tweetEl.dataset.tweetId; const tweet = [...forYouTweets, ...followingTweets].find(t => t.id === tweetId); if (tweet && tweet.createdAt) { timeEl.textContent = getRelativeTime(tweet.createdAt); } } }); } setInterval(updateAllTweetTimes, 30000); function showSensitiveContent(tweetId) { const overlay = document.querySelector(`#media-${tweetId} .sensitive-overlay`); const content = document.getElementById(`content-${tweetId}`); if (overlay) { overlay.style.display = 'none'; } if (content) { content.style.filter = 'none'; } } function generateRandomLikes() { return Math.floor(Math.random() * 50) + 1; } function formatCommentTime(commentTimestamp) { if (!commentTimestamp || isNaN(commentTimestamp) || commentTimestamp <= 0) { console.warn('⚠️ [时间显示] 无效的时间戳:', commentTimestamp); return '刚刚'; } const now = Date.now(); const diff = now - commentTimestamp; const minutes = Math.floor(diff / (1000 * 60)); const hours = Math.floor(diff / (1000 * 60 * 60)); const days = Math.floor(diff / (1000 * 60 * 60 * 24)); if (minutes < 1) return '刚刚'; if (minutes < 60) return `${minutes}分钟前`; if (hours < 24) return `${hours}小时前`; if (days < 7) return `${days}天前`; const date = new Date(commentTimestamp); if (isNaN(date.getTime())) { console.warn('⚠️ [时间显示] 无效的日期对象，时间戳:', commentTimestamp); return '刚刚'; } const month = date.getMonth() + 1; const day = date.getDate(); return `${month}月${day}日`; } function createCommentElement(comment, isReply = false) { const commentEl = document.createElement('div'); commentEl.className = isReply ? 'comment-item reply-item' : 'comment-item'; commentEl.dataset.commentId = comment.id; const randomLikes = generateRandomLikes(); const randomComments = Math.floor(Math.random() * 10) + 1; const randomRetweets = Math.floor(Math.random() * 5) + 1; const randomViews = Math.floor(Math.random() * 1000) + 50; commentEl.innerHTML = ` <img class="tweet-avatar" src="${comment.user.avatar}" alt="${comment.user.name}" onclick="openAccountProfile('${comment.user.name.replace(/'/g, "\\'")}', '${comment.user.handle}', '${ comment.user.avatar }', {source: 'tweetDetail', commentContent: '${comment.content .replace(/'/g, "\\'") .substring(0, 100)}'});event.stopPropagation();" style="cursor: pointer; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'"> <div class="comment-main"> <div class="comment-user-info"> <span class="tweet-user-name" onclick="openAccountProfile('${comment.user.name.replace(/'/g, "\\'")}', '${ comment.user.handle }', '${comment.user.avatar}', {source: 'tweetDetail', commentContent: '${comment.content .replace(/'/g, "\\'") .substring(0, 100)}'});event.stopPropagation();" style="cursor: pointer;">${comment.user.name}</span> ${ comment.user.verified ? '<svg class="tweet-verified" viewBox="0 0 24 24"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>' : '' } <span class="tweet-user-handle">${ comment.user.handle.startsWith('@') ? comment.user.handle : '@' + comment.user.handle }</span> <span class="tweet-time">·${comment.timestamp ? formatCommentTime(comment.timestamp) : comment.time || '刚刚'}</span> <div style="margin-left: auto; cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color: 0.2s; display: flex; align-items: center;" onmouseover="this.style.backgroundColor='color-mix(in srgb, var(--x-accent) , 0.1)'" onmouseout="this.style.backgroundColor='transparent'" onclick="${ comment.user.handle === userProfileData.handle ? `deleteUserComment('${comment.id}')` : `event.stopPropagation(); showXToast('更多选项开发中', 'info')` }"> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #71767b;"> <g><circle cx="12" cy="5" r="2"></circle><circle cx="12" cy="12" r="2"></circle><circle cx="12" cy="19" r="2"></circle></g> </svg> </div> </div> <div class="comment-content"> ${comment.replyTo ? `<span class="reply-to">${comment.replyTo}</span>` : ''} ${processContent(cleanReplyContent(comment.content, comment.replyTo))} ${ comment.image ? comment.image.type === 'description' ? `<div style="margin-top: 8px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 8px; box-sizing: border-box;"> <div style="color:var(--x-text-primary); font-size: 13px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${comment.image.content}</div> </div>` : `<div style="margin-top: 8px; border-radius: 12px; overflow: hidden; max-width: 300px;"> <img src="${comment.image.content}" style="width: 100%; max-height: 280px; object-fit: cover; display: block;" alt="评论图片"> </div>` : '' } ${ comment.sticker ? `<div style="margin-top: 8px; max-width: 120px;"> <img src="${comment.sticker.url}" alt="${comment.sticker.description}" style="width: 100%; height: auto; display: block; border-radius: 8px; cursor: pointer;" onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'padding: 12px; color:var(--x-text-secondary); text-align: center;\\'>表情包加载失败</div>';" title="${comment.sticker.description}"> </div>` : '' } </div> <div class="comment-actions" style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px; gap: 2px; max-width: 100%; overflow-x: hidden;"> <div class="comment-action reply-action" onclick="showReplyInput('${comment.id}', '${ comment.user.handle }')" style="display: flex; align-items: center; gap: 2px; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 1 auto; min-width: 0;"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;"> <g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g> </svg> <span style="font-size: 12px; white-space: nowrap;">${randomComments}</span> </div> <div class="comment-action" onclick="handleQuoteRetweetFromData('comment', '${ comment.id }')" style="display: flex; align-items: center; gap: 2px; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 1 auto; min-width: 0;"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;"> <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g> </svg> <span style="font-size: 12px; white-space: nowrap;">${randomRetweets}</span> </div> <div class="comment-action like" onclick="toggleCommentLike('${ comment.id }', this)" data-liked="false" data-likes="${randomLikes}" style="display: flex; align-items: center; gap: 2px; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 1 auto; min-width: 0;"> <svg class="action-icon like-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;"> <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g> </svg> <span class="like-count" style="font-size: 12px; white-space: nowrap;">${randomLikes}</span> </div> <div class="comment-action" style="display: flex; align-items: center; gap: 2px; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 1 auto; min-width: 0;"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;"> <g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10H6v10H4zm9.248 0v-7h2v7h-2z"></path></g> </svg> <span style="font-size: 12px; white-space: nowrap;">${formatNumber(randomViews)}</span> </div> <div class="comment-action bookmark" style="display: flex; align-items: center; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 0 auto; min-width: 16px;"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;"> <g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g> </svg> </div> <div class="comment-action share comment-share-btn" data-comment-id="${ comment.id }" style="display: flex; align-items: center; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 0 auto; min-width: 16px;"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;"> <g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.29 3.3-1.42-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g> </svg> </div> </div> <div id="reply-input-${ comment.id }" class="reply-input-container" style="display: none; margin-top: 12px; padding-left: 48px;"> <div style="display: flex; align-items: flex-start; gap: 12px;"> <img src="https: <div style="flex: 1;"> <textarea placeholder="发布你的回复" style="width: 100%; min-height: 20px; max-height: 80px; background: transparent; border: none; color: #fff; font-size: 15px; resize: none; outline: none; font-family: inherit; line-height: 1.3; border-bottom: 1px solid #333; padding-bottom: 8px;" oninput="autoResizeReply(this, '${ comment.id }')" onkeydown="handleReplyInput(event, '${comment.id}', '${comment.user.handle}')"></textarea> <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;"> <div style="display: flex; gap: 12px;"> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent); cursor: pointer;"> <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z"></path></g> </svg> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent); cursor: pointer;"> <g><path d="M8 9.5C8 8.119 8.672 7 9.5 7S11 8.119 11 9.5 10.328 12 9.5 12 8 10.881 8 9.5zm6.5 2.5c.828 0 1.5-1.119 1.5-2.5S15.328 7 14.5 7 13 8.119 13 9.5s.672 2.5 1.5 2.5zM12 16c-2.224 0-3.021-2.227-3.051-2.316l-1.897.633c.05.15 1.271 3.684 4.949 3.684s4.898-3.533 4.949-3.684l-1.896-.638c-.033.095-.83 2.322-3.053 2.322zm10.25-4.001c0 5.652-4.598 10.25-10.25 10.25S1.75 17.652 1.75 12 6.348 1.75 12 1.75 22.25 6.348 22.25 12zm-2 0c0-4.549-3.701-8.25-8.25-8.25S3.75 7.451 3.75 12s3.701 8.25 8.25 8.25 8.25-3.701 8.25-8.25z"></path></g> </svg> </div> <div style="display: flex; gap: 8px;"> <button onclick="cancelReply('${ comment.id }')" style="background: transparent; color: #71767b; border: 1px solid #333; border-radius: 16px; padding: 4px 12px; font-size: 13px; cursor: pointer;">取消</button> <button id="reply-btn-${comment.id}" onclick="submitReply('${comment.id}', '${ comment.user.handle }')" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 16px; padding: 4px 12px; font-size: 13px; cursor: pointer; opacity: 0.5;" disabled>回复</button> </div> </div> </div> </div> </div> </div> `; const shareBtn = commentEl.querySelector('.comment-share-btn'); if (shareBtn) { shareBtn.onclick = () => { let parentTweet = null; const currentTweetDataStr = sessionStorage.getItem('currentTweetData'); if (currentTweetDataStr) { try { parentTweet = JSON.parse(currentTweetDataStr); } catch (e) { console.error('解析推文数据失败:', e); } } showShareContentModal( { user: comment.user, content: comment.content, time: comment.time || (comment.timestamp ? formatCommentTime(comment.timestamp) : '刚刚'), image: comment.image, parentTweet: parentTweet, }, 'comment', ); }; } return commentEl; } async function deleteUserComment(commentId) { if (!confirm('确定要删除这条评论吗？')) { return; } const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`); if (commentElement) { commentElement.style.transition = 'opacity 0.3s ease, transform 0.3s ease'; commentElement.style.opacity = '0'; commentElement.style.transform = 'translateX(-20px)'; setTimeout(() => { commentElement.remove(); showXToast('评论已删除', 'success'); }, 300); const removeCommentById = (comments, targetId) => { return comments.filter(comment => { if (comment.id === targetId) { return false; } if (comment.replies && comment.replies.length > 0) { comment.replies = removeCommentById(comment.replies, targetId); } return true; }); }; try { const currentTweetData = sessionStorage.getItem('currentTweetData'); if (currentTweetData) { const tweetData = JSON.parse(currentTweetData); if (tweetData.comments) { tweetData.comments = removeCommentById(tweetData.comments, commentId); sessionStorage.setItem('currentTweetData', JSON.stringify(tweetData)); const commentsCount = document.querySelector('.tweet-stats .comment-count'); if (commentsCount) { const currentCount = parseInt(commentsCount.textContent) || 0; if (currentCount > 0) { commentsCount.textContent = currentCount - 1; } } const db = getXDB(); const tweetsData = await db.xTweetsData.get('tweets'); if (tweetsData) { if (tweetsData.forYouTweets) { const tweetIndex = tweetsData.forYouTweets.findIndex(t => t.id === tweetData.id); if (tweetIndex !== -1) { tweetsData.forYouTweets[tweetIndex].comments = removeCommentById( tweetsData.forYouTweets[tweetIndex].comments || [], commentId, ); forYouTweets[tweetIndex] = tweetsData.forYouTweets[tweetIndex]; } } if (tweetsData.followingTweets) { const tweetIndex = tweetsData.followingTweets.findIndex(t => t.id === tweetData.id); if (tweetIndex !== -1) { tweetsData.followingTweets[tweetIndex].comments = removeCommentById( tweetsData.followingTweets[tweetIndex].comments || [], commentId, ); followingTweets[tweetIndex] = tweetsData.followingTweets[tweetIndex]; } } await db.xTweetsData.put(tweetsData); } if (tweetData.id.startsWith('user_')) { const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweets = await db.xUserTweets.get(userTweetsId); if (userTweets && userTweets.tweets) { const userTweetIndex = userTweets.tweets.findIndex(t => t.id === tweetData.id); if (userTweetIndex !== -1) { userTweets.tweets[userTweetIndex].comments = removeCommentById( userTweets.tweets[userTweetIndex].comments || [], commentId, ); await db.xUserTweets.put(userTweets); } } } console.log('评论已从数据库中删除:', commentId); } } else if (currentTweetId) { const allTweets = [...forYouTweets, ...followingTweets]; const tweet = allTweets.find(t => t.id === currentTweetId); if (tweet && tweet.comments) { tweet.comments = removeCommentById(tweet.comments, commentId); tweet.stats.comments = Math.max(0, (tweet.stats.comments || 0) - 1); const tweetIndex = forYouTweets.findIndex(t => t.id === tweet.id); if (tweetIndex !== -1) { forYouTweets[tweetIndex] = tweet; } else { const followingIndex = followingTweets.findIndex(t => t.id === tweet.id); if (followingIndex !== -1) { followingTweets[followingIndex] = tweet; } } const db = getXDB(); await db.xTweetsData.put({ id: 'tweets', forYouTweets: forYouTweets, followingTweets: followingTweets, lastUpdated: new Date().toISOString(), }); console.log('主页评论已从数据库中删除:', commentId); } } } catch (error) { console.error('删除评论数据失败:', error); showXToast('删除评论失败，请重试', 'error'); } } } function toggleCommentLike(commentId, element) { const isLiked = element.dataset.liked === 'true'; const currentLikes = parseInt(element.dataset.likes); const likeIcon = element.querySelector('.like-icon'); const likeCount = element.querySelector('.like-count'); if (isLiked) { element.dataset.liked = 'false'; element.dataset.likes = (currentLikes - 1).toString(); element.classList.remove('liked'); likeCount.textContent = (currentLikes - 1).toString(); } else { element.dataset.liked = 'true'; element.dataset.likes = (currentLikes + 1).toString(); element.classList.add('liked'); likeCount.textContent = (currentLikes + 1).toString(); likeIcon.classList.add('like-animation'); setTimeout(() => { likeIcon.classList.remove('like-animation'); }, 600); } } function renderComments(tweetId) { const container = document.querySelector('.comments-container'); container.innerHTML = ''; let allTweets = [...forYouTweets, ...followingTweets]; if (searchResultsData.top || searchResultsData.latest) { allTweets = [...allTweets, ...(searchResultsData.top || []), ...(searchResultsData.latest || [])]; } if (currentViewingAccount && currentViewingAccount.tweets) { allTweets = [...allTweets, ...currentViewingAccount.tweets]; } const tweet = allTweets.find(t => t.id === tweetId); if (!tweet || !tweet.comments) return; tweet.comments.forEach(comment => { const commentGroup = document.createElement('div'); commentGroup.style.cssText = 'position: relative;'; const commentElement = createCommentElement(comment); if (comment.replies && comment.replies.length > 0) { commentElement.classList.add('has-replies'); } commentGroup.appendChild(commentElement); const commentAvatar = commentElement.querySelector('.tweet-avatar'); if (commentAvatar) { commentAvatar.style.cursor = 'pointer'; commentAvatar.addEventListener('click', e => { e.stopPropagation(); openAccountProfile(comment.user.name, comment.user.handle, comment.user.avatar, { source: 'comment', commentContent: comment.content, commentImage: comment.image, commentTime: comment.time, }); }); } if (comment.replies && comment.replies.length > 0) { comment.replies.forEach(reply => { const replyElement = createCommentElement(reply, true); commentGroup.appendChild(replyElement); const replyAvatar = replyElement.querySelector('.tweet-avatar'); if (replyAvatar) { replyAvatar.style.cursor = 'pointer'; replyAvatar.addEventListener('click', e => { e.stopPropagation(); openAccountProfile(reply.user.name, reply.user.handle, reply.user.avatar, { source: 'comment', commentContent: reply.content, commentImage: reply.image, commentTime: reply.time, replyTo: reply.replyTo, }); }); } }); } container.appendChild(commentGroup); }); const replyUserAvatars = document.querySelectorAll('.reply-user-avatar'); replyUserAvatars.forEach(avatar => { avatar.src = userProfileData.avatar; }); } let commentImageData = null; let detailCommentImageData = null; function triggerCommentImageUpload() { document.getElementById('comment-image-input').click(); } function handleCommentImageUpload(event) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = function (e) { commentImageData = e.target.result; const preview = document.getElementById('comment-image-preview'); const img = document.getElementById('comment-image-preview-img'); img.src = commentImageData; preview.style.display = 'block'; showXToast('图片已添加', 'success'); }; reader.readAsDataURL(file); } function removeCommentImage() { commentImageData = null; const preview = document.getElementById('comment-image-preview'); const img = document.getElementById('comment-image-preview-img'); img.src = ''; preview.style.display = 'none'; document.getElementById('comment-image-input').value = ''; } function triggerDetailCommentImageUpload() { document.getElementById('detail-comment-image-input').click(); } function openCommentStickers() { if (window.setCommentStickerMode) { window.setCommentStickerMode(true); } if (window.resetSelectedCommentSticker) { window.resetSelectedCommentSticker(); } if (window.openStickerPicker) { window.openStickerPicker(); } else { showXToast('表情包功能暂不可用', 'error'); } } function handleDetailCommentImageUpload(event) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = function (e) { detailCommentImageData = e.target.result; const preview = document.getElementById('detail-comment-image-preview'); const img = document.getElementById('detail-comment-image-preview-img'); img.src = detailCommentImageData; preview.style.display = 'block'; showXToast('图片已添加', 'success'); }; reader.readAsDataURL(file); } function removeDetailCommentImage() { detailCommentImageData = null; const preview = document.getElementById('detail-comment-image-preview'); const img = document.getElementById('detail-comment-image-preview-img'); img.src = ''; preview.style.display = 'none'; document.getElementById('detail-comment-image-input').value = ''; } function handleCommentInput(event) { const textarea = event.target; const replyBtn = document.getElementById('reply-btn'); if (textarea.value.trim().length > 0) { replyBtn.style.opacity = '1'; replyBtn.disabled = false; } else { replyBtn.style.opacity = '0.5'; replyBtn.disabled = true; } if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); if (textarea.value.trim().length > 0) { submitComment(); } } } function autoResize(textarea) { textarea.style.height = '20px'; textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px'; const replyBtn = document.getElementById('reply-btn'); if (textarea.value.trim().length > 0) { replyBtn.style.opacity = '1'; replyBtn.disabled = false; } else { replyBtn.style.opacity = '0.5'; replyBtn.disabled = true; } } let currentTweetId = null; async function submitComment() { const textarea = document.getElementById('comment-input'); const content = textarea.value.trim(); if (content.length === 0 || !currentTweetId) return; let tweet = null; let isAccountTweet = false; const allTweets = [...forYouTweets, ...followingTweets]; tweet = allTweets.find(t => t.id === currentTweetId); if (!tweet && currentViewingAccount && currentViewingAccount.tweets) { tweet = currentViewingAccount.tweets.find(t => t.id === currentTweetId); isAccountTweet = !!tweet; } if (!tweet) { showXToast('无法找到对应的推文', 'error'); return; } if (tweet.privacy === 'private') { showXToast('私有帖子不支持回复功能', 'error'); return; } const newComment = { id: 'new-' + Date.now(), user: { name: window.userProfileData.name, handle: window.userProfileData.handle, avatar: window.userProfileData.avatar, verified: window.userProfileData.verified, }, content: content, timestamp: Date.now(), replies: [], }; if (commentImageData) { newComment.image = { type: 'upload', content: commentImageData, }; } if (tweet) { if (!tweet.comments) { tweet.comments = []; } tweet.comments.push(newComment); tweet.stats.comments += 1; const tweetIndex = forYouTweets.findIndex(t => t.id === tweet.id); if (tweetIndex !== -1) { forYouTweets[tweetIndex] = tweet; } else { const followingIndex = followingTweets.findIndex(t => t.id === tweet.id); if (followingIndex !== -1) { followingTweets[followingIndex] = tweet; } } try { const db = getXDB(); if (isAccountTweet) { const accountHandle = tweet._accountHandle || (currentViewingAccount.accountInfo || currentViewingAccount).handle; const cleanHandle = accountHandle.replace('@', ''); const tweetIndex = currentViewingAccount.tweets.findIndex(t => t.id === tweet.id); if (tweetIndex !== -1) { currentViewingAccount.tweets[tweetIndex] = tweet; } await db.xAccountProfiles.put({ handle: cleanHandle, name: (currentViewingAccount.accountInfo || currentViewingAccount).name, accountInfo: currentViewingAccount.accountInfo || currentViewingAccount, tweets: currentViewingAccount.tweets, accountReplies: currentViewingAccount.accountReplies || [], updatedAt: new Date().toISOString(), }); console.log('✅ 用户评论已保存到账户推文，评论ID:', newComment.id, '账户:', cleanHandle); } else { await db.xTweetsData.put({ id: 'tweets', forYouTweets: forYouTweets, followingTweets: followingTweets, lastUpdated: new Date().toISOString(), }); console.log('用户评论已保存到数据库，评论ID:', newComment.id); } } catch (saveError) { console.error('保存评论数据失败:', saveError); } } renderComments(currentTweetId); textarea.value = ''; textarea.style.height = '20px'; if (commentImageData) { removeCommentImage(); } const replyBtn = document.getElementById('reply-btn'); replyBtn.style.opacity = '0.5'; replyBtn.disabled = true; const commentsContainer = document.querySelector('.comments-container'); setTimeout(() => { commentsContainer.scrollTop = commentsContainer.scrollHeight; }, 100); showXToast('你的评论等待回复中', 'info'); const isOwnPost = tweet.user && (tweet.user.handle === userProfileData.handle || tweet.id.startsWith('user_')); setTimeout(async () => { await generateUnifiedAIResponse(tweet, newComment, { isOwnPost, commentType: 'main_comment', pageType: 'main', parentComment: null, }); }, 100); } function showReplyInput(commentId, userHandle) { document.querySelectorAll('.reply-input-container').forEach(container => { container.style.display = 'none'; }); const replyContainer = document.getElementById(`reply-input-${commentId}`); if (replyContainer) { replyContainer.style.display = 'block'; const textarea = replyContainer.querySelector('textarea'); textarea.focus(); } } function cancelReply(commentId) { const replyContainer = document.getElementById(`reply-input-${commentId}`); if (replyContainer) { replyContainer.style.display = 'none'; const textarea = replyContainer.querySelector('textarea'); textarea.value = ''; textarea.style.height = '20px'; const replyBtn = document.getElementById(`reply-btn-${commentId}`); replyBtn.style.opacity = '0.5'; replyBtn.disabled = true; } } function handleReplyInput(event, commentId, userHandle) { const textarea = event.target; const replyBtn = document.getElementById(`reply-btn-${commentId}`); if (textarea.value.trim().length > 0) { replyBtn.style.opacity = '1'; replyBtn.disabled = false; } else { replyBtn.style.opacity = '0.5'; replyBtn.disabled = true; } if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); if (textarea.value.trim().length > 0) { submitReply(commentId, userHandle); } } } function autoResizeReply(textarea, commentId) { textarea.style.height = '20px'; textarea.style.height = Math.min(textarea.scrollHeight, 80) + 'px'; const replyBtn = document.getElementById(`reply-btn-${commentId}`); if (textarea.value.trim().length > 0) { replyBtn.style.opacity = '1'; replyBtn.disabled = false; } else { replyBtn.style.opacity = '0.5'; replyBtn.disabled = true; } } async function submitReply(commentId, replyToHandle) { const replyContainer = document.getElementById(`reply-input-${commentId}`); const textarea = replyContainer.querySelector('textarea'); const content = textarea.value.trim(); if (content.length === 0) return; let tweetData = null; const currentTweetDataFromSession = sessionStorage.getItem('currentTweetData'); if (currentTweetDataFromSession) { try { tweetData = JSON.parse(currentTweetDataFromSession); } catch (e) { console.error('解析sessionStorage推文数据失败:', e); } } if (!tweetData && currentTweetId) { const allTweets = [...forYouTweets, ...followingTweets]; tweetData = allTweets.find(t => t.id === currentTweetId); } if (!tweetData) { showXToast('无法获取推文信息', 'error'); return; } if (tweetData.privacy === 'private') { showXToast('私有帖子不支持回复功能', 'error'); return; } let parentComment = null; let mainCommentId = commentId; const isDetailPage = !!currentTweetDataFromSession; const commentsContainer = isDetailPage ? document.getElementById('detail-comments-container') : document.querySelector('.comments-container'); const allComments = commentsContainer.querySelectorAll('.comment-item'); let targetCommentEl = null; allComments.forEach(commentEl => { if (commentEl.dataset.commentId === commentId) { targetCommentEl = commentEl; } }); if (targetCommentEl) { const userName = targetCommentEl.querySelector('.tweet-user-name').textContent; const userHandle = targetCommentEl.querySelector('.tweet-user-handle').textContent; const commentContent = targetCommentEl.querySelector('.comment-content').textContent.trim(); parentComment = { id: commentId, user: { name: userName, handle: userHandle }, content: commentContent, }; if (targetCommentEl.classList.contains('reply-item')) { let currentEl = targetCommentEl.previousElementSibling; while (currentEl && currentEl.classList.contains('reply-item')) { currentEl = currentEl.previousElementSibling; } if (currentEl && currentEl.classList.contains('comment-item') && !currentEl.classList.contains('reply-item')) { mainCommentId = currentEl.dataset.commentId; } else { let parentContainer = targetCommentEl.parentNode; let firstComment = parentContainer.querySelector('.comment-item:not(.reply-item)'); if (firstComment) { mainCommentId = firstComment.dataset.commentId; } } } } const newReply = { id: 'reply-' + Date.now(), user: { name: window.userProfileData.name, handle: window.userProfileData.handle, avatar: window.userProfileData.avatar, verified: window.userProfileData.verified, }, content: content, timestamp: Date.now(), replyTo: replyToHandle, replies: [], }; console.log('💬 [楼中楼回复] 创建新回复:', { id: newReply.id, content: newReply.content.substring(0, 50) + '...', replyTo: replyToHandle, mainCommentId, isDetailPage, }); if (isDetailPage) { const commentElement = createCommentElement(newReply, true); if (targetCommentEl) { let insertAfter = null; if (targetCommentEl.classList.contains('reply-item')) { let nextSibling = targetCommentEl.nextElementSibling; insertAfter = targetCommentEl; while (nextSibling && nextSibling.classList.contains('reply-item')) { insertAfter = nextSibling; nextSibling = nextSibling.nextElementSibling; } } else { let nextSibling = targetCommentEl.nextElementSibling; insertAfter = targetCommentEl; while (nextSibling && nextSibling.classList.contains('reply-item')) { insertAfter = nextSibling; nextSibling = nextSibling.nextElementSibling; } } if (insertAfter.nextSibling) { insertAfter.parentNode.insertBefore(commentElement, insertAfter.nextSibling); } else { insertAfter.parentNode.appendChild(commentElement); } } try { console.log('💬 [楼中楼回复] 开始保存到数据库'); let updatedTweetData = JSON.parse(sessionStorage.getItem('currentTweetData')); if (updatedTweetData) { console.log('💬 [楼中楼回复] 推文ID:', updatedTweetData.id); console.log('💬 [楼中楼回复] 主评论ID:', mainCommentId); console.log('💬 [楼中楼回复] 当前评论总数:', updatedTweetData.comments?.length || 0); const mainComment = updatedTweetData.comments.find(c => c.id === mainCommentId); if (mainComment) { console.log('💬 [楼中楼回复] 找到主评论，当前回复数:', mainComment.replies?.length || 0); if (!mainComment.replies) mainComment.replies = []; mainComment.replies.push(newReply); console.log('💬 [楼中楼回复] 新回复已添加，新回复总数:', mainComment.replies.length); sessionStorage.setItem('currentTweetData', JSON.stringify(updatedTweetData)); console.log('✅ [楼中楼回复] sessionStorage 已更新'); const db = getXDB(); const isUserTweet = updatedTweetData.id.startsWith('user_'); const isAccountTweet = updatedTweetData._source === 'account'; console.log('💬 [楼中楼回复] 是否为用户推文:', isUserTweet); console.log('💬 [楼中楼回复] 是否为账户推文:', isAccountTweet); if (isAccountTweet) { console.log('💬 [楼中楼回复] 保存到账户推文数据库'); const accountHandle = updatedTweetData._accountHandle || (currentViewingAccount.accountInfo || currentViewingAccount).handle; const cleanHandle = accountHandle.replace('@', ''); if (currentViewingAccount && currentViewingAccount.tweets) { const tweetIndex = currentViewingAccount.tweets.findIndex(t => t.id === updatedTweetData.id); if (tweetIndex !== -1) { currentViewingAccount.tweets[tweetIndex] = updatedTweetData; await db.xAccountProfiles.put({ handle: cleanHandle, name: (currentViewingAccount.accountInfo || currentViewingAccount).name, accountInfo: currentViewingAccount.accountInfo || currentViewingAccount, tweets: currentViewingAccount.tweets, accountReplies: currentViewingAccount.accountReplies || [], updatedAt: new Date().toISOString(), }); console.log('✅ [楼中楼回复] 账户推文已更新，账户:', cleanHandle); } else { console.warn('⚠️ [楼中楼回复] 未找到目标账户推文'); } } } else if (isUserTweet) { console.log('💬 [楼中楼回复] 保存到用户推文数据库'); const accountTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweets = await db.xUserTweets.get(accountTweetsId); if (userTweets && userTweets.tweets) { console.log('💬 [楼中楼回复] 找到用户推文数据，推文总数:', userTweets.tweets.length); const userTweetIndex = userTweets.tweets.findIndex(t => t.id === updatedTweetData.id); if (userTweetIndex !== -1) { console.log('💬 [楼中楼回复] 找到目标推文，索引:', userTweetIndex); userTweets.tweets[userTweetIndex] = updatedTweetData; await db.xUserTweets.put(userTweets); console.log('✅ [楼中楼回复] 用户推文已更新到账户:', accountTweetsId); } else { console.warn('⚠️ [楼中楼回复] 未找到目标用户推文'); } } else { console.warn('⚠️ [楼中楼回复] 未找到用户推文数据'); } } else { console.log('💬 [楼中楼回复] 保存到主页推文数据库'); const tweetsData = await db.xTweetsData.get('tweets'); if (tweetsData) { let updated = false; if (tweetsData.forYouTweets) { const tweetIndex = tweetsData.forYouTweets.findIndex(t => t.id === updatedTweetData.id); if (tweetIndex !== -1) { tweetsData.forYouTweets[tweetIndex] = updatedTweetData; updated = true; console.log('💬 [楼中楼回复] 已更新 forYouTweets'); } } if (!updated && tweetsData.followingTweets) { const tweetIndex = tweetsData.followingTweets.findIndex(t => t.id === updatedTweetData.id); if (tweetIndex !== -1) { tweetsData.followingTweets[tweetIndex] = updatedTweetData; updated = true; console.log('💬 [楼中楼回复] 已更新 followingTweets'); } } if (updated) { await db.xTweetsData.put(tweetsData); console.log('✅ [楼中楼回复] 主页推文已保存到数据库'); } else { console.warn('⚠️ [楼中楼回复] 未在主页数据中找到目标推文'); } } } } else { console.warn('⚠️ [楼中楼回复] 未找到主评论，mainCommentId:', mainCommentId); } } else { console.warn('⚠️ [楼中楼回复] sessionStorage 中无推文数据'); } } catch (saveError) { console.error('❌ [楼中楼回复] 保存失败:', saveError); } } else { const mainComment = tweetData.comments.find(c => c.id === mainCommentId); if (mainComment) { if (!mainComment.replies) mainComment.replies = []; mainComment.replies.push(newReply); const tweetIndex = forYouTweets.findIndex(t => t.id === tweetData.id); if (tweetIndex !== -1) { forYouTweets[tweetIndex] = tweetData; } else { const followingIndex = followingTweets.findIndex(t => t.id === tweetData.id); if (followingIndex !== -1) { followingTweets[followingIndex] = tweetData; } } try { const db = getXDB(); await db.xTweetsData.put({ id: 'tweets', forYouTweets: forYouTweets, followingTweets: followingTweets, lastUpdated: new Date().toISOString(), }); console.log('用户回复已保存到数据库，回复ID:', newReply.id); } catch (saveError) { console.error('保存回复数据失败:', saveError); } renderComments(currentTweetId); } } cancelReply(commentId); showXToast('你的评论等待回复中', 'info'); const isOwnPost = tweetData.user && (tweetData.user.handle === userProfileData.handle || tweetData.id.startsWith('user_')); setTimeout(async () => { await generateUnifiedAIResponse(tweetData, newReply, { isOwnPost, commentType: 'reply_comment', pageType: isDetailPage ? 'detail' : 'main', parentComment, mainCommentId, }); }, 100); } async function showTweetComments(tweetId) { console.log('📖 [首页推文] 点击评论按钮，推文ID:', tweetId); let tweet = forYouTweets.find(t => t.id === tweetId); if (!tweet) { tweet = followingTweets.find(t => t.id === tweetId); } if (!tweet) { console.error('❌ [首页推文] 未找到推文:', tweetId); showXToast('未找到该推文', 'error'); return; } await showTweetDetail(tweet); } function showXToast(message, type = 'success') { const existingToast = document.querySelector('.x-toast'); if (existingToast) { existingToast.remove(); } const toast = document.createElement('div'); toast.className = 'x-toast'; toast.style.cssText = ` position: fixed; top: 80px; left: 50%; transform: translateX(-50%); background-color: ${ type === 'success' ? '#1d9bf0' : '#f4212e' }; color: #fff; padding: 12px 20px; border-radius: 20px; font-size: 15px; font-weight: 600; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); animation: fadeInOut 3s ease-in-out forwards; `; toast.textContent = message; const style = document.createElement('style'); style.textContent = ` @keyframes fadeInOut { 0 % { opacity: 0; transform: translateX(-50 %) translateY(- 20px); } 15% {opacity: 1; transform: translateX(-50%) translateY(0); } 85% {opacity: 1; transform: translateX(-50%) translateY(0); } 100% {opacity: 0; transform: translateX(-50%) translateY(-20px); } } `; document.head.appendChild(style); document.body.appendChild(toast); setTimeout(() => { if (toast.parentNode) { toast.remove(); } if (style.parentNode) { style.remove(); } }, 3000); } async function refreshXTweets() { const refreshBtn = document.querySelector('.x-refresh-btn'); refreshBtn.style.animation = 'spin 1s linear infinite'; const spinStyle = document.createElement('style'); spinStyle.textContent = ` @keyframes spin { from {transform: rotate(0deg); } to {transform: rotate(360deg); } } `; document.head.appendChild(spinStyle); try { function parseCSVToTweets(csvText) { const lines = csvText .split('\n') .map(line => line.trim()) .filter(line => line); const tweetsData = { forYouTweets: [], followingTweets: [], }; let currentSection = ''; let tweetIndex = 0; for (const line of lines) { if (line.includes('=== 为你推荐 ===')) { currentSection = 'forYou'; tweetIndex = 0; continue; } else if (line.includes('=== 正在关注 ===')) { currentSection = 'following'; tweetIndex = 0; continue; } if (line.includes('用户名,用户句柄,用户头像,是否认证') || line.includes('评论1用户名,评论1句柄')) { continue; } if (currentSection && line.includes(',')) { const values = line.split(',').map(v => v.trim()); if (values.length >= 12) { const tweet = { id: `${currentSection}_${tweetIndex}`, user: { name: values[0] || '匿名用户', handle: values[1] || '@anonymous', avatar: values[2] || 'https: verified: values[3] === '是', }, content: values[4] || '', time: values[5] || '刚刚', media: values[6] ? [ { type: 'image', description: values[6], sensitive: values[7] === '是', }, ] : [], stats: { comments: parseInt(values[8]) || 0, retweets: parseInt(values[9]) || 0, likes: parseInt(values[10]) || 0, views: parseInt(values[11]) || 0, }, comments: [], }; if (values.length >= 19 && values[12] && values[13] && values[17]) { tweet.quotedTweet = { type: values[12] || 'tweet', user: { name: values[13] || '引用用户', handle: values[14] || '@quoted', avatar: values[15] || 'https: verified: values[16] === '是', }, content: values[17] || '', time: values[18] || '刚刚', }; } const comments = []; const commentStartIndex = 19; let commentIndex = 1; let startIndex = commentStartIndex; while (startIndex + 6 < values.length) { const commentName = values[startIndex]; const commentHandle = values[startIndex + 1]; const commentAvatar = values[startIndex + 2]; const commentVerified = values[startIndex + 3]; const commentContent = values[startIndex + 4]; const commentTime = values[startIndex + 5]; const commentReplyTo = values[startIndex + 6]; if (commentName && commentHandle && commentContent) { const newComment = { id: `${tweet.id}_c${commentIndex}`, user: { name: commentName, handle: commentHandle, avatar: commentAvatar || 'https: verified: commentVerified === '是', }, content: commentContent, time: commentTime || '刚刚', replyTo: commentReplyTo || '', replies: [], }; if (commentReplyTo) { const targetComment = comments.find(c => c.user.handle === commentReplyTo); if (targetComment) { targetComment.replies.push(newComment); } else { comments.push(newComment); } } else { comments.push(newComment); } commentIndex++; } else { break; } startIndex += 7; } tweet.comments = comments; if (currentSection === 'forYou') { tweetsData.forYouTweets.push(tweet); } else if (currentSection === 'following') { tweetsData.followingTweets.push(tweet); } tweetIndex++; } } } return tweetsData; } const { db, xDb, apiConfig, xSettings } = await APIUtils.loadConfigAndSettings(); const { userPrompt, worldSetting, boundCharacters } = xSettings; const boundNPCs = await APIUtils.loadBoundNPCs(); const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); console.log('🎭 绑定角色数量:', boundCharacters.length); if (boundCharacters.length > 0) { console.log('🎭 绑定角色列表:', boundCharacters); } console.log('👤 已知身份角色数:', window.userProfileData.knownIdentityCharacters?.length || 0); if (window.userProfileData.knownIdentityCharacters?.length > 0) { console.log('👤 已知身份角色列表:', window.userProfileData.knownIdentityCharacters); } const userPublicIdentity = userXProfileInfo.publicIdentity || ''; const userBio = userXProfileInfo.bio || ''; const isUserHighExposure = /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test( userPublicIdentity + ' ' + userBio, ); const highExposureCharacters = []; if (boundCharacters.length > 0) { const allXProfiles = await xDb.xCharacterProfiles.toArray(); for (const charId of boundCharacters) { const xProfile = allXProfiles.find(p => p.characterId === charId); if (xProfile && xProfile.publicIdentity) { const isCharHighExposure = /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test( xProfile.publicIdentity, ); if (isCharHighExposure) { highExposureCharacters.push({ characterId: charId, xProfile: xProfile, }); } } } } console.log('🌟 高曝光身份检测:', { isUserHighExposure, highExposureCharactersCount: highExposureCharacters.length, highExposureCharactersList: highExposureCharacters.map(c => c.xProfile.xName), }); let recentTweetsContext = ''; if (isUserHighExposure || highExposureCharacters.length > 0) { const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); const recentUserTweets = userTweetsData?.tweets?.slice(0, 3) || []; if (recentUserTweets.length > 0 || highExposureCharacters.length > 0) { recentTweetsContext = ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌟 高曝光身份 - 近期推文上下文 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 以下是高曝光身份的公众人物近期发布的推文，其他用户可能会讨论这些内容： `; if (isUserHighExposure && recentUserTweets.length > 0) { recentTweetsContext += ` 【${userXProfileInfo.name} 的近期推文】（${userXProfileInfo.publicIdentity}） `; recentUserTweets.forEach((tweet, index) => { recentTweetsContext += ` ${index + 1}. "${tweet.content}"`; if (tweet.location) { recentTweetsContext += ` - 位置：${tweet.location}`; } if (tweet.image) { if (tweet.image.type === 'description') { recentTweetsContext += ` - 图片描述：${tweet.image.content}`; } else if (tweet.image.type === 'upload') { recentTweetsContext += ` - 附带真实上传图片`; } else if (tweet.image.type === 'uploads' && tweet.image.images) { recentTweetsContext += ` - 附带${tweet.image.images.length}张真实上传图片`; } } if (tweet.link) { recentTweetsContext += ` - 附带链接：${tweet.link.title || tweet.link.url || '链接'}`; if (tweet.link.description) { recentTweetsContext += `（${tweet.link.description}）`; } } if (tweet.quotedTweet) { const quoted = tweet.quotedTweet; const quotedType = quoted.type === 'tweet' ? '推文' : '评论'; recentTweetsContext += ` - 引用转发了 ${quoted.user.name} 的${quotedType}："${quoted.content}"`; if (quoted.image) { if (quoted.image.type === 'description') { recentTweetsContext += `（含图片：${quoted.image.content}）`; } else { recentTweetsContext += `（含图片）`; } } } if (tweet.quotedFanGroup) { const fanGroup = tweet.quotedFanGroup; recentTweetsContext += ` - 转发了粉丝群：${fanGroup.name}（${fanGroup.memberCount || 0}位成员，门槛：${fanGroup.threshold || '无'}）`; } recentTweetsContext += ` - 发布时间：${tweet.time || '最近'} - 互动数据：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发，${tweet.stats?.comments || 0}评论 `; }); } for (const { xProfile } of highExposureCharacters) { recentTweetsContext += ` 【${xProfile.xName} 的信息】（${xProfile.publicIdentity}） - 可能会发布与其身份相关的推文 - 可能会被其他用户讨论或提及 `; } recentTweetsContext += ` 【高曝光身份推文生成规则】： - 约20-30%的新推文可以包含对上述推文的讨论、转发、或评论 - 讨论应该是其他普通用户或粉丝的视角，而非本人 - 可以是支持、批评、分析、或单纯的转发评论 - 不要在每条推文中都提及，保持自然和多样性 - 其余70-80%的推文应该是与高曝光身份无关的通用热门内容 - 如果生成讨论推文，要体现公众人物的影响力（较高的互动数据） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; console.log('📰 已加载高曝光身份近期推文上下文，用户推文数:', recentUserTweets.length); } } let tokenCount = 0; const now = new Date(); const beijingTime = new Date(now.getTime() + 8 * 60 * 60 * 1000); const timeInfo = ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ⏰ 时间感知 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 当前北京时间：${beijingTime.toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai', year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', weekday: 'long', })} 【时间相关提示】： - 生成的推文时间应该合理（例如：刚刚、1分钟前、5分钟前、1小时前、今天 xx:xx等） - 不要生成未来时间 - 根据当前时间判断是早晨、中午、下午、晚上、深夜，内容应该符合时段特征 - 周末/工作日的内容风格可以有所不同 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; let systemPrompt = timeInfo + StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting, }); tokenCount = TokenUtils.logTokenUsage('推文生成器', '时间感知+基础系统提示词', systemPrompt, tokenCount); const worldBooksContent = await StringBuilders.getApplicableWorldBooks('feed', { boundCharacters, }); if (worldBooksContent) { systemPrompt += worldBooksContent; tokenCount = TokenUtils.logTokenUsage('推文生成器', '世界书内容', worldBooksContent, tokenCount); } systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务说明 🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的内容生成器。请生成两组推文数据： - "为你推荐"页面（热门有趣内容） - "正在关注"页面（个人生活日常） **你只负责生成其他用户的推文，绝不生成用户本人的推文！** 🚨 **重要：你必须只返回有效的JSON格式数据，任何语法错误都会导致系统崩溃！** 🚨 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 【生成要求】： - 每组生成5-10条推文，内容多样化 - 热门推文5-12条评论，普通推文1-5条，支持多层级楼中楼回复 - **绑定角色可以作为推文发布者**：根据角色设定和兴趣发布独立推文 - **绑定NPC可以作为推文发布者**：根据NPC人设和发帖习惯发布推文 - NPC关系互动：有绑定关系的NPC在角色推文下自然留言，体现关系特点 - 除了绑定角色外，其他用户头像统一：https: - 引用推文功能：约20-30%的推文可以使用引用功能，适合表达观点、评论热点、转发有趣内容 【情侣关系与粉丝群体规则】： ${ userXProfileInfo.verificationType === 'couple' && userXProfileInfo.coupleCharacterName ? `- **情侣关系自然化**：用户与${userXProfileInfo.coupleCharacterName}是公开情侣，但这是私人关系 - 情侣角色可以偶尔出现在推文/评论中，但频率要低（建议10-20%概率），保持自然 - 情侣互动应该围绕推文主题，不要每次都强调情侣身份 - 粉丝群体判断： * 如果用户或情侣角色有明星/网红/公众人物等身份 → 可以生成少量CP粉丝评论（最多1-2条） * 如果都是普通人身份 → 禁止生成"磕CP""嗑糖"等粉丝向评论，普通情侣不会有粉丝群体` : '- **普通情侣关系**：如果生成情侣内容，确保只在适合的场景下出现，且不应有粉丝群体' }`; const coreTaskSection = systemPrompt.substring( tokenCount > 0 ? systemPrompt.lastIndexOf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━') : 0, ); tokenCount = TokenUtils.logTokenUsage('推文生成器', '核心任务说明', coreTaskSection, tokenCount); const charactersInfo = await StringBuilders.buildCompleteCharacterInfo( boundCharacters, userXProfileInfo, 'tweet', ); if (charactersInfo) { systemPrompt += charactersInfo; tokenCount = TokenUtils.logTokenUsage('推文生成器', '角色资料信息', charactersInfo, tokenCount); } const relationshipsInfo = await StringBuilders.buildCharacterRelationships( boundCharacters, currentAccountId || 'main', ); if (relationshipsInfo) { systemPrompt += relationshipsInfo; tokenCount = TokenUtils.logTokenUsage('推文生成器', '角色关系网络', relationshipsInfo, tokenCount); console.log('💞 已加载角色关系网络信息'); } if (boundNPCs.length > 0) { const npcSectionStart = systemPrompt.length; systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📋 绑定NPC资料 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 以下是与当前用户绑定的NPC，他们可以在推文生成中作为独立用户出现： `; for (const npc of boundNPCs) { systemPrompt += ` 【NPC基本信息】 - X姓名：${npc.name} - X句柄：${npc.handle} - X头像：${npc.avatar} - 认证状态：false（NPC默认无认证） 【NPC人设】 ${npc.personality || '暂无人设描述'} 【发帖习惯】 ${npc.postingHabits || '暂无发帖习惯描述'} 【主页内容】 ${npc.homepage || '暂无主页内容设置'} ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } systemPrompt += ` 【NPC使用规则】： 1. NPC可以作为推文发布者，生成符合其人设和发帖习惯的推文 2. NPC可以在评论区出现，根据其人设进行互动 3. NPC的内容应该围绕其人设和主页内容展开 4. NPC与角色/用户的互动应该自然，不要过于频繁 5. 严格使用NPC的X姓名(${boundNPCs.map(n => n.name).join('、')})、句柄(${boundNPCs.map(n => n.handle).join('、')})和头像 6. NPC认证状态固定为 false `; const npcSection = systemPrompt.substring(npcSectionStart); tokenCount = TokenUtils.logTokenUsage('推文生成器', 'NPC资料信息', npcSection, tokenCount); } if (recentTweetsContext) { systemPrompt += recentTweetsContext; tokenCount = TokenUtils.logTokenUsage('推文生成器', '高曝光身份推文上下文', recentTweetsContext, tokenCount); } const userConstraintsStart = systemPrompt.length; systemPrompt += StringBuilders.buildUniversalConstraints(userXProfileInfo); const userConstraints = systemPrompt.substring(userConstraintsStart); tokenCount = TokenUtils.logTokenUsage('推文生成器', '用户资料约束', userConstraints, tokenCount); systemPrompt += ` 【JSON返回格式】： \`\`\`json {"forYouTweets": [推文数组], "followingTweets": [推文数组]} \`\`\` 推文对象结构： - user: {name, handle, avatar, verified} - content: 推文文本 - time: 时间描述 - stats: {comments, retweets, likes, views} (纯数字) - media: [{type:"description", description:"文字描述，至少30字"}] (可选) - quotedTweet: {type, user, content, time} (可选，约20-30%推文使用) - comments: [评论数组] (3-8条热门推文，1-4条普通推文) 评论对象结构： - user: {name, handle, avatar, verified} - content: 评论文本 - time: 时间描述 - replies: [回复数组] (可选，支持多层级但不超过3层) - replyTo: "@被回复者句柄" (楼中楼回复时必填) 关键规则： 1. verified字段必须是布尔值(true/false) 2. stats中所有数字必须是纯数字，不带引号 3. 可选字段不使用时完全省略，不要设为null 4. content直接写内容，不用引号包裹`; const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】')); tokenCount = TokenUtils.logTokenUsage('推文生成器', 'JSON格式要求', formatSection, tokenCount); const messages = [{ role: 'user', content: '请生成新的X社交平台推文数据' }]; TokenUtils.logFinalPrompt('推文生成器', systemPrompt, messages[0].content); const aiResponseContent = await APIUtils.sendAIRequest({ apiConfig, systemPrompt, messages, temperature: 0.8, }); let newTweetsData = APIUtils.parseJSONResponse(aiResponseContent); newTweetsData = await APIUtils.postProcessData(newTweetsData, userXProfileInfo); if (!newTweetsData.forYouTweets || !newTweetsData.followingTweets) { throw new Error('AI返回的数据格式不正确，缺少必要字段'); } const processTweets = tweets => { return tweets.map(tweet => { if (!tweet.stats) { tweet.stats = { comments: tweet.comments?.length || 0, retweets: 0, likes: 0, views: 0, }; } if (tweet.comments) { tweet.comments = tweet.comments.map(comment => { const processedComment = { ...comment, id: `c_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, }; if (comment.replies) { processedComment.replies = comment.replies.map(reply => ({ ...reply, id: `r_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, })); } return processedComment; }); } return tweet; }); }; newTweetsData.forYouTweets = processTweets(newTweetsData.forYouTweets); newTweetsData.followingTweets = processTweets(newTweetsData.followingTweets); const timestamp = Date.now(); newTweetsData.forYouTweets.forEach((tweet, index) => { tweet.id = `fy_${timestamp}_${index}`; tweet.createdAt = timestamp; }); newTweetsData.followingTweets.forEach((tweet, index) => { tweet.id = `fl_${timestamp}_${index}`; tweet.createdAt = timestamp; }); forYouTweets.unshift(...newTweetsData.forYouTweets); followingTweets.unshift(...newTweetsData.followingTweets); if (forYouTweets.length > 50) { forYouTweets.splice(50); } if (followingTweets.length > 50) { followingTweets.splice(50); } try { await xDb.xTweetsData.put({ id: 'tweets', forYouTweets: newTweetsData.forYouTweets, followingTweets: newTweetsData.followingTweets, lastUpdated: new Date().toISOString(), }); } catch (saveError) { console.error('保存推文数据失败:', saveError); } const userHandle = userXProfileInfo.handle; let mentionFound = false; for (const tweet of newTweetsData.forYouTweets) { if (tweet.content && tweet.content.includes(userHandle)) { mentionFound = true; break; } if (tweet.comments) { for (const comment of tweet.comments) { if (comment.content && comment.content.includes(userHandle)) { mentionFound = true; break; } if (comment.replies) { for (const reply of comment.replies) { if (reply.content && reply.content.includes(userHandle)) { mentionFound = true; break; } } } if (mentionFound) break; } } if (mentionFound) break; } if (!mentionFound) { for (const tweet of newTweetsData.followingTweets) { if (tweet.content && tweet.content.includes(userHandle)) { mentionFound = true; break; } if (tweet.comments) { for (const comment of tweet.comments) { if (comment.content && comment.content.includes(userHandle)) { mentionFound = true; break; } if (comment.replies) { for (const reply of comment.replies) { if (reply.content && reply.content.includes(userHandle)) { mentionFound = true; break; } } } if (mentionFound) break; } } if (mentionFound) break; } } newTweetsData.forYouTweets.forEach(tweet => { tweet.isNew = true; }); newTweetsData.followingTweets.forEach(tweet => { tweet.isNew = true; }); renderTweets(forYouTweets, 'for-you-content'); renderTweets(followingTweets, 'following-content'); const isEnglish = currentLanguage === 'en'; const userAvatar = window.userProfileData?.avatar || 'https: if (mentionFound) { showPhoneNotification({ title: 'X', message: isEnglish ? 'Your feed has been refreshed! Someone mentioned you 🔔' : '你的首页已刷新！有人提到你了哦 🔔', avatar: userAvatar, leftIcon: 'x', }); } else { showPhoneNotification({ title: 'X', message: isEnglish ? 'Your feed has been refreshed!' : '你的首页已刷新！', avatar: userAvatar, leftIcon: 'x', }); } } catch (error) { console.error('刷新推文失败:', error); showXToast(`刷新失败: ${error.message}`, 'error'); } finally { refreshBtn.style.animation = ''; if (spinStyle.parentNode) { spinStyle.remove(); } } } function showNavNotificationDot(page) { const dotId = `${page}-notification-dot`; const dot = document.getElementById(dotId); if (dot) { dot.style.display = 'block'; console.log(`✨ 显示${page}提醒点`); } } function hideNavNotificationDot(page) { const dotId = `${page}-notification-dot`; const dot = document.getElementById(dotId); if (dot) { dot.style.display = 'none'; console.log(`✅ 清除${page}提醒点`); } } window.showNavNotificationDot = showNavNotificationDot; window.hideNavNotificationDot = hideNavNotificationDot; let autoRefreshFeedTimer = null; let autoRefreshFeedEnabled = false; const REFRESH_INTERVAL = 10 * 60 * 1000; window.toggleAutoRefreshFeed = async function () { autoRefreshFeedEnabled = !autoRefreshFeedEnabled; const toggle = document.getElementById('auto-refresh-feed-toggle'); const circle = toggle.querySelector('.toggle-circle'); const statusDiv = document.getElementById('auto-refresh-feed-status'); if (autoRefreshFeedEnabled) { toggle.style.backgroundColor = 'var(--x-accent)'; circle.style.left = '22px'; statusDiv.style.display = 'block'; startAutoRefreshFeedTimer(); await saveAutoRefreshFeedState(true); const isEnglish = currentLanguage === 'en'; showXToast(isEnglish ? 'Auto refresh enabled' : '智能刷新已开启', 'success'); } else { toggle.style.backgroundColor = '#333'; circle.style.left = '2px'; statusDiv.style.display = 'none'; if (autoRefreshFeedTimer) { clearInterval(autoRefreshFeedTimer); autoRefreshFeedTimer = null; } await saveAutoRefreshFeedState(false); const isEnglish = currentLanguage === 'en'; showXToast(isEnglish ? 'Auto refresh disabled' : '智能刷新已关闭', 'info'); } }; function startAutoRefreshFeedTimer() { if (autoRefreshFeedTimer) { clearInterval(autoRefreshFeedTimer); } autoRefreshFeedTimer = setInterval(async () => { await runAutoRefresh(); }, REFRESH_INTERVAL); updateNextRefreshTime(); } async function runAutoRefresh() { try { console.log('⏰ [智能刷新] 开始自动刷新主页推文...'); await refreshXTweets(); updateNextRefreshTime(); const currentPage = document.querySelector('.x-page[style*="display: flex"]'); const isOnHomePage = currentPage && currentPage.id === 'x-home-page'; if (!isOnHomePage) { showNavNotificationDot('home'); } console.log('✅ [智能刷新] 刷新完成'); } catch (error) { console.error('❌ [智能刷新] 自动刷新失败:', error); } } function updateNextRefreshTime() { const nextTime = new Date(Date.now() + REFRESH_INTERVAL); const timeStr = `${nextTime.getHours().toString().padStart(2, '0')}:${nextTime .getMinutes() .toString() .padStart(2, '0')}`; const timeSpan = document.getElementById('next-refresh-time'); if (timeSpan) { timeSpan.textContent = timeStr; } } async function saveAutoRefreshFeedState(enabled) { try { const xDb = getXDB(); const settingsId = `xSettings_${currentAccountId || 'main'}`; let settings = await xDb.xSettings.get(settingsId); if (!settings) { settings = { id: settingsId, autoRefreshFeedEnabled: enabled, updatedAt: new Date().toISOString(), }; } else { settings.autoRefreshFeedEnabled = enabled; settings.updatedAt = new Date().toISOString(); } await xDb.xSettings.put(settings); console.log(`💾 [智能刷新] 状态已保存: ${enabled ? '开启' : '关闭'}`); } catch (error) { console.error('保存刷新状态失败:', error); } } async function restoreAutoRefreshFeedState() { try { const xDb = getXDB(); const settingsId = `xSettings_${currentAccountId || 'main'}`; const settings = await xDb.xSettings.get(settingsId); if (settings && settings.autoRefreshFeedEnabled) { console.log('🔄 [智能刷新] 检测到已保存的开启状态，正在恢复...'); setTimeout(() => { const toggle = document.getElementById('auto-refresh-feed-toggle'); if (toggle) { autoRefreshFeedEnabled = false; window.toggleAutoRefreshFeed(); } }, 1000); } else { console.log('ℹ️ [智能刷新] 未检测到开启状态，保持关闭'); } } catch (error) { console.error('恢复刷新状态失败:', error); } } let currentViewingAccount = null; let isProgressMode = false; let progressLongPressTimer = null; function calculateSimilarity(str1, str2) { if (str1 === str2) return 1; if (str1.length === 0 || str2.length === 0) return 0; const longer = str1.length > str2.length ? str1 : str2; const shorter = str1.length > str2.length ? str2 : str1; let matches = 0; const shorterChars = shorter.split(''); const longerChars = longer.split(''); shorterChars.forEach(char => { const index = longerChars.indexOf(char); if (index !== -1) { matches++; longerChars.splice(index, 1); } }); const similarity = matches / longer.length; if (longer.includes(shorter)) { return Math.max(similarity, shorter.length / longer.length); } return similarity; } window.openAccountProfile = async function (accountName, accountHandle, accountAvatar, sourceContext = {}) { try { console.log(`🔍 正在打开账户主页: ${accountName} (${accountHandle})`); console.log('📍 来源信息:', sourceContext); const xDB = getXDB(); const cleanHandle = accountHandle.replace('@', ''); const savedProfile = await xDB.xAccountProfiles.get(cleanHandle); if (savedProfile) { console.log('✅ 找到已保存的账户主页数据'); const characterProfile = await xDB.xCharacterProfiles.toArray(); const matchedCharacter = characterProfile.find( cp => cp.xHandle === accountHandle || cp.xHandle === `@${cleanHandle}`, ); if (matchedCharacter) { console.log('🔄 [账户主页] 检测到角色账户，同步最新X资料'); let verificationType = 'verified'; if ( window.userProfileData.verificationType === 'couple' && window.userProfileData.coupleCharacterId === matchedCharacter.characterId ) { verificationType = 'couple'; } savedProfile.accountInfo = { ...savedProfile.accountInfo, name: matchedCharacter.xName, handle: matchedCharacter.xHandle, avatar: matchedCharacter.xAvatar, verified: matchedCharacter.xVerified, verificationType: matchedCharacter.xVerified ? verificationType : 'none', cover: matchedCharacter.xCover || savedProfile.accountInfo.cover || 'https: bio: matchedCharacter.xBio || '', publicIdentity: matchedCharacter.publicIdentity || '', customTag1: matchedCharacter.customTag1 || null, customTag2: matchedCharacter.customTag2 || null, followingCount: matchedCharacter.followingCount || savedProfile.accountInfo.followingCount || '', followersCount: matchedCharacter.followersCount || savedProfile.accountInfo.followersCount || '', }; const updateUserInfo = user => { if (user && user.handle === matchedCharacter.xHandle) { user.name = matchedCharacter.xName; user.avatar = matchedCharacter.xAvatar; user.verified = matchedCharacter.xVerified; user.verificationType = matchedCharacter.xVerified ? verificationType : 'none'; } }; if (savedProfile.tweets) { savedProfile.tweets.forEach(tweet => { updateUserInfo(tweet.user); if (tweet.comments) { tweet.comments.forEach(comment => { updateUserInfo(comment.user); if (comment.replies) { comment.replies.forEach(reply => updateUserInfo(reply.user)); } }); } }); } if (savedProfile.accountReplies) { savedProfile.accountReplies.forEach(reply => { if (reply.accountReply) { updateUserInfo(reply.accountReply.user); } }); } savedProfile.updatedAt = new Date().toISOString(); await xDB.xAccountProfiles.put(savedProfile); console.log('✅ [账户主页] 已同步最新X资料信息'); } console.log('🔄 [账户主页] 重新读取X平台私信记忆'); savedProfile.xMessageHistory = await StringBuilders._loadXMessageHistory(accountHandle); if (savedProfile.xMessageHistory && savedProfile.xMessageHistory.length > 0) { console.log(`✅ [账户主页] 重新读取到 ${savedProfile.xMessageHistory.length} 条私信记忆`); } else { console.log('ℹ️ [账户主页] 该账户暂无私信记忆'); } console.log('📊 [账户主页] 加载数据统计:', { 推文数: savedProfile.tweets?.length || 0, 回复数: savedProfile.accountReplies?.length || 0, 喜欢数: savedProfile.accountLikes?.length || 0, 私信数: savedProfile.xMessageHistory?.length || 0, }); currentViewingAccount = savedProfile; renderAccountProfile(savedProfile); return; } const accountData = await queryAccountData(accountName, accountHandle, accountAvatar, sourceContext.existingInfo); if (!accountData) { showXToast('无法加载账户信息', 'error'); return; } currentViewingAccount = { ...accountData, sourceContext }; if (accountData.tweets && accountData.tweets.length > 0) { renderAccountProfile(accountData); return; } showXToast('正在生成账户主页...', 'info'); const profileData = await generateAccountProfileContent(accountData, { sourceContext }); if (profileData) { currentViewingAccount = { ...accountData, ...profileData }; console.log('📊 [账户主页] 新生成数据统计:', { 推文数: profileData.tweets?.length || 0, 回复数: profileData.accountReplies?.length || 0, 喜欢数: profileData.accountLikes?.length || 0, }); renderAccountProfile(currentViewingAccount); await saveAccountProfile(currentViewingAccount); showXToast('账户主页已生成并保存', 'success'); } } catch (error) { console.error('打开账户主页失败:', error); showXToast(`加载失败: ${error.message}`, 'error'); } }; async function queryAccountData(accountName, accountHandle, accountAvatar, existingInfo = {}) { console.log(`🔍 [账户查询] 查询账户: ${accountName} (${accountHandle})`); if (existingInfo.bio || existingInfo.followersCount || existingInfo.verified !== undefined) { console.log('📋 [账户查询] 检测到私信名片的现有资料:', { bio: existingInfo.bio, followersCount: existingInfo.followersCount, verified: existingInfo.verified, }); } const profile = await StringBuilders.getUnifiedProfile(accountHandle, { userProfileInfo: window.userProfileData, includeRecentTweets: false, includeRelationships: true, }); if (!profile) { console.log('⚠️ 未知账户，将根据基本信息生成:', accountName); const unknownAccountData = { accountType: 'unknown', name: accountName, handle: accountHandle, avatar: accountAvatar, verified: existingInfo.verified !== undefined ? existingInfo.verified : false, cover: 'https: bio: existingInfo.bio || '', publicIdentity: '', customTag1: null, customTag2: null, followingCount: '', followersCount: existingInfo.followersCount || '', }; if (existingInfo.bio || existingInfo.followersCount) { console.log('✅ 使用来自私信的现有资料:', { bio: existingInfo.bio, followersCount: existingInfo.followersCount, verified: existingInfo.verified, }); } return unknownAccountData; } console.log(`✅ 识别为 ${profile.type} 账户:`, profile.name, `(${profile.handle})`); let xMessageHistory = []; if (profile.type === 'character' && profile.characterData?.xMessageHistory) { xMessageHistory = profile.characterData.xMessageHistory; } else if (profile.type === 'account' && profile.accountData?.xMessageHistory) { xMessageHistory = profile.accountData.xMessageHistory; } else if (profile.type === 'npc' && profile.npcData?.xMessageHistory) { xMessageHistory = profile.npcData.xMessageHistory; } else if (profile.type === 'relationshipNpc' && profile.relationshipData?.xMessageHistory) { xMessageHistory = profile.relationshipData.xMessageHistory; } else if (profile.type === 'stranger' && profile.accountData?.xMessageHistory) { xMessageHistory = profile.accountData.xMessageHistory; } if (xMessageHistory.length > 0) { console.log(`✅ [账户查询] 提取到 ${xMessageHistory.length} 条X平台私信记忆`); } if (profile.type === 'character') { let verificationType = 'verified'; if ( window.userProfileData.verificationType === 'couple' && window.userProfileData.coupleCharacterId === profile.characterId ) { verificationType = 'couple'; } const accountData = { accountType: 'character', name: profile.name, handle: profile.handle, avatar: profile.avatar, verified: existingInfo.verified !== undefined ? existingInfo.verified : profile.verified, verificationType: profile.verified ? verificationType : 'none', cover: profile.xProfile.xCover || 'https: bio: existingInfo.bio || profile.bio, publicIdentity: profile.publicIdentity, customTag1: profile.xProfile.customTag1 || null, customTag2: profile.xProfile.customTag2 || null, followingCount: profile.xProfile.followingCount || '', followersCount: existingInfo.followersCount || profile.xProfile.followersCount || '', personality: profile.characterData.aiPersona || '', characterData: profile.character, xProfileData: profile.xProfile, characterId: profile.characterId, xMessageHistory: xMessageHistory, }; if (existingInfo.bio || existingInfo.followersCount) { console.log('✅ [角色账户] 已应用私信名片的现有资料'); } return accountData; } else if (profile.type === 'npc') { const accountData = { accountType: 'npc', name: profile.npc.name, handle: profile.npc.handle, avatar: profile.npc.avatar, verified: existingInfo.verified !== undefined ? existingInfo.verified : false, cover: 'https: bio: existingInfo.bio || '', publicIdentity: '', customTag1: null, customTag2: null, followingCount: '', followersCount: existingInfo.followersCount || '', personality: profile.npc.personality || '', postingHabits: profile.npc.postingHabits || '', homepage: profile.npc.homepage || '', npcData: profile.npc, xMessageHistory: xMessageHistory, }; if (existingInfo.bio || existingInfo.followersCount) { console.log('✅ [NPC账户] 已应用私信名片的现有资料'); } return accountData; } else if (profile.type === 'relationshipNpc') { const accountData = { accountType: 'relationshipNpc', name: profile.relationship.npcName, handle: profile.relationship.npcHandle, avatar: accountAvatar || 'https: verified: existingInfo.verified !== undefined ? existingInfo.verified : false, cover: 'https: bio: existingInfo.bio || '', publicIdentity: '', customTag1: null, customTag2: null, followingCount: '', followersCount: existingInfo.followersCount || '', relationshipType: profile.relationship.relationshipType, relationshipDescription: profile.relationship.description || '', ownerCharacterId: profile.ownerCharacter.id, ownerCharacterName: profile.ownerCharacter.name, ownerXProfile: profile.ownerXProfile, relationshipData: profile.relationship, xMessageHistory: xMessageHistory, }; if (existingInfo.bio || existingInfo.followersCount) { console.log('✅ [关系NPC账户] 已应用私信名片的现有资料'); } return accountData; } else if (profile.type === 'account') { const accountData = { accountType: 'account', name: profile.accountInfo.name, handle: profile.accountInfo.handle, avatar: profile.accountInfo.avatar, verified: existingInfo.verified !== undefined ? existingInfo.verified : profile.accountInfo.verified || false, verificationType: profile.accountInfo.verificationType || 'none', cover: profile.accountInfo.cover || 'https: bio: existingInfo.bio || profile.accountInfo.bio || '', publicIdentity: profile.accountInfo.publicIdentity || '', customTag1: profile.accountInfo.customTag1 || null, customTag2: profile.accountInfo.customTag2 || null, followingCount: profile.accountInfo.followingCount || '', followersCount: existingInfo.followersCount || profile.accountInfo.followersCount || '', accountInfo: profile.accountInfo, xMessageHistory: xMessageHistory, }; if (existingInfo.bio || existingInfo.followersCount) { console.log('✅ [X账户] 已应用私信名片的现有资料'); } return accountData; } return { accountType: 'unknown', name: accountName, handle: accountHandle, avatar: accountAvatar, verified: existingInfo.verified !== undefined ? existingInfo.verified : false, cover: 'https: bio: existingInfo.bio || '', publicIdentity: '', customTag1: null, customTag2: null, followingCount: '', followersCount: existingInfo.followersCount || '', }; } async function generateAccountProfileContent(accountData, options = {}) { try { const { isProgressMode = false, existingTweets = [], existingReplies = [], sourceContext = {} } = options; const { apiConfig, xSettings, xDb } = await APIUtils.loadConfigAndSettings(); const { userPrompt, worldSetting } = xSettings; const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); let tokenCount = 0; let systemPrompt = StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting }); tokenCount = TokenUtils.logTokenUsage('账户主页生成器', '基础系统提示词', systemPrompt, tokenCount); const worldBooksOptions = { boundCharacters: [] }; if (accountData.accountType === 'character' && accountData.characterId) { worldBooksOptions.boundCharacters = [accountData.characterId]; } const worldBooksContent = await StringBuilders.getApplicableWorldBooks('profile', worldBooksOptions); if (worldBooksContent) { systemPrompt += worldBooksContent; tokenCount = TokenUtils.logTokenUsage('账户主页生成器', '世界书内容', worldBooksContent, tokenCount); } if (isProgressMode) { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务：推进账户主页内容 🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你需要为X平台账户生成**新的**主页展示内容，包括： - **新的**推文（3-4条，必须与已有内容完全不同） - **新的**回复互动（2-3条，必须与已有回复完全不同） ⚠️⚠️⚠️ 【绝对禁止重复】⚠️⚠️⚠️ - 已有的推文和回复会在下方完整展示 - 新推文的内容、话题、观点必须与已有推文**完全不同** - 新回复必须是全新的互动对象和内容 - 绝对不允许出现相同或高度相似的表达 **推进模式生成策略**： - 账户基本信息已固定，不需要生成 - 新推文应展现不同的话题维度或新的生活动态 - 可以是时间流逝后的新话题、新想法、新事件 - 新推文的时间应该比已有推文更新 - 严格遵循账户已有的风格和人设，但内容必须全新 - **禁止生成置顶推文**：所有新推文的 pinned 字段必须设置为 false 或不设置 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } else { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务：生成账户主页内容 🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你需要为X平台账户生成主页展示内容，包括： - 账户基本信息（若已提供则严格使用，不可修改） - 最近发布的推文（3-5条） - 推文下的评论互动 **生成原则**： - 如果是已知角色账户，必须严格遵循其X资料设定 - 如果是NPC账户，必须严格遵循其人设和发帖习惯 - 如果是角色关系NPC账户，必须体现与所属角色的关系特点，遵循关系设定 - 如果是未知账户，根据昵称、句柄、简介进行合理推断 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } systemPrompt += ` 【目标账户信息】： - X姓名：${accountData.name} - X句柄：${accountData.handle} - X头像：${accountData.avatar} - 认证状态：${accountData.verified ? '是' : '否'} ${ accountData.verified ? `- 认证类型：${ accountData.verificationType === 'couple' ? '情侣认证（心形图标）' : accountData.verificationType === 'verified' ? '普通认证（蓝色勾标）' : '普通认证（蓝色勾标）' }` : '' } ${accountData.bio ? `- X简介：${accountData.bio}` : ''} ${accountData.publicIdentity ? `- 公众身份：${accountData.publicIdentity}` : ''} ${accountData.personality ? `- 人设描述：${accountData.personality}` : ''} ${accountData.postingHabits ? `- 发帖习惯：${accountData.postingHabits}` : ''} ${accountData.cover ? `- 背景图：${accountData.cover}` : ''} ${ accountData.customTag1 ? `- 自定义标签1：${accountData.customTag1.icon} ${accountData.customTag1.text} (${accountData.customTag1.color})` : '' } ${ accountData.customTag2 ? `- 自定义标签2：${accountData.customTag2.icon} ${accountData.customTag2.text} (${accountData.customTag2.color})` : '' } ${accountData.followingCount ? `- 正在关注：${accountData.followingCount}` : ''} ${accountData.followersCount ? `- 关注者：${accountData.followersCount}` : ''} `; if (sourceContext && sourceContext.source) { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 【账户来源上下文】 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; if (sourceContext.source === 'feed') { systemPrompt += `来源：首页推文 该账户发布的内容： "${sourceContext.tweetContent}" ${ sourceContext.tweetMedia && sourceContext.tweetMedia.length > 0 ? `媒体内容：${sourceContext.tweetMedia[0].description}\n` : '' }- 发布时间：${sourceContext.tweetTime} - 互动数据：${sourceContext.tweetStats?.comments || 0}评论，${sourceContext.tweetStats?.likes || 0}喜欢，${ sourceContext.tweetStats?.retweets || 0 }转发 **生成要求**： - 基于该账户发布的内容，推断其兴趣、话题偏好和发帖风格 - 生成的主页推文应该与这条推文风格一致 - 可以生成主题相关但不重复的推文内容`; } else if (sourceContext.source === 'comment') { systemPrompt += `来源：评论区 该账户发表的评论： "${sourceContext.commentContent}" ${ sourceContext.commentImage ? `评论图片：${ sourceContext.commentImage.type === 'description' ? sourceContext.commentImage.content : '包含图片' }\n` : '' }- 发布时间：${sourceContext.commentTime} ${sourceContext.replyTo ? `- 回复对象：${sourceContext.replyTo}\n` : ''} **生成要求**： - 基于该账户发表的评论，推断其互动风格和表达习惯 - 生成的主页推文应该体现类似的表达方式和兴趣点 - 主页推文可以与评论主题相关，但要展现更完整的个人特色`; } else if (sourceContext.source === 'search') { systemPrompt += `来源：搜索结果 搜索关键词："${sourceContext.searchQuery}" 该账户在搜索结果中的信息： - 昵称：${accountData.name} - 句柄：${accountData.handle} ${sourceContext.userBio ? `- 简介：${sourceContext.userBio}\n` : ''}- 认证状态：${ sourceContext.verified ? '已认证' : '未认证' } **生成要求**： - 基于搜索关键词和账户基本信息，推断账户特点和内容方向 - 生成的推文应该与搜索关键词"${sourceContext.searchQuery}"有一定相关性 - 确保账户特点与简介、昵称、句柄相符`; } else if (sourceContext.source === 'dm' || sourceContext.source === 'dm_quote_profile') { const sourceName = sourceContext.source === 'dm' ? '私信详情页' : '私信中的账户名片'; systemPrompt += `来源：${sourceName} 该账户的已知信息： - 昵称：${accountData.name} - 句柄：${accountData.handle} ${accountData.bio ? `- 简介：${accountData.bio}\n` : ''}${ accountData.followersCount ? `- 关注者：${accountData.followersCount}\n` : '' }- 认证状态：${accountData.verified ? '已认证' : '未认证'} ${sourceContext.messagePreview ? `- 私信预览："${sourceContext.messagePreview}"\n` : ''}`; if (sourceContext.source === 'dm_quote_profile' && sourceContext.conversationContext) { try { const { currentConversationHandle, messageId } = sourceContext.conversationContext; console.log('📝 [名片生成] 尝试读取对话记录:', currentConversationHandle, '| messageId:', messageId); const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageId}`; console.log('📝 [名片生成] 查询对话ID:', conversationId); const savedConversation = await xDb.xAccountProfiles.get(conversationId); if ( savedConversation && savedConversation.data && savedConversation.data.messages && savedConversation.data.messages.length > 0 ) { console.log(`✅ [名片生成] 找到对话记录，共 ${savedConversation.data.messages.length} 条消息`); systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 【私信对话上下文】（该账户在私信中的对话记录） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const recentMessages = savedConversation.data.messages.slice(-30); let msgCount = 0; for (const msg of recentMessages) { const sender = msg.isOwn ? '用户' : accountData.name; let content = ''; if (msg.type === 'text') { content = msg.content; } else if (msg.type === 'image') { content = msg.isOwn ? '[用户发送了图片]' : `[图片: ${msg.imageDescription || '图片'}]`; } else if (msg.type === 'voice') { content = `[语音: ${msg.voiceText || '语音消息'}]`; } else if (msg.type === 'sticker') { content = '[表情包]'; } else if (msg.type === 'transfer') { const amount = msg.amount ? `$${msg.amount}` : ''; const note = msg.note ? ` (${msg.note})` : ''; content = `[转账${amount}${note}]`; } else if (msg.type === 'link') { content = `[分享链接: ${msg.title || '链接'}]`; } else if (msg.type === 'quoteTweet') { content = `[转发推文: ${msg.tweet?.content || ''}]`; } else if (msg.type === 'quoteProfile') { const profile = msg.profile || {}; content = `[分享主页: ${profile.name || ''}${profile.bio ? ` - ${profile.bio}` : ''}${ profile.followers ? ` (${profile.followers}关注者)` : '' }]`; } else { content = `[${msg.type}消息]`; } if (content) { const displayContent = content.length > 150 ? `${content.substring(0, 150)}...` : content; systemPrompt += `${sender}: ${displayContent}\n`; msgCount++; } if (msgCount >= 30) break; } systemPrompt += ` ⚠️ 重要说明： - 以上是该账户与用户在私信中的真实对话记录（共${msgCount}条） - 生成账户主页时，必须基于这些对话内容来推断账户的性格、兴趣和特点 - 生成的推文内容、风格、话题应该与对话中展现的形象高度一致 - 如果对话中提到了具体的事件、话题或兴趣，推文应该体现这些内容 - 如果对话中有转发的账户名片，说明该账户与这些名片账户有关联 - 确保账户主页与私信中的形象完全匹配，不要出现矛盾 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const conversationSection = systemPrompt.substring(systemPrompt.lastIndexOf('【私信对话上下文】')); tokenCount = TokenUtils.logTokenUsage( '账户主页生成器', '私信对话上下文', conversationSection, tokenCount, ); } else { console.log('ℹ️ [名片生成] 未找到对话记录或对话为空'); if (savedConversation) { console.log('📋 [名片生成] 对话数据结构:', { hasData: !!savedConversation.data, hasMessages: !!savedConversation.data?.messages, messageCount: savedConversation.data?.messages?.length || 0, }); } else { console.log('📋 [名片生成] 数据库中未找到该对话ID的记录'); } } } catch (error) { console.error('❌ [名片生成] 读取对话记录失败:', error); } } systemPrompt += ` **生成要求**： - ${accountData.bio ? '已有简介，必须严格使用，不可修改' : '需要生成符合该账户特点的简介'} - ${ accountData.followersCount ? `已有关注者数量(${accountData.followersCount})，必须使用，不可修改` : '需要生成合理的关注者数量（100-5000之间）' } - 生成的推文内容要与已有信息（简介、私信内容等）保持一致 - ${ sourceContext.source === 'dm_quote_profile' && sourceContext.conversationContext ? '特别注意：生成的账户主页必须与上述私信对话中展现的性格、兴趣、话题完全一致' : '确保账户形象真实可信，符合其在私信中展现的特点' }`; } systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const contextSection = systemPrompt.substring(systemPrompt.lastIndexOf('【账户来源上下文】')); tokenCount = TokenUtils.logTokenUsage('账户主页生成器', '账户来源上下文', contextSection, tokenCount); } if (accountData.accountType === 'character') { systemPrompt += ` 【角色账户特殊要求】： - **严格遵守**：所有已提供的X资料信息必须完全一致，不得修改 - 推文内容要符合角色人设和性格特点 - 评论互动要体现角色的社交风格 - 如有NPC关系，可在推文/评论中自然体现`; } else if (accountData.accountType === 'npc') { systemPrompt += ` 【NPC账户特殊要求】： - **严格遵守**：使用NPC的姓名、句柄、头像、人设 - 推文内容符合NPC的发帖习惯和主页内容设置 - 评论互动符合NPC的性格特点`; } else if (accountData.accountType === 'relationshipNpc') { systemPrompt += ` 【角色关系NPC账户特殊要求】： - **严格遵守**：使用NPC的姓名（${accountData.name}）和句柄（${accountData.handle}） - 该NPC与角色 ${accountData.ownerCharacterName} (${accountData.ownerXProfile.xName} - ${ accountData.ownerXProfile.xHandle }) 的关系：${accountData.relationshipType} ${accountData.relationshipDescription ? `- 关系描述：${accountData.relationshipDescription}` : ''} - 推文内容应体现这种关系特点，可能会提及或艾特 ${accountData.ownerXProfile.xHandle} - 生成的推文和互动要符合该NPC与角色的关系设定 - 评论区可能出现 ${accountData.ownerXProfile.xName} 的互动，要体现两者的关系 - 如未提供bio、关注者数等信息，由AI根据NPC特点和关系合理补充`; } else { systemPrompt += ` 【未知账户生成要求】： - 根据提供的昵称、句柄、简介推断账户特点 - 生成合理的推文内容和互动风格 - 保持账户身份的一致性`; } const accountInfoSection = systemPrompt.substring(systemPrompt.indexOf('【目标账户信息】')); tokenCount = TokenUtils.logTokenUsage('账户主页生成器', '账户信息与要求', accountInfoSection, tokenCount); if (accountData.accountType === 'relationshipNpc' && accountData.ownerCharacterId) { const mainDB = getDB(); const allChats = await mainDB.chats.toArray(); const ownerCharacter = allChats.find(c => c.id === accountData.ownerCharacterId); const ownerXProfile = accountData.ownerXProfile; if (ownerCharacter && ownerXProfile) { let ownerInfo = ` 【所属角色详细资料】（该NPC的关系对象）： ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ - 角色本名：${ownerCharacter.name} - 角色人设：${ownerCharacter.settings.aiPersona || '无特定人设'} - X平台身份（必须严格使用）： * X用户名：${ownerXProfile.xName} * X句柄：${ownerXProfile.xHandle} * X头像：${ownerXProfile.xAvatar} * 认证状态：${ownerXProfile.xVerified ? '是' : '否'}`; if (ownerXProfile.xBio) ownerInfo += `\n * X简介：${ownerXProfile.xBio}`; if (ownerXProfile.publicIdentity) ownerInfo += `\n * 公众身份：${ownerXProfile.publicIdentity}`; ownerInfo += ` - 该NPC（${accountData.name}）与角色（${ownerXProfile.xName}）的关系：${accountData.relationshipType} ${accountData.relationshipDescription ? `- 关系详情：${accountData.relationshipDescription}` : ''} 【关系互动要求】： - 推文内容应自然体现与 ${ownerXProfile.xName} (${ownerXProfile.xHandle}) 的关系 - ${ownerXProfile.xName} 可能在评论区出现，互动要符合双方关系设定 - 必须严格使用 ${ownerXProfile.xName} 的X平台身份信息 - 可以提及或艾特 ${ownerXProfile.xHandle}，但不要过度频繁 - 保持该NPC独立的个性，不要完全依附于角色 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; systemPrompt += ownerInfo; tokenCount = TokenUtils.logTokenUsage('账户主页生成器', '关系NPC-所属角色资料', ownerInfo, tokenCount); if (ownerXProfile.relationships && ownerXProfile.relationships.length > 0) { let otherNpcsInfo = ` 【所属角色的其他NPC关系】（可能在互动中出现）： `; ownerXProfile.relationships.forEach(rel => { if (rel.npcHandle !== accountData.handle) { otherNpcsInfo += ` - ${rel.npcName} (${rel.npcHandle}): ${rel.relationshipType}`; if (rel.description) otherNpcsInfo += ` - ${rel.description}`; } }); otherNpcsInfo += ` 注意：这些NPC也可能出现在评论区，要体现各自与 ${ownerXProfile.xName} 的关系特点。 `; systemPrompt += otherNpcsInfo; tokenCount = TokenUtils.logTokenUsage('账户主页生成器', '关系NPC-其他NPC关系', otherNpcsInfo, tokenCount); } const ownerRelationshipsInfo = await StringBuilders.buildCharacterRelationships( [accountData.ownerCharacterId], currentAccountId || 'main', ); if (ownerRelationshipsInfo) { systemPrompt += ` 【所属角色的角色关系网络】（可能在互动中出现）： ${ownerRelationshipsInfo} `; tokenCount = TokenUtils.logTokenUsage( '账户主页生成器', '关系NPC-角色关系网络', ownerRelationshipsInfo, tokenCount, ); } } } if (accountData.accountType === 'character' && accountData.characterId) { const relationshipsInfo = await StringBuilders.buildCharacterRelationships( [accountData.characterId], currentAccountId || 'main', ); if (relationshipsInfo) { systemPrompt += relationshipsInfo; tokenCount = TokenUtils.logTokenUsage('账户主页生成器', '角色关系网络', relationshipsInfo, tokenCount); try { const mainDB = getDB(); const currentAccount = currentAccountId || 'main'; const dataId = `xCharacterRelationships_${currentAccount}`; const relationshipRecord = await xDb.xCharacterRelationships.get(dataId); if (relationshipRecord && relationshipRecord.data) { const links = relationshipRecord.data.links || []; const relatedCharacterIds = new Set(); links.forEach(link => { if (link.charA === accountData.characterId) { relatedCharacterIds.add(link.charB); } else if (link.charB === accountData.characterId) { relatedCharacterIds.add(link.charA); } }); if (relatedCharacterIds.size > 0) { const allChats = await mainDB.chats.toArray(); const allXProfiles = await xDb.xCharacterProfiles.toArray(); let relatedCharsInfo = ` 【关系角色详细资料】（可能出现在评论或互动中的角色）： `; for (const charId of relatedCharacterIds) { const charData = allChats.find(c => c.id === charId); const xProfile = allXProfiles.find(p => p.characterId === charId); if (charData && xProfile) { relatedCharsInfo += ` - 角色名：${charData.name} 人设：${charData.settings.aiPersona || '无特定人设'} X平台身份（必须严格使用）： - X用户名：${xProfile.xName} - X句柄：${xProfile.xHandle} - X头像：${xProfile.xAvatar} - 认证状态：${xProfile.xVerified ? '是' : '否'}`; if (xProfile.xBio) relatedCharsInfo += `\n - X简介：${xProfile.xBio}`; if (xProfile.publicIdentity) relatedCharsInfo += `\n - 公众身份：${xProfile.publicIdentity}`; relatedCharsInfo += `\n`; } } relatedCharsInfo += ` 【关系角色互动要求】： - 关系角色可能在推文评论或回复中出现，体现彼此的关系 - 必须严格使用上述X平台身份信息（xName、xHandle、xAvatar等） - 互动内容要符合角色人设和关系设定 - 保持各角色身份的一致性和准确性 `; systemPrompt += relatedCharsInfo; tokenCount = TokenUtils.logTokenUsage( '账户主页生成器', '关系角色详细资料', relatedCharsInfo, tokenCount, ); } } } catch (error) { console.error('获取关系角色详细资料失败:', error); } } } if (isProgressMode && (existingTweets.length > 0 || existingReplies.length > 0)) { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 【已有内容上下文】- 绝对禁止重复以下内容 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ⚠️ 以下是该账户的所有已有推文和回复，生成新内容时必须**完全避开**这些话题和表达： **已有推文（共${existingTweets.length}条）**： `; existingTweets.forEach((tweet, index) => { systemPrompt += ` ${index + 1}. "${tweet.content}" - 时间：${tweet.time} - 互动：${tweet.stats.comments || 0}评论，${tweet.stats.likes || 0}喜欢 ${tweet.media && tweet.media.length > 0 ? ` - 媒体：${tweet.media[0].description}\n` : ''}`; }); if (existingReplies.length > 0) { systemPrompt += ` **已有回复（共${existingReplies.length}条）**： `; existingReplies.forEach((reply, index) => { systemPrompt += ` ${index + 1}. 回复了${reply.type === 'tweet' ? '推文' : '评论'}: "${reply.accountReply.content}" - 时间：${reply.accountReply.time}`; }); } systemPrompt += ` 🚫🚫🚫 【重复检测清单】🚫🚫🚫 - 上述${existingTweets.length}条推文的内容、话题、观点都已被使用 - 新推文必须是**全新的话题**或**不同角度的观点** - 不要生成任何与上述内容相似度超过30%的推文 - 时间设置必须比最新推文（${existingTweets[0]?.time || '未知'}）更新 - 保持风格一致，但内容必须创新 **新内容生成方向建议**： - 探索完全不同的生活话题或兴趣领域 - 展现不同时间段的新想法或新发现 - 基于人设生成全新角度的内容 - 避免重复已有推文的关键词和主题 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const existingContentSection = systemPrompt.substring(systemPrompt.indexOf('【已有内容上下文】')); tokenCount = TokenUtils.logTokenUsage('账户主页生成器', '已有内容上下文', existingContentSection, tokenCount); } const userConstraintsStart = systemPrompt.length; systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 当前生成账户 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 正在生成：${accountData.name} (${accountData.handle}) 的账户主页 账户类型：${ accountData.accountType === 'character' ? '角色账户' : accountData.accountType === 'npc' ? 'NPC账户' : accountData.accountType === 'relationshipNpc' ? `角色关系NPC账户（与 ${accountData.ownerCharacterName} 的关系NPC）` : '未知账户' } ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; if (accountData.accountType === 'character' && accountData.characterId) { const knowsUserIdentity = userXProfileInfo.knownIdentityCharacters.includes(accountData.characterId); if (knowsUserIdentity) { const knowsUserStart = systemPrompt.length; const verificationDesc = { verified: '蓝色勾标认证', couple: '情侣认证', married: '已婚认证', vip: 'VIP认证', }[userXProfileInfo.verificationType] || '无认证'; const hasUserPersona = accountData.xProfileData?.userPersona && accountData.xProfileData.userPersona.trim(); systemPrompt += ` 【用户身份信息】该角色认识用户 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 用户X平台资料（仅供参考，严禁假扮）： - 用户名：${userXProfileInfo.name} - 用户句柄：${userXProfileInfo.handle} - 认证状态：${verificationDesc} ${userXProfileInfo.publicIdentity ? `- 公众身份：${userXProfileInfo.publicIdentity}` : ''} ${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ''} `; try { const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || []; if (recentUserTweets.length > 0) { systemPrompt += ` 用户近期推文（${recentUserTweets.length}条）： `; recentUserTweets.forEach((tweet, index) => { systemPrompt += ` ${index + 1}. "${tweet.content}" - 时间：${tweet.time || '最近'} - 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发，${tweet.stats?.comments || 0}评论 ${ tweet.image ? ` - 媒体：${tweet.image.type === 'description' ? tweet.image.content.substring(0, 50) + '...' : '包含图片'}\n` : '' }`; }); } } catch (error) { console.warn('读取用户推文失败:', error); } systemPrompt += ` 该角色了解的用户信息： ${ hasUserPersona ? accountData.xProfileData.userPersona : '⚠️ 未设置用户人设 - 该角色只知道用户的基本X平台信息（上述资料），不了解用户的私人信息、性格特点或两者之间的具体关系。' } 🚫 【关键约束】 ${ hasUserPersona ? `- 该角色可以在推文中提及或艾特用户 ${userXProfileInfo.handle}，也可以讨论用户的推文 - 但评论区不能出现用户 ${userXProfileInfo.name} (${userXProfileInfo.handle}) 的发言 - 所有评论必须是虚构的普通用户，不得使用用户的名称或句柄` : `- 该角色可以在推文中提及用户 ${userXProfileInfo.handle}（基于基本认识），也可以讨论用户的推文 - 但不要捏造或推断两者的具体关系（如情侣、伴侣、家人等） - 评论区绝对禁止出现用户 ${userXProfileInfo.name} (${userXProfileInfo.handle}) 的发言 - 所有评论必须是虚构的普通用户，不得使用用户的名称或句柄 - ⚠️ 重要：未设置用户人设意味着不能假设两者有特殊关系` } - ${accountData.name} 和 ${userXProfileInfo.name} 是两个完全独立的不同个体 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const knowsUserInfo = systemPrompt.substring(knowsUserStart); tokenCount = TokenUtils.logTokenUsage('账户主页生成器', '角色认识用户-资料与推文', knowsUserInfo, tokenCount); } else { systemPrompt += ` 【用户身份信息】该角色不认识用户 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 用户X平台公开资料（仅供参考，禁止假扮）： - 用户名：${userXProfileInfo.name} - 用户句柄：${userXProfileInfo.handle} ${userXProfileInfo.publicIdentity ? `- 公众身份：${userXProfileInfo.publicIdentity}` : ''} 身份关系： - ${accountData.name} 不知道用户的真实身份 - ${accountData.name} 和 ${userXProfileInfo.name} 是完全独立的不同个体 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } } else { const accountTexts = [ accountData.name || '', accountData.handle || '', accountData.bio || '', accountData.publicIdentity || '', accountData.personality || '', accountData.postingHabits || '', accountData.homepage || '', ].join(' '); const mentionsUser = accountTexts.includes(userXProfileInfo.name) || accountTexts.includes(userXProfileInfo.handle) || accountTexts.includes(userXProfileInfo.handle.replace('@', '')); const mainDB = getDB(); const allChats = await mainDB.chats.toArray(); const allXProfiles = await xDb.xCharacterProfiles.toArray(); const mentionedCharacters = []; for (const xProfile of allXProfiles) { if ( accountTexts.includes(xProfile.xName) || accountTexts.includes(xProfile.xHandle) || accountTexts.includes(xProfile.xHandle.replace('@', '')) ) { const character = allChats.find(c => c.id === xProfile.characterId); if (character) { mentionedCharacters.push({ character, xProfile }); } } } if (mentionsUser || mentionedCharacters.length > 0) { const mentionedInfoStart = systemPrompt.length; systemPrompt += ` 【提及的身份信息】该账户资料提及以下身份 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; if (mentionsUser) { const verificationDesc = { verified: '蓝色勾标认证', couple: '情侣认证', married: '已婚认证', vip: 'VIP认证', }[userXProfileInfo.verificationType] || '无认证'; systemPrompt += ` 用户X平台公开资料（仅供参考，禁止假扮）： - 用户名：${userXProfileInfo.name} - 用户句柄：${userXProfileInfo.handle} - 认证状态：${verificationDesc} ${userXProfileInfo.publicIdentity ? `- 公众身份：${userXProfileInfo.publicIdentity}` : ''} ${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ''} `; try { const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || []; if (recentUserTweets.length > 0) { systemPrompt += ` 用户近期推文（${recentUserTweets.length}条）： `; recentUserTweets.forEach((tweet, index) => { systemPrompt += ` ${index + 1}. "${tweet.content}" - 时间：${tweet.time || '最近'} - 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发，${tweet.stats?.comments || 0}评论 ${ tweet.image ? ` - 媒体：${tweet.image.type === 'description' ? tweet.image.content.substring(0, 50) + '...' : '包含图片'}\n` : '' }`; }); } } catch (error) { console.warn('读取用户推文失败:', error); } } if (mentionedCharacters.length > 0) { systemPrompt += ` 提及的角色X平台资料（仅供参考，禁止假扮）： `; for (const { character, xProfile } of mentionedCharacters) { systemPrompt += ` - ${character.name} - X身份：${xProfile.xName} (${xProfile.xHandle}) ${xProfile.publicIdentity ? `公众身份：${xProfile.publicIdentity}` : ''} ${xProfile.xBio ? `简介：${xProfile.xBio}` : ''} `; try { const cleanCharHandle = xProfile.xHandle.replace('@', ''); const charAccountProfile = await xDb.xAccountProfiles.get(cleanCharHandle); const recentCharTweets = charAccountProfile?.tweets?.slice(0, 5) || []; if (recentCharTweets.length > 0) { systemPrompt += ` ${xProfile.xName} 的近期推文（${recentCharTweets.length}条）： `; recentCharTweets.forEach((tweet, index) => { systemPrompt += ` ${index + 1}. "${tweet.content}" - 时间：${tweet.time || '最近'} - 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发 ${tweet.media && tweet.media.length > 0 ? ` - 媒体：${tweet.media[0].description.substring(0, 50) + '...'}\n` : ''}`; }); } } catch (error) { console.warn(`读取角色 ${xProfile.xName} 的推文失败:`, error); } } } systemPrompt += ` 互动说明： - ${accountData.name} 可以讨论或评论上述身份和他们的推文内容 - 可以基于上述推文内容生成相关的互动或回应 - 但 ${accountData.name} 不是上述任何身份，是独立的个体 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const mentionedInfo = systemPrompt.substring(mentionedInfoStart); tokenCount = TokenUtils.logTokenUsage('账户主页生成器', '提及身份信息与推文', mentionedInfo, tokenCount); } else { systemPrompt += ` 【用户身份信息】无关联 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 用户基本标识（仅供参考，禁止假扮）： - 用户名：${userXProfileInfo.name} - 用户句柄：${userXProfileInfo.handle} 身份关系： - ${accountData.name} 与用户无任何关联 - ${accountData.name} 和 ${userXProfileInfo.name} 是完全独立的不同个体 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } } if (accountData.xMessageHistory && accountData.xMessageHistory.length > 0) { const xMessageSectionStart = systemPrompt.length; console.log(`📝 [账户主页生成器] 开始处理私信记忆，总数: ${accountData.xMessageHistory.length} 条`); systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 【X平台私信记忆】（该账户与用户的私信对话记录） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const recentXMessages = accountData.xMessageHistory.slice(-50); let xMemCount = 0; for (const msg of recentXMessages) { const sender = msg.isOwn ? '用户' : accountData.name; let content = ''; if (msg.type === 'text') { content = msg.content; } else if (msg.type === 'image') { content = msg.isOwn ? '[用户发送了图片]' : `[图片: ${msg.imageDescription || '图片'}]`; } else if (msg.type === 'voice') { content = `[语音: ${msg.voiceText || '语音消息'}]`; } else if (msg.type === 'sticker') { content = '[表情包]'; } else if (msg.type === 'transfer') { const amount = msg.amount ? `$${msg.amount}` : ''; const note = msg.note ? ` (${msg.note})` : ''; content = `[转账${amount}${note}]`; } else if (msg.type === 'link') { content = `[分享链接: ${msg.title || '链接'}]`; } else if (msg.type === 'quoteTweet') { content = `[转发推文: ${msg.tweet?.content || ''}]`; } else if (msg.type === 'quoteProfile') { content = `[分享主页: ${msg.profile?.name || ''}]`; } else { content = `[${msg.type}消息]`; } if (content) { const displayContent = content.length > 80 ? `${content.substring(0, 80)}...` : content; systemPrompt += `${sender}: ${displayContent}\n`; xMemCount++; } if (xMemCount >= 50) break; } systemPrompt += ` ⚠️ 重要说明： - 这些是在X平台私信功能中的真实对话记录 - 无论账户类型（角色/NPC/陌生人），这些对话都是客观存在的 - 生成账户主页时，可以基于这些互动记录展现关系和沟通风格 - 不要在公开推文中直接提及私密的私信内容 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const xMessageSection = systemPrompt.substring(xMessageSectionStart); const xMessageTokens = TokenUtils.estimateTokens(xMessageSection); console.log( `📊 [私信] ${ accountData.accountType === 'character' ? '角色' : accountData.accountType === 'npc' ? 'NPC' : '账户' } ${accountData.name}: ${xMemCount}条, ~${xMessageTokens} tokens`, ); tokenCount = TokenUtils.logTokenUsage('账户主页生成器', 'X平台私信记忆', xMessageSection, tokenCount); } else { console.log(`ℹ️ [账户主页生成器] 该账户无私信记忆数据`); } systemPrompt += ` 🚫🚫🚫 核心禁令（最高优先级）🚫🚫🚫 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 【绝对禁止】假扮用户发布任何内容！ 身份识别： 当前账户：${accountData.name} (${accountData.handle}) 用户账户：${userXProfileInfo.name} (${userXProfileInfo.handle}) ⚠️ 这是两个完全不同的独立个体！ 生成规则： ✅ 可以生成：${accountData.name} (${accountData.handle}) 发布的推文/评论/回复 ✅ 可以生成：虚构的普通X平台用户（自创用户名和句柄） ❌ 绝对禁止：以 ${userXProfileInfo.name} (${userXProfileInfo.handle}) 的身份发布任何内容 ❌ 绝对禁止：在 user.name 或 user.handle 字段中使用用户的名称或句柄 ⚠️ 重要提醒： 所有推文的 user 字段必须是 ${accountData.name} (${accountData.handle}) 所有评论的 user 字段必须是虚构用户（不得是 ${userXProfileInfo.name} 或 ${userXProfileInfo.handle}）${ accountData.accountType === 'relationshipNpc' ? ` 特殊说明：该NPC与 ${accountData.ownerXProfile.xName} (${accountData.ownerXProfile.xHandle}) 有关系， 评论区可以出现 ${accountData.ownerXProfile.xName} 的互动，但必须严格使用其X平台身份信息` : '' } ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const userConstraints = systemPrompt.substring(userConstraintsStart); tokenCount = TokenUtils.logTokenUsage('账户主页生成器', '身份约束与核心禁令', userConstraints, tokenCount); if (isProgressMode) { systemPrompt += ` 【JSON返回格式】： \`\`\`json {"tweets": [推文数组], "accountReplies": [回复数组], "accountLikes": [喜欢数组]} \`\`\` **注意**：推进模式下不需要返回accountInfo，只需返回新的推文、回复和喜欢`; } else { systemPrompt += ` 【JSON返回格式】： \`\`\`json {"accountInfo": {...}, "tweets": [推文数组], "accountReplies": [回复数组], "accountLikes": [喜欢数组]} \`\`\` accountInfo对象结构： - name, handle, avatar, verified (已提供的必须完全一致) - verificationType: ${ accountData.verified ? `"${accountData.verificationType || 'verified'}" (必须使用此值，不可修改)` : '"none" (不可修改)' } - cover: 可补充 - bio: ${accountData.bio ? `"${accountData.bio}" (已提供，必须使用此值，不可修改)` : '可补充'} - customTag1/2: {icon, text, color} (可选) - followingCount: 可补充 - followersCount: ${ accountData.followersCount ? `"${accountData.followersCount}" (已提供，必须使用此值，不可修改)` : '可补充' }`; } systemPrompt += ` tweets数组（3-5条）： - user: {name, handle, avatar, verified, verificationType} - content: 推文文本 - time: 时间描述 - stats: {comments, retweets, likes, views} (纯数字) - media: [{type:"description", description:"图片描述，至少20字"}] (可选) - comments: [评论数组] (1-5条，必须生成，10-20%的评论可带图) - pinned: true/false (可选，第一条推文可置顶，显示"已置顶"标识) 评论对象结构（重要）： - id: 评论唯一ID（可留空，系统自动生成） - user: {name, handle, avatar, verified} - content: 评论文本 (可与sticker同时存在) - timeOffset: 相对推文发布的分钟数（负数，如-5表示推文发布后5分钟的评论） - sticker: {url: "表情包链接", description: "表情包描述"} (可选，约10-15%评论使用) - image: {type: "description", content: "图片文字描述"} (可选，10-20%的评论带图，用于展示图片视频等媒体) - replies: [楼中楼回复数组] (可选，0-2条) 楼中楼回复对象结构： - id: 回复唯一ID（可留空，系统自动生成） - user: {name, handle, avatar, verified} - content: 回复文本 (可与sticker同时存在) - timeOffset: 相对推文发布的分钟数（负数，如-10表示推文发布后10分钟的回复） - sticker: {url: "表情包链接", description: "表情包描述"} (可选，约10-15%回复使用) - image: {type: "description", content: "图片文字描述"} (可选，少量回复可带图) - replyTo: "@被回复者句柄" (必填) accountReplies数组（2-4条，账户的回复记录）： 🚨 重要：每条回复都必须包含完整的三部分数据结构 结构说明： - type: "tweet" | "comment" (回复推文或回复评论) - originalTweet: 原始推文对象（🚨必填！无论type是什么） { user: {name, handle, avatar, verified}, content: "推文内容", time: "时间描述", stats: {comments: 数字, retweets: 数字, likes: 数字, views: 数字}, media: [{type:"description", description:"图片描述"}] } - originalComment: 原始评论对象（⚠️仅当type="comment"时必填） { user: {name, handle, avatar, verified}, content: "评论内容", time: "时间描述" } - accountReply: 账户的回复对象（🚨必填！） { user: {name, handle, avatar, verified}, content: "回复内容", time: "时间描述", stats: {comments: 数字, retweets: 数字, likes: 数字, views: 数字} } 📋 示例1（回复推文）： { "type": "tweet", "originalTweet": {完整推文对象}, "accountReply": {账户回复对象} } 📋 示例2（回复评论）： { "type": "comment", "originalTweet": {完整推文对象}, ← 必须提供！评论所属的推文 "originalComment": {完整评论对象}, ← 必须提供！被回复的评论 "accountReply": {账户回复对象} } accountLikes数组（3-5条，账户喜欢的推文）： - user: {name, handle, avatar, verified, verificationType} - content: 推文文本 - time: 时间描述 - stats: {comments, retweets, likes, views} (纯数字) - media: [{type:"description", description:"图片描述"}] (可选，30-40%的推文可带媒体) - comments: [评论数组] (1-3条即可，比主页推文评论少一些) 📋 喜欢推文示例： { "user": { "name": "某用户", "handle": "@someuser", "avatar": "https: "verified": false }, "content": "推文内容", "time": "2小时", "stats": { "comments": 45, "retweets": 128, "likes": 892, "views": 12400 }, "comments": [...] } ⚠️ accountLikes特殊要求： - 喜欢的推文来自其他用户，不是账户自己的推文 - 推文内容应该与账户的兴趣、身份、人设相关 - 如果是角色账户，喜欢的内容要符合角色性格 - 如果是关系NPC，可以喜欢所属角色的推文 - 推文的互动数据应该合理（likes数应该较高，因为值得被喜欢） - 时间描述应该是相对时间（如"3小时"、"昨天"、"2天"等） 【表情包使用规则】： - 表情包仅限使用世界书中提供的真实链接，严禁虚构或编造链接 - 表情包与文字内容可以同时存在，用于增强表达效果 - 使用频率控制在约10-15%的评论和回复中，保持自然 - sticker对象包含url和description两个必需字段 关键规则： 1. accountInfo已提供字段必须与输入完全一致，不得修改 2. 未提供字段由AI合理补充 3. verified必须是布尔值(true/false) 4. 如果该账户在角色X资料或NPC设置中标注为情侣关系，必须设置verificationType为"couple" 5. ${ isProgressMode ? '**禁止生成置顶推文**：所有推文的 pinned 必须为 false 或不设置' : '建议将最重要或最新的一条推文设置为pinned: true（置顶）' } 6. stats所有数字必须是纯数字，不带引号 7. 每条推文必须包含1-5条评论，评论内容要与推文相关 8. 评论可以包含楼中楼回复（replies数组），形成对话链 9. 🚨 accountReplies必须生成2-4条，每条都必须包含完整数据： - type="tweet": 必须有 originalTweet + accountReply - type="comment": 必须有 originalTweet + originalComment + accountReply（三个都要！） 10. accountReplies中的accountReply.user必须使用目标账户的信息 11. 🚨 accountLikes必须生成3-5条，每条都是完整的推文对象： - 必须包含user、content、time、stats字段 - user不能是目标账户本人（账户不能喜欢自己的推文） - 推文内容要与账户兴趣相关，体现账户的品味和关注点 12. 除了角色和npc以外所有账号都使用统一头像：https: 13. 默认背景图：https: 14. 🚫 **禁止假扮用户**：绝对不可在user字段使用 ${userXProfileInfo.name} 或 ${ userXProfileInfo.handle }，这是用户身份，不可假扮 15. ${ accountData.accountType === 'character' ? `🚫 **严禁自创角色关系**：除非明确提供的关系信息，不要让目标角色(${accountData.name})在推文/评论中声称与其他角色有特殊关系（如情侣、家人等）。所有评论者必须是虚构用户，不要使用其他已知角色的身份。` : accountData.accountType === 'relationshipNpc' ? `✅ **关系NPC互动规则**：该NPC与 ${accountData.ownerXProfile.xName} (${accountData.ownerXProfile.xHandle}) 有 ${accountData.relationshipType} 关系。评论区可以出现 ${accountData.ownerXProfile.xName} 的互动，必须严格使用其X平台身份信息。其他评论者应为虚构用户。` : '评论者应为虚构的普通用户，保持身份的独立性' } 16. sticker字段只能使用世界书中存在的真实链接，禁止虚构`; const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】')); tokenCount = TokenUtils.logTokenUsage('账户主页生成器', 'JSON格式要求', formatSection, tokenCount); const messages = [{ role: 'user', content: `请生成账户 ${accountData.name} (${accountData.handle}) 的主页内容` }]; TokenUtils.logFinalPrompt('账户主页生成器', systemPrompt, messages[0].content); const aiResponseContent = await APIUtils.sendAIRequest({ apiConfig, systemPrompt, messages, temperature: 0.7, }); let profileData = APIUtils.parseJSONResponse(aiResponseContent); profileData = await APIUtils.postProcessData(profileData, userXProfileInfo); if (isProgressMode) { if (!profileData.tweets) { throw new Error('AI返回的数据格式不正确：缺少推文数据'); } if (existingTweets && existingTweets.length > 0) { const newTweets = profileData.tweets || []; const filteredTweets = newTweets.filter(newTweet => { const newContent = newTweet.content.toLowerCase().trim(); const isDuplicate = existingTweets.some(existingTweet => { const existingContent = existingTweet.content.toLowerCase().trim(); if (existingContent === newContent) return true; const similarity = calculateSimilarity(existingContent, newContent); if (similarity > 0.7) { console.log( `🚫 [账户主页推进] 检测到重复推文（相似度${(similarity * 100).toFixed(1)}%）:`, newContent.substring(0, 50), ); return true; } return false; }); return !isDuplicate; }); const removedCount = newTweets.length - filteredTweets.length; if (removedCount > 0) { console.log(`🔍 [账户主页推进] 过滤了 ${removedCount} 条重复推文`); profileData.tweets = filteredTweets; } if (filteredTweets.length === 0) { throw new Error('AI生成的所有推文都与已有内容重复，请重新生成'); } } if (existingReplies && existingReplies.length > 0 && profileData.accountReplies) { const newReplies = profileData.accountReplies || []; const filteredReplies = newReplies.filter(newReply => { const newContent = newReply.accountReply?.content?.toLowerCase().trim() || ''; if (!newContent) return true; const isDuplicate = existingReplies.some(existingReply => { const existingContent = existingReply.accountReply?.content?.toLowerCase().trim() || ''; if (!existingContent) return false; if (existingContent === newContent) return true; const similarity = calculateSimilarity(existingContent, newContent); if (similarity > 0.7) { console.log( `🚫 [账户主页推进] 检测到重复回复（相似度${(similarity * 100).toFixed(1)}%）:`, newContent.substring(0, 50), ); return true; } return false; }); return !isDuplicate; }); const removedCount = newReplies.length - filteredReplies.length; if (removedCount > 0) { console.log(`🔍 [账户主页推进] 过滤了 ${removedCount} 条重复回复`); profileData.accountReplies = filteredReplies; } } } else { if (!profileData.accountInfo || !profileData.tweets) { throw new Error('AI返回的数据格式不正确'); } if (profileData.accountInfo) { const correctVerificationType = accountData.verificationType || 'verified'; profileData.accountInfo.verificationType = correctVerificationType; console.log(`🔒 [账户主页生成] 强制设置账户认证类型: ${correctVerificationType}`); } } const correctVerificationType = accountData.verificationType || 'verified'; const accountHandle = accountData.handle; let fixedCount = 0; if (profileData.tweets && profileData.tweets.length > 0) { profileData.tweets.forEach(tweet => { if (tweet.user && tweet.user.handle === accountHandle) { if (tweet.user.verificationType !== correctVerificationType) { tweet.user.verificationType = correctVerificationType; fixedCount++; } } if (tweet.comments && tweet.comments.length > 0) { tweet.comments.forEach(comment => { if (comment.user && comment.user.handle === accountHandle) { if (comment.user.verificationType !== correctVerificationType) { comment.user.verificationType = correctVerificationType; fixedCount++; } } if (comment.replies && comment.replies.length > 0) { comment.replies.forEach(reply => { if (reply.user && reply.user.handle === accountHandle) { if (reply.user.verificationType !== correctVerificationType) { reply.user.verificationType = correctVerificationType; fixedCount++; } } }); } }); } }); } if (profileData.accountReplies && profileData.accountReplies.length > 0) { profileData.accountReplies.forEach(replyRecord => { if ( replyRecord.accountReply && replyRecord.accountReply.user && replyRecord.accountReply.user.handle === accountHandle ) { if (replyRecord.accountReply.user.verificationType !== correctVerificationType) { replyRecord.accountReply.user.verificationType = correctVerificationType; fixedCount++; } } }); } if (fixedCount > 0) { console.log(`🔒 [账户主页生成] 共修正了 ${fixedCount} 处认证类型错误`); } const timestamp = Date.now(); profileData.tweets.forEach((tweet, tweetIndex) => { if (!tweet.id) { tweet.id = `account_tweet_${timestamp}_${tweetIndex}`; } if (!tweet.timestamp) { const hoursAgo = tweetIndex * 2 + Math.floor(Math.random() * 2); tweet.timestamp = timestamp - hoursAgo * 60 * 60 * 1000; } if (!tweet.stats) { tweet.stats = { comments: tweet.comments?.length || 0, retweets: 0, likes: 0, views: 0, }; } if (tweet.comments && tweet.comments.length > 0) { tweet.comments.forEach((comment, commentIndex) => { if (!comment.id) { comment.id = `account_comment_${timestamp}_${tweetIndex}_${commentIndex}`; } if (comment.timeOffset !== undefined) { comment.timestamp = tweet.timestamp + Math.abs(comment.timeOffset) * 60 * 1000; delete comment.timeOffset; } else if (!comment.timestamp) { comment.timestamp = tweet.timestamp + (5 + Math.random() * 30) * 60 * 1000; } if (comment.replies && comment.replies.length > 0) { comment.replies.forEach((reply, replyIndex) => { if (!reply.id) { reply.id = `account_reply_${timestamp}_${tweetIndex}_${commentIndex}_${replyIndex}`; } if (reply.timeOffset !== undefined) { reply.timestamp = tweet.timestamp + Math.abs(reply.timeOffset) * 60 * 1000; delete reply.timeOffset; } else if (!reply.timestamp) { reply.timestamp = comment.timestamp + (1 + Math.random() * 10) * 60 * 1000; } }); } }); } }); if (profileData.accountLikes && profileData.accountLikes.length > 0) { profileData.accountLikes.forEach((likedTweet, likeIndex) => { if (!likedTweet.id) { likedTweet.id = `account_liked_${timestamp}_${likeIndex}`; } if (!likedTweet.timestamp) { const daysAgo = likeIndex + 1 + Math.floor(Math.random() * 2); likedTweet.timestamp = timestamp - daysAgo * 24 * 60 * 60 * 1000; } if (!likedTweet.stats) { likedTweet.stats = { comments: likedTweet.comments?.length || 0, retweets: 0, likes: 0, views: 0, }; } if (likedTweet.comments && likedTweet.comments.length > 0) { likedTweet.comments.forEach((comment, commentIndex) => { if (!comment.id) { comment.id = `liked_comment_${timestamp}_${likeIndex}_${commentIndex}`; } if (comment.timeOffset !== undefined) { comment.timestamp = likedTweet.timestamp + Math.abs(comment.timeOffset) * 60 * 1000; delete comment.timeOffset; } else if (!comment.timestamp) { comment.timestamp = likedTweet.timestamp + (5 + Math.random() * 30) * 60 * 1000; } }); } }); } const isEnglish = currentLanguage === 'en'; const userAvatar = window.userProfileData?.avatar || 'https: showPhoneNotification({ title: 'X', message: isEnglish ? 'Account profile has been generated!' : '账户主页已生成！', avatar: userAvatar, leftIcon: 'x', }); return profileData; } catch (error) { console.error('生成账户主页内容失败:', error); showXToast(`生成失败: ${error.message}`, 'error'); return null; } } function renderAccountProfile(accountData) { console.log('渲染账户主页:', accountData); const accountInfo = accountData.accountInfo || accountData; document.getElementById('account-profile-nav-name').textContent = accountInfo.name || accountData.name; const tweetCount = (accountData.tweets && accountData.tweets.length) || 0; document.getElementById('account-profile-nav-count').textContent = `${DataUtils.formatNumber( tweetCount, )} ${getI18nText('accountPostsCount')}`; const coverImage = document.getElementById('account-cover-image'); coverImage.style.backgroundImage = `url('${ accountInfo.cover || accountData.cover || 'https: }')`; document.getElementById('account-avatar-image').src = accountInfo.avatar || accountData.avatar; document.getElementById('account-display-name').textContent = accountInfo.name || accountData.name; const verifiedBadge = document.getElementById('account-verified-badge'); const verificationType = accountInfo.verificationType || accountData.verificationType || 'verified'; if (accountInfo.verified || accountData.verified) { if (verificationType === 'couple') { verifiedBadge.innerHTML = ` <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);"> <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g> </svg> `; } else { verifiedBadge.innerHTML = ` <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);"> <g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g> </svg> `; } verifiedBadge.style.display = 'inline-flex'; verifiedBadge.style.alignItems = 'center'; } else { verifiedBadge.style.display = 'none'; } const handle = accountInfo.handle || accountData.handle; document.getElementById('account-handle-text').textContent = handle.startsWith('@') ? handle : `@${handle}`; const bioElement = document.getElementById('account-bio-text'); if (accountInfo.bio || accountData.bio) { bioElement.textContent = accountInfo.bio || accountData.bio; bioElement.style.display = 'block'; } else { bioElement.style.display = 'none'; } const tagsContainer = document.getElementById('account-tags-container'); tagsContainer.innerHTML = ''; const customTag1 = accountInfo.customTag1 || accountData.customTag1; const customTag2 = accountInfo.customTag2 || accountData.customTag2; if (customTag1 && customTag1.text) { const tag1 = document.createElement('div'); tag1.style.cssText = `display: flex; align-items: center; gap: 4px; color: ${ customTag1.color || '#71767b' }; font-size: 15px;`; tag1.innerHTML = `<span>${customTag1.icon || ''}</span><span>${customTag1.text}</span>`; tagsContainer.appendChild(tag1); } if (customTag2 && customTag2.text) { const tag2 = document.createElement('div'); tag2.style.cssText = `display: flex; align-items: center; gap: 4px; color: ${ customTag2.color || '#71767b' }; font-size: 15px;`; tag2.innerHTML = `<span>${customTag2.icon || ''}</span><span>${customTag2.text}</span>`; tagsContainer.appendChild(tag2); } document.getElementById('account-following-count').textContent = accountInfo.followingCount || accountData.followingCount || '0'; document.getElementById('account-followers-count').textContent = accountInfo.followersCount || accountData.followersCount || '0'; const followBtn = document.getElementById('account-follow-btn'); if (followBtn && followBtn.textContent.includes('关注')) { followBtn.textContent = getI18nText('accountFollow'); } else if (followBtn && followBtn.textContent.includes('Following')) { followBtn.textContent = getI18nText('accountFollow'); } const tweetsContainer = document.getElementById('account-tweets-container'); tweetsContainer.innerHTML = ''; if (accountData.tweets && accountData.tweets.length > 0) { accountData.tweets.forEach(tweet => { const tweetElement = createAccountTweetElement(tweet, accountInfo); tweetsContainer.appendChild(tweetElement); }); } else { tweetsContainer.innerHTML = '<div style="padding: 40px; text-align: center; color: #71767b;">该账户还没有发布推文</div>'; } document.querySelectorAll('.x-page').forEach(page => (page.style.display = 'none')); document.getElementById('account-profile-page').style.display = 'flex'; showXToast(`已加载 ${accountInfo.name || accountData.name} 的主页`, 'success'); } function createAccountReplyElement(reply) { const replyEl = document.createElement('div'); replyEl.style.cssText = 'border-bottom: 1px solid #2f3336;'; const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount; if (!reply || !reply.type) { console.warn('⚠️ [账户回复] 回复数据不完整:', reply); replyEl.innerHTML = '<div style="padding: 16px; color: #71767b;">回复数据不完整</div>'; return replyEl; } let accountVerifiedBadgeHtml = ''; if (accountInfo.verified) { if (accountInfo.verificationType === 'couple') { accountVerifiedBadgeHtml = '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>'; } else { accountVerifiedBadgeHtml = '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'; } } if (reply.type === 'tweet') { if (!reply.originalTweet || !reply.originalTweet.user || !reply.accountReply) { console.warn('⚠️ [账户回复] 推文回复数据不完整:', reply); replyEl.innerHTML = '<div style="padding: 16px; color: #71767b;">推文回复数据不完整</div>'; return replyEl; } const originalUser = reply.originalTweet.user; const accountReply = reply.accountReply; let originalVerifiedHtml = ''; if (originalUser.verified) { originalVerifiedHtml = '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'; } replyEl.innerHTML = ` <div style="padding: 12px 16px;"> <div style="display: flex; gap: 12px; margin-bottom: 8px;"> <img src="${originalUser.avatar}" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;"> <div style="flex: 1; min-width: 0;"> <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; flex-wrap: wrap;"> <span style="color: #fff; font-weight: 800; font-size: 15px;">${originalUser.name}</span> ${originalVerifiedHtml} <span style="color: #71767b; font-size: 15px;">${ originalUser.handle.startsWith('@') ? originalUser.handle : '@' + originalUser.handle }</span> <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span> <span class="tweet-time" data-timestamp="${ reply.originalTweet.timestamp || Date.now() }" style="color: #71767b; font-size: 15px;">${ reply.originalTweet.timestamp ? getRelativeTime(reply.originalTweet.timestamp) : reply.originalTweet.time || '刚刚' }</span> </div> <div style="color: #fff; font-size: 15px; line-height: 20px; word-wrap: break-word;">${processContent( reply.originalTweet.content, )}</div> ${ reply.originalTweet.media && reply.originalTweet.media.length > 0 ? ` <div style="background-color:var(--x-bg-secondary); border-radius: 16px; padding: 12px; margin-top: 12px; border: 1px solid var(--x-border-color);"> <div style="color:var(--x-text-primary); font-size: 15px; line-height: 20px;">${reply.originalTweet.media[0].description}</div> </div> ` : '' } </div> </div> <div style="display: flex; gap: 12px;"> <div style="width: 40px; display: flex; justify-content: center; position: relative;"> <div style="width: 2px; height: 100%; background-color: #2f3336;"></div> </div> <div style="flex: 1;"></div> </div> <div style="display: flex; gap: 12px; margin-top: 8px;"> <img src="${accountInfo.avatar}" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;"> <div style="flex: 1; min-width: 0;"> <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; flex-wrap: wrap;"> <span style="color: #fff; font-weight: 800; font-size: 15px;">${accountInfo.name}</span> ${accountVerifiedBadgeHtml} <span style="color: #71767b; font-size: 15px;">${ accountInfo.handle.startsWith('@') ? accountInfo.handle : '@' + accountInfo.handle }</span> <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span> <span class="tweet-time" data-timestamp="${ accountReply.timestamp || Date.now() }" style="color: #71767b; font-size: 15px;">${ accountReply.timestamp ? getRelativeTime(accountReply.timestamp) : accountReply.time || '刚刚' }</span> </div> <div style="color: #71767b; font-size: 15px; margin-bottom: 4px;">${getI18nText( 'accountReplyTo', )} <span style="color: var(--x-accent);">${ originalUser.handle.startsWith('@') ? originalUser.handle : '@' + originalUser.handle }</span></div> <div style="color: #fff; font-size: 15px; line-height: 20px; margin-bottom: 12px; word-wrap: break-word;">${processContent( accountReply.content, )}</div> <div style="display: flex; justify-content: space-between; max-width: 425px;"> <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g></svg> <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.comments || 0)}</span> </div> <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='#00ba7c'" onmouseout="this.style.color='#71767b'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g></svg> <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.retweets || 0)}</span> </div> <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='#f91880'" onmouseout="this.style.color='#71767b'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg> <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.likes || 0)}</span> </div> <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10h2L6 21H4zm9.248 0v-7h2v7h-2z"></path></g></svg> <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.views || 0)}</span> </div> </div> </div> </div> </div> `; } else if (reply.type === 'comment') { if ( !reply.originalTweet || !reply.originalTweet.user || !reply.originalComment || !reply.originalComment.user || !reply.accountReply ) { console.warn('⚠️ [账户回复] 评论回复数据不完整:', reply); replyEl.innerHTML = '<div style="padding: 16px; color: #71767b;">评论回复数据不完整</div>'; return replyEl; } const originalTweetUser = reply.originalTweet.user; const originalCommentUser = reply.originalComment.user; const accountReply = reply.accountReply; let tweetVerifiedHtml = ''; if (originalTweetUser.verified) { tweetVerifiedHtml = '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'; } let commentVerifiedHtml = ''; if (originalCommentUser.verified) { commentVerifiedHtml = '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'; } replyEl.innerHTML = ` <div style="padding: 12px 16px;"> <div style="display: flex; gap: 12px; margin-bottom: 4px;"> <img src="${originalTweetUser.avatar}" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;"> <div style="flex: 1; min-width: 0;"> <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; flex-wrap: wrap;"> <span style="color: #fff; font-weight: 800; font-size: 15px;">${originalTweetUser.name}</span> ${tweetVerifiedHtml} <span style="color: #71767b; font-size: 15px;">${ originalTweetUser.handle.startsWith('@') ? originalTweetUser.handle : '@' + originalTweetUser.handle }</span> <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span> <span class="tweet-time" data-timestamp="${ reply.originalTweet.timestamp || Date.now() }" style="color: #71767b; font-size: 15px;">${ reply.originalTweet.timestamp ? getRelativeTime(reply.originalTweet.timestamp) : reply.originalTweet.time || '刚刚' }</span> </div> <div style="color: #fff; font-size: 15px; line-height: 20px; word-wrap: break-word;">${processContent( reply.originalTweet.content, )}</div> ${ reply.originalTweet.media && reply.originalTweet.media.length > 0 ? ` <div style="background-color:var(--x-bg-secondary); border-radius: 16px; padding: 12px; margin-top: 12px; border: 1px solid var(--x-border-color);"> <div style="color:var(--x-text-primary); font-size: 15px; line-height: 20px;">${reply.originalTweet.media[0].description}</div> </div> ` : '' } </div> </div> <div style="display: flex; gap: 12px; margin-top: 8px;"> <div style="width: 40px; display: flex; justify-content: center;"> <div style="width: 2px; background-color: #2f3336; height: 100%;"></div> </div> <div style="flex: 1; padding-top: 4px;"> <div style="display: flex; gap: 12px;"> <img src="${originalCommentUser.avatar}" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;"> <div style="flex: 1; min-width: 0;"> <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; flex-wrap: wrap;"> <span style="color: #fff; font-weight: 800; font-size: 15px;">${originalCommentUser.name}</span> ${commentVerifiedHtml} <span style="color: #71767b; font-size: 15px;">${ originalCommentUser.handle.startsWith('@') ? originalCommentUser.handle : '@' + originalCommentUser.handle }</span> <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span> <span class="tweet-time" data-timestamp="${ reply.originalComment.timestamp || Date.now() }" style="color: #71767b; font-size: 15px;">${ reply.originalComment.timestamp ? getRelativeTime(reply.originalComment.timestamp) : reply.originalComment.time || '刚刚' }</span> </div> <div style="color: #fff; font-size: 15px; line-height: 20px; word-wrap: break-word;">${processContent( reply.originalComment.content, )}</div> </div> </div> </div> </div> <div style="display: flex; gap: 12px; margin-top: 8px;"> <div style="width: 40px; display: flex; justify-content: center;"> <div style="width: 2px; background-color: #2f3336; height: 100%;"></div> </div> <div style="flex: 1; padding-top: 4px;"> <div style="display: flex; gap: 12px;"> <img src="${accountInfo.avatar}" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;"> <div style="flex: 1; min-width: 0;"> <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; flex-wrap: wrap;"> <span style="color: #fff; font-weight: 800; font-size: 15px;">${accountInfo.name}</span> ${accountVerifiedBadgeHtml} <span style="color: #71767b; font-size: 15px;">${ accountInfo.handle.startsWith('@') ? accountInfo.handle : '@' + accountInfo.handle }</span> <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span> <span class="tweet-time" data-timestamp="${ accountReply.timestamp || Date.now() }" style="color: #71767b; font-size: 15px;">${ accountReply.timestamp ? getRelativeTime(accountReply.timestamp) : accountReply.time || '刚刚' }</span> </div> <div style="color: #71767b; font-size: 15px; margin-bottom: 4px;">${getI18nText( 'accountReplyTo', )} <span style="color: var(--x-accent);">${ originalCommentUser.handle.startsWith('@') ? originalCommentUser.handle : '@' + originalCommentUser.handle }</span></div> <div style="color: #fff; font-size: 15px; line-height: 20px; margin-bottom: 12px; word-wrap: break-word;">${processContent( accountReply.content, )}</div> <div style="display: flex; justify-content: space-between; max-width: 425px;"> <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g></svg> <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.comments || 0)}</span> </div> <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='#00ba7c'" onmouseout="this.style.color='#71767b'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g></svg> <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.retweets || 0)}</span> </div> <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='#f91880'" onmouseout="this.style.color='#71767b'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg> <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.likes || 0)}</span> </div> <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10h2L6 21H4zm9.248 0v-7h2v7h-2z"></path></g></svg> <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.views || 0)}</span> </div> </div> </div> </div> </div> </div> </div> `; } return replyEl; } function createLikedTweetElement(tweet, accountInfo) { const tweetEl = document.createElement('div'); tweetEl.style.cssText = 'border-bottom: 1px solid var(--x-border-color);'; const user = tweet.user; let verifiedBadgeHtml = ''; if (user.verified) { if (user.verificationType === 'couple') { verifiedBadgeHtml = '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>'; } else { verifiedBadgeHtml = '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'; } } tweetEl.innerHTML = ` <div style="padding: 12px 16px 0; display: flex; align-items: center; gap: 12px;"> <div style="width: 40px; display: flex; justify-content: flex-end;"> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-text-secondary);"> <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g> </svg> </div> <span style="color:var(--x-text-secondary); font-size: 13px; font-weight: 700;">${accountInfo.name} ${getI18nText( 'accountLiked', )}</span> </div> <div style="padding: 12px 16px; display: flex; gap: 12px; position: relative;"> <img src="${user.avatar}" alt="${user.name}" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;"> <div style="flex: 1; min-width: 0;"> <div style="display: flex; align-items: center; gap: 2px; margin-bottom: 2px; flex-wrap: wrap;"> <span style="color:var(--x-text-primary); font-weight: 800; font-size: 15px;">${user.name}</span> ${verifiedBadgeHtml} <span style="color:var(--x-text-secondary); font-size: 15px; margin-left: 4px;">${ user.handle.startsWith('@') ? user.handle : '@' + user.handle }</span> <span style="color:var(--x-text-secondary); font-size: 15px; margin: 0 4px;">·</span> <span class="tweet-time" data-timestamp="${ tweet.timestamp || Date.now() }" style="color:var(--x-text-secondary); font-size: 15px;">${ tweet.timestamp ? getRelativeTime(tweet.timestamp) : tweet.time || '刚刚' }</span> </div> <div style="color:var(--x-text-primary); font-size: 15px; line-height: 20px; margin-bottom: 12px; word-wrap: break-word;">${processContent( tweet.content, )}</div> ${ tweet.media && tweet.media.length > 0 ? ` <div style="background-color:var(--x-bg-secondary); border-radius: 16px; padding: 12px; margin-bottom: 12px; border: 1px solid var(--x-border-color);"> <div style="color:var(--x-text-primary); font-size: 15px; line-height: 20px;">${tweet.media[0].description}</div> </div> ` : '' } <div style="display: flex; justify-content: space-between; max-width: 425px; margin-top: 12px;"> <div onclick="showLikedTweetDetail('${ tweet.id || Date.now() }')" style="display: flex; align-items: center; gap: 4px; color:var(--x-text-secondary); cursor: pointer; padding: 0;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='var(--x-text-secondary)'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g></svg> <span style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.comments || 0)}</span> </div> <div style="display: flex; align-items: center; gap: 4px; color:var(--x-text-secondary); cursor: pointer; padding: 0;" onmouseover="this.style.color='#00ba7c'" onmouseout="this.style.color='var(--x-text-secondary)'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g></svg> <span style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.retweets || 0)}</span> </div> <div style="display: flex; align-items: center; gap: 4px; color: #f91880; cursor: pointer; padding: 0;" onmouseover="this.style.color='#f91880'" onmouseout="this.style.color='#f91880'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg> <span style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.likes || 0)}</span> </div> <div style="display: flex; align-items: center; gap: 4px; color:var(--x-text-secondary); cursor: pointer; padding: 0;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='var(--x-text-secondary)'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10h2L6 21H4zm9.248 0v-7h2v7h-2z"></path></g></svg> <span style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.views || 0)}</span> </div> <div style="display: flex; align-items: center; gap: 8px; color:var(--x-text-secondary); cursor: pointer; padding: 0;"> <div style="display: flex; align-items: center;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='var(--x-text-secondary)'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g></svg> </div> <div style="display: flex; align-items: center;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='var(--x-text-secondary)'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.3 3.3-1.41-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g></svg> </div> </div> </div> </div> <div style="position: absolute; top: 12px; right: 16px; cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-secondary);"> <g><path d="M3 12c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm9 2c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm7 0c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z"></path></g> </svg> </div> </div> `; tweetEl.dataset.tweetData = JSON.stringify(tweet); return tweetEl; } function createAccountTweetElement(tweet, accountInfo) { const tweetEl = document.createElement('div'); tweetEl.style.cssText = 'border-bottom: 1px solid var(--x-border-color);'; const user = tweet.user || accountInfo; const isPinned = tweet.pinned || false; let verifiedBadgeHtml = ''; if (user.verified) { if (user.verificationType === 'couple') { verifiedBadgeHtml = '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>'; } else { verifiedBadgeHtml = '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'; } } tweetEl.innerHTML = ` ${ isPinned ? ` <div style="padding: 12px 16px 0; display: flex; align-items: center; gap: 12px;"> <div style="width: 40px; display: flex; justify-content: flex-end;"> <svg viewBox="0 0 32 32" style="width: 16px; height: 16px; fill: #71767b;"> <path d="M20.743 14.815l-0.933-12.065h5.191c0.414 0 0.75-0.336 0.75-0.75s-0.336-0.75-0.75-0.75v0h-18c-0.414 0-0.75 0.336-0.75 0.75s0.336 0.75 0.75 0.75v0h5.432l-1.275 12.103c-3.213 0.959-5.574 3.738-5.904 7.113l-0.003 0.034c0 0.414 0.336 0.75 0.75 0.75h9.25v7.25c0 0.414 0.336 0.75 0.75 0.75s0.75-0.336 0.75-0.75v0-7.25h9.25c0.414-0 0.75-0.336 0.75-0.75v0c0-3.017-2.35-5.787-6.007-7.185zM12.104 16.081c0.096-0.035 0.179-0.085 0.249-0.148l-0.001 0.001 0.005-0.003c0.126-0.117 0.211-0.275 0.233-0.453l0-0.004 0.011-0.022 1.337-12.701h4.367l0.979 12.681c0.033 0.35 0.303 0.627 0.647 0.67l0.004 0c2.542 0.682 4.512 2.623 5.222 5.096l0.013 0.052h-18.341c0.729-2.54 2.714-4.49 5.222-5.157l0.052-0.012z"></path> </svg> </div> <span style="color: #71767b; font-size: 13px; font-weight: 700;">${getI18nText('accountPinned')}</span> </div> ` : '' } <div style="padding: 12px 16px; display: flex; gap: 12px; position: relative;"> <img src="${user.avatar}" alt="${user.name}" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;"> <div style="flex: 1; min-width: 0;"> <div style="display: flex; align-items: center; gap: 2px; margin-bottom: 2px; flex-wrap: wrap;"> <span style="color: #fff; font-weight: 800; font-size: 15px;">${user.name}</span> ${verifiedBadgeHtml} <span style="color: #71767b; font-size: 15px; margin-left: 4px;">${ user.handle.startsWith('@') ? user.handle : '@' + user.handle }</span> <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span> <span class="tweet-time" data-timestamp="${tweet.timestamp || Date.now()}" style="color: #71767b; font-size: 15px;">${ tweet.timestamp ? getRelativeTime(tweet.timestamp) : tweet.time || '刚刚' }</span> </div> <div style="color: #fff; font-size: 15px; line-height: 20px; margin-bottom: 12px; word-wrap: break-word;">${processContent( tweet.content, )}</div> ${ tweet.media && tweet.media.length > 0 ? ` <div style="background-color:var(--x-bg-secondary); border-radius: 16px; padding: 12px; margin-bottom: 12px; border: 1px solid var(--x-border-color);"> <div style="color:var(--x-text-primary); font-size: 15px; line-height: 20px;">${tweet.media[0].description}</div> </div> ` : '' } <div style="display: flex; justify-content: space-between; max-width: 425px; margin-top: 12px;"> <div onclick="showAccountTweetDetail('${ tweet.id }')" style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer; padding: 0;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g></svg> <span style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.comments || 0)}</span> </div> <div onclick="handleQuoteRetweetFromAccountTweet('${ tweet.id }')" style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer; padding: 0;" onmouseover="this.style.color='#00ba7c'" onmouseout="this.style.color='#71767b'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g></svg> <span style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.retweets || 0)}</span> </div> <div class="tweet-action like" onclick="toggleLike('${tweet.id}', this)" data-liked="false" data-likes="${ tweet.stats.likes || 0 }" style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer; padding: 0;" onmouseover="this.style.color='#f91880'" onmouseout="this.style.color='#71767b'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg> <span class="like-count" style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.likes || 0)}</span> </div> <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer; padding: 0;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10h2L6 21H4zm9.248 0v-7h2v7h-2z"></path></g></svg> <span style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.views || 0)}</span> </div> <div style="display: flex; align-items: center; gap: 8px; color: #71767b; cursor: pointer; padding: 0;"> <div onclick="toggleBookmark('${ tweet.id }', this)" data-bookmarked="false" style="display: flex; align-items: center;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g></svg> </div> <div style="display: flex; align-items: center;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.3 3.3-1.41-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g></svg> </div> </div> </div> </div> <div style="position: absolute; top: 12px; right: 16px; cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #71767b;"> <g><path d="M3 12c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm9 2c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm7 0c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z"></path></g> </svg> </div> </div> `; return tweetEl; } window.closeAccountProfile = function () { if (isProgressMode) { isProgressMode = false; updateRefreshButtonUI(); } document.getElementById('account-profile-page').style.display = 'none'; if (isInSearchResults && currentSearchQuery) { console.log('📖 [返回] 从账户主页返回搜索结果页'); document.getElementById('trending-view').style.display = 'none'; document.getElementById('search-results-view').style.display = 'flex'; const backBtn = document.getElementById('search-back-btn'); if (backBtn) backBtn.style.display = 'flex'; const refreshBtn = document.querySelector('.refresh-trends-btn'); if (refreshBtn) refreshBtn.style.display = 'none'; document.getElementById('x-search-page').style.display = 'flex'; } else { document.getElementById('x-home-page').style.display = 'flex'; } }; window.showAccountTweetDetail = async function (tweetId) { if (!currentViewingAccount || !currentViewingAccount.tweets) { showXToast('无法找到推文数据', 'error'); return; } const tweet = currentViewingAccount.tweets.find(t => t.id === tweetId); if (!tweet) { showXToast('未找到该推文', 'error'); return; } tweet._source = 'account'; tweet._accountHandle = (currentViewingAccount.accountInfo || currentViewingAccount).handle; await showTweetDetail(tweet); }; window.showLikedTweetDetail = async function (tweetId) { if (!currentViewingAccount || !currentViewingAccount.accountLikes) { showXToast('无法找到喜欢数据', 'error'); return; } const tweet = currentViewingAccount.accountLikes.find(t => t.id === tweetId); if (!tweet) { showXToast('未找到该推文', 'error'); return; } tweet._source = 'liked'; tweet._accountHandle = (currentViewingAccount.accountInfo || currentViewingAccount).handle; await showTweetDetail(tweet); }; window.toggleAccountFollow = function () { const followBtn = document.getElementById('account-follow-btn'); const notifyBtn = document.getElementById('account-notify-btn'); const followText = getI18nText('accountFollow'); const followingText = getI18nText('accountFollowing'); const bgPrimary = getComputedStyle(document.getElementById('x-social-screen')) .getPropertyValue('--x-bg-primary') .trim(); const textPrimary = getComputedStyle(document.getElementById('x-social-screen')) .getPropertyValue('--x-text-primary') .trim(); const borderColor = getComputedStyle(document.getElementById('x-social-screen')) .getPropertyValue('--x-border-color') .trim(); if (followBtn.textContent === followText) { followBtn.textContent = followingText; followBtn.style.backgroundColor = bgPrimary || '#000'; followBtn.style.color = textPrimary || '#fff'; followBtn.style.border = `1px solid ${borderColor || '#536471'}`; notifyBtn.style.display = 'flex'; showXToast('已关注该账户', 'success'); } else { followBtn.textContent = followText; followBtn.style.backgroundColor = textPrimary || '#fff'; followBtn.style.color = bgPrimary || '#000'; followBtn.style.border = 'none'; notifyBtn.style.display = 'none'; showXToast('已取消关注', 'info'); } }; window.toggleAccountNotifications = function () { showXToast('通知设置已更新', 'success'); }; window.sendMessageToAccount = async function () { if (!currentViewingAccount) { showXToast('无法获取账户信息', 'error'); return; } console.log('📨 从账户主页打开私信详情页'); const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount; const cleanHandle = accountInfo.handle.replace('@', ''); try { const xDb = getXDB(); const settingsId = `xSettings_${currentAccountId || 'main'}`; const xSettings = await xDb.xSettings.get(settingsId); const boundCharacters = xSettings?.boundCharacters || []; let matchedCharacterId = null; for (const characterId of boundCharacters) { const xProfile = await xDb.xCharacterProfiles.get(characterId); if (xProfile && xProfile.xHandle.replace('@', '') === cleanHandle) { matchedCharacterId = characterId; console.log('✅ [统一ID] 找到匹配的已绑定角色:', characterId); break; } } let accountId; if (matchedCharacterId) { accountId = `msg_${matchedCharacterId}`; console.log('📝 [统一ID] 使用角色ID格式:', accountId); } else { accountId = `msg_account_${cleanHandle}`; console.log('📝 [统一ID] 使用账户ID格式:', accountId); } const messageData = { id: accountId, userName: accountInfo.name, userHandle: accountInfo.handle, userAvatar: accountInfo.avatar, user: { name: accountInfo.name, handle: accountInfo.handle, avatar: accountInfo.avatar, verified: accountInfo.verified || false, }, lastMessage: '', timestamp: new Date().toISOString(), unread: false, _fromAccountProfile: true, }; const profileData = { name: accountInfo.name, handle: accountInfo.handle, avatar: accountInfo.avatar, bio: accountInfo.bio || '', followersCount: accountInfo.followersCount || '0', verified: accountInfo.verified || false, }; currentMessageConversation = messageData; userMessageQueue = []; document.getElementById('x-message-detail-page').style.display = 'flex'; loadCharacterMessageDetail(messageData, profileData); console.log('✅ 已打开私信详情页（来自账户主页）'); } catch (error) { console.error('❌ [统一ID] 查找角色失败:', error); const accountId = `msg_account_${cleanHandle}`; const messageData = { id: accountId, userName: accountInfo.name, userHandle: accountInfo.handle, userAvatar: accountInfo.avatar, user: { name: accountInfo.name, handle: accountInfo.handle, avatar: accountInfo.avatar, verified: accountInfo.verified || false, }, lastMessage: '', timestamp: new Date().toISOString(), unread: false, _fromAccountProfile: true, }; const profileData = { name: accountInfo.name, handle: accountInfo.handle, avatar: accountInfo.avatar, bio: accountInfo.bio || '', followersCount: accountInfo.followersCount || '0', verified: accountInfo.verified || false, }; currentMessageConversation = messageData; userMessageQueue = []; document.getElementById('x-message-detail-page').style.display = 'flex'; loadCharacterMessageDetail(messageData, profileData); console.log('✅ 已打开私信详情页（使用默认ID，来自账户主页）'); } }; window.switchAccountTab = function (tabName) { const tabs = document.querySelectorAll('.account-tab'); tabs.forEach(tab => { if (tab.onclick.toString().includes(tabName)) { tab.style.fontWeight = '700'; tab.style.color = '#fff'; tab.style.borderBottom = '4px solid var(--x-accent)'; } else { tab.style.fontWeight = '500'; tab.style.color = '#71767b'; tab.style.borderBottom = '4px solid transparent'; } }); const tweetsContainer = document.getElementById('account-tweets-container'); tweetsContainer.innerHTML = ''; if (tabName === 'posts') { if (currentViewingAccount && currentViewingAccount.tweets) { const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount; currentViewingAccount.tweets.forEach(tweet => { const tweetElement = createAccountTweetElement(tweet, accountInfo); tweetsContainer.appendChild(tweetElement); }); } else { tweetsContainer.innerHTML = ` <div style="padding: 60px 32px; text-align: center;"> <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;">${getI18nText( 'accountNoPosts', )}</div> <div style="color: #71767b; font-size: 15px;">${getI18nText('accountNoPostsDesc')}</div> </div> `; } } else if (tabName === 'replies') { if ( currentViewingAccount && currentViewingAccount.accountReplies && currentViewingAccount.accountReplies.length > 0 ) { const validReplies = currentViewingAccount.accountReplies.filter(reply => { if (!reply) { console.warn('⚠️ [账户标签] 跳过无效回复: null/undefined'); return false; } if (!reply.type) { console.warn('⚠️ [账户标签] 跳过无效回复: 缺少 type 字段', reply); return false; } return true; }); if (validReplies.length > 0) { validReplies.forEach(reply => { const replyElement = createAccountReplyElement(reply); tweetsContainer.appendChild(replyElement); }); } else { tweetsContainer.innerHTML = ` <div style="padding: 60px 32px; text-align: center;"> <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;">${getI18nText( 'accountNoReplies', )}</div> <div style="color: #71767b; font-size: 15px;">${getI18nText('accountNoRepliesDesc')}</div> </div> `; } } else { tweetsContainer.innerHTML = ` <div style="padding: 60px 32px; text-align: center;"> <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;">${getI18nText( 'accountNoReplies', )}</div> <div style="color: #71767b; font-size: 15px;">${getI18nText('accountNoRepliesDesc')}</div> </div> `; } } else if (tabName === 'likes') { console.log('🔍 [喜欢列表] 开始渲染喜欢列表'); console.log('🔍 [喜欢列表] currentViewingAccount:', currentViewingAccount); console.log('🔍 [喜欢列表] accountLikes数量:', currentViewingAccount?.accountLikes?.length || 0); if ( currentViewingAccount && currentViewingAccount.accountLikes && currentViewingAccount.accountLikes.length > 0 ) { console.log('✅ [喜欢列表] 找到喜欢数据，开始渲染'); const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount; currentViewingAccount.accountLikes.forEach((likedTweet, index) => { console.log(`📋 [喜欢列表] 渲染第 ${index + 1} 条喜欢:`, likedTweet.content?.substring(0, 30)); const tweetElement = createLikedTweetElement(likedTweet, accountInfo); tweetsContainer.appendChild(tweetElement); }); console.log(`✅ [喜欢列表] 共渲染了 ${currentViewingAccount.accountLikes.length} 条喜欢`); } else { console.warn('⚠️ [喜欢列表] 无喜欢数据，显示空状态'); tweetsContainer.innerHTML = ` <div style="padding: 60px 32px; text-align: center;"> <div style="color:var(--x-text-secondary); font-size: 31px; font-weight: 800; margin-bottom: 8px;">${getI18nText( 'accountNoLikes', )}</div> <div style="color:var(--x-text-secondary); font-size: 15px;">${getI18nText('accountNoLikesDesc')}</div> </div> `; } } }; async function saveAccountProfile(accountData) { try { const xDB = getXDB(); const cleanHandle = accountData.accountInfo.handle.replace('@', ''); const profileToSave = { handle: cleanHandle, name: accountData.accountInfo.name, accountInfo: accountData.accountInfo, tweets: accountData.tweets || [], accountReplies: accountData.accountReplies || [], accountLikes: accountData.accountLikes || [], updatedAt: new Date().toISOString(), }; await xDB.xAccountProfiles.put(profileToSave); console.log( '✅ 账户主页数据已保存:', cleanHandle, '- 推文数:', profileToSave.tweets.length, '- 回复数:', profileToSave.accountReplies.length, '- 喜欢数:', profileToSave.accountLikes.length, ); } catch (error) { console.error('保存账户主页数据失败:', error); } } async function addTweetToAccountProfile(userHandle, tweetData) { try { const xDB = getXDB(); const cleanHandle = userHandle.replace('@', ''); console.log(`📝 [账户主页同步] 开始将推文添加到 ${cleanHandle} 的账户主页`); let accountProfile = await xDB.xAccountProfiles.get(cleanHandle); if (!accountProfile) { console.log(`📝 [账户主页同步] 账户主页不存在，创建新的主页数据`); accountProfile = { handle: cleanHandle, name: tweetData.user.name, accountInfo: { name: tweetData.user.name, handle: userHandle, avatar: tweetData.user.avatar, verified: tweetData.user.verified || false, verificationType: tweetData.user.verificationType || 'verified', }, tweets: [], accountReplies: [], accountLikes: [], updatedAt: new Date().toISOString(), }; } if (!accountProfile.tweets) { accountProfile.tweets = []; } const isDuplicate = accountProfile.tweets.some( tweet => tweet.id === tweetData.id || tweet.timestamp === tweetData.timestamp, ); if (isDuplicate) { console.log(`⏭️ [账户主页同步] 推文已存在，跳过添加`); return; } const pinnedTweet = accountProfile.tweets.find(t => t.pinned); const unpinnedTweets = accountProfile.tweets.filter(t => !t.pinned); unpinnedTweets.unshift(tweetData); unpinnedTweets.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)); if (pinnedTweet) { accountProfile.tweets = [pinnedTweet, ...unpinnedTweets]; } else { accountProfile.tweets = unpinnedTweets; } accountProfile.updatedAt = new Date().toISOString(); await xDB.xAccountProfiles.put(accountProfile); console.log( `✅ [账户主页同步] 推文已添加到 ${cleanHandle} 的主页，当前推文总数: ${accountProfile.tweets.length}`, ); if ( currentViewingAccount && (currentViewingAccount.accountInfo?.handle === userHandle || currentViewingAccount.handle === userHandle) ) { console.log(`🔄 [账户主页同步] 检测到正在查看该账户主页，刷新显示`); currentViewingAccount.tweets = accountProfile.tweets; renderAccountProfile(currentViewingAccount); } } catch (error) { console.error('❌ [账户主页同步] 添加推文到账户主页失败:', error); } } window.toggleProgressMode = function () { isProgressMode = !isProgressMode; updateRefreshButtonUI(); if (isProgressMode) { showXToast('已切换到推进模式 - 将生成新内容并追加', 'success'); } else { showXToast('已切换到重新生成模式 - 将覆盖现有内容', 'info'); } }; function updateRefreshButtonUI() { const refreshBtn = document.querySelector('#account-profile-page [onclick="refreshAccountProfile()"]'); if (!refreshBtn) return; const textColor = getComputedStyle(document.getElementById('x-social-screen')).getPropertyValue('--x-text-primary').trim() || '#fff'; if (isProgressMode) { refreshBtn.innerHTML = ` <svg xmlns="http: <path d="M3 12h4.5l1.5 -6l4 12l2 -9l1.5 3h4.5" /> </svg> `; refreshBtn.setAttribute('title', '推进账户主页（生成新内容并追加）'); } else { refreshBtn.innerHTML = ` <svg xmlns="http: <path d="M9 4.55a8 8 0 0 1 6 14.9m0 -4.45v5h5" /> <path d="M5.63 7.16l0 .01" /> <path d="M4.06 11l0 .01" /> <path d="M4.63 15.1l0 .01" /> <path d="M7.16 18.37l0 .01" /> <path d="M11 19.94l0 .01" /> </svg> `; refreshBtn.setAttribute('title', '重新生成账户主页'); } } window.handleRefreshButtonMouseDown = function () { progressLongPressTimer = setTimeout(() => { toggleProgressMode(); }, 800); }; window.handleRefreshButtonMouseUp = function () { if (progressLongPressTimer) { clearTimeout(progressLongPressTimer); progressLongPressTimer = null; } }; window.refreshAccountProfile = async function () { if (progressLongPressTimer) { clearTimeout(progressLongPressTimer); progressLongPressTimer = null; } if (!currentViewingAccount) { showXToast('未找到当前账户信息', 'error'); return; } try { if (isProgressMode) { showXToast('正在推进账户主页...', 'info'); await progressAccountProfile(); } else { showXToast('正在重新生成账户主页...', 'info'); const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount; const accountData = await queryAccountData(accountInfo.name, accountInfo.handle, accountInfo.avatar); if (!accountData) { showXToast('无法加载账户信息', 'error'); return; } const profileData = await generateAccountProfileContent(accountData); if (profileData) { currentViewingAccount = { ...accountData, ...profileData }; console.log('📊 [账户主页] 重新生成数据统计:', { 推文数: profileData.tweets?.length || 0, 回复数: profileData.accountReplies?.length || 0, 喜欢数: profileData.accountLikes?.length || 0, }); renderAccountProfile(currentViewingAccount); await saveAccountProfile(currentViewingAccount); showXToast('账户主页已刷新', 'success'); } } } catch (error) { console.error('刷新账户主页失败:', error); showXToast(`刷新失败: ${error.message}`, 'error'); } }; async function progressAccountProfile() { try { const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount; const accountData = await queryAccountData(accountInfo.name, accountInfo.handle, accountInfo.avatar); if (!accountData) { showXToast('无法加载账户信息', 'error'); return; } const newProfileData = await generateAccountProfileContent(accountData, { isProgressMode: true, existingTweets: currentViewingAccount.tweets || [], existingReplies: currentViewingAccount.accountReplies || [], }); if (newProfileData) { if (newProfileData.tweets) { newProfileData.tweets.forEach(tweet => { tweet.pinned = false; }); } const existingTweets = currentViewingAccount.tweets || []; const pinnedTweet = existingTweets.find(t => t.pinned); const unpinnedOldTweets = existingTweets.filter(t => !t.pinned); const newTweets = newProfileData.tweets || []; let updatedTweets; if (pinnedTweet) { updatedTweets = [pinnedTweet, ...newTweets, ...unpinnedOldTweets]; } else { updatedTweets = [...newTweets, ...unpinnedOldTweets]; } const updatedReplies = [ ...(newProfileData.accountReplies || []), ...(currentViewingAccount.accountReplies || []), ]; const updatedLikes = [...(newProfileData.accountLikes || []), ...(currentViewingAccount.accountLikes || [])]; console.log('📊 [推进模式] 数据合并统计:', { 新推文: newProfileData.tweets?.length || 0, 旧推文: (currentViewingAccount.tweets || []).filter(t => !t.pinned).length, 合并后推文: updatedTweets.length, 新回复: newProfileData.accountReplies?.length || 0, 旧回复: (currentViewingAccount.accountReplies || []).length, 合并后回复: updatedReplies.length, 新喜欢: newProfileData.accountLikes?.length || 0, 旧喜欢: (currentViewingAccount.accountLikes || []).length, 合并后喜欢: updatedLikes.length, }); currentViewingAccount = { ...currentViewingAccount, tweets: updatedTweets, accountReplies: updatedReplies, accountLikes: updatedLikes, accountInfo: currentViewingAccount.accountInfo || accountInfo, }; renderAccountProfile(currentViewingAccount); await saveAccountProfile(currentViewingAccount); showXToast( `已推进：新增 ${newProfileData.tweets?.length || 0} 条推文，${ newProfileData.accountReplies?.length || 0 } 条回复，${newProfileData.accountLikes?.length || 0} 条喜欢`, 'success', ); } } catch (error) { console.error('推进账户主页失败:', error); showXToast(`推进失败: ${error.message}`, 'error'); } } const languageConfig = { zh: { navHome: '主页', navSearch: '搜索', navNotifications: '通知', navMessages: '消息', homeTitle: '主页', homeForYou: '为你推荐', homeFollowing: '正在关注', homeCompose: '有什么新鲜事?', homeNoTweets: '暂无推文', homeNoTweetsDesc: '开始关注一些人，或刷新查看推荐内容', searchTitle: '搜索', searchPlaceholder: '搜索', searchTrending: '热门话题', searchNoResults: '无搜索结果', searchRefresh: '刷新热搜', notificationsTitle: '通知', notificationsTabAll: '全部', notificationsTabMentions: '提及', notificationsEmpty: '暂无通知', notificationsEmptyDesc: '当有人点赞、评论或关注你时，你会在这里看到通知', notificationsRecommended: '推荐关注', notificationsLiked: '喜欢了你的帖子', notificationsFollowed: '关注了你', notificationsReplied: '回复了你', notificationsMentioned: '提及了你', notificationsRetweeted: '转推了你的帖子', messagesTitle: '私信', messagesEmpty: '暂无私信', messagesEmptyDesc: '发送私信与朋友保持联系', messageFollowers: '位关注者', messageInputPlaceholder: '开始写私信', profileTitle: '个人资料', profileEditProfile: '编辑个人资料', profileFollowing: '正在关注', profileFollowers: '关注者', profilePosts: '帖子', profilePostsCount: '帖子', profileLikes: '喜欢', profileHighlights: '亮点', profileArticles: '文章', profileMedia: '媒体', profileNoLikes: '还没有喜欢的推文', profileNoLikesDesc: '当你喜欢一条推文时，它会显示在这里。', profileNoHighlights: '还没有收藏', profileNoHighlightsDesc: '点击推文下方的书签按钮来收藏喜欢的内容', profileNoArticles: '还没有文章', profileNoArticlesDesc: '发布的文章会显示在这里。', profileNoMedia: '还没有媒体', profileNoMediaDesc: '包含照片和视频的推文会显示在这里。', profileAccountManager: '账号管理', tweetDetailTitle: '帖子', tweetDetailReply: '回复', tweetDetailReplyPlaceholder: '发布你的回复', tweetDetailRerollTooltip: '重新生成回复', tweetDetailRetweets: '转推', tweetDetailLikes: '喜欢', tweetDetailBookmarks: '书签', tweetDetailViews: '查看', commentsTitle: '发帖', commentsReply: '回复', commentsReplyPlaceholder: '发布你的回复', accountPostsCount: '个帖子', accountFollow: '关注', accountFollowing: '正在关注', accountFollowingLabel: '正在关注', accountFollowersLabel: '关注者', accountFollowsYou: '关注你', accountPostsTab: '帖子', accountRepliesTab: '回复', accountLikesTab: '喜欢', accountPinned: '已置顶', accountNoPosts: '还没有帖子', accountNoPostsDesc: '该账户的帖子会显示在这里。', accountNoReplies: '还没有回复', accountNoRepliesDesc: '该账户的回复会显示在这里。', accountNoLikes: '还没有喜欢', accountNoLikesDesc: '该账户喜欢的内容会显示在这里。', accountReplyTo: '回复', accountLiked: '已喜欢', settingsTitle: '设置', settingsPrompt: '提示词', settingsPromptPlaceholder: '输入系统提示词...', settingsWorldView: '世界观设定', settingsWorldViewPlaceholder: '描述角色所在的世界观、背景设定...', settingsCharacterBinding: '绑定角色', settingsCharacterBindingDesc: '开启后，绑定的角色可以在X上发布推文', settingsSelectCharacter: '选择要绑定的角色', settingsRelationship: '角色关系册', settingsRelationshipDesc: '开启后，可以为已绑定的角色建立关系网络，设置角色之间的双向关系', settingsRelationshipGraph: '角色关系图', settingsEditGraph: '编辑关系图', settingsNPCBinding: '绑定NPC', settingsNPCBindingDesc: '开启后，可以创建和管理自定义NPC，设置其人设、发帖习惯和绑定用户', settingsNPCList: 'NPC列表', settingsCreateNPC: '+ 创建NPC', settingsSave: '保存设置', settingsSavePreset: '保存为预设', settingsImport: '导入数据', settingsExport: '导出数据', settingsPresetManagement: '预设管理', settingsWorldBooks: '世界书管理', settingsWorldBooksDesc: '世界书可以为AI提供额外的知识库，支持绑定到不同场景和角色', settingsWorldBooksButton: '打开世界书管理面板', settingsAutoTweetDetection: '智能发推检测', settingsAutoTweetDetectionDesc: '开启后，每隔5分钟自动检测已绑定角色的聊天记忆，生成New Tweet通知', settingsAutoTweetDetectionNote: '仅对设置了"角色身份识别"和"专属用户人设"的角色生效', settingsDetectionRunning: '检测服务运行中', settingsNextDetectionTime: '下次检测时间', settingsAutoRefreshFeed: '智能刷新主页', settingsAutoRefreshFeedDesc: '开启后，每隔10分钟自动刷新主页推文', settingsRefreshRunning: '刷新服务运行中', settingsNextRefreshTime: '下次刷新时间', relationshipNoData: '暂无关系数据', relationshipNoDataHint: '点击上方按钮开始创建角色关系', relationshipCharacterCount: '角色数', relationshipLinkCount: '关系数', relationshipAddCharacter: '+ 添加角色', relationshipSave: '保存关系图', relationshipClose: '关闭', relationshipEmptyState: '暂无角色', relationshipEmptyStateHint: '点击上方按钮添加角色', liveTitle: '直播', liveAudioTab: '语音直播', liveVideoTab: '视频直播', liveOnlineCount: '人在线', liveJoinStream: '加入直播', liveNoAudioStreams: '暂无语音直播', liveNoVideoStreams: '暂无视频直播', liveWaitingContent: '等待精彩内容上线', toastThemeLight: '已切换到日间模式', toastThemeDark: '已切换到夜间模式', toastLanguageChinese: '已切换到中文', toastLanguageEnglish: '已切换到英文', btnSave: '保存', btnCancel: '取消', btnEdit: '编辑', btnDelete: '删除', btnConfirm: '确认', }, en: { navHome: 'Home', navSearch: 'Explore', navNotifications: 'Notifications', navMessages: 'Messages', homeTitle: 'Home', homeForYou: 'For you', homeFollowing: 'Following', homeCompose: "What's happening?", homeNoTweets: 'No posts yet', homeNoTweetsDesc: 'Follow people or refresh to see recommended content', searchTitle: 'Explore', searchPlaceholder: 'Search', searchTrending: "What's happening", searchNoResults: 'No results found', searchRefresh: 'Refresh trends', notificationsTitle: 'Notifications', notificationsTabAll: 'All', notificationsTabMentions: 'Mentions', notificationsEmpty: 'No notifications yet', notificationsEmptyDesc: "When someone likes, comments, or follows you, you'll see it here", notificationsRecommended: 'Recommended', notificationsLiked: 'liked your post', notificationsFollowed: 'followed you', notificationsReplied: 'replied to you', notificationsMentioned: 'mentioned you', notificationsRetweeted: 'retweeted your post', messagesTitle: 'Messages', messagesEmpty: 'No messages yet', messagesEmptyDesc: 'Send a message to stay in touch with friends', messageFollowers: 'followers', messageInputPlaceholder: 'Start a message', profileTitle: 'Profile', profileEditProfile: 'Edit profile', profileFollowing: 'Following', profileFollowers: 'Followers', profilePosts: 'Posts', profilePostsCount: 'posts', profileLikes: 'Likes', profileHighlights: 'Highlights', profileArticles: 'Articles', profileMedia: 'Media', profileNoLikes: 'No liked posts yet', profileNoLikesDesc: 'When you like a post, it will show up here.', profileNoHighlights: 'No bookmarks yet', profileNoHighlightsDesc: 'Tap the bookmark button below posts to save your favorites', profileNoArticles: 'No articles yet', profileNoArticlesDesc: 'Published articles will show up here.', profileNoMedia: 'No media yet', profileNoMediaDesc: 'Posts with photos and videos will show up here.', profileAccountManager: 'Account Manager', tweetDetailTitle: 'Post', tweetDetailReply: 'Reply', tweetDetailReplyPlaceholder: 'Post your reply', tweetDetailRerollTooltip: 'Regenerate replies', tweetDetailRetweets: 'Reposts', tweetDetailLikes: 'Likes', tweetDetailBookmarks: 'Bookmarks', tweetDetailViews: 'Views', commentsTitle: 'Post', commentsReply: 'Reply', commentsReplyPlaceholder: 'Post your reply', accountPostsCount: 'posts', accountFollow: 'Follow', accountFollowing: 'Following', accountFollowingLabel: 'Following', accountFollowersLabel: 'Followers', accountFollowsYou: 'Follows you', accountPostsTab: 'Posts', accountRepliesTab: 'Replies', accountLikesTab: 'Likes', accountPinned: 'Pinned', accountNoPosts: 'No posts yet', accountNoPostsDesc: 'Posts from this account will show up here.', accountNoReplies: 'No replies yet', accountNoRepliesDesc: 'Replies from this account will show up here.', accountNoLikes: 'No likes yet', accountNoLikesDesc: 'Liked posts will show up here.', accountReplyTo: 'Replying to', accountLiked: 'liked', settingsTitle: 'Settings', settingsPrompt: 'System Prompt', settingsPromptPlaceholder: 'Enter system prompt...', settingsWorldView: 'World Setting', settingsWorldViewPlaceholder: 'Describe the world setting and background...', settingsCharacterBinding: 'Character Binding', settingsCharacterBindingDesc: 'When enabled, bound characters can post on X', settingsSelectCharacter: 'Select Character to Bind', settingsRelationship: 'Character Relations', settingsRelationshipDesc: 'When enabled, create relationship networks for bound characters', settingsRelationshipGraph: 'Relationship Graph', settingsEditGraph: 'Edit Graph', settingsNPCBinding: 'NPC Binding', settingsNPCBindingDesc: 'When enabled, create and manage custom NPCs', settingsNPCList: 'NPC List', settingsCreateNPC: '+ Create NPC', settingsSave: 'Save Settings', settingsSavePreset: 'Save as Preset', settingsImport: 'Import Data', settingsExport: 'Export Data', settingsPresetManagement: 'Preset Management', settingsWorldBooks: 'World Books', settingsWorldBooksDesc: 'World books provide additional knowledge base for AI, can be bound to different scenes and characters', settingsWorldBooksButton: 'Open World Books Panel', settingsAutoTweetDetection: 'Auto Tweet Detection', settingsAutoTweetDetectionDesc: 'When enabled, automatically detect chat history of bound characters every 5 minutes and generate New Tweet notifications', settingsAutoTweetDetectionNote: 'Only effective for characters with "Identity Recognition" and "Exclusive User Persona" settings', settingsDetectionRunning: 'Detection service running', settingsNextDetectionTime: 'Next detection time', settingsAutoRefreshFeed: 'Auto Refresh Feed', settingsAutoRefreshFeedDesc: 'When enabled, automatically refresh feed every 10 minutes', settingsRefreshRunning: 'Refresh service running', settingsNextRefreshTime: 'Next refresh time', relationshipNoData: 'No relationship data', relationshipNoDataHint: 'Click button above to create character relationships', relationshipCharacterCount: 'Characters', relationshipLinkCount: 'Relations', relationshipAddCharacter: '+ Add Character', relationshipSave: 'Save Graph', relationshipClose: 'Close', relationshipEmptyState: 'No characters', relationshipEmptyStateHint: 'Click button above to add characters', liveTitle: 'Live', liveAudioTab: 'Audio Live', liveVideoTab: 'Video Live', liveOnlineCount: 'viewers', liveJoinStream: 'Join Live', liveNoAudioStreams: 'No audio streams', liveNoVideoStreams: 'No video streams', liveWaitingContent: 'Waiting for exciting content', toastThemeLight: 'Switched to Light Mode', toastThemeDark: 'Switched to Dark Mode', toastLanguageChinese: 'Switched to Chinese', toastLanguageEnglish: 'Switched to English', btnSave: 'Save', btnCancel: 'Cancel', btnEdit: 'Edit', btnDelete: 'Delete', btnConfirm: 'Confirm', }, }; let currentLanguage = 'zh'; async function toggleXLanguage() { try { currentLanguage = currentLanguage === 'zh' ? 'en' : 'zh'; applyLanguage(currentLanguage); const xDb = getXDB(); const settingsId = `xLanguage_${currentAccountId || 'main'}`; await xDb.xSettings.put({ id: settingsId, language: currentLanguage, updatedAt: new Date().toISOString(), }); console.log(`🌐 语言已切换为: ${currentLanguage === 'zh' ? '中文' : 'English'}`); showXToast( currentLanguage === 'zh' ? languageConfig.zh.toastLanguageChinese : languageConfig.en.toastLanguageEnglish, 'success', ); } catch (error) { console.error('语言切换失败:', error); showXToast('Language switch failed', 'error'); } } function getI18nText(key) { const config = languageConfig[currentLanguage] || languageConfig['zh']; return config[key] || key; } function applyLanguage(lang) { const config = languageConfig[lang]; if (!config) return; console.log(`🌐 正在应用语言: ${lang}`); const languageText = document.getElementById('language-text'); if (languageText) { languageText.textContent = lang === 'zh' ? '中文' : 'EN'; } document.querySelectorAll('[data-i18n]').forEach(el => { const key = el.getAttribute('data-i18n'); if (config[key]) { if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') { el.placeholder = config[key]; } else { el.textContent = config[key]; } } }); const profileHeaderCount = document.getElementById('x-profile-header-count'); if (profileHeaderCount && profileHeaderCount.textContent) { const count = profileHeaderCount.textContent.match(/\d+/); if (count) { profileHeaderCount.textContent = `${count[0]} ${config.profilePostsCount}`; } } updateTweetDetailLanguage(config); updateAccountProfileLanguage(config); console.log(`✅ 语言已应用: ${lang === 'zh' ? '中文' : 'English'}`); } function updateAccountProfileLanguage(config) { const accountNavCount = document.getElementById('account-profile-nav-count'); if (accountNavCount && accountNavCount.textContent) { const count = accountNavCount.textContent.match(/\d+/); if (count) { accountNavCount.textContent = `${count[0]} ${config.accountPostsCount}`; } } const followBtn = document.getElementById('account-follow-btn'); if (followBtn) { if (followBtn.textContent.includes('Following') || followBtn.textContent.includes('正在关注')) { followBtn.textContent = config.accountFollowing; } else if (followBtn.textContent.includes('Follow') || followBtn.textContent.includes('关注')) { followBtn.textContent = config.accountFollow; } } } function updateTweetDetailLanguage(config) { const statsDiv = document.getElementById('tweet-detail-stats'); if (statsDiv) { const spans = statsDiv.querySelectorAll('span[style*="color: #71767b"]'); if (spans.length >= 3) { spans[0].textContent = config.tweetDetailRetweets; spans[1].textContent = config.tweetDetailLikes; spans[2].textContent = config.tweetDetailBookmarks; } } const viewsLabel = document.getElementById('tweet-detail-views-label'); if (viewsLabel) { viewsLabel.textContent = config.tweetDetailViews; } } async function loadLanguagePreference() { try { const xDb = getXDB(); const settingsId = `xLanguage_${currentAccountId || 'main'}`; const savedSettings = await xDb.xSettings.get(settingsId); if (savedSettings && savedSettings.language) { currentLanguage = savedSettings.language; applyLanguage(currentLanguage); } } catch (error) { console.error('加载语言偏好失败:', error); } } async function toggleXTheme() { try { const xSocialScreen = document.getElementById('x-social-screen'); if (!xSocialScreen) return; const isLightMode = xSocialScreen.classList.contains('x-theme-light'); const newTheme = isLightMode ? 'dark' : 'light'; if (newTheme === 'light') { xSocialScreen.classList.add('x-theme-light'); } else { xSocialScreen.classList.remove('x-theme-light'); } const darkIcon = document.getElementById('theme-icon-dark'); const lightIcon = document.getElementById('theme-icon-light'); if (newTheme === 'light') { darkIcon.style.display = 'none'; lightIcon.style.display = 'block'; } else { darkIcon.style.display = 'block'; lightIcon.style.display = 'none'; } const xDb = getXDB(); const settingsId = `xTheme_${currentAccountId || 'main'}`; await xDb.xSettings.put({ id: settingsId, theme: newTheme, updatedAt: new Date().toISOString(), }); applyThemeToElements(newTheme); const relationshipModal = document.getElementById('character-relationship-graph-modal'); if (relationshipModal && relationshipModal.style.display !== 'none') { renderRelationshipGraph(); } const relationshipArea = document.getElementById('relationship-binding-area'); if (relationshipArea && relationshipArea.style.display !== 'none') { setTimeout(() => { updateRelationshipPreview(); }, 100); } console.log(`🎨 主题已切换为: ${newTheme === 'light' ? '日间模式' : '夜间模式'}`); const config = languageConfig[currentLanguage] || languageConfig.zh; showXToast(newTheme === 'light' ? config.toastThemeLight : config.toastThemeDark, 'success'); } catch (error) { console.error('主题切换失败:', error); showXToast('主题切换失败', 'error'); } } function applyThemeToElements(theme) { const xSocialScreen = document.getElementById('x-social-screen'); if (!xSocialScreen) return; const isLight = theme === 'light'; const elementsToUpdate = { '.x-top-bar, .x-bottom-nav, .settings-header, .tweet-detail-header, .compose-header, .modal-header, .account-header': { backgroundColor: isLight ? '#fff' : '#000', borderBottomColor: isLight ? '#eff3f4' : '#2f3336', }, '.tweet-user-name, .tweet-content, .comment-content': { color: isLight ? '#0f1419' : '#fff', }, '.tweet-user-handle, .tweet-time, .comment-time': { color: isLight ? '#536471' : '#71767b', }, '.tweet-item, .comment-item, .settings-section': { borderBottomColor: isLight ? '#eff3f4' : '#2f3336', }, 'textarea, input[type="text"]': { backgroundColor: isLight ? '#f7f9f9' : '#1a1a1a', borderColor: isLight ? '#eff3f4' : '#333', color: isLight ? '#0f1419' : '#fff', }, }; } async function loadXThemePreference() { try { const xDb = getXDB(); const settingsId = `xTheme_${currentAccountId || 'main'}`; const themeSettings = await xDb.xSettings.get(settingsId); if (themeSettings && themeSettings.theme) { const xSocialScreen = document.getElementById('x-social-screen'); if (!xSocialScreen) return; if (themeSettings.theme === 'light') { xSocialScreen.classList.add('x-theme-light'); const darkIcon = document.getElementById('theme-icon-dark'); const lightIcon = document.getElementById('theme-icon-light'); if (darkIcon && lightIcon) { darkIcon.style.display = 'none'; lightIcon.style.display = 'block'; } applyThemeToElements('light'); } console.log(`🎨 已加载主题偏好: ${themeSettings.theme === 'light' ? '日间模式' : '夜间模式'}`); } } catch (error) { console.error('加载主题偏好失败:', error); } } let currentLiveTab = 'audio'; let liveCustomCategories = []; const liveBackgroundImages = [ 'https: 'https: 'https: 'https: 'https: 'https: 'https: 'https: 'https: ]; function getRandomBackground() { const randomIndex = Math.floor(Math.random() * liveBackgroundImages.length); return liveBackgroundImages[randomIndex]; } const liveStreamData = { audio: [ { id: 'audio_1', title: '深夜聊天室 | 来聊聊最近的心情故事吧', streamerHandle: '@nighttalker', streamerName: '夜谈者', streamerAvatar: 'https: description: '和大家聊聊生活中的点点滴滴，分享今天的心情和想法', onlineCount: 156, category: '生活分享', isLive: true, duration: '1h 23m', background: getRandomBackground(), }, ], video: [ { id: 'video_1', title: 'AI技术探讨 - 大语言模型的发展与未来', streamerHandle: '@techexplorer', streamerName: '科技探索者', streamerAvatar: 'https: description: '探讨最新的人工智能技术趋势，欢迎大家一起交流学习', onlineCount: 892, category: '科技教育', isLive: true, duration: '2h 15m', background: getRandomBackground(), }, ], }; function switchLiveTab(tabName) { currentLiveTab = tabName; const tabs = document.querySelectorAll('.live-tab'); tabs.forEach(tab => { tab.classList.remove('live-tab-active'); tab.style.color = '#71767b'; tab.style.backgroundColor = 'rgba(255,255,255,0.1)'; }); let activeTab = null; if (tabName === 'audio') { activeTab = tabs[0]; } else if (tabName === 'video') { activeTab = tabs[1]; } else { activeTab = Array.from(tabs).find(tab => tab.onclick && tab.onclick.toString().includes(tabName)); } if (activeTab) { activeTab.classList.add('live-tab-active'); activeTab.style.color = '#fff'; activeTab.style.backgroundColor = 'var(--x-accent)'; } const allContents = document.querySelectorAll('.live-tab-content'); allContents.forEach(content => { content.style.opacity = '0'; content.style.transition = 'opacity 0.2s ease-out'; }); setTimeout(() => { allContents.forEach(content => { content.style.display = 'none'; }); if (tabName === 'audio' || tabName === 'video') { const targetContent = document.getElementById(`live-${tabName}-content`); if (targetContent) { targetContent.style.display = 'block'; setTimeout(() => { targetContent.style.opacity = '1'; }, 10); } renderLiveStreams(tabName); } else { const audioContent = document.getElementById('live-audio-content'); if (audioContent) { audioContent.style.display = 'block'; setTimeout(() => { audioContent.style.opacity = '1'; }, 10); const container = document.getElementById('live-audio-list'); if (container) { const customStreams = liveStreamData[tabName] || []; const category = liveCustomCategories.find(cat => cat.id === tabName); const categoryName = category ? category.name : '自定义分类'; if (customStreams.length === 0) { container.innerHTML = ` <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px 20px; color: #aaa; text-align: center;"> <svg viewBox="0 0 24 24" style="width: 48px; height: 48px; fill: currentColor; opacity: 0.5; margin-bottom: 16px;"> <path d="M10.5 20h-5.5a2 2 0 0 1 -2 -2v-9a2 2 0 0 1 2 -2h1a2 2 0 0 0 2 -2a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1a2 2 0 0 0 2 2h1a2 2 0 0 1 2 2v2.5" /> <path d="M14.569 11.45a3 3 0 1 0 -4.518 3.83" /> </svg> <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">${categoryName}直播</div> <div style="font-size: 14px; opacity: 0.8;">该分类下暂无直播内容</div> </div> `; } else { customStreams.forEach(stream => { if (!stream.background) { stream.background = getRandomBackground(); } }); container.innerHTML = customStreams .map((stream, index) => createLiveStreamCard(stream, tabName, index)) .join(''); } } } } }, 200); } function renderLiveStreams(type) { const container = document.getElementById(`live-${type}-list`); if (!container) return; const streams = liveStreamData[type] || []; if (streams.length === 0) { const config = languageConfig[currentLanguage] || languageConfig['zh']; const noStreamsText = type === 'audio' ? config.liveNoAudioStreams : config.liveNoVideoStreams; container.innerHTML = ` <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px 20px; color: #aaa; text-align: center;"> <svg viewBox="0 0 24 24" style="width: 48px; height: 48px; fill: currentColor; opacity: 0.5; margin-bottom: 16px;"> <path d="M10.5 20h-5.5a2 2 0 0 1 -2 -2v-9a2 2 0 0 1 2 -2h1a2 2 0 0 0 2 -2a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1a2 2 0 0 0 2 2h1a2 2 0 0 1 2 2v2.5" /> <path d="M14.569 11.45a3 3 0 1 0 -4.518 3.83" /> </svg> <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">${noStreamsText}</div> <div style="font-size: 14px; opacity: 0.8;">${config.liveWaitingContent}</div> </div> `; return; } streams.forEach(stream => { if (!stream.background) { stream.background = getRandomBackground(); } }); container.innerHTML = streams.map((stream, index) => createLiveStreamCard(stream, type, index)).join(''); } function createLiveStreamCard(stream, type, index = 0) { const config = languageConfig[currentLanguage] || languageConfig['zh']; const animationDelay = index * 0.05; return ` <div class="live-stream-card" onclick="joinLiveStream('${stream.id}')" style="cursor: pointer; transition: all 0.2s ease; position: relative; margin-bottom: 16px; animation: liveCardFadeIn 0.4s ease-out ${animationDelay}s both; opacity: 0;" onmouseover="this.querySelector('.card-overlay').style.opacity='1'" onmouseout="this.querySelector('.card-overlay').style.opacity='0'"> <!-- 缩略图容器 --> <div style="position: relative; width: 100%; aspect-ratio: 16/9; border-radius: 12px; overflow: hidden; margin-bottom: 12px; background-color: #1a1a1a;"> <!-- 背景图片 --> <img src="${stream.background}" alt="${stream.title}" style="width: 100%; height: 100%; object-fit: cover;"> <!-- 在线人数指示器 --> <div style="position: absolute; top: 8px; left: 8px; display: flex; align-items: center; gap: 4px; background-color: rgba(0,0,0,0.7); padding: 3px 8px; border-radius: 4px;"> <div style="width: 8px; height: 8px; background-color: var(--x-accent); border-radius: 50%; animation: pulse 2s infinite;"></div> <span style="color: #fff; font-size: 12px; font-weight: 500;">${stream.onlineCount.toLocaleString()}</span> </div> <!-- 持续时间 --> <div style="position: absolute; bottom: 8px; right: 8px; background-color: rgba(0,0,0,0.7); padding: 3px 8px; border-radius: 4px;"> <span style="color: #fff; font-size: 12px; font-weight: 500;">${stream.duration}</span> </div> <!-- 悬停覆盖层 --> <div class="card-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; opacity: 0; transition: opacity 0.2s ease;"> <div style="width: 48px; height: 48px; border-radius: 50%; background-color: var(--x-accent); display: flex; justify-content: center; align-items: center;"> <svg viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: #fff;"> <path d="M8 5v14l11-7z"></path> </svg> </div> </div> </div> <!-- 内容区域 --> <div style="display: flex; gap: 12px;"> <!-- 主播头像 --> <div style="width: 36px; height: 36px; border-radius: 50%; overflow: hidden; flex-shrink: 0;"> <img src="${stream.streamerAvatar}" alt="${ stream.streamerName }" style="width: 100%; height: 100%; object-fit: cover;"> </div> <!-- 文本内容 --> <div style="flex: 1; min-width: 0;"> <!-- 直播标题 --> <h3 style="color: #fff; font-size: 14px; font-weight: 500; margin: 0 0 6px 0; line-height: 1.3; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;">${ stream.title }</h3> <!-- 主播名和分类 --> <div style="display: flex; flex-direction: column;"> <span style="color: #aaa; font-size: 12px; margin-bottom: 2px;">${stream.streamerName} ${ stream.streamerHandle }</span> <div style="display: flex; align-items: center; gap: 8px;"> <span style="color: #aaa; font-size: 12px;">${stream.category}</span> </div> </div> </div> <!-- 更多选项 --> <div style="width: 24px; display: flex; justify-content: center; cursor: pointer;" onclick="event.stopPropagation()"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #fff;"> <path d="M12 16.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5.67-1.5 1.5-1.5zM10.5 12c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5-1.5.67-1.5 1.5zm0-6c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5-1.5.67-1.5 1.5z"></path> </svg> </div> </div> </div> <style> @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } } @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } } @keyframes liveCardFadeIn { 0% { opacity: 0; transform: translateY(20px); } 100% { opacity: 1; transform: translateY(0); } } </style> `; } function joinLiveStream(streamId) { console.log('正在加入直播间:', streamId); showXToast('直播功能开发中...', 'info'); } async function initLivePage() { try { currentLiveTab = 'audio'; await loadSavedLiveData(); const liveCharacters = await loadLiveCharacterStatus(); renderLiveStreams('audio'); renderLiveStreams('video'); syncLivePageAvatar(); await loadLiveCustomCategories(); await syncLiveCharacterAvatars(liveCharacters); window.liveBtnExpanded = false; resetLiveActionButtons(); console.log('✅ [直播页面] 初始化完成'); } catch (error) { console.error('❌ [直播页面] 初始化失败:', error); } } function resetLiveActionButtons() { setTimeout(() => { const refreshBtn = document.getElementById('live-refresh-btn'); const startBtn = document.getElementById('live-start-btn'); const mainBtn = document.getElementById('live-main-btn'); const mainIcon = document.getElementById('live-main-icon'); if (refreshBtn && startBtn && mainBtn && mainIcon) { refreshBtn.style.transform = 'scale(0)'; refreshBtn.style.opacity = '0'; startBtn.style.transform = 'scale(0)'; startBtn.style.opacity = '0'; mainBtn.style.transform = 'scale(1)'; mainIcon.style.transform = 'rotate(0deg)'; } }, 100); } function syncLivePageAvatar() { const liveAvatar = document.getElementById('live-page-user-avatar'); if (liveAvatar && window.userProfileData && window.userProfileData.avatar) { liveAvatar.src = window.userProfileData.avatar; } } async function syncLiveCharacterAvatars(liveCharacters = []) { try { console.log('🎭 [角色头像] 开始同步角色头像和直播状态...'); const xDb = getXDB(); const allXProfiles = await xDb.xCharacterProfiles.toArray(); let boundCharacters = []; try { const { xSettings } = await APIUtils.loadConfigAndSettings(); boundCharacters = xSettings.boundCharacters || []; } catch (error) { console.warn('⚠️ [角色头像] 获取绑定角色失败:', error); boundCharacters = []; } const characterAvatars = []; for (const charId of boundCharacters) { const xProfile = allXProfiles.find(p => p.characterId === charId); if (xProfile) { const isLive = liveCharacters.some(lc => lc.characterId === charId); characterAvatars.push({ characterId: charId, name: xProfile.xName, handle: xProfile.xHandle, avatar: xProfile.xAvatar, isLive: isLive, xProfile: xProfile, }); } } characterAvatars.sort((a, b) => { if (a.isLive && !b.isLive) return -1; if (!a.isLive && b.isLive) return 1; return 0; }); let avatarContainer = document.querySelector('#x-live-page > div:nth-child(2)'); if (!avatarContainer) { console.warn('⚠️ [角色头像] 未找到头像容器，尝试备用选择器...'); avatarContainer = document.querySelector( '#x-live-page div[style*="overflow-x: auto"][style*="padding: 8px 16px"]', ); if (avatarContainer) { console.log('✅ [角色头像] 使用备用选择器找到容器'); } else { console.error('❌ [角色头像] 完全未找到头像容器'); return; } } if (characterAvatars.length === 0) { avatarContainer.innerHTML = ` <div style="display: flex; flex-direction: column; align-items: center; gap: 6px; min-width: 64px;"> <div style="width: 56px; height: 56px; border-radius: 50%; overflow: hidden; position: relative; display: flex; align-items: center; justify-content: center; background-color: rgba(255,255,255,0.1);"> <svg viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: #71767b;"> <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/> </svg> </div> <span style="color: #71767b; font-size: 12px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; max-width: 60px;">暂无角色</span> </div> `; } else { const avatarHTML = characterAvatars .map((char, index) => { const glowEffect = char.isLive ? `box-shadow: 0 0 0 3px var(--x-accent), 0 0 15px var(--x-accent); animation: liveGlow 2s ease-in-out infinite;` : ''; return ` <div style="display: flex; flex-direction: column; align-items: center; gap: 6px; min-width: 64px; margin-right: ${ index < characterAvatars.length - 1 ? '12px' : '0' };"> <div style="width: 56px; height: 56px; border-radius: 50%; overflow: hidden; position: relative; ${glowEffect}" title="${char.name} ${char.isLive ? '(正在直播)' : ''}" onclick="handleLiveCharacterClick('${char.characterId}', ${char.isLive})"> <img src="${char.avatar}" style="width: 100%; height: 100%; object-fit: cover; cursor: pointer;" alt="${char.name}"> ${ char.isLive ? ` <div style="position: absolute; top: -2px; right: -2px; width: 20px; height: 20px; background-color: var(--x-accent); border-radius: 50%; display: flex; justify-content: center; align-items: center; border: 3px solid #0f0f0f;"> <div style="width: 8px; height: 8px; background-color: #fff; border-radius: 50%; animation: pulse 2s infinite;"></div> </div> ` : '' } </div> <span style="color: ${ char.isLive ? 'var(--x-accent)' : '#fff' }; font-size: 12px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; max-width: 60px; font-weight: ${ char.isLive ? '600' : '400' };"> ${char.name} </span> </div> `; }) .join(''); avatarContainer.innerHTML = avatarHTML; if (liveCharacters.length > 0) { const style = document.getElementById('live-glow-style'); if (!style) { const newStyle = document.createElement('style'); newStyle.id = 'live-glow-style'; newStyle.textContent = ` @keyframes liveGlow { 0% { box-shadow: 0 0 0 3px var(--x-accent), 0 0 15px var(--x-accent); } 50% { box-shadow: 0 0 0 3px var(--x-accent), 0 0 25px var(--x-accent); } 100% { box-shadow: 0 0 0 3px var(--x-accent), 0 0 15px var(--x-accent); } } `; document.head.appendChild(newStyle); } } } const liveCount = characterAvatars.filter(c => c.isLive).length; console.log(`✅ [角色头像] 同步完成，共${characterAvatars.length}个角色，${liveCount}个正在直播`); } catch (error) { console.error('❌ [角色头像] 同步失败:', error); } } function toggleLiveActionButtons() { const refreshBtn = document.getElementById('live-refresh-btn'); const startBtn = document.getElementById('live-start-btn'); const mainBtn = document.getElementById('live-main-btn'); const mainIcon = document.getElementById('live-main-icon'); if (!refreshBtn || !startBtn || !mainBtn || !mainIcon) return; window.liveBtnExpanded = !window.liveBtnExpanded; if (window.liveBtnExpanded) { mainBtn.style.transform = 'rotate(45deg)'; mainIcon.style.transform = 'rotate(-45deg)'; setTimeout(() => { refreshBtn.style.transform = 'scale(1) translateX(0)'; refreshBtn.style.opacity = '1'; }, 50); setTimeout(() => { startBtn.style.transform = 'scale(1) translateX(0)'; startBtn.style.opacity = '1'; }, 100); } else { mainBtn.style.transform = 'scale(1)'; mainIcon.style.transform = 'rotate(0deg)'; refreshBtn.style.transform = 'scale(0) translateX(15px)'; refreshBtn.style.opacity = '0'; startBtn.style.transform = 'scale(0) translateX(-15px)'; startBtn.style.opacity = '0'; } } async function refreshLiveStreams() { console.log('🔴 [直播刷新] 开始刷新直播列表...'); const refreshBtn = document.getElementById('live-refresh-btn'); if (refreshBtn) { const svg = refreshBtn.querySelector('svg'); if (svg) { svg.style.animation = 'spin 1s linear'; } } try { const { db, xDb, apiConfig, xSettings } = await APIUtils.loadConfigAndSettings(); const { userPrompt, worldSetting, boundCharacters } = xSettings; const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); let tokenCount = 0; let systemPrompt = StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting, }); tokenCount = TokenUtils.logTokenUsage('直播刷新生成器', '基础系统提示词', systemPrompt, tokenCount); const worldBooksContent = await StringBuilders.getApplicableWorldBooks('live', { boundCharacters, }); if (worldBooksContent) { systemPrompt += worldBooksContent; tokenCount = TokenUtils.logTokenUsage('直播刷新生成器', '世界书内容', worldBooksContent, tokenCount); } systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务说明 🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的直播内容生成器。请生成当前的直播数据。 【生成要求】： - 为"语音直播"和"视频直播"各生成3个直播间 - 如果有自定义直播分类，也为每个分类生成3个直播间 - 直播内容要多样化，符合分类特点 - 直播者可以是绑定角色、绑定NPC或虚构的普通用户 - 绑定角色是否正在直播由AI根据角色人设和兴趣决定 【直播数据格式】： - 直播标题：简洁有趣，符合直播内容 - 直播者信息：姓名、句柄、头像、认证状态 - 直播时长：合理的时长（如 "1h 23m", "2h 15m", "35m"等） - 在线人数：1-2000之间的合理数字 - 直播类别：符合分类的具体标签 - 直播间简介：可选，简短描述直播内容 🚨 **重要：你必须只返回有效的JSON格式数据，任何语法错误都会导致系统崩溃！** 🚨 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const coreTaskSection = systemPrompt.substring(systemPrompt.lastIndexOf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━')); tokenCount = TokenUtils.logTokenUsage('直播刷新生成器', '核心任务说明', coreTaskSection, tokenCount); const charactersInfo = await StringBuilders.buildCompleteCharacterInfo(boundCharacters, userXProfileInfo, 'live'); if (charactersInfo) { systemPrompt += charactersInfo; tokenCount = TokenUtils.logTokenUsage('直播刷新生成器', '角色资料信息', charactersInfo, tokenCount); } const boundNPCs = await APIUtils.loadBoundNPCs(); if (boundNPCs.length > 0) { const npcSectionStart = systemPrompt.length; systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📋 绑定NPC资料（可作为直播者） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 以下NPC可以作为直播者出现： `; for (const npc of boundNPCs) { systemPrompt += ` 【NPC信息】 - X姓名：${npc.name} - X句柄：${npc.handle} - X头像：${npc.avatar} - 认证状态：false 【人设描述】 ${npc.personality || '暂无人设描述'} 【发帖习惯/兴趣】 ${npc.postingHabits || '暂无描述'} ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } const npcSection = systemPrompt.substring(npcSectionStart); tokenCount = TokenUtils.logTokenUsage('直播刷新生成器', 'NPC资料信息', npcSection, tokenCount); } const enabledCustomCategories = liveCustomCategories.filter(cat => cat.enabled && cat.name.trim()); if (enabledCustomCategories.length > 0) { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📂 自定义直播分类 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; enabledCustomCategories.forEach(category => { systemPrompt += ` 【${category.name}】 - 分类描述：${category.description || '无描述'} - 生成要求：为此分类生成3个相关的直播间 `; }); systemPrompt += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; tokenCount = TokenUtils.logTokenUsage( '直播刷新生成器', '自定义分类信息', systemPrompt.substring(systemPrompt.lastIndexOf('📂 自定义直播分类')), tokenCount, ); } const userConstraintsStart = systemPrompt.length; systemPrompt += StringBuilders.buildUniversalConstraints(userXProfileInfo); const userConstraints = systemPrompt.substring(userConstraintsStart); tokenCount = TokenUtils.logTokenUsage('直播刷新生成器', '用户约束信息', userConstraints, tokenCount); let jsonFormat = `{ "audio": [ { "title": "直播标题", "streamerName": "主播姓名", "streamerHandle": "@句柄", "streamerAvatar": "头像链接", "description": "直播间简介（可选）", "onlineCount": 数字, "category": "直播类别", "duration": "直播时长", "isLive": true } ], "video": [ { "title": "直播标题", "streamerName": "主播姓名", "streamerHandle": "@句柄", "streamerAvatar": "头像链接", "description": "直播间简介（可选）", "onlineCount": 数字, "category": "直播类别", "duration": "直播时长", "isLive": true } ]`; if (enabledCustomCategories.length > 0) { enabledCustomCategories.forEach(category => { jsonFormat += `, "${category.id}": [ { "title": "直播标题", "streamerName": "主播姓名", "streamerHandle": "@句柄", "streamerAvatar": "头像链接", "description": "直播间简介（可选）", "onlineCount": 数字, "category": "直播类别", "duration": "直播时长", "isLive": true } ]`; }); } jsonFormat += ` }`; systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📋 JSON返回格式 - 严格执行 📋 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ⚠️ 必须返回完全有效的JSON，任何语法错误都将导致解析失败！ ${jsonFormat} 🚨 【JSON语法严格要求】🚨 1. **字符串值**：必须用双引号包围，内容中的引号必须转义为\\" 2. **数字值**：onlineCount直接写数字，不要加引号 ✅ "onlineCount": 156 ❌ "onlineCount": "156" 3. **布尔值**：isLive固定为true，不加引号 ✅ "isLive": true ❌ "isLive": "true" 4. **数组**：用[]包围，元素间用逗号分隔，最后一个元素后不要逗号 5. **对象**：用{}包围，键必须用双引号，最后一个元素后不要逗号 🔒 【必需字段检查】🔒 每个直播间必须包含：title, streamerName, streamerHandle, streamerAvatar, onlineCount, category, duration, isLive 其中 description 是可选字段 【直播者选择策略】： 1. 绑定角色：根据角色人设、兴趣、X资料等判断是否适合直播，如果适合则可作为主播 2. 绑定NPC：根据NPC人设和发帖习惯判断是否适合直播 3. 虚构用户：创建符合直播内容的虚构主播 4. 头像规则： - 绑定角色：使用角色的xAvatar - 绑定NPC：使用NPC的avatar - 虚构用户：使用默认头像 https: 5. 认证状态：绑定角色根据xVerified，绑定NPC和虚构用户默认false 【内容质量要求】： 1. 直播标题要有趣吸引人，符合分类特点 2. 在线人数要合理（1-2000），热门内容人数可以多一些 3. 直播时长要现实合理（15分钟到8小时之间） 4. 直播类别要具体且符合内容（如"音乐分享"、"技术教程"、"游戏娱乐"等） 5. 直播间简介简洁明了，1-2句话描述直播内容 请直接返回JSON数据，不要添加任何解释文字或markdown标记。 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`; const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('📋 JSON返回格式')); tokenCount = TokenUtils.logTokenUsage('直播刷新生成器', 'JSON格式要求', formatSection, tokenCount); const messages = [ { role: 'user', content: `请生成新的X直播平台直播数据。 ⚠️ 关键要求： 1. 必须返回完全有效的JSON格式，不要有任何语法错误 2. 严格按照上述示例的格式和字段类型 3. 数字字段不要加引号，布尔值不要加引号 4. 字符串中的引号必须转义 5. 不要在对象或数组末尾添加多余的逗号 请直接返回JSON，不要添加任何解释文字。`, }, ]; const userMessage = messages[0].content; TokenUtils.logFinalPrompt('直播刷新生成器', systemPrompt, userMessage); const aiResponseContent = await APIUtils.sendAIRequest({ apiConfig, systemPrompt, messages, temperature: 0.8, }); let newLiveData = APIUtils.parseJSONResponse(aiResponseContent); newLiveData = await APIUtils.postProcessData(newLiveData, userXProfileInfo); if (!newLiveData.audio || !newLiveData.video) { throw new Error('AI返回的数据格式不正确，缺少必要字段'); } const timestamp = Date.now(); const processStreams = (streams, type) => { return streams.map((stream, index) => { return { ...stream, id: `${type}_${timestamp}_${index}`, background: getRandomBackground(), createdAt: timestamp, }; }); }; newLiveData.audio = processStreams(newLiveData.audio, 'audio'); newLiveData.video = processStreams(newLiveData.video, 'video'); enabledCustomCategories.forEach(category => { if (newLiveData[category.id] && Array.isArray(newLiveData[category.id])) { newLiveData[category.id] = processStreams(newLiveData[category.id], category.id); } }); liveStreamData.audio = newLiveData.audio; liveStreamData.video = newLiveData.video; enabledCustomCategories.forEach(category => { if (newLiveData[category.id]) { liveStreamData[category.id] = newLiveData[category.id]; } }); try { const saveData = { id: 'liveStreams', audio: newLiveData.audio, video: newLiveData.video, lastUpdated: new Date().toISOString(), }; enabledCustomCategories.forEach(category => { if (newLiveData[category.id]) { saveData[category.id] = newLiveData[category.id]; } }); await xDb.xTweetsData.put(saveData); console.log('✅ 直播数据已保存到数据库'); } catch (saveError) { console.error('⚠️ 保存直播数据失败:', saveError); } const liveCharacters = []; const allStreams = [ ...newLiveData.audio, ...newLiveData.video, ...Object.keys(newLiveData) .filter(key => !['audio', 'video'].includes(key)) .reduce((acc, key) => { if (Array.isArray(newLiveData[key])) { acc.push(...newLiveData[key]); } return acc; }, []), ]; if (boundCharacters.length > 0) { const allXProfiles = await xDb.xCharacterProfiles.toArray(); for (const charId of boundCharacters) { const xProfile = allXProfiles.find(p => p.characterId === charId); if (xProfile) { const isStreaming = allStreams.some( stream => stream.streamerHandle === xProfile.xHandle || stream.streamerName === xProfile.xName, ); if (isStreaming) { liveCharacters.push({ characterId: charId, xProfile: xProfile, isLive: true, }); } } } } await saveLiveCharacterStatus(liveCharacters); await syncLiveCharacterAvatars(liveCharacters); if (currentLiveTab === 'audio' || currentLiveTab === 'video') { renderLiveStreams(currentLiveTab); } else { const targetContent = document.getElementById('live-audio-content'); if (targetContent && targetContent.style.display !== 'none') { const container = document.getElementById('live-audio-list'); if (container && liveStreamData[currentLiveTab]) { container.innerHTML = liveStreamData[currentLiveTab] .map((stream, index) => createLiveStreamCard(stream, currentLiveTab, index)) .join(''); } } } const liveCharacterCount = liveCharacters.length; const totalStreams = allStreams.length; const isEnglish = currentLanguage === 'en'; const userAvatar = window.userProfileData?.avatar || 'https: if (liveCharacterCount > 0) { showPhoneNotification({ title: 'X', message: isEnglish ? `Live list refreshed! ${liveCharacterCount} character${ liveCharacterCount > 1 ? 's are' : ' is' } now streaming!` : `直播列表已刷新！${liveCharacterCount}个绑定角色正在直播`, avatar: userAvatar, leftIcon: 'x', }); } else { showPhoneNotification({ title: 'X', message: isEnglish ? `Live list refreshed! ${totalStreams} stream${totalStreams > 1 ? 's' : ''} available` : `直播列表已刷新！共${totalStreams}个直播间`, avatar: userAvatar, leftIcon: 'x', }); } console.log('✅ [直播刷新] 刷新完成', { 总直播间数: totalStreams, 正在直播的角色: liveCharacterCount, 自定义分类: enabledCustomCategories.length, }); } catch (error) { console.error('❌ [直播刷新] 刷新失败:', error); showXToast(`直播刷新失败: ${error.message}`, 'error'); } finally { if (refreshBtn) { const svg = refreshBtn.querySelector('svg'); if (svg) { svg.style.animation = ''; } } } } function startLiveStream() { console.log('开启直播'); showXToast('直播功能开发中...', 'info'); } function handleLiveCharacterClick(characterId, isLive) { if (isLive) { console.log('进入角色直播间:', characterId); showXToast('直播间功能开发中...', 'info'); } else { console.log('角色未在直播:', characterId); showXToast('该角色当前未在直播', 'info'); } } function handleLiveMainBtnMouseOver() { const mainBtn = document.getElementById('live-main-btn'); if (mainBtn) { mainBtn.style.transform = 'scale(1.1)'; } } function handleLiveMainBtnMouseOut() { const mainBtn = document.getElementById('live-main-btn'); if (mainBtn) { mainBtn.style.transform = window.liveBtnExpanded ? 'rotate(45deg)' : 'scale(1)'; } } function handleLiveMainBtnTouchStart() { const mainBtn = document.getElementById('live-main-btn'); if (mainBtn) { mainBtn.style.transform = 'scale(1.05)'; } } function handleLiveMainBtnTouchEnd() { const mainBtn = document.getElementById('live-main-btn'); if (mainBtn) { mainBtn.style.transform = window.liveBtnExpanded ? 'rotate(45deg)' : 'scale(1)'; } } function handleLiveSubBtnMouseOver(element) { if (element) { element.style.transform = 'scale(1.1)'; } } function handleLiveSubBtnMouseOut(element) { if (element) { element.style.transform = 'scale(1)'; } } function handleLiveSubBtnTouchStart(element) { if (element) { element.style.transform = 'scale(1.05)'; } } function handleLiveSubBtnTouchEnd(element) { if (element) { element.style.transform = 'scale(1)'; } } function openLiveCategoryModal() { const modal = document.getElementById('live-category-manager-modal'); if (modal) { modal.style.display = 'block'; document.body.style.overflow = 'hidden'; renderLiveCustomCategoriesList(); } } function closeLiveCategoryModal(event) { if (event && event.target !== event.currentTarget) { return; } const modal = document.getElementById('live-category-manager-modal'); if (modal) { modal.style.display = 'none'; document.body.style.overflow = 'auto'; } } function addNewLiveCategory() { const newCategory = { id: `live_cat_${Date.now()}`, name: '', description: '', enabled: true, }; liveCustomCategories.push(newCategory); renderLiveCustomCategoriesList(); } function deleteLiveCategory(categoryId) { liveCustomCategories = liveCustomCategories.filter(cat => cat.id !== categoryId); renderLiveCustomCategoriesList(); renderLiveCategoryTabs(); } function toggleLiveCategory(categoryId) { const category = liveCustomCategories.find(cat => cat.id === categoryId); if (category) { category.enabled = !category.enabled; renderLiveCategoryTabs(); } } function updateLiveCategoryName(categoryId, name) { const category = liveCustomCategories.find(cat => cat.id === categoryId); if (category) { category.name = name; } } function updateLiveCategoryDescription(categoryId, description) { const category = liveCustomCategories.find(cat => cat.id === categoryId); if (category) { category.description = description; } } function renderLiveCustomCategoriesList() { const container = document.getElementById('live-custom-categories-list'); if (!container) return; if (liveCustomCategories.length === 0) { container.innerHTML = ` <div style="text-align: center; padding: 40px 20px; color: #71767b;"> <svg viewBox="0 0 24 24" style="width: 48px; height: 48px; fill: currentColor; margin-bottom: 16px; opacity: 0.5;"> <path d="M19.5 12.75h-6.75V19.5h-1.5v-6.75H4.5v-1.5h6.75V4.5h1.5v6.75h6.75v1.5z"></path> </svg> <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">暂无自定义分类</div> <div style="font-size: 14px;">点击"添加分类"开始创建</div> </div> `; return; } container.innerHTML = liveCustomCategories .map( category => ` <div style="background-color: rgba(255,255,255,0.05); border-radius: 12px; padding: 16px; border: 1px solid rgba(255,255,255,0.1);"> <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;"> <div style="display: flex; align-items: center; gap: 12px; flex: 1;"> <label style="display: flex; align-items: center; cursor: pointer;"> <input type="checkbox" ${category.enabled ? 'checked' : ''} onchange="toggleLiveCategory('${category.id}')" style="width: 18px; height: 18px; accent-color: var(--x-accent);"> </label> <input type="text" placeholder="分类名称" value="${category.name}" onchange="updateLiveCategoryName('${category.id}', this.value)" style="flex: 1; background-color: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff; padding: 8px 12px; font-size: 14px; outline: none;" onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='rgba(255,255,255,0.2)'"> </div> <button onclick="deleteLiveCategory('${category.id}')" style="background: transparent; border: 1px solid #f4212e; color: #f4212e; border-radius: 8px; padding: 6px 12px; font-size: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'" onmouseout="this.style.backgroundColor='transparent'"> 删除 </button> </div> <textarea placeholder="分类描述（可选）" onchange="updateLiveCategoryDescription('${category.id}', this.value)" style="width: 100%; background-color: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff; padding: 8px 12px; font-size: 14px; resize: vertical; min-height: 60px; outline: none; font-family: inherit;" onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='rgba(255,255,255,0.2)'">${category.description}</textarea> </div> `, ) .join(''); } async function saveLiveCustomCategories() { try { const validCategories = liveCustomCategories.filter(cat => cat.name.trim()); if (validCategories.length !== liveCustomCategories.length) { showXToast('请填写所有分类的名称', 'error'); return; } const xDb = getXDB(); const categoryDataId = `liveCategories_${currentAccountId || 'main'}`; await xDb.xSettings.put({ id: categoryDataId, categories: liveCustomCategories, updatedAt: new Date().toISOString(), }); renderLiveCategoryTabs(); showXToast('直播分类设置已保存', 'success'); closeLiveCategoryModal(); } catch (error) { console.error('保存直播分类失败:', error); showXToast('保存失败: ' + error.message, 'error'); } } async function loadLiveCustomCategories() { try { const xDb = getXDB(); const categoryDataId = `liveCategories_${currentAccountId || 'main'}`; const savedData = await xDb.xSettings.get(categoryDataId); if (savedData && savedData.categories) { liveCustomCategories = savedData.categories; renderLiveCategoryTabs(); console.log(`✅ [直播分类] 已加载 ${liveCustomCategories.length} 个自定义分类`); } else { console.log('ℹ️ [直播分类] 未找到保存的自定义分类'); } } catch (error) { console.error('❌ [直播分类] 加载失败:', error); } } async function loadSavedLiveData() { try { const xDb = getXDB(); const savedData = await xDb.xTweetsData.get('liveStreams'); if (savedData) { const lastUpdated = new Date(savedData.lastUpdated); const now = new Date(); const diffHours = (now - lastUpdated) / (1000 * 60 * 60); if (diffHours > 2) { console.log('🕐 [直播数据] 数据已过期，使用默认数据'); return; } if (savedData.audio) { liveStreamData.audio = savedData.audio; } if (savedData.video) { liveStreamData.video = savedData.video; } Object.keys(savedData).forEach(key => { if (key !== 'id' && key !== 'audio' && key !== 'video' && key !== 'lastUpdated') { liveStreamData[key] = savedData[key]; } }); console.log('✅ [直播数据] 已加载保存的直播数据'); } else { console.log('ℹ️ [直播数据] 未找到保存的直播数据，使用默认数据'); } } catch (error) { console.error('❌ [直播数据] 加载失败:', error); } } async function loadLiveCharacterStatus() { try { const xDb = getXDB(); const statusDataId = `liveCharacterStatus_${currentAccountId || 'main'}`; const savedStatus = await xDb.xSettings.get(statusDataId); if (savedStatus && savedStatus.liveCharacters) { const lastUpdated = new Date(savedStatus.lastUpdated); const now = new Date(); const diffHours = (now - lastUpdated) / (1000 * 60 * 60); if (diffHours > 2) { console.log('🕐 [直播状态] 直播状态已过期，清除状态'); await xDb.xSettings.delete(statusDataId); return []; } console.log(`✅ [直播状态] 已加载 ${savedStatus.liveCharacters.length} 个角色的直播状态`); return savedStatus.liveCharacters; } else { console.log('ℹ️ [直播状态] 未找到保存的直播状态'); return []; } } catch (error) { console.error('❌ [直播状态] 加载失败:', error); return []; } } async function saveLiveCharacterStatus(liveCharacters) { try { const xDb = getXDB(); const statusDataId = `liveCharacterStatus_${currentAccountId || 'main'}`; await xDb.xSettings.put({ id: statusDataId, liveCharacters: liveCharacters, lastUpdated: new Date().toISOString(), }); console.log(`✅ [直播状态] 已保存 ${liveCharacters.length} 个角色的直播状态`); } catch (error) { console.error('❌ [直播状态] 保存失败:', error); } } function renderLiveCategoryTabs() { const container = document.getElementById('live-categories-container'); if (!container) return; const existingCustomTabs = container.querySelectorAll('.live-custom-tab'); existingCustomTabs.forEach(tab => tab.remove()); const enabledCategories = liveCustomCategories.filter(cat => cat.enabled && cat.name.trim()); const addButton = container.querySelector('.live-add-category-btn'); enabledCategories.forEach(category => { const tabElement = document.createElement('div'); tabElement.className = 'live-tab live-custom-tab'; tabElement.onclick = () => switchLiveTab(category.id); tabElement.style.cssText = ` padding: 8px 12px; background-color: rgba(255,255,255,0.1); border-radius: 16px; font-size: 14px; font-weight: 500; cursor: pointer; color: #71767b; white-space: nowrap; `; tabElement.innerHTML = `<span>${category.name}</span>`; container.insertBefore(tabElement, addButton); }); } const presetAccentColors = [ { name: 'Twitter蓝', color: '#1d9bf0' }, { name: '薰衣草紫', color: '#7856ff' }, { name: '玫瑰粉', color: '#f91880' }, { name: '翡翠绿', color: '#00ba7c' }, { name: '橙色', color: '#ff7a00' }, { name: '红色', color: '#f4212e' }, { name: '黄色', color: '#ffd400' }, { name: '青色', color: '#00d4ff' }, ]; function openAccentColorPicker() { const modal = document.createElement('div'); modal.id = 'accent-color-picker-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; backdrop-filter: blur(4px); `; const xSocialScreen = document.getElementById('x-social-screen'); const currentAccent = getComputedStyle(xSocialScreen).getPropertyValue('--x-accent').trim(); modal.innerHTML = ` <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 400px; border: 1px solid var(--x-border-color); overflow: hidden; "> <div style="padding: 20px; border-bottom: 1px solid var(--x-border-color); display: flex; align-items: center; justify-content: space-between; "> <h3 style="margin: 0; color:var(--x-text-primary); font-size: 20px; font-weight: 700;">选择主题色</h3> <button onclick="closeAccentColorPicker()" style="background: transparent; border: none; color:var(--x-text-secondary); cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </button> </div> <div style="padding: 20px;"> <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 12px;">预设颜色</div> <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 20px;"> ${presetAccentColors .map( preset => ` <div onclick="applyAccentColor('${ preset.color }')" style="cursor: pointer; aspect-ratio: 1; border-radius: 8px; background-color: ${ preset.color }; border: 3px solid ${ preset.color === currentAccent ? 'var(--x-text-primary)' : 'transparent' }; transition: all 0.2s; position: relative; display: flex; align-items: center; justify-content: center; " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'"> ${ preset.color === currentAccent ? '<svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;"><path d="M9 16.17L5.53 12.7l-1.06 1.06L9 18.3l9.54-9.54-1.06-1.06L9 16.17z"/></svg>' : '' } </div> `, ) .join('')} </div> <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 12px;">自定义颜色</div> <div style="display: flex; gap: 12px; align-items: center;"> <input type="color" id="custom-accent-color" value="${currentAccent}" style="width: 60px; height: 40px; border: 2px solid var(--x-border-color); border-radius: 8px; cursor: pointer; background: transparent; "> <button onclick="applyAccentColor(document.getElementById('custom-accent-color').value)" style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px 20px; font-size: 15px; font-weight: 700; cursor: pointer; transition: opacity 0.2s; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'"> 应用 </button> </div> <button onclick="applyAccentColor('#1d9bf0')" style="width: 100%; margin-top: 16px; background: transparent; color:var(--x-text-secondary); border: 1px solid var(--x-border-color); border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> 重置为默认色 </button> </div> </div> `; document.body.appendChild(modal); modal.addEventListener('click', e => { if (e.target === modal) { closeAccentColorPicker(); } }); } function closeAccentColorPicker() { const modal = document.getElementById('accent-color-picker-modal'); if (modal) { modal.remove(); } } async function applyAccentColor(color) { try { const xSocialScreen = document.getElementById('x-social-screen'); if (!xSocialScreen) return; xSocialScreen.style.setProperty('--x-accent', color); const xDb = getXDB(); const settingsId = `xAccentColor_${currentAccountId || 'main'}`; await xDb.xSettings.put({ id: settingsId, accentColor: color, updatedAt: new Date().toISOString(), }); showXToast('主题色已更新', 'success'); closeAccentColorPicker(); console.log('✅ 主题色已应用:', color); } catch (error) { console.error('应用主题色失败:', error); showXToast('应用主题色失败', 'error'); } } async function loadAccentColorPreference() { try { const xDb = getXDB(); const settingsId = `xAccentColor_${currentAccountId || 'main'}`; const savedSettings = await xDb.xSettings.get(settingsId); if (savedSettings && savedSettings.accentColor) { const xSocialScreen = document.getElementById('x-social-screen'); if (xSocialScreen) { xSocialScreen.style.setProperty('--x-accent', savedSettings.accentColor); console.log('✅ 已加载主题色:', savedSettings.accentColor); } } } catch (error) { console.error('加载主题色偏好失败:', error); } } let accountAskboxData = { avatar: 'https: nickname: '⩌⌯⩌', prompt: '在这里输入你的匿名提问，或点击下方按钮生成随机提问...', background: 'https: answeredQuestions: [], }; let currentUserQuestion = ''; let isAccountAskboxMultiSelectMode = false; let selectedAccountQuestions = new Set(); let accountQuestionLongPressTimer = null; window.openAccountAskbox = async function () { if (!currentViewingAccount) { showXToast('未找到当前账户信息', 'error'); return; } try { await loadAccountAskboxData(); document.getElementById('account-profile-page').style.display = 'none'; document.getElementById('account-askbox-page').style.display = 'flex'; } catch (error) { console.error('打开账户提问箱失败:', error); showXToast('打开提问箱失败: ' + error.message, 'error'); } }; window.closeAccountAskbox = function () { if (isAccountAskboxMultiSelectMode) { exitAccountAskboxMultiSelectMode(); } document.getElementById('account-askbox-page').style.display = 'none'; document.getElementById('account-profile-page').style.display = 'flex'; }; async function loadAccountAskboxDataFromDB() { try { const xDb = getXDB(); const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount; const accountHandle = accountInfo.handle.replace('@', ''); const askboxId = `account_askbox_${accountHandle}`; const savedData = await xDb.xAccountAskbox.get(askboxId); if (savedData) { Object.assign(accountAskboxData, savedData); console.log('✅ 账户提问箱数据已从数据库加载:', accountHandle); } else { accountAskboxData = { avatar: 'https: nickname: '⩌⌯⩌', prompt: '在这里输入你的匿名提问，或点击下方按钮生成随机提问...', background: 'https: answeredQuestions: [], id: askboxId, }; await xDb.xAccountAskbox.put(accountAskboxData); console.log('✅ 已创建默认账户提问箱数据:', accountHandle); } } catch (error) { console.error('❌ 加载账户提问箱数据失败:', error); } } async function saveAccountAskboxDataToDB() { try { const xDb = getXDB(); const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount; const accountHandle = accountInfo.handle.replace('@', ''); const askboxId = `account_askbox_${accountHandle}`; accountAskboxData.id = askboxId; await xDb.xAccountAskbox.put(accountAskboxData); console.log('✅ 账户提问箱数据已保存到数据库:', accountHandle); } catch (error) { console.error('❌ 保存账户提问箱数据失败:', error); } } async function loadAccountAskboxData() { await loadAccountAskboxDataFromDB(); currentUserQuestion = ''; const avatarEl = document.getElementById('account-askbox-avatar'); const nicknameEl = document.getElementById('account-askbox-nickname'); const promptEl = document.getElementById('account-askbox-prompt'); const backgroundEl = document.getElementById('account-askbox-background'); if (avatarEl) avatarEl.src = accountAskboxData.avatar; if (nicknameEl) nicknameEl.textContent = accountAskboxData.nickname; if (promptEl) promptEl.textContent = '在这里输入你的匿名提问，或点击下方按钮生成随机提问...'; if (backgroundEl) backgroundEl.style.backgroundImage = `url('${accountAskboxData.background}')`; renderAccountAnsweredQuestions(); } window.changeAccountAskboxAvatar = async function () { const newAvatar = prompt('请输入新的头像URL:', accountAskboxData.avatar); if (newAvatar && newAvatar.trim()) { accountAskboxData.avatar = newAvatar.trim(); const avatarEl = document.getElementById('account-askbox-avatar'); if (avatarEl) avatarEl.src = accountAskboxData.avatar; await saveAccountAskboxDataToDB(); showXToast('头像已更新并保存', 'success'); } }; window.saveAccountAskboxNickname = async function () { const nicknameEl = document.getElementById('account-askbox-nickname'); if (!nicknameEl) return; const newNickname = nicknameEl.textContent.trim(); if (newNickname && newNickname !== accountAskboxData.nickname) { accountAskboxData.nickname = newNickname; await saveAccountAskboxDataToDB(); console.log('✅ 昵称已自动保存:', newNickname); } }; window.saveAccountAskboxPrompt = async function () { const promptEl = document.getElementById('account-askbox-prompt'); if (!promptEl) return; const newText = promptEl.textContent.trim(); const defaultPrompt = '在这里输入你的匿名提问，或点击下方按钮生成随机提问...'; if (newText && newText !== defaultPrompt) { currentUserQuestion = newText; console.log('📝 [提问箱] 用户输入了提问:', currentUserQuestion); } else { currentUserQuestion = ''; console.log('📝 [提问箱] 用户清空了提问'); } }; window.openAccountAskboxSettings = function () { const newBackground = prompt('请输入新的背景图URL:', accountAskboxData.background); if (newBackground && newBackground.trim()) { accountAskboxData.background = newBackground.trim(); const backgroundEl = document.getElementById('account-askbox-background'); if (backgroundEl) backgroundEl.style.backgroundImage = `url('${accountAskboxData.background}')`; saveAccountAskboxDataToDB(); showXToast('背景图已更新并保存', 'success'); } }; window.getNewAccountQuestion = async function () { if (!currentViewingAccount) { showXToast('未找到当前账户信息', 'error'); return; } try { const isUserQuestion = currentUserQuestion && currentUserQuestion.trim().length > 0; if (isUserQuestion) { console.log('🎯 [提问箱] 检测到用户提问，准备生成回答:', currentUserQuestion); showXToast('正在生成回答...', 'info'); } else { console.log('🎲 [提问箱] 没有用户提问，生成随机问答'); showXToast('正在生成新的提问...', 'info'); } const db = getDB(); const xDb = getXDB(); const apiConfig = await db.apiConfig.get('main'); if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey || !apiConfig.model) { showXToast('请先配置API设置', 'error'); return; } const { proxyUrl, apiKey, model } = apiConfig; const settingsId = `xSettings_${currentAccountId || 'main'}`; const xSettings = await xDb.xSettings.get(settingsId); const userPrompt = xSettings?.systemPrompt || ''; const worldSetting = xSettings?.worldSetting || ''; const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount; const accountHandle = accountInfo.handle.replace('@', ''); const accountProfile = await StringBuilders.getUnifiedProfile(accountInfo.handle); if (!accountProfile) { showXToast('无法获取账户资料', 'error'); return; } console.log('📋 [提问箱] 账户类型:', accountProfile.type); let accountDetailInfo = StringBuilders.formatProfileForPrompt(accountProfile, { includeType: true, includeTweets: false, includeRelationships: true, }); let accountTweetsInfo = ''; if (currentViewingAccount.tweets && currentViewingAccount.tweets.length > 0) { accountTweetsInfo = `\n【该账户最近发布的推文】：\n`; currentViewingAccount.tweets.slice(0, 5).forEach((tweet, i) => { accountTweetsInfo += `${i + 1}. ${tweet.content}${tweet.time ? ` (${tweet.time})` : ''}`; if (tweet.image) { if (tweet.image.type === 'description') { accountTweetsInfo += `\n [图片描述: ${tweet.image.content}]`; } else if (tweet.image.type === 'upload') { accountTweetsInfo += `\n [包含上传的图片]`; } } if (tweet.media && tweet.media.length > 0) { tweet.media.forEach(m => { if (m.type === 'description' && m.description) { accountTweetsInfo += `\n [图片描述: ${m.description}]`; } }); } accountTweetsInfo += '\n'; }); } const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); let coupleCharacterInfo = ''; if (accountProfile.relationships && accountProfile.relationships.length > 0) { const coupleRelation = accountProfile.relationships.find(rel => rel.relationshipType === '恋人'); if (coupleRelation) { coupleCharacterInfo = `\n【该账户的情侣关系】：\n与 ${coupleRelation.npcName}（${coupleRelation.npcHandle}）是恋人关系`; if (coupleRelation.description) { coupleCharacterInfo += `\n${coupleRelation.description}`; } } } let existingQuestionsContext = ''; if (accountAskboxData.answeredQuestions.length > 0) { existingQuestionsContext = `\n【已有的提问列表（需要重新生成回答）】：\n`; accountAskboxData.answeredQuestions.forEach((q, i) => { existingQuestionsContext += `${i + 1}. ${q.question}\n`; }); } let systemPrompt = StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting, }); let userQuestionContext = ''; if (isUserQuestion) { userQuestionContext = `\n【🔴 用户匿名提问（必须回答）】：\n"${currentUserQuestion}"\n`; } systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务说明 - 账户提问箱生成 🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你需要为该账户生成匿名提问，并以该账户的身份回答这些提问。 ${accountDetailInfo} ${accountTweetsInfo} ${coupleCharacterInfo} ${userQuestionContext} ${existingQuestionsContext} 【生成要求】： 1. ${ isUserQuestion ? `必须回答用户的匿名提问"${currentUserQuestion}"，同时额外生成2-5个随机问答` : existingQuestionsContext ? '如果有已有提问列表，请基于这些提问重新生成回答' : '生成3-10个适合该账户身份的匿名提问' } 2. ${isUserQuestion ? '用户提问是完全匿名的，不要在回答中假设提问者的身份' : '提问要自然、真实，符合匿名提问箱的风格'} 3. ${isUserQuestion ? '' : '提问内容要与账户的X平台公开信息相关（X姓名、简介、公开身份、最近推文）'} 4. ${ accountProfile.type === 'character' || accountProfile.type === 'npc' ? '回答必须严格符合角色/NPC的人设和性格特点' : '回答要自然、真实' } 5. ${ isUserQuestion ? '回答用户提问时要自然、真诚，体现账户的性格和口吻' : `提问可以是： - 关于最近推文内容的追问或评论 - 关于生活经验、情感态度的询问 - 关于兴趣爱好、日常生活的好奇 - 轻松幽默或真诚的话题` } 6. ${isUserQuestion ? '' : '提问长度适中（10-50字）'} 7. 回答要体现该账户的性格和口吻，长度适中（20-100字） 8. ${isUserQuestion ? '' : '避免过于私密、冒犯或不适当的问题'} ${ !isUserQuestion ? `【🔒 隐私保护规则 - 匿名提问限制】： 🚨 匿名提问者只能基于该账户的X平台公开信息： ✅ 可以基于：X姓名、X句柄、X简介、公开身份、公开的推文内容 ❌ 禁止提及：真实姓名、真实职业、私密关系、未公开的身份信息 ❌ 禁止使用：只有亲密关系才知道的称呼（如"老师"、"同学"等，除非是公开身份） 示例说明： - ✅ 正确："姐姐你平时喜欢什么类型的音乐啊？"（基于公开称呼） - ❌ 错误："张老师今天上课讲了什么内容？"（泄露了真实姓氏和职业） - ❌ 错误："同学你这次考试考得怎么样？"（假装是同学关系） ⚠️ 回答也要注意：不要在回答中主动泄露私密信息，除非是角色本人想公开` : '' } 【返回格式】： 返回JSON数组，每个对象包含question和answer字段： \`\`\`json [ {"question": "提问内容1", "answer": "该账户的回答1"}, {"question": "提问内容2", "answer": "该账户的回答2"}, {"question": "提问内容3", "answer": "该账户的回答3"} ] \`\`\` 【重要】： - 必须返回有效的JSON数组格式 - question是匿名提问的内容 - answer是该账户以自己的身份和人设回答的内容 - ${ isUserQuestion ? `请务必包含用户提问"${currentUserQuestion}"的回答，并额外生成2-5组随机问答，将用户问答自然混入其中，不要特殊化` : existingQuestionsContext ? `请基于已有的${accountAskboxData.answeredQuestions.length}个提问重新生成回答` : '生成3-10组问答' } 现在，请生成JSON格式的问答内容：`; const messages = [ { role: 'user', content: isUserQuestion ? `请回答用户的匿名提问"${currentUserQuestion}"，同时生成2-5组随机问答，将用户问答自然混入其中，返回JSON数组格式` : existingQuestionsContext ? `请基于已有的${accountAskboxData.answeredQuestions.length}个提问，以该账户的身份重新生成回答，返回JSON数组格式` : '请生成3-10组问答，返回JSON数组格式', }, ]; let isGemini = proxyUrl.includes('generativelanguage'); let response; if (isGemini) { const GEMINI_API_URL = 'https: const geminiConfig = { url: `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`, data: { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [ { parts: [ { text: systemPrompt + '\n\n' + messages.map(m => m.content).join('\n'), }, ], }, ], generationConfig: { temperature: 0.9, }, }), }, }; response = await fetch(geminiConfig.url, geminiConfig.data); } else { const openAiPayload = { model: model, messages: [{ role: 'system', content: systemPrompt }, ...messages], temperature: 0.9, stream: false, }; response = await fetch(`${proxyUrl}/v1/chat/completions`, { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${apiKey}`, }, body: JSON.stringify(openAiPayload), }); } if (!response.ok) { const errorData = await response.json(); throw new Error(`API错误: ${response.status} - ${errorData.error?.message || response.statusText}`); } const data = await response.json(); let aiResponseContent; if (isGemini) { if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) { aiResponseContent = data.candidates[0].content.parts[0].text || ''; } } else { aiResponseContent = data.choices?.[0]?.message?.content || ''; } console.log('AI生成的问答:', aiResponseContent); let qaArray; try { let jsonText = aiResponseContent.trim(); const jsonMatch = jsonText.match(/```(?:json)?\s*(\[\s*\{[\s\S]*?\}\s*\])\s*```/); if (jsonMatch) { jsonText = jsonMatch[1]; } else if (jsonText.startsWith('[') && jsonText.endsWith(']')) { jsonText = jsonText; } else { throw new Error('未找到有效的JSON格式'); } qaArray = JSON.parse(jsonText); if (!Array.isArray(qaArray) || qaArray.length === 0) { throw new Error('AI返回的不是有效的数组或数组为空'); } } catch (parseError) { console.error('JSON解析失败:', parseError); throw new Error(`解析AI回答失败: ${parseError.message}`); } console.log(`✅ 解析到 ${qaArray.length} 组问答:`, qaArray); if (existingQuestionsContext) { accountAskboxData.answeredQuestions = []; } const newQuestions = qaArray.map((qa, index) => ({ id: `q_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`, question: qa.question || '', answer: qa.answer || '', date: new Date().toISOString(), })); accountAskboxData.answeredQuestions.unshift(...newQuestions); await saveAccountAskboxDataToDB(); renderAccountAnsweredQuestions(); if (isUserQuestion) { showXToast('已生成回答！', 'success'); currentUserQuestion = ''; const promptEl = document.getElementById('account-askbox-prompt'); if (promptEl) { promptEl.textContent = '在这里输入你的匿名提问，或点击下方按钮生成随机提问...'; } console.log(`✅ [提问箱] 用户提问已回答，问题已混入${newQuestions.length}组问答中`); } else { showXToast( `${existingQuestionsContext ? '已重新生成回答' : `生成了 ${newQuestions.length} 组问答`}`, 'success', ); } if (accountProfile.type === 'character' && accountProfile.characterData) { const triggerProbability = 0.3; const shouldTrigger = Math.random() < triggerProbability; console.log('🔔 检测到角色提问箱'); console.log(`🎲 触发概率: ${(triggerProbability * 100).toFixed(0)}%, 本次${shouldTrigger ? '触发' : '不触发'}`); if (!shouldTrigger) { console.log('⏭️ 本次未触发角色主动发消息'); return; } console.log('✅ 准备触发角色主动发消息'); console.log('📋 角色数据:', accountProfile.characterData.originalName, accountProfile.characterData.id); const characterId = accountProfile.characterData.id; const askboxSummary = accountAskboxData.answeredQuestions .slice(0, 3) .map((qa, index) => `${index + 1}. Q: ${qa.question}\n A: ${qa.answer}`) .join('\n\n'); window.openAccentColorPicker = openAccentColorPicker; window.closeAccentColorPicker = closeAccentColorPicker; window.applyAccentColor = applyAccentColor; setTimeout(async () => { try { const messageId = `msg_${characterId}`; const messagesListId = `messagesList_${currentAccountId || 'main'}`; const messagesListData = await xDb.xAccountProfiles.get(messagesListId); let existingMessage = null; if (messagesListData && messagesListData.data) { existingMessage = messagesListData.data.find(msg => msg.id === messageId); } if (!existingMessage) { const newMessage = { id: messageId, user: { name: accountData.name, handle: accountData.handle, avatar: accountData.avatar, verified: accountData.verified || false, }, preview: '发现你在看我的提问箱...', time: '刚刚', unread: true, unreadCount: 1, }; if (messagesListData && messagesListData.data) { messagesListData.data.unshift(newMessage); await xDb.xAccountProfiles.put(messagesListData); } else { await xDb.xAccountProfiles.put({ handle: messagesListId, name: 'messagesList', data: [newMessage], updatedAt: new Date().toISOString(), }); } existingMessage = newMessage; sampleMessagesData.unshift(newMessage); } const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageId}`; const existingConversation = await xDb.xAccountProfiles.get(conversationId); const hasHistory = existingConversation && existingConversation.data && existingConversation.data.messages && existingConversation.data.messages.length > 0; console.log('🎯 触发角色主动发消息（提问箱查看）'); console.log( `📖 现有对话记录: ${ hasHistory ? existingConversation.data.messages.length + '条消息' : '无（首次对话）' }`, ); const aiMessages = await generateMessageConversation( existingMessage, true, { isAskboxViewed: true, askboxContent: askboxSummary, characterId: characterId, }, ); if (aiMessages && aiMessages.length > 0) { await saveAIMessagesToDB(aiMessages, existingMessage); if (messagesListData && messagesListData.data) { const msgIndex = messagesListData.data.findIndex(msg => msg.id === messageId); if (msgIndex !== -1) { messagesListData.data[msgIndex].preview = aiMessages[0].content || aiMessages[0].voiceText || '[消息]'; messagesListData.data[msgIndex].time = aiMessages[0].time || '刚刚'; messagesListData.data[msgIndex].unread = true; messagesListData.data[msgIndex].unreadCount = (messagesListData.data[msgIndex].unreadCount || 0) + aiMessages.length; await xDb.xAccountProfiles.put(messagesListData); sampleMessagesData = messagesListData.data; } } console.log(`✅ 角色已发送 ${aiMessages.length} 条私信`); showXToast(`${accountProfile.name} 给你发来了新消息`, 'info'); } } catch (error) { console.error('触发角色主动发消息失败:', error); } }, 1000); } } catch (error) { console.error('生成提问失败:', error); showXToast(`生成失败: ${error.message}`, 'error'); } }; function renderAccountAnsweredQuestions() { const container = document.getElementById('account-answered-questions-list'); const titleEl = document.getElementById('account-answered-questions-title'); if (!container) return; if (accountAskboxData.answeredQuestions.length === 0) { if (titleEl) titleEl.style.display = 'none'; container.innerHTML = ` <div style="text-align: center; color: rgba(255,255,255,0.6); font-size: 14px; padding: 40px 20px; "> 暂无提问 </div> `; return; } if (titleEl) titleEl.style.display = 'block'; container.innerHTML = accountAskboxData.answeredQuestions .map((q, index) => { const date = new Date(q.date); const dateStr = date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' }); const isSelected = selectedAccountQuestions.has(q.id); return ` <div class="account-askbox-question-item" data-question-id="${q.id}" style="background-color: rgba(255,255,255,0.9); backdrop-filter: blur(10px); border-radius: 16px; overflow: hidden; margin-bottom: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); transition: all 0.2s; ${ isSelected ? 'border: 3px solid var(--x-accent); background-color: color-mix(in srgb, var(--x-accent) , 0.1);' : '' } ${isAccountAskboxMultiSelectMode ? 'border-left: 3px solid var(--x-accent);' : ''} " onmouseover="if(!${isAccountAskboxMultiSelectMode}){this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0,0,0,0.2)';}" onmouseout="if(!${isAccountAskboxMultiSelectMode}){this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';}" onmousedown="startAccountQuestionLongPress('${q.id}')" onmouseup="endAccountQuestionLongPress()" onmouseleave="endAccountQuestionLongPress()" ontouchstart="handleAccountQuestionTouchStart(event, '${q.id}')" ontouchend="handleAccountQuestionTouchEnd(event, '${q.id}')" ontouchcancel="endAccountQuestionLongPress()" onclick="if(${isAccountAskboxMultiSelectMode}){toggleAccountQuestionSelection('${q.id}');event.stopPropagation();}" > <div style="background: linear-gradient(135deg, #3a3a3a 0%, #2a2a2a 100%); padding: 20px; color: #fff; "> <div style="font-size: 15px; line-height: 1.6; word-break: break-word;"> ${q.question} </div> </div> <div style="background-color:#fff; padding: 20px; min-height: 60px; color: #333; "> <div id="account-answer-${q.id}" contenteditable="true" data-question-id="${q.id}" style="font-size: 14px; line-height: 1.6; word-break: break-word; outline: none; cursor: text; min-height: 20px; ${ q.answer ? '' : 'color: #999; text-align: center;' } " onblur="saveAccountQuestionAnswer('${q.id}')" onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();this.blur();}" onfocus="if(this.textContent==='点击此处回复...'){this.textContent='';this.style.color='#333';this.style.textAlign='left';}">${ q.answer || '点击此处回复...' }</div> </div> <div style="background-color: #f5f5f5; padding: 8px 20px; color: #999; font-size: 12px; text-align: right; "> ${dateStr} </div> </div> `; }) .join(''); } window.saveAccountQuestionAnswer = async function (questionId) { const answerEl = document.getElementById(`account-answer-${questionId}`); if (!answerEl) return; const question = accountAskboxData.answeredQuestions.find(q => q.id === questionId); if (!question) return; let newAnswer = answerEl.textContent.trim(); if (newAnswer === '点击此处回复...') { newAnswer = ''; } if (newAnswer !== question.answer) { question.answer = newAnswer; await saveAccountAskboxDataToDB(); console.log('✅ 回复已自动保存:', questionId); } }; window.startAccountQuestionLongPress = function (questionId) { if (isAccountAskboxMultiSelectMode) return; accountQuestionLongPressTimer = setTimeout(() => { enterAccountAskboxMultiSelectMode(); toggleAccountQuestionSelection(questionId); }, 500); }; window.endAccountQuestionLongPress = function () { if (accountQuestionLongPressTimer) { clearTimeout(accountQuestionLongPressTimer); accountQuestionLongPressTimer = null; } }; window.handleAccountQuestionTouchStart = function (event, questionId) { if (isAccountAskboxMultiSelectMode) { return; } window.accountQuestionTouchStartTime = Date.now(); window.accountQuestionTouchStartY = event.touches[0].clientY; accountQuestionLongPressTimer = setTimeout(() => { enterAccountAskboxMultiSelectMode(); toggleAccountQuestionSelection(questionId); }, 500); }; window.handleAccountQuestionTouchEnd = function (event, questionId) { if (accountQuestionLongPressTimer) { clearTimeout(accountQuestionLongPressTimer); accountQuestionLongPressTimer = null; } if (isAccountAskboxMultiSelectMode) { const touchDuration = Date.now() - (window.accountQuestionTouchStartTime || 0); const touchMoveY = Math.abs( (event.changedTouches[0]?.clientY || window.accountQuestionTouchStartY || 0) - (window.accountQuestionTouchStartY || 0), ); if (touchDuration < 500 && touchMoveY < 10) { event.preventDefault(); toggleAccountQuestionSelection(questionId); } } }; window.toggleAccountQuestionSelection = function (questionId) { if (!isAccountAskboxMultiSelectMode) { enterAccountAskboxMultiSelectMode(); } const questionEl = document.querySelector(`.account-askbox-question-item[data-question-id="${questionId}"]`); if (!questionEl) return; if (selectedAccountQuestions.has(questionId)) { selectedAccountQuestions.delete(questionId); questionEl.style.border = ''; questionEl.style.backgroundColor = 'rgba(255,255,255,0.9)'; } else { selectedAccountQuestions.add(questionId); questionEl.style.border = '3px solid var(--x-accent)'; questionEl.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) , 0.1)'; } updateAccountAskboxDeleteUI(); }; function enterAccountAskboxMultiSelectMode() { isAccountAskboxMultiSelectMode = true; showAccountAskboxDeleteToolbar(); document.querySelectorAll('.account-askbox-question-item').forEach(item => { item.style.borderLeft = '3px solid var(--x-accent)'; }); console.log('✅ 已进入账户提问箱多选模式'); } window.exitAccountAskboxMultiSelectMode = function () { isAccountAskboxMultiSelectMode = false; selectedAccountQuestions.clear(); hideAccountAskboxDeleteToolbar(); if (accountQuestionLongPressTimer) { clearTimeout(accountQuestionLongPressTimer); accountQuestionLongPressTimer = null; } window.accountQuestionTouchStartTime = null; window.accountQuestionTouchStartY = null; document.querySelectorAll('.account-askbox-question-item').forEach(item => { item.style.border = ''; item.style.borderLeft = ''; item.style.backgroundColor = 'rgba(255,255,255,0.9)'; }); console.log('✅ 已退出账户提问箱多选模式'); }; function showAccountAskboxDeleteToolbar() { let toolbar = document.getElementById('account-askbox-delete-toolbar'); if (!toolbar) { toolbar = document.createElement('div'); toolbar.id = 'account-askbox-delete-toolbar'; toolbar.style.cssText = ` position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); border-radius: 24px; padding: 12px 20px; display: flex; align-items: center; gap: 16px; z-index: 2000; box-shadow: 0 4px 20px rgba(0,0,0,0.5); `; toolbar.innerHTML = ` <button onclick="selectAllAccountQuestions()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'"> 全选 </button> <span id="account-askbox-selected-count" style="color: #fff; font-size: 14px; font-weight: 500;">已选择 0 个</span> <button onclick="deleteSelectedAccountQuestions()" style="background-color: #f91880; color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#d0155f'" onmouseout="this.style.backgroundColor='#f91880'"> 删除 </button> <button onclick="exitAccountAskboxMultiSelectMode()" style="background-color: rgba(255,255,255,0.15); color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.25)'" onmouseout="this.style.backgroundColor='rgba(255,255,255,0.15)'"> 取消 </button> `; document.body.appendChild(toolbar); } toolbar.style.display = 'flex'; } function hideAccountAskboxDeleteToolbar() { const toolbar = document.getElementById('account-askbox-delete-toolbar'); if (toolbar) { toolbar.style.display = 'none'; } } function updateAccountAskboxDeleteUI() { const countEl = document.getElementById('account-askbox-selected-count'); if (countEl) { countEl.textContent = `已选择 ${selectedAccountQuestions.size} 个`; } } window.selectAllAccountQuestions = function () { document.querySelectorAll('.account-askbox-question-item').forEach(item => { const questionId = item.dataset.questionId; if (!selectedAccountQuestions.has(questionId)) { selectedAccountQuestions.add(questionId); item.style.border = '3px solid var(--x-accent)'; item.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) , 0.1)'; } }); updateAccountAskboxDeleteUI(); }; window.deleteSelectedAccountQuestions = async function () { if (selectedAccountQuestions.size === 0) { showXToast('请先选择要删除的提问', 'warning'); return; } const confirmDelete = confirm(`确定要删除选中的 ${selectedAccountQuestions.size} 个提问吗？删除后无法恢复。`); if (!confirmDelete) return; try { accountAskboxData.answeredQuestions = accountAskboxData.answeredQuestions.filter( q => !selectedAccountQuestions.has(q.id), ); await saveAccountAskboxDataToDB(); showXToast(`已删除 ${selectedAccountQuestions.size} 个提问`, 'success'); window.exitAccountAskboxMultiSelectMode(); renderAccountAnsweredQuestions(); } catch (error) { console.error('删除提问失败:', error); showXToast('删除失败: ' + error.message, 'error'); } }; let xSettingsData = { systemPrompt: '', worldSetting: '', characterBinding: false, boundCharacters: [], worldBooks: [], }; if (!window.userProfileData) { window.userProfileData = { name: '我', handle: '@me', avatar: 'https: coverImage: 'https: bio: '欢迎来到我的X主页！', verified: false, verificationType: 'none', coupleCharacterId: '', coupleCharacterName: '', customTag1: '科技爱好者', customTag1Icon: '✨', customTag1Color: '#71767b', customTag2: '2024年加入', customTag2Icon: '📅', customTag2Color: '#71767b', following: '156', followers: '89', knownIdentityCharacters: [], publicIdentity: '', showRealName: false, realName: '', }; } let userProfileData = window.userProfileData; function getUserVerificationTypeDescription(userProfile) { const verificationType = userProfile.verificationType || 'none'; const descriptions = { none: '无认证', verified: '已认证（蓝色勾标）', couple: '情侣认证（白色心形）', married: '已婚认证（白色圆环）', vip: 'VIP认证（白色菱形）', }; return descriptions[verificationType] || '无认证'; } async function initializeXSettings() { try { const db = getXDB(); await loadGlobalWorldBooks(); const settingsId = `xSettings_${currentAccountId || 'main'}`; const savedSettings = await db.xSettings.get(settingsId); if (savedSettings) { const globalWorldBooks = xSettingsData.worldBooks; xSettingsData = savedSettings; xSettingsData.worldBooks = globalWorldBooks; } else { const globalWorldBooks = xSettingsData.worldBooks; xSettingsData = { systemPrompt: '', worldSetting: '', characterBinding: false, boundCharacters: [], npcBinding: false, worldBooks: globalWorldBooks, }; } await loadXSettingsToUI(); loadXPresetsList(); console.log('✅ X设置已加载 (账户:', currentAccountId || 'main', ')'); console.log('📚 全局世界书:', xSettingsData.worldBooks?.length || 0, '个'); } catch (error) { console.error('初始化X设置失败:', error); } } async function loadXSettingsToUI() { document.getElementById('x-system-prompt').value = xSettingsData.systemPrompt || ''; document.getElementById('x-world-setting').value = xSettingsData.worldSetting || ''; if (!xSettingsData.boundCharacters) { xSettingsData.boundCharacters = []; } if (!xSettingsData.worldBooks) { xSettingsData.worldBooks = []; } updateCharacterToggleUI(); const bindingArea = document.getElementById('character-binding-area'); if (xSettingsData.characterBinding) { bindingArea.style.display = 'block'; loadCharactersList(); } else { bindingArea.style.display = 'none'; } updateRelationshipToggleUI(); const relationshipArea = document.getElementById('relationship-binding-area'); if (xSettingsData.characterRelationship?.enabled) { relationshipArea.style.display = 'block'; await loadRelationshipData(); setTimeout(() => { updateRelationshipPreview(); }, 200); } else { relationshipArea.style.display = 'none'; } updateNPCToggleUI(); const npcArea = document.getElementById('npc-binding-area'); if (xSettingsData.npcBinding) { npcArea.style.display = 'block'; loadNPCsList(); } else { npcArea.style.display = 'none'; } } async function saveGlobalWorldBooks() { try { const db = getXDB(); await db.xSettings.put({ id: 'globalWorldBooks', worldBooks: xSettingsData.worldBooks || [], lastUpdated: new Date().toISOString(), }); console.log('✅ 全局世界书已保存'); } catch (error) { console.error('保存全局世界书失败:', error); throw error; } } async function loadGlobalWorldBooks() { try { const db = getXDB(); const globalData = await db.xSettings.get('globalWorldBooks'); if (globalData && globalData.worldBooks && globalData.worldBooks.length > 0) { xSettingsData.worldBooks = globalData.worldBooks; console.log('✅ 全局世界书已加载:', xSettingsData.worldBooks.length, '个'); } else { console.log('📦 [世界书迁移] 全局世界书为空，尝试从账户设置迁移...'); const settingsId = `xSettings_${currentAccountId || 'main'}`; const accountSettings = await db.xSettings.get(settingsId); if (accountSettings && accountSettings.worldBooks && accountSettings.worldBooks.length > 0) { console.log( `📦 [世界书迁移] 发现账户设置中有 ${accountSettings.worldBooks.length} 个世界书，正在迁移到全局设置...`, ); xSettingsData.worldBooks = accountSettings.worldBooks; await saveGlobalWorldBooks(); console.log('✅ [世界书迁移] 迁移完成！'); } else { xSettingsData.worldBooks = []; console.log('ℹ️ [世界书] 无世界书数据'); } } } catch (error) { console.error('加载全局世界书失败:', error); xSettingsData.worldBooks = []; } } async function saveXSettings() { try { xSettingsData.systemPrompt = document.getElementById('x-system-prompt').value; xSettingsData.worldSetting = document.getElementById('x-world-setting').value; const db = getXDB(); const settingsId = `xSettings_${currentAccountId || 'main'}`; const settingsToSave = { ...xSettingsData }; delete settingsToSave.worldBooks; await db.xSettings.put({ id: settingsId, ...settingsToSave, lastUpdated: new Date().toISOString(), }); console.log('✅ X设置已保存 (账户:', currentAccountId || 'main', ')'); showXToast('设置已保存', 'success'); } catch (error) { console.error('保存设置失败:', error); showXToast('保存失败: ' + error.message, 'error'); } } window.openWorldBooksManageModal = async function () { await loadGlobalWorldBooks(); const modal = document.createElement('div'); modal.id = 'world-books-manage-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); backdrop-filter: blur(4px); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 12px; box-sizing: border-box; `; modal.innerHTML = ` <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 100%; max-width: 700px; max-height: calc(100vh - 24px); display: flex; flex-direction: column; border: 1px solid var(--x-border-color); box-sizing: border-box; " onclick="event.stopPropagation()"> <div style="display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--x-border-color); flex-shrink: 0; "> <h2 style="color:var(--x-text-primary); font-size: 20px; font-weight: 700; margin: 0; ">世界书管理<span style="font-size: 14px; color:var(--x-text-secondary); font-weight: 400; margin-left: 8px;">(全局共享)</span></h2> <div style="display: flex; gap: 12px; align-items: center;"> <button onclick="openCreateWorldBookModal()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'"> + 添加世界书 </button> <div onclick="closeWorldBooksManageModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </div> </div> </div> <div id="world-books-manage-list" style="flex: 1; overflow-y: auto; padding: 16px 20px; "> </div> </div> `; const xScreen = document.getElementById('x-social-screen'); if (xScreen) { xScreen.appendChild(modal); } else { document.body.appendChild(modal); } renderWorldBooksManageList(); modal.addEventListener('click', e => { if (e.target === modal) { closeWorldBooksManageModal(); } }); }; window.closeWorldBooksManageModal = function () { const modal = document.getElementById('world-books-manage-modal'); if (modal) { modal.remove(); } }; function renderWorldBooksManageList() { const container = document.getElementById('world-books-manage-list'); if (!container) return; if (!xSettingsData.worldBooks || xSettingsData.worldBooks.length === 0) { container.innerHTML = ` <div style="color:var(--x-text-secondary); font-size: 15px; text-align: center; padding: 60px 20px; background-color:var(--x-bg-secondary); border-radius: 16px; border: 2px dashed var(--x-border-color); "> <svg viewBox="0 0 24 24" style="width: 48px; height: 48px; fill: var(--x-text-secondary); margin-bottom: 16px;"> <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v13c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-13c0-.276-.224-.5-.5-.5h-13z"></path></g> </svg> <div style="font-weight: 600; margin-bottom: 8px; font-size: 16px;">暂无世界书</div> <div style="font-size: 13px;">点击右上角"添加世界书"按钮创建第一个世界书</div> </div> `; return; } const sceneLabels = { global: '全局', messages: '私信', search: '搜索', trending: '热搜', profile: '主页', feed: '首页', tweetDetail: '详情', }; container.innerHTML = ` <div style="display: flex; flex-direction: column; gap: 12px;"> ${xSettingsData.worldBooks .map((wb, index) => { const sceneTags = wb.scenes?.map(s => sceneLabels[s] || s).join(', ') || '未绑定场景'; let bindInfo = []; if (wb.bindToAll) bindInfo.push('全局对话'); if (wb.bindToCharacterOnly) bindInfo.push('仅角色对话'); if (wb.boundCharacters && wb.boundCharacters.length > 0) { bindInfo.push(`${wb.boundCharacters.length}个指定角色`); } const bindText = bindInfo.length > 0 ? bindInfo.join(' + ') : '未绑定目标'; const isIdle = wb.isIdle || (wb.targetType === 'none' && (!wb.scenes || wb.scenes.length === 0)); return ` <div style="background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 16px; padding: 16px; transition: all 0.2s; " onmouseover="this.style.borderColor='var(--x-accent)'" onmouseout="this.style.borderColor='var(--x-border-color)'"> <div style="display: flex; align-items: start; justify-content: space-between; margin-bottom: 12px;"> <div style="flex: 1; min-width: 0;"> <div style="color:var(--x-text-primary); font-size: 17px; font-weight: 700; margin-bottom: 8px; ">${wb.name}</div> <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px; "> ${ isIdle ? ` <span style="display: inline-flex; align-items: center; background-color: rgba(113, 118, 123, 0.2); color:var(--x-text-secondary); padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: 600; "> <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: var(--x-text-secondary); margin-right: 4px;"> <g><path d="M8 7c0 2.21-1.79 4-4 4S0 9.21 0 7s1.79-4 4-4 4 1.79 4 4zm5-4c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm9 0c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"></path></g> </svg> 闲置状态（暂未启用） </span> ` : ` <span style="display: inline-flex; align-items: center; background-color: #1d9bf0; color: #ffffff; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: 600; "> <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #ffffff; margin-right: 4px;"> <g><path d="M12 7c-1.93 0-3.5 1.57-3.5 3.5S10.07 14 12 14s3.5-1.57 3.5-3.5S13.93 7 12 7zm0 5c-.827 0-1.5-.673-1.5-1.5S11.173 9 12 9s1.5.673 1.5 1.5S12.827 12 12 12zm0-10c-4.687 0-8.5 3.813-8.5 8.5 0 5.967 7.621 11.116 7.945 11.332l.555.37.555-.37c.324-.216 7.945-5.365 7.945-11.332C20.5 5.813 16.687 2 12 2zm0 17.77c-1.665-1.241-6.5-5.196-6.5-9.27C5.5 6.916 8.416 4 12 4s6.5 2.916 6.5 6.5c0 4.073-4.835 8.028-6.5 9.27z"></path></g> </svg> ${sceneTags} </span> <span style="display: inline-flex; align-items: center; background-color: rgba(29, 155, 240, 0.15); color: #1d9bf0; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: 600; "> <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #1d9bf0; margin-right: 4px;"> <g><path d="M17.863 13.44c1.477 1.58 2.366 3.8 2.632 6.46l.11 1.1H3.395l.11-1.1c.266-2.66 1.155-4.88 2.632-6.46C7.627 11.85 9.648 11 12 11s4.373.85 5.863 2.44zM12 2C9.791 2 8 3.79 8 6s1.791 4 4 4 4-1.79 4-4-1.791-4-4-4z"></path></g> </svg> ${bindText} </span> ` } </div> </div> <div style="display: flex; gap: 8px; flex-shrink: 0; margin-left: 12px;"> <button onclick="editWorldBookInManage(${index})" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 18px; padding: 8px 16px; font-size: 13px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">编辑</button> <button onclick="deleteWorldBookInManage(${index})" style="background-color: #f4212e; color: #fff; border: none; border-radius: 18px; padding: 8px 16px; font-size: 13px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">删除</button> </div> </div> <div style="color:var(--x-text-secondary); font-size: 14px; line-height: 1.6; max-height: 80px; overflow: hidden; text-overflow: ellipsis; background-color:var(--x-bg-primary); padding: 12px; border-radius: 8px; ">${wb.content.substring( 0, 150, )}${wb.content.length > 150 ? '...' : ''}</div> </div> `; }) .join('')} </div> `; } window.editWorldBookInManage = function (index) { const worldBook = xSettingsData.worldBooks[index]; openWorldBookModal(worldBook, index); }; window.deleteWorldBookInManage = async function (index) { if (!confirm('确定要删除这个世界书吗？')) return; xSettingsData.worldBooks.splice(index, 1); await saveGlobalWorldBooks(); renderWorldBooksManageList(); showXToast('世界书已删除', 'success'); }; window.openCreateWorldBookModal = function () { openWorldBookModal(); }; function openWorldBookModal(worldBook = null, editIndex = null) { const isEdit = worldBook !== null; const modal = document.createElement('div'); modal.id = 'world-book-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); backdrop-filter: blur(4px); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 12px; box-sizing: border-box; `; modal.innerHTML = ` <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 100%; max-width: 600px; max-height: calc(100vh - 24px); overflow-y: auto; border: 1px solid var(--x-border-color); box-sizing: border-box; " onclick="event.stopPropagation()"> <div style="display: flex; align-items: center; justify-content: space-between; padding: 14px 16px; border-bottom: 1px solid var(--x-border-color); position: sticky; top: 0; background-color:var(--x-bg-primary); z-index: 1; "> <h2 style="color:var(--x-text-primary); font-size: 18px; font-weight: 700; margin: 0; ">${ isEdit ? '编辑世界书' : '创建世界书' }</h2> <div onclick="closeWorldBookModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </div> </div> <div style="padding: 16px;"> <form id="world-book-form" onsubmit="saveWorldBook(event)"> <div style="margin-bottom: 16px;"> <label style="display: block; color:var(--x-text-primary); font-size: 14px; font-weight: 600; margin-bottom: 6px; ">世界书名称 *</label> <input type="text" id="wb-name" required value="${worldBook?.name || ''}" placeholder="例如：表情包库、角色关系设定..." style="width: 100%; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; color:var(--x-text-primary); padding: 10px 12px; font-size: 14px; outline: none; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'"> </div> <div style="margin-bottom: 16px;"> <label style="display: block; color:var(--x-text-primary); font-size: 14px; font-weight: 600; margin-bottom: 6px; ">世界书内容 *</label> <textarea id="wb-content" required rows="6" placeholder="输入世界书内容，例如：&#10;表情包链接：&#10;- 开心：https: style="width: 100%; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; color:var(--x-text-primary); padding: 10px 12px; font-size: 14px; resize: vertical; outline: none; font-family: inherit; line-height: 1.5; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'">${worldBook?.content || ''}</textarea> </div> <div style="margin-bottom: 16px;"> <label style="display: block; color:var(--x-text-primary); font-size: 14px; font-weight: 600; margin-bottom: 4px; ">绑定场景（可多选）</label> <div style="color:var(--x-text-secondary); font-size: 12px; margin-bottom: 8px; line-height: 1.4; ">💡 提示：如果不绑定任何场景和目标，世界书将处于闲置状态，不会被应用到任何场景</div> <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; "> ${['global', 'messages', 'search', 'trending', 'profile', 'feed', 'tweetDetail'] .map(scene => { const labels = { global: '全局', messages: '私信界面', search: '搜索界面', trending: '热搜界面', profile: '角色主页', feed: '首页推文', tweetDetail: '推文详情', }; const checked = worldBook?.scenes?.includes(scene) || false; return ` <label style="display: flex; align-items: center; padding: 8px 10px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'"> <input type="checkbox" name="wb-scenes" value="${scene}" ${checked ? 'checked' : ''} style="margin-right: 6px; cursor: pointer;"> <span style="color:var(--x-text-primary); font-size: 13px;">${labels[scene]}</span> </label> `; }) .join('')} </div> </div> <div style="margin-bottom: 16px;"> <label style="display: block; color:var(--x-text-primary); font-size: 14px; font-weight: 600; margin-bottom: 8px; ">绑定目标（可选）</label> <label style="display: flex; align-items: center; padding: 8px 10px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; cursor: pointer; margin-bottom: 6px; "> <input type="checkbox" id="wb-bind-all" ${worldBook?.bindToAll ? 'checked' : ''} style="margin-right: 6px; cursor: pointer;"> <span style="color:var(--x-text-primary); font-size: 13px;">绑定到全局对话</span> </label> <label style="display: flex; align-items: center; padding: 8px 10px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; cursor: pointer; margin-bottom: 6px; "> <input type="checkbox" id="wb-bind-character-only" ${worldBook?.bindToCharacterOnly ? 'checked' : ''} style="margin-right: 6px; cursor: pointer;"> <span style="color:var(--x-text-primary); font-size: 13px;">绑定到仅角色对话</span> </label> <div style="margin-top: 6px;"> <label style="display: block; color:var(--x-text-secondary); font-size: 12px; margin-bottom: 6px; ">绑定到指定角色（任何相关情景都会使用）：</label> <div id="wb-character-list" style="max-height: 160px; overflow-y: auto; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 6px; "> </div> </div> </div> <div style="display: flex; gap: 10px; margin-top: 20px;"> <button type="button" onclick="closeWorldBookModal()" style="flex: 1; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 20px; padding: 11px; color:var(--x-text-primary); font-size: 14px; font-weight: 600; cursor: pointer; box-sizing: border-box; ">取消</button> <button type="submit" style="flex: 1; background-color: var(--x-accent); border: none; border-radius: 20px; padding: 11px; color: #fff; font-size: 14px; font-weight: 600; cursor: pointer; box-sizing: border-box; ">${ isEdit ? '保存修改' : '创建世界书' }</button> </div> </form> </div> </div> `; const xScreen = document.getElementById('x-social-screen'); if (xScreen) { xScreen.appendChild(modal); } else { document.body.appendChild(modal); } if (isEdit) { modal.setAttribute('data-edit-index', editIndex); } loadWorldBookCharactersList(worldBook?.boundCharacters || []); modal.addEventListener('click', e => { if (e.target === modal) { closeWorldBookModal(); } }); } async function loadWorldBookCharactersList(selectedCharacters = []) { try { const db = getDB(); const allChats = await db.chats.toArray(); const characters = allChats.filter(chat => !chat.isGroup); const container = document.getElementById('wb-character-list'); if (!container) return; if (characters.length === 0) { container.innerHTML = ` <div style="color:var(--x-text-secondary); font-size: 12px; text-align: center; padding: 16px; ">暂无可绑定的角色</div> `; return; } container.innerHTML = characters .map( char => ` <label style="display: flex; align-items: center; padding: 6px 8px; border-radius: 6px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <input type="checkbox" name="wb-characters" value="${char.id}" ${selectedCharacters.includes(char.id) ? 'checked' : ''} style="margin-right: 6px; cursor: pointer;"> <span style="color:var(--x-text-primary); font-size: 13px;">${char.name}</span> </label> `, ) .join(''); } catch (error) { console.error('加载角色列表失败:', error); } } window.closeWorldBookModal = function () { const modal = document.getElementById('world-book-modal'); if (modal) { modal.remove(); } }; window.saveWorldBook = async function (event) { event.preventDefault(); const name = document.getElementById('wb-name').value.trim(); const content = document.getElementById('wb-content').value.trim(); if (!name || !content) { showXToast('请填写完整信息', 'error'); return; } const sceneCheckboxes = document.querySelectorAll('input[name="wb-scenes"]:checked'); const scenes = Array.from(sceneCheckboxes).map(cb => cb.value); const bindToAll = document.getElementById('wb-bind-all').checked; const bindToCharacterOnly = document.getElementById('wb-bind-character-only').checked; const characterCheckboxes = document.querySelectorAll('input[name="wb-characters"]:checked'); const boundCharacters = Array.from(characterCheckboxes).map(cb => cb.value); let targetType = 'none'; let selectedCharacters = []; if (bindToAll) { targetType = 'all'; } else if (bindToCharacterOnly) { targetType = 'characterOnly'; } else if (boundCharacters.length > 0) { targetType = 'specific'; selectedCharacters = [...boundCharacters]; } const isIdle = targetType === 'none' && (!scenes || scenes.length === 0); const worldBook = { name, content, scenes, targetType, selectedCharacters, bindToAll, bindToCharacterOnly, boundCharacters, isIdle, createdAt: new Date().toISOString(), }; const modal = document.getElementById('world-book-modal'); const editIndex = modal?.getAttribute('data-edit-index'); if (!xSettingsData.worldBooks) { xSettingsData.worldBooks = []; } if (editIndex !== null && editIndex !== undefined) { xSettingsData.worldBooks[parseInt(editIndex)] = worldBook; showXToast('世界书已更新', 'success'); } else { xSettingsData.worldBooks.push(worldBook); showXToast('世界书已创建', 'success'); } await saveGlobalWorldBooks(); const manageModal = document.getElementById('world-books-manage-modal'); if (manageModal) { renderWorldBooksManageList(); } closeWorldBookModal(); }; async function saveXPreset() { const presetName = prompt('请输入预设名称:'); if (!presetName || presetName.trim() === '') { showXToast('预设名称不能为空', 'error'); return; } try { const presetData = { systemPrompt: document.getElementById('x-system-prompt').value, worldSetting: document.getElementById('x-world-setting').value, characterBinding: xSettingsData.characterBinding || false, boundCharacters: xSettingsData.boundCharacters || [], }; const db = getXDB(); await db.xPresets.add({ name: presetName.trim(), ...presetData, createdAt: new Date().toISOString(), }); showXToast(`预设"${presetName}"已保存`, 'success'); loadXPresetsList(); } catch (error) { console.error('保存预设失败:', error); showXToast('保存预设失败: ' + error.message, 'error'); } } async function loadXPresetsList() { try { const db = getXDB(); const presets = await db.xPresets.orderBy('createdAt').reverse().toArray(); const presetsList = document.getElementById('x-presets-list'); if (presets.length === 0) { presetsList.innerHTML = '<p style="color: #71767b; font-size: 14px; text-align: center; margin: 20px 0;">暂无保存的预设</p>'; return; } presetsList.innerHTML = presets .map( preset => ` <div class="preset-item" style="display: flex; align-items: center; justify-content: space-between; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px; margin-bottom: 8px;"> <div style="flex: 1; min-width: 0;"> <div style="color: #fff; font-weight: 600; font-size: 15px; margin-bottom: 4px; word-wrap: break-word;">${ preset.name }</div> <div style="color: #71767b; font-size: 13px;">${new Date(preset.createdAt).toLocaleString()}</div> </div> <div style="display: flex; gap: 8px; flex-shrink: 0;"> <button onclick="loadXPreset(${preset.id})" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 15px; padding: 6px 12px; font-size: 12px; cursor: pointer; white-space: nowrap;"> 加载 </button> <button onclick="deleteXPreset(${preset.id})" style="background-color: #f4212e; color: #fff; border: none; border-radius: 15px; padding: 6px 12px; font-size: 12px; cursor: pointer; white-space: nowrap;"> 删除 </button> </div> </div> `, ) .join(''); } catch (error) { console.error('加载预设列表失败:', error); } } async function loadXPreset(presetId) { try { const db = getXDB(); const preset = await db.xPresets.get(presetId); if (preset) { xSettingsData.systemPrompt = preset.systemPrompt || ''; xSettingsData.worldSetting = preset.worldSetting || ''; xSettingsData.characterBinding = preset.characterBinding || false; xSettingsData.boundCharacters = preset.boundCharacters || []; await loadXSettingsToUI(); showXToast(`已加载预设"${preset.name}"`, 'success'); } } catch (error) { console.error('加载预设失败:', error); showXToast('加载预设失败: ' + error.message, 'error'); } } async function deleteXPreset(presetId) { if (!confirm('确定要删除这个预设吗？')) return; try { const db = getXDB(); await db.xPresets.delete(presetId); showXToast('预设已删除', 'success'); loadXPresetsList(); } catch (error) { console.error('删除预设失败:', error); showXToast('删除预设失败: ' + error.message, 'error'); } } async function exportXData() { try { const xDb = getXDB(); const exportData = { xSettings: await xDb.xSettings.toArray(), xUserProfile: await xDb.xUserProfile.toArray(), xTweetsData: await xDb.xTweetsData.toArray(), xUserTweets: await xDb.xUserTweets.toArray(), xCharacterProfiles: await xDb.xCharacterProfiles.toArray(), xPresets: await xDb.xPresets.toArray(), xAskbox: await xDb.xAskbox.toArray(), xActiveAccount: await xDb.xActiveAccount.toArray(), xAccountList: await xDb.xAccountList.toArray(), xNPCs: await xDb.xNPCs.toArray(), xAccountProfiles: await xDb.xAccountProfiles.toArray(), xAccountAskbox: await xDb.xAccountAskbox.toArray(), xBookmarks: await xDb.xBookmarks.toArray(), xCharacterRelationships: await xDb.xCharacterRelationships.toArray(), exportTime: new Date().toISOString(), version: '2.1', dataType: 'x-social-full-backup', }; const dataStr = JSON.stringify(exportData, null, 2); const dataBlob = new Blob([dataStr], { type: 'application/json' }); const link = document.createElement('a'); link.href = URL.createObjectURL(dataBlob); link.download = `x-data-backup-${new Date().toISOString().split('T')[0]}.json`; link.click(); showXToast('所有数据已导出', 'success'); console.log('✅ X数据导出成功，包含:', { 设置数: exportData.xSettings.length, 用户资料数: exportData.xUserProfile.length, 推文数据数: exportData.xTweetsData.length, 用户推文数: exportData.xUserTweets.length, 角色X资料数: exportData.xCharacterProfiles.length, 预设数: exportData.xPresets.length, 用户提问箱数: exportData.xAskbox.length, 活跃账户数: exportData.xActiveAccount.length, 账户列表数: exportData.xAccountList.length, NPC设置数: exportData.xNPCs.length, 账户主页数据数: exportData.xAccountProfiles.length, 账户提问箱数: exportData.xAccountAskbox.length, 书签数: exportData.xBookmarks.length, 关系册数: exportData.xCharacterRelationships.length, }); } catch (error) { console.error('❌ 导出数据失败:', error); showXToast('导出失败: ' + error.message, 'error'); } } function importXData() { if ( !confirm( '⚠️ 警告：导入数据将完全替换当前所有X数据（包括用户资料、推文、帖子、设置等），此操作不可撤销！\n\n确定要继续吗？', ) ) { return; } const input = document.createElement('input'); input.type = 'file'; input.accept = '.json'; input.onchange = async function (event) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = async function (e) { try { const importData = JSON.parse(e.target.result); if (!importData || importData.dataType !== 'x-social-full-backup') { showXToast('导入失败: 不是有效的X数据备份文件', 'error'); return; } showXToast('正在导入数据，请稍候...', 'info'); const xDb = getXDB(); await xDb.xSettings.clear(); await xDb.xUserProfile.clear(); await xDb.xTweetsData.clear(); await xDb.xUserTweets.clear(); await xDb.xCharacterProfiles.clear(); await xDb.xPresets.clear(); await xDb.xAskbox.clear(); await xDb.xActiveAccount.clear(); await xDb.xAccountList.clear(); await xDb.xNPCs.clear(); await xDb.xAccountProfiles.clear(); await xDb.xAccountAskbox.clear(); await xDb.xBookmarks.clear(); await xDb.xCharacterRelationships.clear(); console.log('✅ 已清空旧数据'); if (importData.xSettings && importData.xSettings.length > 0) { await xDb.xSettings.bulkAdd(importData.xSettings); } if (importData.xUserProfile && importData.xUserProfile.length > 0) { await xDb.xUserProfile.bulkAdd(importData.xUserProfile); } if (importData.xTweetsData && importData.xTweetsData.length > 0) { await xDb.xTweetsData.bulkAdd(importData.xTweetsData); } if (importData.xUserTweets && importData.xUserTweets.length > 0) { await xDb.xUserTweets.bulkAdd(importData.xUserTweets); } if (importData.xCharacterProfiles && importData.xCharacterProfiles.length > 0) { await xDb.xCharacterProfiles.bulkAdd(importData.xCharacterProfiles); } if (importData.xPresets && importData.xPresets.length > 0) { await xDb.xPresets.bulkAdd(importData.xPresets); } if (importData.xAskbox && importData.xAskbox.length > 0) { await xDb.xAskbox.bulkAdd(importData.xAskbox); } if (importData.xActiveAccount && importData.xActiveAccount.length > 0) { await xDb.xActiveAccount.bulkAdd(importData.xActiveAccount); } if (importData.xAccountList && importData.xAccountList.length > 0) { await xDb.xAccountList.bulkAdd(importData.xAccountList); } if (importData.xNPCs && importData.xNPCs.length > 0) { await xDb.xNPCs.bulkAdd(importData.xNPCs); } if (importData.xAccountProfiles && importData.xAccountProfiles.length > 0) { await xDb.xAccountProfiles.bulkAdd(importData.xAccountProfiles); } if (importData.xAccountAskbox && importData.xAccountAskbox.length > 0) { await xDb.xAccountAskbox.bulkAdd(importData.xAccountAskbox); } if (importData.xBookmarks && importData.xBookmarks.length > 0) { await xDb.xBookmarks.bulkAdd(importData.xBookmarks); } if (importData.xCharacterRelationships && importData.xCharacterRelationships.length > 0) { await xDb.xCharacterRelationships.bulkAdd(importData.xCharacterRelationships); } console.log('✅ X数据导入成功，包含:', { 设置数: importData.xSettings?.length || 0, 用户资料数: importData.xUserProfile?.length || 0, 推文数据数: importData.xTweetsData?.length || 0, 用户推文数: importData.xUserTweets?.length || 0, 角色X资料数: importData.xCharacterProfiles?.length || 0, 预设数: importData.xPresets?.length || 0, 用户提问箱数: importData.xAskbox?.length || 0, 活跃账户数: importData.xActiveAccount?.length || 0, 账户列表数: importData.xAccountList?.length || 0, NPC设置数: importData.xNPCs?.length || 0, 账户主页数据数: importData.xAccountProfiles?.length || 0, 账户提问箱数: importData.xAccountAskbox?.length || 0, 书签数: importData.xBookmarks?.length || 0, 关系册数: importData.xCharacterRelationships?.length || 0, }); showXToast('数据导入成功！页面即将刷新...', 'success'); setTimeout(() => { window.location.reload(); }, 1500); } catch (error) { console.error('❌ 导入数据失败:', error); showXToast('导入失败: ' + error.message, 'error'); } }; reader.readAsText(file); }; input.click(); } function toggleCharacterBinding() { xSettingsData.characterBinding = !xSettingsData.characterBinding; updateCharacterToggleUI(); const bindingArea = document.getElementById('character-binding-area'); if (xSettingsData.characterBinding) { bindingArea.style.display = 'block'; loadCharactersList(); } else { bindingArea.style.display = 'none'; if (!xSettingsData.boundCharacters) xSettingsData.boundCharacters = []; } } function updateCharacterToggleUI() { const toggle = document.getElementById('x-character-toggle'); const circle = toggle.querySelector('.toggle-circle'); if (xSettingsData.characterBinding) { toggle.style.backgroundColor = 'var(--x-accent)'; circle.style.left = '22px'; } else { toggle.style.backgroundColor = '#333'; circle.style.left = '2px'; } } async function loadCharactersList() { try { const db = getDB(); const allChats = await db.chats.toArray(); const characters = allChats.filter(chat => !chat.isGroup); const charactersList = document.getElementById('characters-list'); if (characters.length === 0) { charactersList.innerHTML = TemplateBuilders.buildEmptyState('暂无可绑定的角色，请先创建角色聊天'); return; } if (!xSettingsData.boundCharacters) xSettingsData.boundCharacters = []; charactersList.innerHTML = characters .map(character => { const isChecked = xSettingsData.boundCharacters.includes(character.id); return TemplateBuilders.buildCharacterItem(character, isChecked); }) .join(''); } catch (error) { ValidationUtils.handleError(error, '加载角色列表'); document.getElementById('characters-list').innerHTML = TemplateBuilders.buildErrorState('加载角色列表失败'); } } function toggleCharacterSelection(characterId) { if (!xSettingsData.boundCharacters) { xSettingsData.boundCharacters = []; } const index = xSettingsData.boundCharacters.indexOf(characterId); if (index > -1) { xSettingsData.boundCharacters.splice(index, 1); } else { xSettingsData.boundCharacters.push(characterId); } const checkbox = document.querySelector(`[data-character-id="${characterId}"]`); if (checkbox) { const isChecked = xSettingsData.boundCharacters.includes(characterId); checkbox.outerHTML = TemplateBuilders.buildCheckbox(characterId, isChecked); } } let longPressTimer = null; let longPressTarget = null; function startLongPress(characterId) { longPressTarget = characterId; longPressTimer = setTimeout(() => { if (longPressTarget === characterId) { openCharacterXProfile(characterId); } }, 500); } function endLongPress() { if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; } longPressTarget = null; } async function openCharacterXProfile(characterId) { try { const modalElement = document.getElementById('character-x-profile-modal'); if (!modalElement) { console.error('❌ 角色X资料弹窗元素不存在于DOM中'); showXToast('无法打开X资料设置，请先绑定角色', 'error'); return; } const db = getDB(); const xDb = getXDB(); const character = await db.chats.get(characterId); if (!character) { showXToast('未找到角色信息', 'error'); return; } let xProfile = await xDb.xCharacterProfiles.get(characterId); if (!xProfile) { xProfile = { characterId: characterId, xName: character.name, xHandle: character.name.toLowerCase().replace(/\s+/g, '_'), xAvatar: 'https: xVerified: false, xBio: '', relationships: [], }; } if (!xProfile.relationships) { xProfile.relationships = []; } const formElement = document.getElementById('character-x-profile-form'); if (!formElement) { console.error('❌ 角色X资料表单不存在，弹窗可能未正确加载'); showXToast('弹窗加载失败，请先勾选绑定该角色，然后刷新页面重试', 'error'); const modal = document.getElementById('character-x-profile-modal'); if (modal) modal.style.display = 'none'; return; } const infoDisplay = document.getElementById('character-info-display'); if (infoDisplay) { infoDisplay.innerHTML = TemplateBuilders.buildCharacterInfoDisplay(character); } const avatarElement = document.getElementById('character-x-avatar'); const avatarUrlElement = document.getElementById('character-x-avatar-url'); const coverPreviewElement = document.getElementById('character-x-cover-preview'); const coverUrlElement = document.getElementById('character-x-cover-url'); const nameElement = document.getElementById('character-x-name'); const handleElement = document.getElementById('character-x-handle'); const verifiedElement = document.getElementById('character-x-verified'); const tag1IconElement = document.getElementById('character-tag1-icon'); const tag1TextElement = document.getElementById('character-custom-tag1'); const tag1ColorElement = document.getElementById('character-tag1-color'); const tag2IconElement = document.getElementById('character-tag2-icon'); const tag2TextElement = document.getElementById('character-custom-tag2'); const tag2ColorElement = document.getElementById('character-tag2-color'); const followingCountElement = document.getElementById('character-following-count'); const followersCountElement = document.getElementById('character-followers-count'); const bioElement = document.getElementById('character-x-bio'); const publicIdentityElement = document.getElementById('character-public-identity'); const showRealNameElement = document.getElementById('character-show-real-name'); const realNameElement = document.getElementById('character-real-name'); const defaultAvatar = 'https: const defaultCover = 'https: if (avatarElement) avatarElement.src = xProfile.xAvatar || defaultAvatar; if (avatarUrlElement) avatarUrlElement.value = xProfile.xAvatar || defaultAvatar; if (coverPreviewElement) coverPreviewElement.src = xProfile.xCover || defaultCover; if (coverUrlElement) coverUrlElement.value = xProfile.xCover || ''; if (nameElement) nameElement.value = xProfile.xName || character.name || ''; if (handleElement) handleElement.value = xProfile.xHandle || ''; if (verifiedElement) verifiedElement.checked = xProfile.xVerified || false; if (tag1IconElement) tag1IconElement.value = xProfile.customTag1?.icon || ''; if (tag1TextElement) tag1TextElement.value = xProfile.customTag1?.text || ''; if (tag1ColorElement) tag1ColorElement.value = xProfile.customTag1?.color || '#71767b'; if (tag2IconElement) tag2IconElement.value = xProfile.customTag2?.icon || ''; if (tag2TextElement) tag2TextElement.value = xProfile.customTag2?.text || ''; if (tag2ColorElement) tag2ColorElement.value = xProfile.customTag2?.color || '#71767b'; if (followingCountElement) followingCountElement.value = xProfile.followingCount || ''; if (followersCountElement) followersCountElement.value = xProfile.followersCount || ''; if (bioElement) bioElement.value = xProfile.xBio || ''; if (publicIdentityElement) publicIdentityElement.value = xProfile.publicIdentity || ''; if (showRealNameElement) showRealNameElement.checked = xProfile.showRealName || false; if (realNameElement) realNameElement.value = xProfile.realName || ''; toggleCharacterRealNameInput(); const autoMessageEnabledElement = document.getElementById('character-auto-message-enabled'); const autoMessageIntervalElement = document.getElementById('character-auto-message-interval'); if (autoMessageEnabledElement) { autoMessageEnabledElement.checked = xProfile.autoMessageEnabled || false; } if (autoMessageIntervalElement) { autoMessageIntervalElement.value = xProfile.autoMessageInterval || 60; } window.toggleAutoMessageSettings(); updateCharacterXProfileCounts(); formElement.setAttribute('data-character-id', characterId); console.log('📖 [打开X资料] 加载关系数据，关系数:', (xProfile.relationships || []).length); renderRelationshipsList(xProfile.relationships || []); const modal = document.getElementById('character-x-profile-modal'); if (modal) { modal.style.display = 'block'; } } catch (error) { ValidationUtils.handleError(error, '打开角色X资料'); } } function closeCharacterXProfileModal() { const modal = document.getElementById('character-x-profile-modal'); if (modal) { modal.style.display = 'none'; } } function updateCharacterXAvatar(url) { const avatarImg = document.getElementById('character-x-avatar'); if (!url || url.trim() === '') { avatarImg.src = 'https: return; } try { new URL(url); } catch (e) { avatarImg.src = 'https: return; } const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp']; const isImageUrl = imageExtensions.some(ext => url.toLowerCase().includes(ext)); if (!isImageUrl) { avatarImg.onerror = function () { this.src = 'https: showXToast('头像链接无效，已使用默认头像', 'warning'); }; } avatarImg.src = url; } function updateCharacterXCover(url) { const coverImg = document.getElementById('character-x-cover-preview'); if (!url || url.trim() === '') { coverImg.src = 'https: return; } try { new URL(url); } catch (e) { coverImg.src = 'https: return; } const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp']; const isImageUrl = imageExtensions.some(ext => url.toLowerCase().includes(ext)); if (!isImageUrl) { coverImg.onerror = function () { this.src = 'https: showXToast('背景图链接无效，已使用默认背景', 'warning'); }; } coverImg.src = url; } function updateCharacterBioCount() { updateCharacterXProfileCounts(); } function updateCharacterXProfileCounts() { const bioTextarea = document.getElementById('character-x-bio'); const bioCountSpan = document.getElementById('character-bio-count'); if (bioTextarea && bioCountSpan) { bioCountSpan.textContent = bioTextarea.value.length; } const realNameInput = document.getElementById('character-real-name'); const realNameCountSpan = document.getElementById('character-real-name-count'); if (realNameInput && realNameCountSpan) { realNameCountSpan.textContent = realNameInput.value.length; } } async function saveCharacterXProfile(event) { event.preventDefault(); const formElement = document.getElementById('character-x-profile-form'); if (!formElement) { showXToast('表单元素未找到', 'error'); return; } const characterId = formElement.getAttribute('data-character-id'); if (!characterId) { showXToast('角色ID未找到', 'error'); return; } const getElementValue = (id, defaultValue = '') => { const element = document.getElementById(id); return element ? element.value.trim() : defaultValue; }; const getElementChecked = (id, defaultValue = false) => { const element = document.getElementById(id); return element ? element.checked : defaultValue; }; const xName = getElementValue('character-x-name'); const xHandle = getElementValue('character-x-handle'); const xAvatarUrl = getElementValue('character-x-avatar-url'); const xAvatar = xAvatarUrl || 'https: const xVerified = getElementChecked('character-x-verified'); const xCoverUrl = getElementValue('character-x-cover-url'); const xCover = xCoverUrl || 'https: const tag1Icon = getElementValue('character-tag1-icon'); const tag1Text = getElementValue('character-custom-tag1'); const tag1ColorElement = document.getElementById('character-tag1-color'); const tag1Color = tag1ColorElement ? tag1ColorElement.value : '#71767b'; const tag2Icon = getElementValue('character-tag2-icon'); const tag2Text = getElementValue('character-custom-tag2'); const tag2ColorElement = document.getElementById('character-tag2-color'); const tag2Color = tag2ColorElement ? tag2ColorElement.value : '#71767b'; const followingCount = getElementValue('character-following-count'); const followersCount = getElementValue('character-followers-count'); const xBio = getElementValue('character-x-bio'); const publicIdentity = getElementValue('character-public-identity'); const showRealName = getElementChecked('character-show-real-name'); const realName = getElementValue('character-real-name'); const autoMessageEnabled = getElementChecked('character-auto-message-enabled'); const autoMessageInterval = parseInt(getElementValue('character-auto-message-interval')) || 60; if (!xName) { showXToast('X用户名不能为空', 'error'); return; } if (!xHandle) { showXToast('X句柄不能为空', 'error'); return; } if (xName.length > 50) { showXToast('X用户名不能超过50个字符', 'error'); return; } if (xHandle.length > 15) { showXToast('X句柄不能超过15个字符', 'error'); return; } if (xBio && xBio.length > 160) { showXToast('X简介不能超过160个字符', 'error'); return; } if (showRealName && realName && realName.length > 50) { showXToast('真实姓名不能超过50个字符', 'error'); return; } if (showRealName && !realName) { showXToast('建议填写真实姓名', 'warning'); } if (autoMessageEnabled) { if (autoMessageInterval < 10) { showXToast('自动发消息间隔不能少于10秒', 'error'); return; } if (autoMessageInterval > 3600) { showXToast('自动发消息间隔不能超过3600秒', 'error'); return; } } if (xAvatarUrl) { try { new URL(xAvatarUrl); } catch (e) { showXToast('头像URL格式无效，将使用默认头像', 'warning'); } } try { const db = getXDB(); console.log('💾 [保存X资料] 开始保存，当前关系数:', currentRelationships.length); const existingProfile = await db.xCharacterProfiles.get(characterId); const userPersona = existingProfile?.userPersona || ''; console.log('💾 [保存X资料] 保留现有用户人设，长度:', userPersona.length, '字符'); await db.xCharacterProfiles.put({ characterId: characterId, xName: xName, xHandle: xHandle, xAvatar: xAvatar, xVerified: xVerified, xCover: xCover, customTag1: tag1Text ? { icon: tag1Icon, text: tag1Text, color: tag1Color } : null, customTag2: tag2Text ? { icon: tag2Icon, text: tag2Text, color: tag2Color } : null, followingCount: followingCount, followersCount: followersCount, xBio: xBio, publicIdentity: publicIdentity, showRealName: showRealName, realName: showRealName ? realName : '', relationships: JSON.parse(JSON.stringify(currentRelationships)), autoMessageEnabled: autoMessageEnabled, autoMessageInterval: autoMessageInterval, userPersona: userPersona, lastUpdated: new Date().toISOString(), }); console.log('✅ [保存X资料] X资料已保存，关系数:', currentRelationships.length); showXToast('X资料已保存', 'success'); if (typeof stopAutoMessageSystem === 'function' && typeof startAutoMessageSystem === 'function') { stopAutoMessageSystem(); setTimeout(() => { startAutoMessageSystem(); }, 500); } closeCharacterXProfileModal(); } catch (error) { console.error('❌ [保存X资料] 保存角色X资料失败:', error); showXToast('保存失败: ' + error.message, 'error'); } } let currentEditingRelationshipId = null; let currentRelationships = []; function renderRelationshipsList(relationships) { currentRelationships = relationships ? JSON.parse(JSON.stringify(relationships)) : []; console.log('📋 [渲染关系列表] 当前关系数:', currentRelationships.length); const container = document.getElementById('character-relationships-list'); if (currentRelationships.length === 0) { container.innerHTML = ` <div style="text-align: center; color: #71767b; font-size: 13px; padding: 20px;"> 暂无绑定关系，点击上方"添加关系"按钮开始绑定NPC </div> `; return; } container.innerHTML = currentRelationships .map( rel => ` <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px; margin-bottom: 8px;"> <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;"> <div style="flex: 1;"> <div style="color: #fff; font-weight: 600; font-size: 14px; margin-bottom: 4px;"> ${rel.npcName} <span style="color: #71767b; font-weight: normal;">${rel.npcHandle}</span> </div> <div style="color: var(--x-accent); font-size: 12px; background-color: rgba(29,155,240,0.1); padding: 2px 8px; border-radius: 12px; display: inline-block; margin-bottom: 6px;"> ${rel.relationshipType} </div> </div> <div style="display: flex; gap: 8px;"> <button onclick="editRelationship('${rel.id}')" style="background: none; border: none; color: var(--x-accent); cursor: pointer; padding: 4px 8px; font-size: 12px;"> 编辑 </button> <button onclick="deleteRelationship('${rel.id}')" style="background: none; border: none; color: #f4212e; cursor: pointer; padding: 4px 8px; font-size: 12px;"> 删除 </button> </div> </div> ${rel.description ? `<div style="color: #71767b; font-size: 12px; line-height: 1.4;">${rel.description}</div>` : ''} </div> `, ) .join(''); } function openAddRelationshipModal() { currentEditingRelationshipId = null; document.getElementById('relationship-modal-title').textContent = '添加NPC关系'; document.getElementById('relationship-npc-name').value = ''; document.getElementById('relationship-npc-handle').value = ''; document.getElementById('relationship-type').value = '朋友'; document.getElementById('relationship-description').value = ''; updateRelationshipDescCount(); document.getElementById('relationship-modal').style.display = 'block'; } function editRelationship(relationshipId) { const relationship = currentRelationships.find(rel => rel.id === relationshipId); if (!relationship) return; currentEditingRelationshipId = relationshipId; document.getElementById('relationship-modal-title').textContent = '编辑NPC关系'; document.getElementById('relationship-npc-name').value = relationship.npcName; document.getElementById('relationship-npc-handle').value = relationship.npcHandle; document.getElementById('relationship-type').value = relationship.relationshipType; document.getElementById('relationship-description').value = relationship.description || ''; updateRelationshipDescCount(); document.getElementById('relationship-modal').style.display = 'block'; } async function deleteRelationship(relationshipId) { if (!confirm('确定要删除这个关系绑定吗？')) return; try { console.log('🗑️ [删除关系] 开始删除关系:', relationshipId); console.log('🗑️ [删除关系] 删除前关系数:', currentRelationships.length); const beforeLength = currentRelationships.length; currentRelationships = currentRelationships.filter(rel => rel.id !== relationshipId); const afterLength = currentRelationships.length; console.log('🗑️ [删除关系] 删除后关系数:', afterLength); if (beforeLength === afterLength) { console.warn('⚠️ [删除关系] 未找到要删除的关系'); showXToast('未找到要删除的关系', 'warning'); return; } await saveRelationshipsToDatabase(); renderRelationshipsList(currentRelationships); showXToast('关系已删除', 'success'); } catch (error) { console.error('❌ [删除关系] 删除关系失败:', error); showXToast(`删除失败: ${error.message}`, 'error'); } } function closeRelationshipModal() { document.getElementById('relationship-modal').style.display = 'none'; currentEditingRelationshipId = null; } function updateRelationshipDescCount() { const descTextarea = document.getElementById('relationship-description'); const countSpan = document.getElementById('relationship-desc-count'); countSpan.textContent = descTextarea.value.length; } async function saveRelationshipsToDatabase() { const characterId = document.getElementById('character-x-profile-form').getAttribute('data-character-id'); if (!characterId) { console.error('❌ [保存关系] 无法获取角色ID'); throw new Error('无法获取角色ID，保存失败'); } try { const db = getXDB(); const currentProfile = await db.xCharacterProfiles.get(characterId); if (!currentProfile) { console.error('❌ [保存关系] 未找到角色资料:', characterId); throw new Error('未找到角色资料'); } currentProfile.relationships = JSON.parse(JSON.stringify(currentRelationships)); await db.xCharacterProfiles.put(currentProfile); console.log('✅ [保存关系] 关系已保存到数据库，当前关系数:', currentProfile.relationships.length); } catch (error) { console.error('❌ [保存关系] 保存关系到数据库失败:', error); throw error; } } async function saveRelationshipForm(event) { event.preventDefault(); const npcName = document.getElementById('relationship-npc-name').value.trim(); const npcHandle = document.getElementById('relationship-npc-handle').value.trim(); const relationshipType = document.getElementById('relationship-type').value; const description = document.getElementById('relationship-description').value.trim(); if (!npcName) { showXToast('NPC名称不能为空', 'error'); return; } if (!npcHandle) { showXToast('NPC句柄不能为空', 'error'); return; } const handleFormatted = npcHandle.startsWith('@') ? npcHandle : `@${npcHandle}`; try { if (currentEditingRelationshipId) { const relationshipIndex = currentRelationships.findIndex(rel => rel.id === currentEditingRelationshipId); if (relationshipIndex !== -1) { currentRelationships[relationshipIndex] = { ...currentRelationships[relationshipIndex], npcName: npcName, npcHandle: handleFormatted, relationshipType: relationshipType, description: description, updatedAt: new Date().toISOString(), }; } } else { const newRelationship = { id: 'rel_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9), npcName: npcName, npcHandle: handleFormatted, relationshipType: relationshipType, description: description, createdAt: new Date().toISOString(), }; currentRelationships.push(newRelationship); } await saveRelationshipsToDatabase(); renderRelationshipsList(currentRelationships); closeRelationshipModal(); showXToast(currentEditingRelationshipId ? '关系已更新' : '关系已添加', 'success'); } catch (error) { console.error('保存关系失败:', error); showXToast('保存失败', 'error'); } } let characterRelationshipData = { characters: [], links: [], }; let currentEditingLinkId = null; async function toggleCharacterRelationship() { if (!xSettingsData.characterRelationship) { xSettingsData.characterRelationship = {}; } xSettingsData.characterRelationship.enabled = !xSettingsData.characterRelationship.enabled; updateRelationshipToggleUI(); const relationshipArea = document.getElementById('relationship-binding-area'); if (xSettingsData.characterRelationship.enabled) { relationshipArea.style.display = 'block'; await loadRelationshipData(); setTimeout(() => { updateRelationshipPreview(); }, 100); } else { relationshipArea.style.display = 'none'; } await saveXSettings(); } function updateRelationshipToggleUI() { const toggle = document.getElementById('x-relationship-toggle'); const circle = toggle?.querySelector('.toggle-circle'); if (!toggle || !circle) return; const enabled = xSettingsData.characterRelationship?.enabled || false; if (enabled) { toggle.style.backgroundColor = 'var(--x-accent)'; circle.style.left = '22px'; } else { toggle.style.backgroundColor = '#333'; circle.style.left = '2px'; } } async function loadRelationshipData() { try { const db = getXDB(); const currentAccount = currentAccountId || 'main'; const dataId = `xCharacterRelationships_${currentAccount}`; const savedData = await db.xCharacterRelationships.get(dataId); const boundChars = xSettingsData.boundCharacters || []; const mainDB = getDB(); const allChats = await mainDB.chats.toArray(); const currentBoundCharacters = allChats .filter(chat => !chat.isGroup && boundChars.includes(chat.id)) .map(chat => ({ id: chat.id, name: chat.name, avatar: chat.settings?.aiAvatar || 'https: })); if (savedData && savedData.data) { characterRelationshipData = savedData.data; const existingCharIds = new Set(characterRelationshipData.characters.map(c => c.id)); const currentCharIds = new Set(currentBoundCharacters.map(c => c.id)); currentBoundCharacters.forEach(char => { if (!existingCharIds.has(char.id)) { characterRelationshipData.characters.push(char); console.log('➕ 新增角色到关系册:', char.name); } }); characterRelationshipData.characters = characterRelationshipData.characters.filter(char => { const isStillBound = currentCharIds.has(char.id); if (!isStillBound) { console.log('➖ 从关系册移除角色:', char.name); characterRelationshipData.links = characterRelationshipData.links.filter( link => link.charA !== char.id && link.charB !== char.id, ); } return isStillBound; }); characterRelationshipData.characters.forEach(char => { const updatedChar = currentBoundCharacters.find(c => c.id === char.id); if (updatedChar) { char.name = updatedChar.name; char.avatar = updatedChar.avatar; } }); } else { characterRelationshipData.characters = currentBoundCharacters; characterRelationshipData.links = []; } console.log('✅ 已加载角色关系数据:', { 角色数: characterRelationshipData.characters.length, 关系数: characterRelationshipData.links.length, 角色列表: characterRelationshipData.characters.map(c => c.name), }); } catch (error) { console.error('❌ 加载关系数据失败:', error); } } function updateRelationshipPreview() { const canvas = document.getElementById('relationship-preview-canvas'); const placeholder = document.getElementById('relationship-preview-placeholder'); const stats = document.getElementById('relationship-stats'); if (!canvas) return; const linkCount = characterRelationshipData.links?.length || 0; const charCount = characterRelationshipData.characters?.length || 0; const chars = characterRelationshipData.characters || []; const links = characterRelationshipData.links || []; if (charCount > 0) { placeholder.style.display = 'none'; stats.style.display = 'block'; document.getElementById('relationship-character-count').textContent = charCount; document.getElementById('relationship-link-count').textContent = linkCount; const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, canvas.width, canvas.height); const computedStyle = getComputedStyle(document.documentElement); const accentColor = computedStyle.getPropertyValue('--x-accent').trim() || '#1d9bf0'; const bgColor = computedStyle.getPropertyValue('--x-bg-primary').trim() || '#000'; const textColor = computedStyle.getPropertyValue('--x-text-primary').trim() || '#fff'; const scale = 0.5; const centerX = canvas.width / 2; const centerY = canvas.height / 2; const radius = Math.min(canvas.width, canvas.height) / 2 - 20; chars.forEach((char, index) => { const angle = (index / chars.length) * Math.PI * 2 - Math.PI / 2; char.previewX = centerX + radius * Math.cos(angle); char.previewY = centerY + radius * Math.sin(angle); }); ctx.strokeStyle = accentColor; ctx.lineWidth = 1.5; links.forEach(link => { const charA = chars.find(c => c.id === link.charA); const charB = chars.find(c => c.id === link.charB); if (charA && charB) { ctx.beginPath(); ctx.moveTo(charA.previewX, charA.previewY); ctx.lineTo(charB.previewX, charB.previewY); ctx.stroke(); } }); chars.forEach(char => { ctx.beginPath(); ctx.arc(char.previewX, char.previewY, 15, 0, Math.PI * 2); ctx.fillStyle = accentColor; ctx.fill(); ctx.strokeStyle = bgColor; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = textColor; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(char.name.charAt(0), char.previewX, char.previewY); }); } else { placeholder.style.display = 'block'; stats.style.display = 'none'; } } let resizeTimeout; function handleRelationshipCanvasResize() { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { const modal = document.getElementById('character-relationship-graph-modal'); if (modal && modal.style.display !== 'none') { initRelationshipCanvas(); renderRelationshipGraph(); } }, 300); } function handleRelationshipGraphKeyPress(event) { if (event.key === 'Escape' && isSelectingCharsForLink) { isSelectingCharsForLink = false; selectedCharForLink = null; renderRelationshipGraph(); showXToast('已取消选择', 'info'); console.log('📍 已退出角色选择模式'); } } async function openCharacterRelationshipGraph() { await loadRelationshipData(); const modal = document.getElementById('character-relationship-graph-modal'); if (modal) { modal.style.display = 'block'; document.body.style.overflow = 'hidden'; setTimeout(() => { initRelationshipCanvas(); renderRelationshipGraph(); renderRelationshipList(); }, 100); window.addEventListener('resize', handleRelationshipCanvasResize); window.addEventListener('orientationchange', handleRelationshipCanvasResize); window.addEventListener('keydown', handleRelationshipGraphKeyPress); } } function closeCharacterRelationshipGraph(event) { if (event && event.target !== event.currentTarget) return; const modal = document.getElementById('character-relationship-graph-modal'); if (modal) { modal.style.display = 'none'; document.body.style.overflow = 'auto'; isSelectingCharsForLink = false; selectedCharForLink = null; window.removeEventListener('resize', handleRelationshipCanvasResize); window.removeEventListener('orientationchange', handleRelationshipCanvasResize); window.removeEventListener('keydown', handleRelationshipGraphKeyPress); } } let isDragging = false; let draggedCharId = null; let dragOffsetX = 0; let dragOffsetY = 0; let isSelectingCharsForLink = false; let selectedCharForLink = null; function initRelationshipCanvas() { const canvas = document.getElementById('relationship-graph-canvas'); if (!canvas) return; const container = canvas.parentElement; canvas.width = container.clientWidth; canvas.height = container.clientHeight; canvas.onmousedown = handleCanvasMouseDown; canvas.onmousemove = handleCanvasMouseMove; canvas.onmouseup = handleCanvasMouseUp; canvas.onclick = handleCanvasClick; canvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: false }); canvas.addEventListener('touchmove', handleCanvasTouchMove, { passive: false }); canvas.addEventListener('touchend', handleCanvasTouchEnd, { passive: false }); } const avatarImageCache = {}; function renderRelationshipGraph() { const canvas = document.getElementById('relationship-graph-canvas'); const emptyState = document.getElementById('graph-empty-state'); if (!canvas) return; const ctx = canvas.getContext('2d'); const chars = characterRelationshipData.characters || []; const links = characterRelationshipData.links || []; const computedStyle = getComputedStyle(document.documentElement); const accentColor = computedStyle.getPropertyValue('--x-accent').trim() || '#1d9bf0'; const bgPrimary = computedStyle.getPropertyValue('--x-bg-primary').trim() || '#000'; const bgSecondary = computedStyle.getPropertyValue('--x-bg-secondary').trim() || '#1a1a1a'; const textPrimary = computedStyle.getPropertyValue('--x-text-primary').trim() || '#fff'; const isDark = bgPrimary.includes('#000') || bgPrimary.includes('0, 0, 0'); const textBgColor = isDark ? 'rgba(0, 0, 0, 0.7)' : 'rgba(255, 255, 255, 0.85)'; document.getElementById('graph-character-count').textContent = `${chars.length} 角色`; document.getElementById('graph-link-count').textContent = `${links.length} 关系`; if (chars.length === 0) { emptyState.style.display = 'block'; return; } emptyState.style.display = 'none'; ctx.clearRect(0, 0, canvas.width, canvas.height); if (isSelectingCharsForLink) { const tipText = selectedCharForLink ? '请点击第二个角色' : '请点击第一个角色'; ctx.fillStyle = accentColor; ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(tipText, canvas.width / 2, 30); ctx.fillStyle = textPrimary; ctx.font = '12px sans-serif'; ctx.fillText('(按 ESC 键取消)', canvas.width / 2, 50); } const centerX = canvas.width / 2; const centerY = canvas.height / 2; const radius = Math.min(canvas.width, canvas.height) / 3; chars.forEach((char, index) => { if (char.x === undefined || char.y === undefined) { const angle = (index / chars.length) * Math.PI * 2 - Math.PI / 2; char.x = centerX + radius * Math.cos(angle); char.y = centerY + radius * Math.sin(angle); } }); links.forEach(link => { const charA = chars.find(c => c.id === link.charA); const charB = chars.find(c => c.id === link.charB); if (charA && charB) { ctx.beginPath(); ctx.moveTo(charA.x, charA.y); ctx.lineTo(charB.x, charB.y); ctx.strokeStyle = accentColor; ctx.lineWidth = 2; ctx.stroke(); const midX = (charA.x + charB.x) / 2; const midY = (charA.y + charB.y) / 2; const isMobile = window.innerWidth < 768; const textBoxWidth = isMobile ? 70 : 80; const textBoxHeight = isMobile ? 30 : 35; const fontSize = isMobile ? '10px' : '11px'; ctx.fillStyle = textBgColor; ctx.fillRect(midX - textBoxWidth / 2, midY - textBoxHeight / 2, textBoxWidth, textBoxHeight); ctx.fillStyle = accentColor; ctx.font = fontSize + ' sans-serif'; ctx.textAlign = 'center'; const lineSpacing = isMobile ? 12 : 15; ctx.fillText(link.relationAtoB || '关系', midX, midY - lineSpacing / 2); ctx.fillText(link.relationBtoA || '关系', midX, midY + lineSpacing / 2); } }); const isMobile = window.innerWidth < 768; const avatarRadius = isMobile ? 25 : 35; const avatarInnerRadius = avatarRadius - 2; chars.forEach(char => { const isSelected = isSelectingCharsForLink && selectedCharForLink === char.id; if (isSelected) { ctx.beginPath(); ctx.arc(char.x, char.y, avatarRadius + 5, 0, Math.PI * 2); ctx.strokeStyle = accentColor; ctx.lineWidth = 3; ctx.stroke(); } ctx.beginPath(); ctx.arc(char.x, char.y, avatarRadius, 0, Math.PI * 2); ctx.fillStyle = isSelected ? '#FFA500' : accentColor; ctx.fill(); ctx.strokeStyle = bgPrimary; ctx.lineWidth = 2; ctx.stroke(); if (char.avatar) { if (avatarImageCache[char.avatar]) { const img = avatarImageCache[char.avatar]; ctx.save(); ctx.beginPath(); ctx.arc(char.x, char.y, avatarInnerRadius, 0, Math.PI * 2); ctx.closePath(); ctx.clip(); ctx.drawImage( img, char.x - avatarInnerRadius, char.y - avatarInnerRadius, avatarInnerRadius * 2, avatarInnerRadius * 2, ); ctx.restore(); } else { const img = new Image(); img.crossOrigin = 'anonymous'; img.onload = () => { avatarImageCache[char.avatar] = img; renderRelationshipGraph(); }; img.onerror = () => { ctx.fillStyle = textPrimary; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(char.name.charAt(0), char.x, char.y); }; img.src = char.avatar; ctx.fillStyle = textPrimary; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(char.name.charAt(0), char.x, char.y); } } else { ctx.fillStyle = textPrimary; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(char.name.charAt(0), char.x, char.y); } ctx.fillStyle = textPrimary; ctx.font = isMobile ? 'bold 11px sans-serif' : 'bold 12px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'top'; ctx.fillText(char.name, char.x, char.y + avatarRadius + 10); char.radius = avatarRadius; }); } function handleCanvasMouseDown(event) { const canvas = event.target; const rect = canvas.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; const chars = characterRelationshipData.characters || []; for (const char of chars) { const dx = x - char.x; const dy = y - char.y; const radius = char.radius || 35; if (Math.sqrt(dx * dx + dy * dy) < radius) { isDragging = true; draggedCharId = char.id; dragOffsetX = dx; dragOffsetY = dy; canvas.style.cursor = 'grabbing'; return; } } } function handleCanvasTouchStart(event) { event.preventDefault(); const canvas = event.target; const rect = canvas.getBoundingClientRect(); const touch = event.touches[0]; const x = touch.clientX - rect.left; const y = touch.clientY - rect.top; touchStartTime = Date.now(); touchStartX = x; touchStartY = y; const chars = characterRelationshipData.characters || []; for (const char of chars) { const dx = x - char.x; const dy = y - char.y; const radius = char.radius || 35; if (Math.sqrt(dx * dx + dy * dy) < radius) { draggedCharId = char.id; dragOffsetX = dx; dragOffsetY = dy; return; } } } function handleCanvasMouseMove(event) { const canvas = event.target; const rect = canvas.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; const chars = characterRelationshipData.characters || []; if (isDragging && draggedCharId) { const char = chars.find(c => c.id === draggedCharId); if (char) { char.x = x - dragOffsetX; char.y = y - dragOffsetY; renderRelationshipGraph(); } } else { const hoveredChar = chars.find(char => { const dx = x - char.x; const dy = y - char.y; const radius = char.radius || 35; return Math.sqrt(dx * dx + dy * dy) < radius; }); canvas.style.cursor = hoveredChar ? 'grab' : 'default'; } } function handleCanvasTouchMove(event) { event.preventDefault(); const canvas = event.target; const rect = canvas.getBoundingClientRect(); const touch = event.touches[0]; const x = touch.clientX - rect.left; const y = touch.clientY - rect.top; const chars = characterRelationshipData.characters || []; if (draggedCharId && !isDragging) { const dx = x - touchStartX; const dy = y - touchStartY; const distance = Math.sqrt(dx * dx + dy * dy); if (distance > 10) { isDragging = true; console.log('📍 开始拖拽角色'); } } if (isDragging && draggedCharId) { const char = chars.find(c => c.id === draggedCharId); if (char) { char.x = x - dragOffsetX; char.y = y - dragOffsetY; renderRelationshipGraph(); } } } function handleCanvasMouseUp(event) { if (isDragging) { isDragging = false; draggedCharId = null; event.target.style.cursor = 'default'; } } let touchStartTime = 0; let touchStartX = 0; let touchStartY = 0; function handleCanvasTouchEnd(event) { event.preventDefault(); const wasDragging = isDragging; if (isDragging) { isDragging = false; draggedCharId = null; } else if (draggedCharId) { draggedCharId = null; } if (!wasDragging && event.changedTouches && event.changedTouches.length > 0) { const canvas = event.target; const rect = canvas.getBoundingClientRect(); const touch = event.changedTouches[0]; const x = touch.clientX - rect.left; const y = touch.clientY - rect.top; const chars = characterRelationshipData.characters || []; const links = characterRelationshipData.links || []; if (isSelectingCharsForLink) { for (const char of chars) { const dx = x - char.x; const dy = y - char.y; const radius = char.radius || 35; if (Math.sqrt(dx * dx + dy * dy) < radius) { handleCharacterSelection(char); return; } } return; } for (const link of links) { const charA = chars.find(c => c.id === link.charA); const charB = chars.find(c => c.id === link.charB); if (charA && charB) { const dist = distanceToLine(x, y, charA.x, charA.y, charB.x, charB.y); if (dist < 20) { openEditRelationshipDetailModal(link); return; } } } } } function handleCanvasClick(event) { if (isDragging) return; const canvas = event.target; const rect = canvas.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; const chars = characterRelationshipData.characters || []; const links = characterRelationshipData.links || []; if (isSelectingCharsForLink) { for (const char of chars) { const dx = x - char.x; const dy = y - char.y; const radius = char.radius || 35; if (Math.sqrt(dx * dx + dy * dy) < radius) { handleCharacterSelection(char); return; } } return; } for (const link of links) { const charA = chars.find(c => c.id === link.charA); const charB = chars.find(c => c.id === link.charB); if (charA && charB) { const dist = distanceToLine(x, y, charA.x, charA.y, charB.x, charB.y); if (dist < 15) { openEditRelationshipDetailModal(link); return; } } } } function handleCharacterSelection(char) { if (!selectedCharForLink) { selectedCharForLink = char.id; console.log('✅ 已选择第一个角色:', char.name); showXToast(`已选择 ${char.name}，请点击第二个角色`, 'info'); renderRelationshipGraph(); } else { if (selectedCharForLink === char.id) { showXToast('请选择不同的角色', 'error'); return; } const existingLink = characterRelationshipData.links.find( link => (link.charA === selectedCharForLink && link.charB === char.id) || (link.charA === char.id && link.charB === selectedCharForLink), ); if (existingLink) { showXToast('这两个角色已存在关系，请直接点击连线编辑', 'error'); isSelectingCharsForLink = false; selectedCharForLink = null; renderRelationshipGraph(); return; } console.log('✅ 已选择第二个角色:', char.name); const newLink = { id: 'link_' + Date.now(), charA: selectedCharForLink, charB: char.id, relationAtoB: '', relationBtoA: '', story: '', }; characterRelationshipData.links.push(newLink); isSelectingCharsForLink = false; selectedCharForLink = null; renderRelationshipGraph(); renderRelationshipList(); window.characterRelationshipData = characterRelationshipData; setTimeout(() => { openEditRelationshipDetailModal(newLink); }, 100); } } function distanceToLine(px, py, x1, y1, x2, y2) { const A = px - x1; const B = py - y1; const C = x2 - x1; const D = y2 - y1; const dot = A * C + B * D; const lenSq = C * C + D * D; let param = -1; if (lenSq !== 0) param = dot / lenSq; let xx, yy; if (param < 0) { xx = x1; yy = y1; } else if (param > 1) { xx = x2; yy = y2; } else { xx = x1 + param * C; yy = y1 + param * D; } const dx = px - xx; const dy = py - yy; return Math.sqrt(dx * dx + dy * dy); } function addRelationshipLink() { const chars = characterRelationshipData.characters || []; if (chars.length < 2) { showXToast('至少需要2个已绑定角色才能创建关系', 'error'); return; } isSelectingCharsForLink = true; selectedCharForLink = null; showXToast('请点击选择第一个角色', 'info'); console.log('📍 进入角色选择模式'); renderRelationshipGraph(); } function openEditRelationshipDetailModal(link) { currentEditingLinkId = link.id; const chars = characterRelationshipData.characters || []; const charA = chars.find(c => c.id === link.charA); const charB = chars.find(c => c.id === link.charB); if (!charA || !charB) return; document.getElementById('char-a-name').textContent = charA.name; document.getElementById('char-b-name').textContent = charB.name; document.getElementById('char-a-to-b-label').textContent = `${charA.name} 是 ${charB.name} 的：`; document.getElementById('char-b-to-a-label').textContent = `${charB.name} 是 ${charA.name} 的：`; document.getElementById('relationship-a-to-b').value = link.relationAtoB || ''; document.getElementById('relationship-b-to-a').value = link.relationBtoA || ''; document.getElementById('relationship-story').value = link.story || ''; const modal = document.getElementById('edit-relationship-detail-modal'); if (modal) { modal.style.display = 'block'; } } function closeEditRelationshipDetail(event) { if (event && event.target !== event.currentTarget) return; const modal = document.getElementById('edit-relationship-detail-modal'); if (modal) { modal.style.display = 'none'; } currentEditingLinkId = null; } async function saveRelationshipDetail() { if (!currentEditingLinkId) return; const link = characterRelationshipData.links.find(l => l.id === currentEditingLinkId); if (!link) return; link.relationAtoB = document.getElementById('relationship-a-to-b').value.trim(); link.relationBtoA = document.getElementById('relationship-b-to-a').value.trim(); link.story = document.getElementById('relationship-story').value.trim(); renderRelationshipGraph(); renderRelationshipList(); closeEditRelationshipDetail(); try { const db = getXDB(); const currentAccount = currentAccountId || 'main'; const dataId = `xCharacterRelationships_${currentAccount}`; await db.xCharacterRelationships.put({ id: dataId, accountId: currentAccount, data: characterRelationshipData, lastUpdated: new Date().toISOString(), }); updateRelationshipPreview(); showXToast('关系已更新并保存', 'success'); console.log('✅ 关系已自动保存:', link); } catch (error) { console.error('❌ 保存关系失败:', error); showXToast('关系已更新但保存失败', 'error'); } } async function deleteRelationshipLink() { if (!currentEditingLinkId) return; if (!confirm('确定要删除这条关系吗？')) return; characterRelationshipData.links = characterRelationshipData.links.filter(l => l.id !== currentEditingLinkId); renderRelationshipGraph(); renderRelationshipList(); closeEditRelationshipDetail(); try { const db = getXDB(); const currentAccount = currentAccountId || 'main'; const dataId = `xCharacterRelationships_${currentAccount}`; await db.xCharacterRelationships.put({ id: dataId, accountId: currentAccount, data: characterRelationshipData, lastUpdated: new Date().toISOString(), }); updateRelationshipPreview(); showXToast('关系已删除', 'success'); } catch (error) { console.error('❌ 删除关系失败:', error); showXToast('关系已删除但保存失败', 'error'); } } async function clearAllRelationships() { if (!confirm('确定要清空所有关系吗？此操作不可恢复。')) return; characterRelationshipData.links = []; renderRelationshipGraph(); renderRelationshipList(); try { const db = getXDB(); const currentAccount = currentAccountId || 'main'; const dataId = `xCharacterRelationships_${currentAccount}`; await db.xCharacterRelationships.put({ id: dataId, accountId: currentAccount, data: characterRelationshipData, lastUpdated: new Date().toISOString(), }); updateRelationshipPreview(); showXToast('已清空所有关系', 'success'); } catch (error) { console.error('❌ 清空关系失败:', error); showXToast('已清空但保存失败', 'error'); } } function renderRelationshipList() { const listContainer = document.getElementById('relationship-links-list'); if (!listContainer) return; const links = characterRelationshipData.links || []; const chars = characterRelationshipData.characters || []; if (links.length === 0) { listContainer.innerHTML = '<div style="color: #71767b; text-align: center; padding: 20px;">暂无关系</div>'; return; } listContainer.innerHTML = links .map(link => { const charA = chars.find(c => c.id === link.charA); const charB = chars.find(c => c.id === link.charB); if (!charA || !charB) return ''; const storyPreview = link.story ? ` <div style="color: #71767b; font-size: 11px; margin-top: 6px; padding-top: 6px; border-top: 1px solid #2f3336;"> ${link.story.length > 50 ? link.story.substring(0, 50) + '...' : link.story} </div> ` : ''; return ` <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px; margin-bottom: 8px; cursor: pointer; transition: background-color 0.2s; " onclick="openEditRelationshipDetailModal(window.characterRelationshipData.links.find(l => l.id === '${ link.id }'))" onmouseover="this.style.backgroundColor='#2a2a2a'" onmouseout="this.style.backgroundColor='#1a1a1a'"> <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;"> <div style="display: flex; align-items: center; gap: 8px;"> <span style="color: #fff; font-weight: 600; font-size: 14px;">${charA.name}</span> <span style="color: #71767b;">⇆</span> <span style="color: #fff; font-weight: 600; font-size: 14px;">${charB.name}</span> </div> </div> <div style="display: flex; gap: 12px; font-size: 12px;"> <div style="color: var(--x-accent);">${charA.name}: ${link.relationAtoB || '(未设置)'}</div> <div style="color: var(--x-accent);">${charB.name}: ${link.relationBtoA || '(未设置)'}</div> </div> ${storyPreview} </div> `; }) .join(''); } async function saveRelationshipGraph() { try { const db = getXDB(); const currentAccount = currentAccountId || 'main'; const dataId = `xCharacterRelationships_${currentAccount}`; await db.xCharacterRelationships.put({ id: dataId, accountId: currentAccount, data: characterRelationshipData, lastUpdated: new Date().toISOString(), }); updateRelationshipPreview(); closeCharacterRelationshipGraph(); showXToast('关系图已保存', 'success'); console.log('✅ 关系图已保存:', characterRelationshipData); } catch (error) { console.error('❌ 保存关系图失败:', error); showXToast('保存失败', 'error'); } } let currentEditingNPCId = null; async function toggleNPCBinding() { xSettingsData.npcBinding = !xSettingsData.npcBinding; updateNPCToggleUI(); const npcArea = document.getElementById('npc-binding-area'); if (xSettingsData.npcBinding) { npcArea.style.display = 'block'; await loadNPCsList(); } else { npcArea.style.display = 'none'; } await saveXSettings(); } function updateNPCToggleUI() { const toggle = document.getElementById('x-npc-toggle'); const circle = toggle.querySelector('.toggle-circle'); if (xSettingsData.npcBinding) { toggle.style.backgroundColor = 'var(--x-accent)'; circle.style.left = '22px'; } else { toggle.style.backgroundColor = '#333'; circle.style.left = '2px'; } } async function loadNPCsList() { try { const db = getXDB(); const npcId = 'xNPCs_global'; const npcData = await db.xNPCs.get(npcId); const allNPCs = npcData?.npcs || []; const currentAccount = currentAccountId || 'main'; const npcs = allNPCs.filter(npc => npc.boundUsers && npc.boundUsers.includes(currentAccount)); const npcsList = document.getElementById('npcs-list'); if (npcs.length === 0) { npcsList.innerHTML = '<p style="color: #71767b; font-size: 14px; text-align: center; padding: 20px 0;">暂无绑定到此账号的NPC，点击上方按钮创建</p>'; return; } npcsList.innerHTML = npcs .map( npc => ` <div style="background-color: #0a0a0a; border: 1px solid #2f3336; border-radius: 8px; padding: 12px; margin-bottom: 8px; display: flex; align-items: center; gap: 12px; "> <img src="${npc.avatar || 'https: style="width: 48px; height: 48px; border-radius: 50%; flex-shrink: 0;" alt="${npc.name}"> <div style="flex: 1; min-width: 0;"> <div style="color: #fff; font-weight: 600; font-size: 15px; margin-bottom: 2px;">${npc.name}</div> <div style="color: #71767b; font-size: 14px;">${npc.handle}</div> <div style="color: #71767b; font-size: 13px; margin-top: 4px;"> 绑定用户: ${npc.boundUsers?.length || 0}个 </div> </div> <div style="display: flex; gap: 8px; flex-shrink: 0;"> <button onclick="editNPC('${ npc.id }')" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 15px; padding: 6px 12px; font-size: 13px; cursor: pointer; white-space: nowrap; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'"> 编辑 </button> <button onclick="deleteNPC('${ npc.id }')" style="background-color: #f4212e; color: #fff; border: none; border-radius: 15px; padding: 6px 12px; font-size: 13px; cursor: pointer; white-space: nowrap; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#d11a29'" onmouseout="this.style.backgroundColor='#f4212e'"> 删除 </button> </div> </div> `, ) .join(''); } catch (error) { console.error('加载NPC列表失败:', error); document.getElementById('npcs-list').innerHTML = '<p style="color: #f4212e; font-size: 14px; text-align: center; padding: 20px 0;">加载失败，请重试</p>'; } } function openCreateNPCModal() { currentEditingNPCId = null; document.getElementById('npc-name').value = ''; document.getElementById('npc-handle').value = ''; document.getElementById('npc-avatar').value = ''; document.getElementById('npc-personality').value = ''; document.getElementById('npc-posting-habits').value = ''; document.getElementById('npc-homepage').value = ''; document.getElementById('npc-modal-title').textContent = '创建NPC'; loadNPCBindUsersList(); document.getElementById('npc-edit-modal').style.display = 'block'; document.body.style.overflow = 'hidden'; } async function editNPC(npcId) { try { const db = getXDB(); const npcDataId = 'xNPCs_global'; const npcData = await db.xNPCs.get(npcDataId); const npcs = npcData?.npcs || []; const npc = npcs.find(n => n.id === npcId); if (!npc) { showXToast('NPC不存在', 'error'); return; } currentEditingNPCId = npcId; document.getElementById('npc-name').value = npc.name || ''; document.getElementById('npc-handle').value = npc.handle || ''; document.getElementById('npc-avatar').value = npc.avatar || ''; document.getElementById('npc-personality').value = npc.personality || ''; document.getElementById('npc-posting-habits').value = npc.postingHabits || ''; document.getElementById('npc-homepage').value = npc.homepage || ''; document.getElementById('npc-modal-title').textContent = '编辑NPC'; await loadNPCBindUsersList(npc.boundUsers || []); document.getElementById('npc-edit-modal').style.display = 'block'; document.body.style.overflow = 'hidden'; } catch (error) { console.error('加载NPC数据失败:', error); showXToast('加载失败', 'error'); } } async function loadNPCBindUsersList(selectedUsers = []) { try { const db = getXDB(); const accounts = await db.xAccountList.toArray(); const usersList = document.getElementById('npc-bind-users'); if (accounts.length === 0) { usersList.innerHTML = '<p style="color: #71767b; font-size: 14px; text-align: center; padding: 10px 0;">暂无账号</p>'; return; } usersList.innerHTML = accounts .map(account => { const isChecked = selectedUsers.includes(account.accountId); return ` <label style="display: flex; align-items: center; gap: 12px; padding: 8px; cursor: pointer; border-radius: 6px; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.05)'" onmouseout="this.style.backgroundColor='transparent'"> <input type="checkbox" value="${account.accountId}" ${isChecked ? 'checked' : ''} style="width: 16px; height: 16px; accent-color: var(--x-accent); cursor: pointer;"> <img src="${account.avatar}" style="width: 32px; height: 32px; border-radius: 50%;" alt="${account.name}"> <div style="flex: 1;"> <div style="color: #fff; font-size: 14px; font-weight: 600;">${account.name}</div> <div style="color: #71767b; font-size: 13px;">账号ID: ${account.accountId}</div> </div> </label> `; }) .join(''); } catch (error) { console.error('加载用户列表失败:', error); } } async function saveNPC() { try { const name = document.getElementById('npc-name').value.trim(); const handle = document.getElementById('npc-handle').value.trim(); const avatar = document.getElementById('npc-avatar').value.trim(); const personality = document.getElementById('npc-personality').value.trim(); const postingHabits = document.getElementById('npc-posting-habits').value.trim(); const homepage = document.getElementById('npc-homepage').value.trim(); const boundUsers = Array.from(document.querySelectorAll('#npc-bind-users input[type="checkbox"]:checked')).map( input => input.value, ); if (!name) { showXToast('NPC姓名不能为空', 'error'); return; } if (!handle) { showXToast('NPC句柄不能为空', 'error'); return; } const handleFormatted = handle.startsWith('@') ? handle : `@${handle}`; const db = getXDB(); const npcDataId = 'xNPCs_global'; const npcData = await db.xNPCs.get(npcDataId); let npcs = npcData?.npcs || []; if (currentEditingNPCId) { const index = npcs.findIndex(n => n.id === currentEditingNPCId); if (index !== -1) { npcs[index] = { ...npcs[index], name, handle: handleFormatted, avatar: avatar || 'https: personality, postingHabits, homepage, boundUsers, updatedAt: new Date().toISOString(), }; } } else { const newNPC = { id: 'npc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9), name, handle: handleFormatted, avatar: avatar || 'https: personality, postingHabits, homepage, boundUsers, createdAt: new Date().toISOString(), }; npcs.push(newNPC); } await db.xNPCs.put({ id: npcDataId, npcs, lastUpdated: new Date().toISOString(), }); console.log(`✅ NPC已${currentEditingNPCId ? '更新' : '创建'}:`, name, handle); console.log('📎 绑定账号数量:', boundUsers.length); console.log('📎 绑定账号列表:', boundUsers.length > 0 ? boundUsers : '无'); await loadNPCsList(); closeNPCEditModal(); showXToast(currentEditingNPCId ? 'NPC已更新' : 'NPC已创建', 'success'); } catch (error) { console.error('保存NPC失败:', error); showXToast('保存失败: ' + error.message, 'error'); } } async function deleteNPC(npcId) { if (!confirm('确定要删除这个NPC吗？\n此操作将影响所有绑定了此NPC的账号。')) return; try { const db = getXDB(); const npcDataId = 'xNPCs_global'; const npcData = await db.xNPCs.get(npcDataId); let npcs = npcData?.npcs || []; npcs = npcs.filter(n => n.id !== npcId); await db.xNPCs.put({ id: npcDataId, npcs, lastUpdated: new Date().toISOString(), }); await loadNPCsList(); showXToast('NPC已删除', 'success'); } catch (error) { console.error('删除NPC失败:', error); showXToast('删除失败', 'error'); } } function closeNPCEditModal(event) { if (event && event.target !== event.currentTarget) return; document.getElementById('npc-edit-modal').style.display = 'none'; document.body.style.overflow = 'auto'; currentEditingNPCId = null; } function switchProfileTab(tabName) { document.querySelectorAll('.profile-tab').forEach(tab => { tab.classList.remove('active'); tab.style.color = '#71767b'; tab.querySelector('.tab-indicator').style.display = 'none'; }); document.querySelectorAll('.profile-tab-content').forEach(content => { content.style.display = 'none'; }); const activeTab = document.querySelector(`.profile-tab[onclick="switchProfileTab('${tabName}')"]`); if (activeTab) { activeTab.classList.add('active'); activeTab.style.color = '#fff'; activeTab.querySelector('.tab-indicator').style.display = 'block'; } const contentArea = document.getElementById(`profile-${tabName}-content`); if (contentArea) { contentArea.style.display = 'block'; } if (tabName === 'posts') { loadUserProfileTweets(); } else if (tabName === 'highlights') { loadHighlights(); } else if (tabName === 'likes') { loadLikes(); } } function editProfile() { openEditProfileModal(); } function loadUserProfileToUI() { const profile = window.userProfileData; const topBarAvatar = document.getElementById('top-bar-avatar'); if (topBarAvatar) { topBarAvatar.src = profile.avatar; } const profileElements = { 'x-profile-header-name': profile.name, 'x-profile-user-name': profile.name, 'x-profile-user-handle': profile.handle, 'x-profile-bio': profile.bio, 'x-profile-following-count': profile.following, 'x-profile-followers-count': profile.followers, }; Object.entries(profileElements).forEach(([id, value]) => { const element = document.getElementById(id); if (element) { element.textContent = value; } }); const tag1Element = document.getElementById('x-profile-tag1'); const tag1IconElement = document.getElementById('x-profile-tag1-icon'); const tag2Element = document.getElementById('x-profile-tag2'); const tag2IconElement = document.getElementById('x-profile-tag2-icon'); if (tag1Element) { tag1Element.textContent = profile.customTag1; tag1Element.style.color = profile.customTag1Color || '#71767b'; } if (tag1IconElement) { tag1IconElement.textContent = profile.customTag1Icon || '✨'; } if (tag2Element) { tag2Element.textContent = profile.customTag2; tag2Element.style.color = profile.customTag2Color || '#71767b'; } if (tag2IconElement) { tag2IconElement.textContent = profile.customTag2Icon || '📅'; } const mainAvatar = document.getElementById('x-profile-main-avatar'); if (mainAvatar) { mainAvatar.src = profile.avatar; } const coverImage = document.getElementById('x-profile-cover-image'); if (coverImage) { coverImage.src = profile.coverImage; } updateVerificationBadge(); const commentInputAvatar = document.querySelector('#comment-input-area img, .comment-input-area img'); if (commentInputAvatar) { commentInputAvatar.src = profile.avatar; } const commentUserAvatar = document.getElementById('comment-user-avatar'); if (commentUserAvatar) { commentUserAvatar.src = profile.avatar; } const detailCommentUserAvatar = document.getElementById('detail-comment-user-avatar'); if (detailCommentUserAvatar) { detailCommentUserAvatar.src = profile.avatar; } const replyUserAvatars = document.querySelectorAll('.reply-user-avatar'); replyUserAvatars.forEach(avatar => { avatar.src = profile.avatar; }); const composeUserAvatar = document.getElementById('compose-user-avatar'); if (composeUserAvatar) { composeUserAvatar.src = profile.avatar; } console.log('✅ UI已更新，当前用户资料:', profile.name); } function updateVerificationBadge() { const verifiedBadge = document.getElementById('x-profile-verified-badge'); if (!verifiedBadge) return; const verificationType = userProfileData.verificationType || 'none'; if (verificationType === 'none') { verifiedBadge.style.display = 'none'; return; } verifiedBadge.style.display = 'inline-block'; let badgeColor = '#1d9bf0'; let badgePath = ''; switch (verificationType) { case 'verified': badgeColor = '#1d9bf0'; badgePath = 'M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z'; break; case 'couple': badgeColor = getComputedStyle(document.getElementById('x-social-screen')).getPropertyValue('--x-text-primary').trim() || '#fff'; badgePath = 'M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z'; break; case 'married': badgeColor = getComputedStyle(document.getElementById('x-social-screen')).getPropertyValue('--x-text-primary').trim() || '#fff'; badgePath = 'M12 4c4.42 0 8 3.58 8 8s-3.58 8-8 8-8-3.58-8-8 3.58-8 8-8zm0 2c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6z'; break; case 'vip': badgeColor = getComputedStyle(document.getElementById('x-social-screen')).getPropertyValue('--x-text-primary').trim() || '#fff'; badgePath = 'M12 3l6 6-6 6-6-6 6-6zm0 2.83L8.83 9 12 12.17 15.17 9 12 5.83z'; break; default: badgeColor = '#1d9bf0'; badgePath = 'M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z'; break; } verifiedBadge.style.fill = badgeColor; const pathElement = verifiedBadge.querySelector('path'); if (pathElement) { pathElement.setAttribute('d', badgePath); } if (verificationType === 'couple' && userProfileData.coupleCharacterName) { verifiedBadge.setAttribute('title', `情侣认证 - 与${userProfileData.coupleCharacterName}是情侣关系`); } else { const titles = { verified: '已认证账户', married: '已婚认证', vip: 'VIP认证', couple: '情侣认证', }; verifiedBadge.setAttribute('title', titles[verificationType] || '已认证账户'); } } async function setCoupleVerificationForCharacter(characterId, userNameAsCouple) { try { const db = getXDB(); let xProfile = await db.xCharacterProfiles.get(characterId); if (xProfile) { xProfile.xVerified = true; xProfile.verificationType = 'couple'; xProfile.couplePartnerName = userNameAsCouple; await db.xCharacterProfiles.put(xProfile); console.log(`已为角色 ${xProfile.xName} 设置情侣认证，情侣对象: ${userNameAsCouple}`); } } catch (error) { console.error('为角色设置情侣认证失败:', error); } } function syncUserAvatar(newAvatarUrl) { userProfileData.avatar = newAvatarUrl; const avatarSelectors = [ '#top-bar-avatar', '#x-profile-main-avatar', '.comment-input-area img', '#comment-user-avatar', '#detail-comment-user-avatar', '#compose-user-avatar', '#live-page-user-avatar', ]; avatarSelectors.forEach(selector => { const element = document.querySelector(selector); if (element) { element.src = newAvatarUrl; } }); document.querySelectorAll('.reply-user-avatar').forEach(avatar => { avatar.src = newAvatarUrl; }); document.querySelectorAll('.comment-item img[alt="我"], .comment-item img[alt="Your avatar"]').forEach(img => { img.src = newAvatarUrl; }); } function renderUserTweets() { const container = document.getElementById('x-profile-tweets-container'); if (!container) return; const userTweets = []; if (userTweets.length === 0) { container.innerHTML = ` <div style="padding: 60px 32px; text-align: center;"> <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;">还没有发帖</div> <div style="color: #71767b; font-size: 15px;">当你发布推文时，它们会显示在这里。</div> </div> `; } else { container.innerHTML = ''; userTweets.forEach(tweet => { const tweetElement = createTweetElement(tweet); container.appendChild(tweetElement); }); } const headerCount = document.getElementById('x-profile-header-count'); if (headerCount) { headerCount.textContent = `${userTweets.length} 帖子`; } } let followersFluctuationTimer = null; function startFollowersFluctuationSystem() { if (followersFluctuationTimer) { clearInterval(followersFluctuationTimer); } console.log('📊 [粉丝数浮动] 系统已启动'); setTimeout(() => { triggerFollowersFluctuation(); }, 5000); const scheduleNext = () => { const randomInterval = (10 + Math.random() * 20) * 60 * 1000; console.log(`📊 [粉丝数浮动] 下次触发时间: ${(randomInterval / 60000).toFixed(1)}分钟后`); followersFluctuationTimer = setTimeout(() => { triggerFollowersFluctuation(); scheduleNext(); }, randomInterval); }; scheduleNext(); } function stopFollowersFluctuationSystem() { if (followersFluctuationTimer) { clearTimeout(followersFluctuationTimer); followersFluctuationTimer = null; console.log('📊 [粉丝数浮动] 系统已停止'); } } async function triggerFollowersFluctuation() { try { console.log('📊 [粉丝数浮动] 开始检查所有账户...'); await updateUserFollowersCount(); await updateAllCharactersFollowersCount(); console.log('✅ [粉丝数浮动] 所有账户粉丝数已更新'); } catch (error) { console.error('❌ [粉丝数浮动] 触发失败:', error); } } async function updateUserFollowersCount() { try { const xDb = getXDB(); const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); const recentTweets = userTweetsData?.tweets?.slice(0, 3) || []; const originalFollowersStr = window.userProfileData.followers || '0'; const currentFollowersNum = parseFollowersCount(originalFollowersStr); const fluctuation = calculateFollowersFluctuation({ publicIdentity: window.userProfileData.publicIdentity || '', bio: window.userProfileData.bio || '', recentTweets: recentTweets, currentFollowers: currentFollowersNum, }); if (fluctuation === 0) { console.log('📊 [用户粉丝数] 本次无变化'); return; } const newFollowersNum = Math.max(0, currentFollowersNum + fluctuation); const newFollowersStr = formatFollowersCount(newFollowersNum, originalFollowersStr); window.userProfileData.followers = newFollowersStr; window.userProfileData.followersCount = newFollowersStr; window.userProfileData.lastUpdated = new Date().toISOString(); await xDb.xUserProfile.put({ id: currentAccountId || 'main', ...window.userProfileData, }); const followersElement = document.getElementById('x-profile-followers-count'); if (followersElement) { followersElement.textContent = newFollowersStr; } console.log( `📊 [用户粉丝数] ${fluctuation > 0 ? '+' : ''}${fluctuation} (${originalFollowersStr} → ${newFollowersStr})`, ); if (Math.abs(fluctuation) >= 50) { const isEnglish = currentLanguage === 'en'; showPhoneNotification({ title: 'X', message: isEnglish ? `Followers ${fluctuation > 0 ? 'increased' : 'decreased'} by ${Math.abs(fluctuation)}` : `粉丝数${fluctuation > 0 ? '增加' : '减少'}了 ${Math.abs(fluctuation)}`, leftIcon: 'x', duration: 3000, }); } } catch (error) { console.error('❌ [用户粉丝数] 更新失败:', error); } } async function updateAllCharactersFollowersCount() { try { const xDb = getXDB(); const allCharacterProfiles = await xDb.xCharacterProfiles.toArray(); if (allCharacterProfiles.length === 0) { console.log('📊 [角色粉丝数] 无已绑定角色'); return; } console.log(`📊 [角色粉丝数] 检查 ${allCharacterProfiles.length} 个角色`); for (const xProfile of allCharacterProfiles) { if (!xProfile.followersCount || xProfile.followersCount === '') { continue; } const cleanHandle = xProfile.xHandle.replace('@', ''); const accountProfile = await xDb.xAccountProfiles.get(cleanHandle); const recentTweets = accountProfile?.tweets?.slice(0, 3) || []; const originalFollowersStr = xProfile.followersCount; const currentFollowersNum = parseFollowersCount(originalFollowersStr); const fluctuation = calculateFollowersFluctuation({ publicIdentity: xProfile.publicIdentity || '', bio: xProfile.xBio || '', recentTweets: recentTweets, currentFollowers: currentFollowersNum, }); if (fluctuation === 0) { continue; } const newFollowersNum = Math.max(0, currentFollowersNum + fluctuation); const newFollowersStr = formatFollowersCount(newFollowersNum, originalFollowersStr); xProfile.followersCount = newFollowersStr; await xDb.xCharacterProfiles.put(xProfile); console.log( `📊 [角色粉丝数] ${xProfile.xName}: ${ fluctuation > 0 ? '+' : '' }${fluctuation} (${originalFollowersStr} → ${newFollowersStr})`, ); if (accountProfile) { accountProfile.accountInfo.followersCount = newFollowersStr; await xDb.xAccountProfiles.put(accountProfile); console.log(` └─ 已同步到账户主页 ${cleanHandle}`); } } } catch (error) { console.error('❌ [角色粉丝数] 更新失败:', error); } } function parseFollowersCount(followersStr) { if (!followersStr || followersStr === '') return 0; const str = followersStr.toString().toLowerCase().trim(); if (str.includes('k')) { const num = parseFloat(str.replace('k', '')); return Math.round(num * 1000); } if (str.includes('w')) { const num = parseFloat(str.replace('w', '')); return Math.round(num * 10000); } if (str.includes('m')) { const num = parseFloat(str.replace('m', '')); return Math.round(num * 1000000); } const num = parseInt(str); return isNaN(num) ? 0 : num; } function formatFollowersCount(count, originalFormat = '') { if (count === 0) return '0'; const originalLower = originalFormat.toString().toLowerCase(); const usesK = originalLower.includes('k'); const usesW = originalLower.includes('w'); const usesM = originalLower.includes('m'); if (usesW) { if (count >= 10000) { const wValue = count / 10000; return wValue % 1 === 0 ? `${Math.round(wValue)}w` : `${wValue.toFixed(1)}w`; } return count.toString(); } if (usesM) { if (count >= 1000000) { const mValue = count / 1000000; return mValue % 1 === 0 ? `${Math.round(mValue)}m` : `${mValue.toFixed(1)}m`; } else if (count >= 1000) { const kValue = count / 1000; return kValue % 1 === 0 ? `${Math.round(kValue)}k` : `${kValue.toFixed(1)}k`; } return count.toString(); } if (usesK || !usesW) { if (count >= 1000000) { const mValue = count / 1000000; return mValue % 1 === 0 ? `${Math.round(mValue)}m` : `${mValue.toFixed(1)}m`; } else if (count >= 1000) { const kValue = count / 1000; return kValue % 1 === 0 ? `${Math.round(kValue)}k` : `${kValue.toFixed(1)}k`; } } return count.toString(); } function calculateFollowersFluctuation({ publicIdentity, bio, recentTweets, currentFollowers }) { const isHighExposure = /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test( publicIdentity + ' ' + bio, ); let tweetQualityScore = 0; if (recentTweets.length > 0) { let totalScore = 0; recentTweets.forEach(tweet => { const stats = tweet.stats || {}; const likes = stats.likes || 0; const retweets = stats.retweets || 0; const comments = stats.comments || 0; const views = stats.views || 0; const engagementRate = views > 0 ? (likes + retweets * 2 + comments * 3) / views : 0; if (engagementRate > 0.1) { totalScore += 1; } else if (engagementRate > 0.05) { totalScore += 0.5; } else if (engagementRate > 0.02) { totalScore += 0; } else { totalScore -= 0.5; } }); tweetQualityScore = totalScore / recentTweets.length; } console.log(` 📊 推文质量评分: ${tweetQualityScore.toFixed(2)} (${recentTweets.length}条推文)`); let baseFluctuation = 0; let direction = 1; if (tweetQualityScore > 0.5) { direction = Math.random() < 0.8 ? 1 : -1; } else if (tweetQualityScore > 0) { direction = Math.random() < 0.7 ? 1 : -1; } else if (tweetQualityScore > -0.5) { direction = Math.random() < 0.5 ? 1 : -1; } else { direction = Math.random() < 0.3 ? 1 : -1; } if (isHighExposure) { if (recentTweets.length > 0) { baseFluctuation = 100 + Math.random() * 400; } else { baseFluctuation = 50 + Math.random() * 150; } } else if (recentTweets.length > 0) { baseFluctuation = 20 + Math.random() * 80; } else { baseFluctuation = 5 + Math.random() * 25; } const qualityMultiplier = 0.5 + Math.abs(tweetQualityScore) * 0.8; baseFluctuation *= qualityMultiplier; if (currentFollowers > 10000) { baseFluctuation *= 1.5; } else if (currentFollowers > 5000) { baseFluctuation *= 1.2; } if (Math.random() > 0.6) { console.log(' 📊 本次随机跳过浮动'); return 0; } const finalFluctuation = Math.round(baseFluctuation * direction); console.log( ` 📊 浮动计算: ${isHighExposure ? '高曝光' : '普通'}身份, 方向${direction > 0 ? '↑' : '↓'}, 幅度${Math.abs( finalFluctuation, )}`, ); return finalFluctuation; } window.triggerAutoMessageAfterAway = async function (messageId) { try { console.log('⏰ [离开后自动消息] 开始触发，messageId:', messageId); const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageId}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (!savedConversation) { console.log('⚠️ [离开后自动消息] 未找到对话数据'); return; } if (!savedConversation.isAway) { console.log('⚠️ [离开后自动消息] 对话已不再处于离开状态'); return; } const now = new Date(); const awayUntil = new Date(savedConversation.awayUntil); if (now < awayUntil) { console.log('⚠️ [离开后自动消息] 离开时间尚未结束'); return; } savedConversation.isAway = false; delete savedConversation.awayUntil; delete savedConversation.awayDuration; await xDb.xAccountProfiles.put(savedConversation); console.log('✅ [离开后自动消息] 已清除离开状态'); const isCharacterMessage = messageId && messageId.startsWith('msg_') && messageId !== 'msg_001'; if (!isCharacterMessage) { console.log('⚠️ [离开后自动消息] 不是绑定角色，跳过'); return; } let userName = '未知'; let userHandle = '@unknown'; let userAvatar = ''; try { const characterId = messageId.replace('msg_', ''); const xProfile = await xDb.xCharacterProfiles.get(characterId); if (xProfile) { userName = xProfile.xName; userHandle = xProfile.xHandle; userAvatar = xProfile.xAvatar; console.log(`✅ [离开后自动消息] 从xCharacterProfiles获取角色信息: ${userName}`); } else if (savedConversation.data && savedConversation.data.senderProfile) { userName = savedConversation.data.senderProfile.name || '未知'; userHandle = savedConversation.data.senderProfile.handle || '@unknown'; userAvatar = savedConversation.data.senderProfile.avatar || ''; console.log(`✅ [离开后自动消息] 从senderProfile获取角色信息: ${userName}`); } else if (savedConversation.data && savedConversation.data.user) { userName = savedConversation.data.user.name || '未知'; userHandle = savedConversation.data.user.handle || '@unknown'; userAvatar = savedConversation.data.user.avatar || ''; console.log(`✅ [离开后自动消息] 从user获取角色信息: ${userName}`); } } catch (error) { console.error('❌ [离开后自动消息] 获取角色信息失败:', error); } const messageData = { id: messageId, user: { name: userName, handle: userHandle, avatar: userAvatar, }, }; console.log('📤 [离开后自动消息] 开始生成AI主动消息'); const aiMessages = await generateMessageConversation(messageData, true, { isAutoMessage: true, timeSinceLastMessage: savedConversation.awayDuration * 60 || 3600, isAwayReturn: true, }); if (aiMessages && aiMessages.length > 0) { const updatedConversation = await xDb.xAccountProfiles.get(conversationId); if (updatedConversation && updatedConversation.data && updatedConversation.data.messages) { updatedConversation.data.messages.push(...aiMessages); await xDb.xAccountProfiles.put(updatedConversation); console.log('✅ [离开后自动消息] AI消息已保存'); } const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); if (savedData && savedData.data) { const messagesList = savedData.data; const messageIndex = messagesList.findIndex(msg => msg.id === messageId); if (messageIndex !== -1) { messagesList[messageIndex].unread = true; messagesList[messageIndex].unreadCount = (messagesList[messageIndex].unreadCount || 0) + aiMessages.length; await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); sampleMessagesData = messagesList; showMessageNotification(messageData.user.name, messageData.user.avatar, aiMessages.length); showNavNotificationDot('messages'); console.log('✅ [离开后自动消息] 已标记为未读并显示提醒'); } } } else { console.log('⚠️ [离开后自动消息] AI未生成消息'); } } catch (error) { console.error('❌ [离开后自动消息] 触发失败:', error); } }; window.currentAccountId = window.currentAccountId || 'main'; let currentAccountId = window.currentAccountId; function toggleProfileMenu() { const menu = document.getElementById('profile-dropdown-menu'); const isVisible = menu.style.display !== 'none'; if (isVisible) { menu.style.display = 'none'; } else { menu.style.display = 'block'; } } document.addEventListener('click', function (event) { const menuBtn = document.getElementById('profile-menu-btn'); const menu = document.getElementById('profile-dropdown-menu'); if (!menuBtn || !menu) return; if (!menuBtn.contains(event.target) && !menu.contains(event.target)) { menu.style.display = 'none'; } }); async function openAccountManager() { document.getElementById('profile-dropdown-menu').style.display = 'none'; showAccountManagerModal(); } async function showAccountManagerModal() { const accounts = await getAllAccounts(); const modal = document.createElement('div'); modal.id = 'account-manager-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10000; backdrop-filter: blur(4px); `; modal.innerHTML = ` <div style="background-color: #1a1a1a; border-radius: 16px; width: 90%; max-width: 480px; max-height: 70vh; overflow-y: auto; border: 1px solid #333; position: relative; "> <div style="padding: 20px; border-bottom: 1px solid #333; display: flex; align-items: center; justify-content: space-between; position: sticky; top: 0; background-color: #1a1a1a; z-index: 10; "> <div> <h3 style="margin: 0; color: #fff; font-size: 20px; font-weight: 700;">账号管理</h3> <p style="margin: 4px 0 0; color: #71767b; font-size: 14px;">管理你的多个X账户</p> </div> <button onclick="closeAccountManager()" style="background: transparent; border: none; color: #71767b; cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </button> </div> <div style="padding: 20px;"> <div id="accounts-list" style="margin-bottom: 20px;"> ${await renderAccountsList(accounts)} </div> <button onclick="createNewAccount()" style="width: 100%; background-color: var(--x-accent); color: #fff; border: none; border-radius: 12px; padding: 16px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px; " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <g><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></g> </svg> 新建账户 </button> </div> </div> `; document.body.appendChild(modal); document.body.style.overflow = 'hidden'; modal.addEventListener('click', e => { if (e.target === modal) { closeAccountManager(); } }); } async function getAllAccounts() { try { const db = getXDB(); const accounts = await db.xAccountList.orderBy('createdAt').toArray(); const activeAccount = await db.xActiveAccount.get('current'); if (accounts.length === 0) { const defaultAccount = { accountId: 'main', name: userProfileData.name || '我', avatar: userProfileData.avatar || 'https: createdAt: new Date().toISOString(), isActive: true, }; await db.xAccountList.put(defaultAccount); await db.xActiveAccount.put({ id: 'current', accountId: 'main' }); return [defaultAccount]; } accounts.forEach(account => { account.isActive = activeAccount && activeAccount.accountId === account.accountId; }); return accounts; } catch (error) { console.error('获取账户列表失败:', error); return []; } } async function renderAccountsList(accounts) { if (accounts.length === 0) { return ` <div style="text-align: center; color: #71767b; padding: 40px 20px;"> <div style="font-size: 16px; margin-bottom: 8px;">暂无账户</div> <div style="font-size: 14px;">创建你的第一个账户</div> </div> `; } return accounts .map( account => ` <div style="border: 2px solid ${ account.isActive ? 'var(--x-accent)' : '#333' }; border-radius: 12px; padding: 16px; margin-bottom: 12px; cursor: pointer; transition: all 0.2s; background-color: ${ account.isActive ? 'color-mix(in srgb, var(--x-accent) , 0.05)' : 'transparent' }; " onclick="switchAccount('${account.accountId}')" onmouseover="if (!${account.isActive}) this.style.borderColor='#536471'" onmouseout="if (!${account.isActive}) this.style.borderColor='#333'"> <div style="display: flex; align-items: center; gap: 12px;"> <img src="${account.avatar}" style="width: 48px; height: 48px; border-radius: 50%;" alt="${account.name}"> <div style="flex: 1;"> <div style="color: #fff; font-size: 16px; font-weight: 700; margin-bottom: 4px;"> ${account.name} ${account.isActive ? '<span style="color: var(--x-accent); font-size: 12px; margin-left: 8px;">● 当前账户</span>' : ''} </div> <div style="color: #71767b; font-size: 14px;"> 创建于 ${new Date(account.createdAt).toLocaleDateString('zh-CN')} </div> </div> ${ !account.isActive && account.accountId !== 'main' ? ` <button onclick="event.stopPropagation(); deleteAccount('${account.accountId}')" style="background: transparent; border: 1px solid #ef4444; color: #ef4444; border-radius: 8px; padding: 6px 8px; font-size: 12px; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='rgba(239, 68, 68, 0.1)'" onmouseout="this.style.backgroundColor='transparent'"> 删除 </button> ` : '' } </div> </div> `, ) .join(''); } function closeAccountManager() { const modal = document.getElementById('account-manager-modal'); if (modal) { modal.remove(); } document.body.style.overflow = 'auto'; } async function switchAccount(accountId) { if (accountId === currentAccountId) { closeAccountManager(); return; } try { if (chatHistoryDetectionTimer) { clearInterval(chatHistoryDetectionTimer); chatHistoryDetectionTimer = null; chatHistoryDetectionEnabled = false; } const db = getXDB(); await db.xActiveAccount.put({ id: 'current', accountId: accountId }); currentAccountId = accountId; window.currentAccountId = accountId; await loadUserProfileFromDB(accountId); await initializeXSettings(); loadUserProfileToUI(); syncUserAvatar(userProfileData.avatar); if (document.getElementById('x-profile-page').style.display !== 'none') { loadUserProfileTweets(); } await loadAskboxDataFromDB(); if (document.getElementById('x-askbox-page').style.display !== 'none') { await loadAskboxData(); } const composeAvatar = document.getElementById('compose-user-avatar'); if (composeAvatar) { composeAvatar.src = userProfileData.avatar; } await loadAccentColorPreference(); await loadWalletData(); const messagesPage = document.getElementById('x-messages-page'); if (messagesPage && messagesPage.style.display === 'flex') { await loadMessagesList(); } const notificationsPage = document.getElementById('x-notifications-page'); if (notificationsPage && notificationsPage.style.display === 'flex') { await loadNotifications(); } closeAccountManager(); showXToast(`已切换到账户：${userProfileData.name}`, 'success'); console.log('✅ 已切换账户，绑定角色数:', xSettingsData.boundCharacters?.length || 0); } catch (error) { console.error('切换账户失败:', error); showXToast('切换账户失败', 'error'); } } async function createNewAccount() { try { const db = getXDB(); const newAccountId = 'account_' + Date.now(); const defaultProfile = getDefaultUserProfile(newAccountId); await db.xUserProfile.put(defaultProfile); const newAccount = { accountId: newAccountId, name: '新用户', avatar: 'https: createdAt: new Date().toISOString(), }; await db.xAccountList.put(newAccount); const askboxId = `askbox_${newAccountId}`; await db.xAskbox.put({ id: askboxId, avatar: 'https: nickname: '= =', prompt: '请向我匿名提问!waiting...', background: 'https: answeredQuestions: [], }); console.log('✅ 已为新账户创建空提问箱:', newAccountId); await switchAccount(newAccountId); } catch (error) { console.error('创建新账户失败:', error); showXToast('创建新账户失败', 'error'); } } async function deleteAccount(accountId) { if (accountId === 'main') { showXToast('无法删除默认账户', 'error'); return; } if (!confirm('确定要删除这个账户吗？此操作无法撤销。')) { return; } try { const db = getXDB(); await db.xUserProfile.delete(accountId); await db.xAccountList.delete(accountId); const askboxId = `askbox_${accountId}`; await db.xAskbox.delete(askboxId); const messagesListId = `messagesList_${accountId}`; await db.xAccountProfiles.delete(messagesListId); const strangerMessagesId = `strangerMessages_${accountId}`; await db.xAccountProfiles.delete(strangerMessagesId); const mentionsId = `mentions_${accountId}`; await db.xAccountProfiles.delete(mentionsId); const allConversations = await db.xAccountProfiles.where('name').equals('messageConversation').toArray(); for (const conv of allConversations) { if (conv.accountId === accountId || conv.handle.startsWith(`messageConversation_${accountId}_`)) { await db.xAccountProfiles.delete(conv.handle); } } await db.xSettings.delete(`xSettings_${accountId}`); await db.xUserTweets.delete(`userTweets_${accountId}`); const bookmarks = await db.xBookmarks.where('accountId').equals(accountId).toArray(); for (const bookmark of bookmarks) { await db.xBookmarks.delete(bookmark.id); } const walletId = `wallet_${accountId}`; await db.xAccountProfiles.delete(walletId); console.log(`✅ 已清理账户 ${accountId} 的所有相关数据`); showXToast('账户已删除', 'success'); closeAccountManager(); setTimeout(() => { showAccountManagerModal(); }, 300); } catch (error) { console.error('删除账户失败:', error); showXToast('删除账户失败', 'error'); } } window.clearCurrentAskboxData = async function () { try { const xDb = getXDB(); const accountId = currentAccountId || 'main'; const askboxId = `askbox_${accountId}`; await xDb.xAskbox.put({ id: askboxId, avatar: 'https: nickname: '= =', prompt: '请向我匿名提问!waiting...', background: 'https: answeredQuestions: [], }); await loadAskboxDataFromDB(); if (document.getElementById('x-askbox-page').style.display !== 'none') { renderAnsweredQuestions(); } console.log('✅ 已清空账户提问箱数据:', accountId); showXToast('提问箱数据已清空', 'success'); } catch (error) { console.error('❌ 清空提问箱数据失败:', error); showXToast('清空失败: ' + error.message, 'error'); } }; async function initializeUserProfile() { await loadActiveAccount(); await loadUserProfileFromDB(); loadUserProfileToUI(); syncUserAvatar(userProfileData.avatar); loadUserProfileTweets(); await loadWalletData(); } async function loadActiveAccount() { try { const db = getXDB(); await initializeMultiAccountSystem(); const activeAccount = await db.xActiveAccount.get('current'); if (activeAccount) { currentAccountId = activeAccount.accountId; window.currentAccountId = activeAccount.accountId; } else { currentAccountId = 'main'; window.currentAccountId = 'main'; await db.xActiveAccount.put({ id: 'current', accountId: 'main' }); } console.log('✅ 已加载激活账户:', currentAccountId); } catch (error) { console.error('加载激活账户失败:', error); currentAccountId = 'main'; window.currentAccountId = 'main'; } } async function initializeMultiAccountSystem() { try { const db = getXDB(); const defaultAccount = await db.xAccountList.get('main'); if (!defaultAccount) { const existingProfile = await db.xUserProfile.get('main'); const defaultAccountData = { accountId: 'main', name: existingProfile?.name || '我', avatar: existingProfile?.avatar || 'https: createdAt: existingProfile?.lastUpdated || new Date().toISOString(), }; await db.xAccountList.put(defaultAccountData); console.log('已创建默认账户记录'); } const activeAccount = await db.xActiveAccount.get('current'); if (!activeAccount) { await db.xActiveAccount.put({ id: 'current', accountId: 'main' }); console.log('已设置默认激活账户'); } } catch (error) { console.error('初始化多账户系统失败:', error); } } async function loadUserProfileFromDB(accountId = null) { try { const db = getXDB(); const targetAccountId = accountId || currentAccountId || 'main'; const savedProfile = await db.xUserProfile.get(targetAccountId); if (savedProfile) { Object.assign(window.userProfileData, savedProfile); } else { console.log('⚠️ 未找到账户资料，使用默认值:', targetAccountId); const defaultProfile = getDefaultUserProfile(targetAccountId); Object.assign(window.userProfileData, defaultProfile); } ensureProfileFields(window.userProfileData); console.log('✅ 已加载用户资料数据:', targetAccountId); if (window.userProfileData.knownIdentityCharacters && window.userProfileData.knownIdentityCharacters.length > 0) { console.log('📌 已知身份角色数量:', window.userProfileData.knownIdentityCharacters.length); } } catch (error) { console.error('❌ 加载用户资料失败，使用默认数据:', error); const defaultProfile = getDefaultUserProfile('main'); Object.assign(window.userProfileData, defaultProfile); } } async function saveUserProfileToDB() { try { const db = getXDB(); const targetAccountId = currentAccountId || 'main'; await db.xUserProfile.put({ id: targetAccountId, ...window.userProfileData, lastUpdated: new Date().toISOString(), }); const existingAccount = await db.xAccountList.get(targetAccountId); if (existingAccount) { existingAccount.name = window.userProfileData.name; existingAccount.avatar = window.userProfileData.avatar; await db.xAccountList.put(existingAccount); } console.log('用户资料已保存到数据库，账户ID:', targetAccountId); if (window.userProfileData.knownIdentityCharacters && window.userProfileData.knownIdentityCharacters.length > 0) { console.log('已知身份角色:', window.userProfileData.knownIdentityCharacters.length + '个'); } } catch (error) { console.error('保存用户资料失败:', error); throw error; } } let walletData = { accountId: 'main', isActivated: false, balance: 0, currency: 'USD', transactions: [], activatedAt: null, initialAmount: 0, creditScore: 100, }; async function openAccountWallet() { document.getElementById('profile-dropdown-menu').style.display = 'none'; await loadWalletData(); startBusinessTransferCheck(); showWalletModal(); } function showWalletModal() { const xSocialScreen = document.getElementById('x-social-screen'); const isLightMode = xSocialScreen && xSocialScreen.classList.contains('x-theme-light'); const modal = document.createElement('div'); modal.id = 'wallet-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: ${ isLightMode ? 'rgba(255, 255, 255, 0.85)' : 'rgba(0, 0, 0, 0.85)' }; display: flex; align-items: center; justify-content: center; z-index: 25; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); `; modal.innerHTML = ` <div style="background-color: ${ isLightMode ? 'rgba(255, 255, 255, 0.95)' : 'rgba(0, 0, 0, 0.95)' }; backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 24px; width: 90%; max-width: 360px; position: relative; overflow: hidden; box-shadow: ${ isLightMode ? '0 20px 60px rgba(0, 0, 0, 0.15), 0 8px 32px rgba(0, 0, 0, 0.1)' : '0 20px 60px rgba(0, 0, 0, 0.8), 0 8px 32px rgba(255, 255, 255, 0.05)' }; border: 2px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)' }; " onclick="event.stopPropagation()"> <div style="background: linear-gradient(135deg, ${ isLightMode ? 'rgba(248, 250, 252, 0.8)' : 'rgba(22, 24, 28, 0.8)' } 0%, ${ isLightMode ? 'rgba(255, 255, 255, 0.6)' : 'rgba(0, 0, 0, 0.6)' } 100%); padding: 24px; text-align: center; border-bottom: 2px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)' }; position: relative; "> <button onclick="closeWalletModal()" style="position: absolute; top: 16px; right: 16px; background: transparent; border: none; color: ${ isLightMode ? '#536471' : '#71767b' }; cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.2s; " onmouseover="this.style.backgroundColor='${ isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)' }';" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </button> <div style="margin-bottom: 16px;"> <img src="${ window.userProfileData?.avatar || userProfileData.avatar }" style="width: 64px; height: 64px; border-radius: 50%; border: 3px solid var(--x-accent); object-fit: cover; " alt="${ window.userProfileData?.name || userProfileData.name }"> </div> <div style="color: ${isLightMode ? '#0f1419' : '#ffffff'}; font-size: 18px; font-weight: 700; margin-bottom: 4px; ">${ window.userProfileData?.name || userProfileData.name }</div> <div style="color: ${isLightMode ? '#536471' : '#71767b'}; font-size: 14px; margin-bottom: 16px; ">Digital Wallet</div> <div id="wallet-status" style="display: inline-block; padding: 8px 16px; border-radius: 20px; font-size: 12px; font-weight: 700; letter-spacing: 1px; ${ walletData.isActivated ? 'background-color: rgba(34, 197, 94, 0.15); color: #22c55e; border: 2px solid rgba(34, 197, 94, 0.4);' : `background-color: ${isLightMode ? 'rgba(156, 163, 175, 0.15)' : 'rgba(156, 163, 175, 0.1)'}; color: ${ isLightMode ? '#6b7280' : '#9ca3af' }; border: 2px solid ${isLightMode ? 'rgba(156, 163, 175, 0.3)' : 'rgba(156, 163, 175, 0.2)'};` } ">${walletData.isActivated ? 'ACTIVATED' : 'INACTIVE'}</div> </div> <div style="padding: 24px; background-color: ${isLightMode ? 'rgba(255, 255, 255, 0.3)' : 'rgba(0, 0, 0, 0.3)'}; "> ${walletData.isActivated ? renderActivatedWallet(isLightMode) : renderInactiveWallet(isLightMode)} </div> <div style="display: flex; justify-content: center; align-items: center; padding: 16px 24px; gap: 24px; border-top: 2px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)' }; background-color: ${isLightMode ? 'rgba(248, 250, 252, 0.5)' : 'rgba(22, 24, 28, 0.5)'}; "> <div onclick="openBusinessTransferManager()" style="padding: 12px; border-radius: 50%; cursor: pointer; transition: all 0.2s; color: ${ isLightMode ? '#536471' : '#71767b' }; " onmouseover="this.style.backgroundColor='${ isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)' }'; this.style.color='var(--x-accent)';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='${ isLightMode ? '#536471' : '#71767b' }';" title="商业转账管理"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path><path d="M12 10L14.5 14L17 10L14.5 12L12 10ZM10 10L7.5 12L10 14L7.5 14L10 10Z"></path></g> </svg> </div> <div onclick="exportWallet()" style="padding: 12px; border-radius: 50%; cursor: pointer; transition: all 0.2s; color: ${ isLightMode ? '#536471' : '#71767b' }; " onmouseover="this.style.backgroundColor='${ isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)' }'; this.style.color='var(--x-accent)';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='${ isLightMode ? '#536471' : '#71767b' }';" title="导出钱包"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <g><path d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2v9.67z"></path></g> </svg> </div> <div onclick="copyWalletInfo()" style="padding: 12px; border-radius: 50%; cursor: pointer; transition: all 0.2s; color: ${ isLightMode ? '#536471' : '#71767b' }; " onmouseover="this.style.backgroundColor='${ isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)' }'; this.style.color='var(--x-accent)';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='${ isLightMode ? '#536471' : '#71767b' }';" title="复制钱包信息"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <g><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></g> </svg> </div> </div> </div> `; document.body.appendChild(modal); document.body.style.overflow = 'hidden'; modal.addEventListener('click', e => { if (e.target === modal) { closeWalletModal(); } }); const walletCard = modal.querySelector('div'); walletCard.style.transform = 'scale(0.8) translateY(20px)'; walletCard.style.opacity = '0'; requestAnimationFrame(() => { walletCard.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)'; walletCard.style.transform = 'scale(1) translateY(0)'; walletCard.style.opacity = '1'; }); } function renderInactiveWallet(isLightMode = false) { return ` <div style="text-align: center;"> <div style="width: 80px; height: 80px; margin: 0 auto 20px; background: linear-gradient(135deg, ${ isLightMode ? 'rgba(248, 250, 252, 0.8)' : 'rgba(22, 24, 28, 0.8)' } 0%, ${ isLightMode ? 'rgba(229, 231, 235, 0.6)' : 'rgba(55, 65, 81, 0.6)' } 100%); border-radius: 16px; display: flex; align-items: center; justify-content: center; border: 2px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)' }; "> <svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${isLightMode ? '#6b7280' : '#9ca3af'};"> <g><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></g> </svg> </div> <div style="color: ${ isLightMode ? '#0f1419' : '#ffffff' }; font-size: 16px; font-weight: 600; margin-bottom: 8px; ">激活你的数字钱包</div> <div style="color: ${ isLightMode ? '#536471' : '#71767b' }; font-size: 14px; line-height: 1.5; margin-bottom: 24px; ">点击下方按钮激活钱包<br>初始金额将根据你的公众身份随机生成</div> <button id="activate-wallet-btn" onclick="activateWallet()" style="width: 100%; background: linear-gradient(135deg, var(--x-accent) 0%, #1a8cd8 100%); color: #fff; border: none; border-radius: 12px; padding: 16px 24px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.3s; position: relative; overflow: hidden; " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(29, 155, 240, 0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'"> <span id="activate-btn-text">🚀 激活钱包</span> <div id="activate-btn-loader" style="display: none;"> <svg style="animation: spin 1s linear infinite; width: 20px; height: 20px;" viewBox="0 0 24 24"> <circle cx="12" cy="12" r="10" stroke="rgba(255,255,255,0.3)" stroke-width="2" fill="none"/> <path d="M4,12a8,8 0 1,1 16,0" stroke="#fff" stroke-width="2" fill="none" stroke-linecap="round"/> </svg> </div> </button> </div> `; } function renderActivatedWallet(isLightMode = false) { return ` <div> <div style="background: linear-gradient(135deg, ${ isLightMode ? 'rgba(248, 250, 252, 0.8)' : 'rgba(22, 24, 28, 0.8)' } 0%, ${isLightMode ? 'rgba(229, 231, 235, 0.6)' : 'rgba(55, 65, 81, 0.6)'} 100%); border: 2px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)' }; border-radius: 16px; padding: 20px; margin-bottom: 20px; text-align: center; "> <div style="color: ${ isLightMode ? '#6b7280' : '#9ca3af' }; font-size: 12px; font-weight: 600; letter-spacing: 1px; margin-bottom: 8px; text-transform: uppercase; ">Balance</div> <div style="color: ${ isLightMode ? '#0f1419' : '#ffffff' }; font-size: 32px; font-weight: 700; margin-bottom: 4px; ">$${walletData.balance.toFixed(2)}</div> <div style="color: ${isLightMode ? '#6b7280' : '#9ca3af'}; font-size: 13px; ">${walletData.currency}</div> </div> <div style="margin-bottom: 16px;"> <div style="color: ${ isLightMode ? '#6b7280' : '#9ca3af' }; font-size: 12px; font-weight: 600; letter-spacing: 1px; margin-bottom: 12px; text-transform: uppercase; ">Recent Activity</div> ${walletData.transactions.length > 0 ? renderTransactions(isLightMode) : renderNoTransactions(isLightMode)} </div> <div style="display: flex; gap: 12px;"> <button onclick="showIncomeHistory()" style="flex: 1; background-color: var(--x-accent); color: ${ isLightMode ? '#0f1419' : '#ffffff' }; border: none; border-radius: 12px; padding: 12px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; position: relative; " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'"> + Add Funds ${ getIncomeRecordsCount() > 0 ? `<span style="position: absolute; top: -2px; right: -2px; background: #22c55e; color: white; border-radius: 50%; width: 16px; height: 16px; font-size: 10px; display: flex; align-items: center; justify-content: center; font-weight: 700; ">${getIncomeRecordsCount()}</span>` : '' } </button> <button onclick="showExpenseHistory()" style="flex: 1; background-color: transparent; color: ${ isLightMode ? '#0f1419' : '#ffffff' }; border: none; border-radius: 12px; padding: 12px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; position: relative; " onmouseover="this.style.backgroundColor='${ isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)' }';" onmouseout="this.style.backgroundColor='transparent'"> Send ${ getExpenseRecordsCount() > 0 ? `<span style="position: absolute; top: -2px; right: -2px; background: #ef4444; color: white; border-radius: 50%; width: 16px; height: 16px; font-size: 10px; display: flex; align-items: center; justify-content: center; font-weight: 700; ">${getExpenseRecordsCount()}</span>` : '' } </button> </div> </div> `; } function renderTransactions(isLightMode = false) { return walletData.transactions .slice(0, 2) .map( transaction => ` <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 2px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)' }; "> <div> <div style="color: ${isLightMode ? '#0f1419' : '#ffffff'}; font-size: 14px; font-weight: 600; margin-bottom: 2px; ">${ transaction.description }</div> <div style="color: ${isLightMode ? '#6b7280' : '#9ca3af'}; font-size: 12px; ">${new Date( transaction.timestamp, ).toLocaleDateString()}</div> </div> <div style="color: ${transaction.amount > 0 ? '#22c55e' : '#ef4444'}; font-size: 14px; font-weight: 700; ">${ transaction.amount > 0 ? '+' : '' }$${Math.abs(transaction.amount).toFixed(2)}</div> </div> `, ) .join(''); } function renderNoTransactions(isLightMode = false) { return ` <div style="text-align: center; padding: 20px; color: ${isLightMode ? '#6b7280' : '#9ca3af'}; font-size: 14px; "> <div style="margin-bottom: 8px; opacity: 0.6;">📋</div> <div>No transactions yet</div> </div> `; } async function activateWallet() { const activateBtn = document.getElementById('activate-wallet-btn'); const btnText = document.getElementById('activate-btn-text'); const btnLoader = document.getElementById('activate-btn-loader'); btnText.style.display = 'none'; btnLoader.style.display = 'block'; activateBtn.disabled = true; activateBtn.style.cursor = 'not-allowed'; await new Promise(resolve => setTimeout(resolve, 2000)); try { const initialAmount = generateInitialAmount(); walletData.isActivated = true; walletData.balance = initialAmount; walletData.initialAmount = initialAmount; walletData.activatedAt = new Date().toISOString(); walletData.transactions = [ { id: 'init_' + Date.now(), description: 'Initial Deposit', amount: initialAmount, timestamp: new Date().toISOString(), type: 'deposit', }, ]; await saveWalletData(); showWalletActivationSuccess(initialAmount); } catch (error) { console.error('激活钱包失败:', error); showXToast('钱包激活失败', 'error'); btnText.style.display = 'block'; btnLoader.style.display = 'none'; activateBtn.disabled = false; activateBtn.style.cursor = 'pointer'; } } function generateInitialAmount() { const publicIdentity = window.userProfileData?.publicIdentity || ''; const identityLower = publicIdentity.toLowerCase(); const amountRanges = { celebrity: { min: 1000, max: 5000, keywords: ['明星', '演员', '歌手', '导演', '艺人', 'celebrity', 'star', 'actor', 'singer'], }, influencer: { min: 500, max: 1500, keywords: ['网红', '博主', '主播', 'influencer', 'streamer', 'youtuber', 'blogger'], }, professional: { min: 200, max: 800, keywords: ['专家', '教授', '医生', '律师', '工程师', 'expert', 'professor', 'doctor', 'lawyer', 'engineer'], }, business: { min: 300, max: 1000, keywords: ['企业家', 'CEO', '总裁', '创始人', 'entrepreneur', 'founder', 'executive'], }, creator: { min: 150, max: 600, keywords: ['作家', '画家', '设计师', '摄影师', 'writer', 'artist', 'designer', 'photographer'], }, regular: { min: 50, max: 200, keywords: [] }, }; for (const [category, config] of Object.entries(amountRanges)) { if (category === 'regular') continue; const hasMatch = config.keywords.some(keyword => identityLower.includes(keyword)); if (hasMatch) { const amount = Math.random() * (config.max - config.min) + config.min; console.log(`💰 根据身份类型 "${category}" 生成初始金额: $${amount.toFixed(2)}`); return Math.round(amount * 100) / 100; } } const regularRange = amountRanges.regular; const amount = Math.random() * (regularRange.max - regularRange.min) + regularRange.min; console.log(`💰 默认身份生成初始金额: $${amount.toFixed(2)}`); return Math.round(amount * 100) / 100; } function showWalletActivationSuccess(amount) { closeWalletModal(); const successModal = document.createElement('div'); successModal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: flex; align-items: center; justify-content: center; z-index: 30; backdrop-filter: blur(12px); `; successModal.innerHTML = ` <div style="background-color:var(--x-bg-primary); border-radius: 24px; padding: 40px; text-align: center; border: 1px solid var(--x-border-color); max-width: 320px; width: 90%; animation: walletSuccessIn 0.6s cubic-bezier(0.4, 0, 0.2, 1); "> <div style="width: 80px; height: 80px; margin: 0 auto 24px; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; animation: walletSuccessCheck 0.8s ease-in-out 0.3s both; "> <svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: white;"> <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></g> </svg> </div> <div style="color:var(--x-text-primary); font-size: 20px; font-weight: 700; margin-bottom: 8px; ">钱包激活成功！</div> <div style="color: #22c55e; font-size: 24px; font-weight: 700; margin-bottom: 16px; ">+$${amount.toFixed(2)}</div> <div style="color:var(--x-text-secondary); font-size: 14px; line-height: 1.5; margin-bottom: 24px; ">恭喜！你的数字钱包已成功激活<br>初始资金已到账</div> <button onclick="this.parentElement.parentElement.remove(); document.body.style.overflow='auto'; openAccountWallet();" style="background: linear-gradient(135deg, var(--x-accent) 0%, #1a8cd8 100%); color: #fff; border: none; border-radius: 12px; padding: 12px 24px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; ">查看钱包</button> </div> `; document.body.appendChild(successModal); setTimeout(() => { if (successModal.parentElement) { successModal.remove(); document.body.style.overflow = 'auto'; } }, 3000); } function closeWalletModal() { const modal = document.getElementById('wallet-modal'); if (modal) { const walletCard = modal.querySelector('div'); walletCard.style.transform = 'scale(0.9) translateY(20px)'; walletCard.style.opacity = '0'; setTimeout(() => { modal.remove(); document.body.style.overflow = 'auto'; }, 200); } } async function loadWalletData() { try { const db = getXDB(); const walletId = `wallet_${currentAccountId || 'main'}`; const savedWallet = await db.xAccountProfiles.get(walletId); if (savedWallet && savedWallet.data) { Object.assign(walletData, savedWallet.data); walletData.accountId = currentAccountId || 'main'; } else { walletData = { accountId: currentAccountId || 'main', isActivated: false, balance: 0, currency: 'USD', transactions: [], activatedAt: null, initialAmount: 0, creditScore: 100, }; } console.log('✅ 钱包数据已加载:', walletData.accountId, walletData.isActivated ? '已激活' : '未激活'); } catch (error) { console.error('加载钱包数据失败:', error); walletData = { accountId: currentAccountId || 'main', isActivated: false, balance: 0, currency: 'USD', transactions: [], activatedAt: null, initialAmount: 0, creditScore: 100, }; } } async function saveWalletData() { try { const db = getXDB(); const walletId = `wallet_${currentAccountId || 'main'}`; await db.xAccountProfiles.put({ handle: walletId, name: 'wallet', accountId: currentAccountId || 'main', data: { ...walletData }, updatedAt: new Date().toISOString(), }); console.log('✅ 钱包数据已保存'); } catch (error) { console.error('保存钱包数据失败:', error); throw error; } } function getIncomeRecordsCount() { return walletData.transactions.filter(t => t.amount > 0).length; } function getExpenseRecordsCount() { return walletData.transactions.filter(t => t.amount < 0).length; } window.showIncomeHistory = function () { const incomeRecords = walletData.transactions.filter(t => t.amount > 0); showTransactionHistory('收款记录', incomeRecords, '#22c55e'); }; window.showExpenseHistory = function () { const expenseRecords = walletData.transactions.filter(t => t.amount < 0); showTransactionHistory('付款记录', expenseRecords, '#ef4444'); }; function showTransactionHistory(title, transactions, accentColor) { const xSocialScreen = document.getElementById('x-social-screen'); const isLightMode = xSocialScreen && xSocialScreen.classList.contains('x-theme-light'); const modal = document.createElement('div'); modal.id = 'transaction-history-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: ${ isLightMode ? 'rgba(255, 255, 255, 0.85)' : 'rgba(0, 0, 0, 0.85)' }; display: flex; align-items: center; justify-content: center; z-index: 26; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); `; modal.innerHTML = ` <div style="background-color: ${ isLightMode ? 'rgba(255, 255, 255, 0.95)' : 'rgba(0, 0, 0, 0.95)' }; backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 24px; width: 90%; max-width: 400px; max-height: 80vh; position: relative; overflow: hidden; box-shadow: ${ isLightMode ? '0 20px 60px rgba(0, 0, 0, 0.15), 0 8px 32px rgba(0, 0, 0, 0.1)' : '0 20px 60px rgba(0, 0, 0, 0.8), 0 8px 32px rgba(255, 255, 255, 0.05)' }; border: 2px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)' }; " onclick="event.stopPropagation()"> <div style="background: linear-gradient(135deg, ${ isLightMode ? 'rgba(0, 0, 0, 0.03)' : 'rgba(255, 255, 255, 0.05)' } 0%, ${ isLightMode ? 'rgba(0, 0, 0, 0.01)' : 'rgba(255, 255, 255, 0.02)' } 100%); padding: 24px; text-align: center; border-bottom: 1px dashed ${ isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.15)' }; position: relative; "> <div style="position: absolute; left: -10px; bottom: -10px; width: 20px; height: 20px; border-radius: 50%; background-color: ${ isLightMode ? 'rgba(255, 255, 255, 0.85)' : 'rgba(0, 0, 0, 0.85)' }; "></div> <div style="position: absolute; right: -10px; bottom: -10px; width: 20px; height: 20px; border-radius: 50%; background-color: ${ isLightMode ? 'rgba(255, 255, 255, 0.85)' : 'rgba(0, 0, 0, 0.85)' }; "></div> <button onclick="closeTransactionHistoryModal()" style="position: absolute; top: 16px; right: 16px; background: transparent; border: none; color: ${ isLightMode ? '#536471' : '#71767b' }; cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.2s; " onmouseover="this.style.backgroundColor='${ isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)' }';" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </button> <div style="color: ${ isLightMode ? '#0f1419' : '#ffffff' }; font-size: 20px; font-weight: 700; margin-bottom: 8px; letter-spacing: 0.5px; ">${title}</div> <div style="color: ${ isLightMode ? '#666666' : '#999999' }; font-size: 12px; font-weight: 600; font-family: monospace; letter-spacing: 1px; text-transform: uppercase; ">${ transactions.length } Records</div> </div> <div style="max-height: 50vh; overflow-y: auto; padding: 16px 24px; "> ${transactions.length > 0 ? renderFullTransactionList(transactions, isLightMode) : renderNoRecords(isLightMode, title)} </div> </div> `; document.body.appendChild(modal); document.body.style.overflow = 'hidden'; modal.addEventListener('click', e => { if (e.target === modal) { closeTransactionHistoryModal(); } }); const historyCard = modal.querySelector('div'); historyCard.style.transform = 'scale(0.8) translateY(20px)'; historyCard.style.opacity = '0'; requestAnimationFrame(() => { historyCard.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)'; historyCard.style.transform = 'scale(1) translateY(0)'; historyCard.style.opacity = '1'; }); } function renderFullTransactionList(transactions, isLightMode = false) { return transactions .map( transaction => ` <div style="margin-bottom: 12px; background: linear-gradient(135deg, ${ isLightMode ? 'rgba(0, 0, 0, 0.02)' : 'rgba(255, 255, 255, 0.03)' } 0%, ${isLightMode ? 'rgba(0, 0, 0, 0.01)' : 'rgba(255, 255, 255, 0.01)'} 100%); border: 1px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)' }; border-radius: 10px; padding: 14px; position: relative; overflow: hidden; "> <div style="position: absolute; bottom: 0; left: 0; right: 0; height: 4px; background: repeating-linear-gradient( 90deg, ${isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'} 0px, ${isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'} 4px, transparent 4px, transparent 8px ); "></div> <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;"> <div style="flex: 1; min-width: 0;"> <div style="color: ${ isLightMode ? '#0f1419' : '#ffffff' }; font-size: 14px; font-weight: 600; margin-bottom: 6px; word-wrap: break-word; ">${transaction.description}</div> <div style="color: ${ isLightMode ? '#6b7280' : '#9ca3af' }; font-size: 11px; margin-bottom: 4px; font-family: monospace; letter-spacing: 0.3px; ">${new Date( transaction.timestamp, ).toLocaleDateString('zh-CN')} ${new Date(transaction.timestamp).toLocaleTimeString('zh-CN', { hour12: false, })}</div> </div> <div style="color: ${ transaction.amount > 0 ? (isLightMode ? '#0f1419' : '#ffffff') : isLightMode ? '#666666' : '#999999' }; font-size: 16px; font-weight: 700; margin-left: 12px; flex-shrink: 0; font-family: monospace; ">${ transaction.amount > 0 ? '+' : '' }$${Math.abs(transaction.amount).toFixed(2)}</div> </div> <div style="display: inline-block; padding: 3px 8px; background: ${ isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.08)' }; border: 1px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.12)' }; border-radius: 6px; font-size: 10px; color: ${ isLightMode ? '#666666' : '#999999' }; font-weight: 600; letter-spacing: 0.5px; ">${getTransactionTypeText(transaction.type)}</div> </div> `, ) .join(''); } function renderNoRecords(isLightMode = false, title) { return ` <div style="text-align: center; padding: 40px 20px; color: ${isLightMode ? '#6b7280' : '#9ca3af'}; font-size: 15px; "> <svg viewBox="0 0 24 24" style="width: 48px; height: 48px; fill: currentColor; opacity: 0.3; margin: 0 auto 12px;"> <g><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></g> </svg> <div style="font-weight: 600; margin-bottom: 8px;">暂无${title}</div> <div style="font-size: 13px; opacity: 0.8;"> ${title.includes('收款') ? '收到的资金会显示在这里' : '转出的资金会显示在这里'} </div> </div> `; } function getTransactionTypeText(type) { const typeMap = { deposit: '充值', transfer_in: '收款', transfer_out: '转账', refund: '退款', init: '初始化', tip: '打赏', penalty: '违约费', fan_group_fee: '粉丝群入群费', }; return typeMap[type] || type; } window.closeTransactionHistoryModal = function () { const modal = document.getElementById('transaction-history-modal'); if (modal) { const historyCard = modal.querySelector('div'); historyCard.style.transform = 'scale(0.9) translateY(20px)'; historyCard.style.opacity = '0'; setTimeout(() => { modal.remove(); document.body.style.overflow = 'auto'; }, 200); } }; function addFunds() { showIncomeHistory(); } function sendMoney() { showExpenseHistory(); } function shareWallet() { showXToast('分享功能开发中...', 'info'); } function exportWallet() { showXToast('导出功能开发中...', 'info'); } function copyWalletInfo() { const userName = window.userProfileData?.name || userProfileData.name || '用户'; const info = `${userName}的数字钱包\n余额: $${walletData.balance.toFixed(2)}\n状态: ${ walletData.isActivated ? '已激活' : '未激活' }`; if (navigator.clipboard) { navigator.clipboard .writeText(info) .then(() => { showXToast('钱包信息已复制', 'success'); }) .catch(() => { showXToast('复制失败', 'error'); }); } else { showXToast('复制功能不支持', 'error'); } } function openEditProfileModal() { const modal = document.getElementById('edit-profile-modal'); modal.style.display = 'flex'; document.body.style.overflow = 'hidden'; loadDataToEditForm(); } function closeEditProfileModal(event) { if (event && event.target !== event.currentTarget) { return; } const modal = document.getElementById('edit-profile-modal'); modal.style.display = 'none'; document.body.style.overflow = 'auto'; } function loadDataToEditForm() { const profile = window.userProfileData; document.getElementById('edit-user-name').value = profile.name; document.getElementById('edit-user-handle').value = profile.handle.replace('@', ''); document.getElementById('edit-user-bio').value = profile.bio; document.getElementById('edit-custom-tag1').value = profile.customTag1; document.getElementById('edit-custom-tag2').value = profile.customTag2; document.getElementById('edit-following-count').value = profile.following; document.getElementById('edit-followers-count').value = profile.followers; document.getElementById('edit-tag1-icon').value = profile.customTag1Icon || '✨'; document.getElementById('edit-tag2-icon').value = profile.customTag2Icon || '📅'; document.getElementById('edit-tag1-color').value = profile.customTag1Color || '#71767b'; document.getElementById('edit-tag2-color').value = profile.customTag2Color || '#71767b'; document.getElementById('edit-tag1-color-text').value = profile.customTag1Color || '#71767b'; document.getElementById('edit-tag2-color-text').value = profile.customTag2Color || '#71767b'; document.getElementById('edit-cover-image').src = profile.coverImage; document.getElementById('edit-main-avatar').src = profile.avatar; document.getElementById('edit-public-identity').value = profile.publicIdentity || ''; document.getElementById('edit-show-real-name').checked = profile.showRealName || false; document.getElementById('edit-real-name').value = profile.realName || ''; toggleRealNameInput(); updateCharacterCounts(); loadVerificationTypeData(); loadIdentityCharactersList(); console.log('✅ 已加载用户数据到编辑表单'); } function loadVerificationTypeData() { const profile = window.userProfileData; const verificationTypeSelect = document.getElementById('edit-verification-type'); if (verificationTypeSelect) { verificationTypeSelect.value = profile.verificationType || 'none'; } const coupleCharacterSelect = document.getElementById('edit-couple-character'); if (coupleCharacterSelect) { coupleCharacterSelect.value = profile.coupleCharacterId || ''; } loadCoupleCharacterOptions(); updateVerificationTypeUI(); } function updateVerificationTypeUI() { const verificationTypeSelect = document.getElementById('edit-verification-type'); const coupleBindingSection = document.getElementById('couple-binding-section'); if (!verificationTypeSelect || !coupleBindingSection) return; const selectedType = verificationTypeSelect.value; if (selectedType === 'couple') { coupleBindingSection.style.display = 'block'; } else { coupleBindingSection.style.display = 'none'; } } async function loadCoupleCharacterOptions() { try { const db = getDB(); const xDb = getXDB(); const allChats = await db.chats.toArray(); const characters = allChats.filter(chat => !chat.isGroup); const coupleCharacterSelect = document.getElementById('edit-couple-character'); if (!coupleCharacterSelect) return; coupleCharacterSelect.innerHTML = '<option value="" style="background-color:#000; color: #fff;">未选择角色</option>'; const characterProfiles = await xDb.xCharacterProfiles.toArray(); const profileMap = new Map(); characterProfiles.forEach(profile => { profileMap.set(profile.characterId, profile); }); characters.forEach(character => { const option = document.createElement('option'); option.value = character.id; const xProfile = profileMap.get(character.id); const displayName = xProfile?.xName || character.name; option.textContent = displayName; option.style.backgroundColor = '#000'; option.style.color = '#fff'; coupleCharacterSelect.appendChild(option); }); if (userProfileData.coupleCharacterId) { coupleCharacterSelect.value = userProfileData.coupleCharacterId; } } catch (error) { console.error('加载情侣角色选项失败:', error); } } function updateCharacterCounts() { const nameInput = document.getElementById('edit-user-name'); const handleInput = document.getElementById('edit-user-handle'); const bioInput = document.getElementById('edit-user-bio'); const tag1Input = document.getElementById('edit-custom-tag1'); const tag2Input = document.getElementById('edit-custom-tag2'); if (nameInput) { const nameCount = nameInput.value.length; nameInput.parentNode.querySelector('div').textContent = `${nameCount} / 50`; } if (handleInput) { const handleCount = handleInput.value.length; handleInput.parentNode.querySelector('div').textContent = `${handleCount} / 15`; } if (bioInput) { const bioCount = bioInput.value.length; bioInput.parentNode.querySelector('div').textContent = `${bioCount} / 160`; } if (tag1Input) { const tag1Count = tag1Input.value.length; const tag1Container = tag1Input.closest('.form-group'); const countDiv = tag1Container.querySelector('div:last-child'); countDiv.textContent = `${tag1Count} / 30`; } if (tag2Input) { const tag2Count = tag2Input.value.length; const tag2Container = tag2Input.closest('.form-group'); const countDiv = tag2Container.querySelector('div:last-child'); countDiv.textContent = `${tag2Count} / 30`; } const realNameInput = document.getElementById('edit-real-name'); if (realNameInput) { const realNameCount = realNameInput.value.length; realNameInput.parentNode.querySelector('div').textContent = `${realNameCount} / 50`; } } function toggleRealNameInput() { const checkbox = document.getElementById('edit-show-real-name'); const container = document.getElementById('real-name-input-container'); if (!checkbox || !container) { console.warn('用户真名相关元素未找到'); return; } if (checkbox.checked) { container.style.display = 'block'; } else { container.style.display = 'none'; const realNameInput = document.getElementById('edit-real-name'); if (realNameInput) { realNameInput.value = ''; updateCharacterCounts(); } } } function toggleCharacterRealNameInput() { const checkbox = document.getElementById('character-show-real-name'); const container = document.getElementById('character-real-name-input-container'); if (!checkbox || !container) { console.warn('角色真名相关元素未找到'); return; } if (checkbox.checked) { container.style.display = 'block'; } else { container.style.display = 'none'; const realNameInput = document.getElementById('character-real-name'); if (realNameInput) { realNameInput.value = ''; updateCharacterXProfileCounts(); } } } window.toggleAutoMessageSettings = function () { const checkbox = document.getElementById('character-auto-message-enabled'); const settingsContainer = document.getElementById('auto-message-time-settings'); if (!checkbox || !settingsContainer) { return; } if (checkbox.checked) { settingsContainer.style.display = 'block'; } else { settingsContainer.style.display = 'none'; } }; function updateTag1ColorFromText() { const colorText = document.getElementById('edit-tag1-color-text'); const colorPicker = document.getElementById('edit-tag1-color'); if (colorText && colorPicker) { const colorValue = colorText.value.trim(); if (colorValue.match(/^#[0-9A-Fa-f]{6}$/)) { colorPicker.value = colorValue; } } } function updateTag1ColorFromPicker() { const colorText = document.getElementById('edit-tag1-color-text'); const colorPicker = document.getElementById('edit-tag1-color'); if (colorText && colorPicker) { colorText.value = colorPicker.value; } } function updateTag2ColorFromText() { const colorText = document.getElementById('edit-tag2-color-text'); const colorPicker = document.getElementById('edit-tag2-color'); if (colorText && colorPicker) { const colorValue = colorText.value.trim(); if (colorValue.match(/^#[0-9A-Fa-f]{6}$/)) { colorPicker.value = colorValue; } } } function updateTag2ColorFromPicker() { const colorText = document.getElementById('edit-tag2-color-text'); const colorPicker = document.getElementById('edit-tag2-color'); if (colorText && colorPicker) { colorText.value = colorPicker.value; } } function getFollowCountValue(input) { if (!input) return ''; return input.toString().trim(); } function editCoverImage() { const currentCover = document.getElementById('edit-cover-image').src; const coverUrl = prompt('请输入封面图片链接：', currentCover); if (coverUrl === null) return; if (!coverUrl.trim()) { showXToast('请输入有效的图片链接', 'error'); return; } try { new URL(coverUrl); } catch (e) { showXToast('请输入有效的图片链接', 'error'); return; } const testImg = new Image(); testImg.onload = function () { document.getElementById('edit-cover-image').src = coverUrl; showXToast('封面图已更新', 'success'); }; testImg.onerror = function () { showXToast('无法加载该图片，请检查链接是否正确', 'error'); }; testImg.src = coverUrl; } function removeCoverImage() { const defaultCover = 'https: document.getElementById('edit-cover-image').src = defaultCover; showXToast('已移除封面图', 'success'); } function editAvatarImage() { const currentAvatar = document.getElementById('edit-main-avatar').src; const avatarUrl = prompt('请输入头像图片链接：', currentAvatar); if (avatarUrl === null) return; if (!avatarUrl.trim()) { showXToast('请输入有效的图片链接', 'error'); return; } try { new URL(avatarUrl); } catch (e) { showXToast('请输入有效的图片链接', 'error'); return; } const testImg = new Image(); testImg.onload = function () { document.getElementById('edit-main-avatar').src = avatarUrl; showXToast('头像已更新', 'success'); }; testImg.onerror = function () { showXToast('无法加载该图片，请检查链接是否正确', 'error'); }; testImg.src = avatarUrl; } async function loadIdentityCharactersList() { console.log(`🔄 [加载角色身份识别列表] 开始加载`); try { const db = getDB(); const xDb = getXDB(); const settingsId = `xSettings_${currentAccountId || 'main'}`; const xSettings = await xDb.xSettings.get(settingsId); const boundCharacters = xSettings?.boundCharacters || []; console.log(`🔄 [加载角色身份识别列表] 绑定角色数: ${boundCharacters.length}`); if (boundCharacters.length === 0) { console.log(`⚠️ [加载角色身份识别列表] 无绑定角色`); renderIdentityCharactersList([]); return; } const allChats = await db.chats.toArray(); const characters = allChats.filter(chat => !chat.isGroup && boundCharacters.includes(chat.id)); console.log(`🔄 [加载角色身份识别列表] 过滤后角色数: ${characters.length}`); const charactersWithXProfile = []; for (const character of characters) { const xProfile = await xDb.xCharacterProfiles.get(character.id); if (xProfile) { const personaLength = (xProfile.userPersona || '').length; console.log(`🔄 [加载角色身份识别列表] 角色 ${character.name} (${character.id})`); console.log(` - X名称: ${xProfile.xName}`); console.log(` - 用户人设长度: ${personaLength} 字符`); console.log( ` - 人设预览: "${(xProfile.userPersona || '').substring(0, 50)}${personaLength > 50 ? '...' : ''}"`, ); charactersWithXProfile.push({ id: character.id, name: character.name, originalName: character.originalName, xProfile: xProfile, }); } } console.log(`✅ [加载角色身份识别列表] 最终角色数: ${charactersWithXProfile.length}`); renderIdentityCharactersList(charactersWithXProfile); } catch (error) { console.error('❌ [加载角色身份识别列表] 加载失败:', error); console.error('❌ [加载角色身份识别列表] 错误详情:', error.message, error.stack); renderIdentityCharactersList([]); } } function renderIdentityCharactersList(characters) { const container = document.getElementById('identity-characters-list'); if (characters.length === 0) { container.innerHTML = ` <div style="text-align: center; color: #71767b; font-size: 13px; padding: 20px;"> 暂无已绑定X资料的角色<br> <span style="font-size: 12px; margin-top: 4px; display: block;"> 请先在X设置中绑定角色并设置X资料 </span> </div> `; return; } if (!userProfileData.knownIdentityCharacters) { userProfileData.knownIdentityCharacters = []; } container.innerHTML = characters .map(character => { const isSelected = userProfileData.knownIdentityCharacters.includes(character.id); return ` <div style="display: flex; align-items: center; gap: 12px; padding: 8px; border-radius: 6px; margin-bottom: 6px; cursor: pointer; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(255,255,255,0.05)'" onmouseout="this.style.backgroundColor='transparent'" onclick="toggleIdentityCharacter('${character.id}')"> <div style="width: 18px; height: 18px; border: 2px solid ${ isSelected ? 'var(--x-accent)' : '#71767b' }; border-radius: 3px; background-color: ${ isSelected ? 'var(--x-accent)' : 'transparent' }; display: flex; align-items: center; justify-content: center; transition: all 0.2s; flex-shrink: 0; "> ${ isSelected ? '<svg viewBox="0 0 24 24" style="width: 12px; height: 12px; fill: #fff;"><path d="M9 16.17L5.53 12.7l-1.06 1.06L9 18.3l9.54-9.54-1.06-1.06L9 16.17z"/></svg>' : '' } </div> <img src="${character.xProfile.xAvatar}" alt="${character.xProfile.xName}" style="width: 32px; height: 32px; border-radius: 50%; flex-shrink: 0;"> <div style="flex: 1; min-width: 0;"> <div style="color: #fff; font-weight: 600; font-size: 14px;"> ${character.xProfile.xName} ${ character.xProfile.xVerified ? '<svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: var(--x-accent); margin-left: 4px; display: inline;"><path d="M22.5 12.5c0-1.58-.875-2.95-2.148-3.6.154-.435.238-.905.238-1.4 0-2.21-1.71-3.998-3.818-3.998-.47 0-.92.084-1.336.25C14.818 2.415 13.51 1.5 12 1.5s-2.816.917-3.437 2.25c-.415-.165-.866-.25-1.336-.25-2.11 0-3.818 1.79-3.818 4 0 .494.083.964.237 1.4-1.272.65-2.147 2.018-2.147 3.6 0 1.495.782 2.798 1.942 3.486-.02.17-.032.34-.032.514 0 2.21 1.708 4 3.818 4 .47 0 .92-.086 1.335-.25.62 1.334 1.926 2.25 3.437 2.25 1.512 0 2.818-.916 3.437-2.25.415.163.865.248 1.336.248 2.11 0 3.818-1.79 3.818-4 0-.174-.012-.344-.033-.513 1.158-.687 1.943-1.99 1.943-3.484zm-6.616-3.334l-4.334 6.5c-.145.217-.382.334-.625.334-.143 0-.288-.04-.416-.126l-2.5-1.668c-.326-.217-.413-.656-.196-.982.217-.326.656-.414.982-.196l1.875 1.25 3.75-5.625c.22-.33.66-.418.99-.196.33.22.418.66.196.99z"/></svg>' : '' } </div> <div style="color: #71767b; font-size: 12px;"> ${character.xProfile.xHandle} • ${character.name} ${ character.xProfile && character.xProfile.userPersona && character.xProfile.userPersona.trim() ? '<span style="color: #10b981; font-size: 11px; margin-left: 8px;">✓ 已设置人设</span>' : '<span style="color: #f59e0b; font-size: 11px; margin-left: 8px;">⚠ 未设置人设</span>' } </div> </div> <div class="persona-setting-btn" onclick="event.stopPropagation(); window.openUserPersonaEditor('${character.id}')" style="width: 32px; height: 32px; border-radius: 50%; background-color: ${ character.xProfile && character.xProfile.userPersona && character.xProfile.userPersona.trim() ? '#10b981' : '#1d9bf0' }; color: #fff; display: flex; align-items: center; justify-content: center; cursor: pointer; flex-shrink: 0; transition: all 0.2s; margin-left: 8px; " onmouseover="this.style.backgroundColor='${ character.xProfile && character.xProfile.userPersona && character.xProfile.userPersona.trim() ? '#059669' : '#1a8cd8' }'; this.style.transform='scale(1.05)'" onmouseout="this.style.backgroundColor='${ character.xProfile && character.xProfile.userPersona && character.xProfile.userPersona.trim() ? '#10b981' : '#1d9bf0' }'; this.style.transform='scale(1)'" title="${ character.xProfile && character.xProfile.userPersona && character.xProfile.userPersona.trim() ? '编辑用户人设' : '设置用户人设' }"> ${ character.xProfile && character.xProfile.userPersona && character.xProfile.userPersona.trim() ? '<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;"><g><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></g></svg>' : '<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;"><g><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></g></svg>' } </div> </div> `; }) .join(''); } function toggleIdentityCharacter(characterId) { if (!userProfileData.knownIdentityCharacters) { userProfileData.knownIdentityCharacters = []; } const index = userProfileData.knownIdentityCharacters.indexOf(characterId); if (index === -1) { userProfileData.knownIdentityCharacters.push(characterId); } else { userProfileData.knownIdentityCharacters.splice(index, 1); } loadIdentityCharactersList(); } window.openUserPersonaEditor = async function (characterId) { console.log(`📖 [打开用户人设编辑器] 角色ID: ${characterId}`); try { const mainDB = getDB(); const xDB = getXDB(); const chat = await mainDB.chats.get(characterId); const xProfile = await xDB.xCharacterProfiles.get(characterId); console.log(`📖 [打开用户人设编辑器] 角色数据:`, chat ? '存在' : '不存在'); console.log(`📖 [打开用户人设编辑器] X资料数据:`, xProfile ? '存在' : '不存在'); if (!chat || !xProfile) { console.error(`❌ [打开用户人设编辑器] 无法获取角色信息`); showXToast('无法获取角色信息', 'error'); return; } const existingPersona = xProfile.userPersona || ''; console.log(`📖 [打开用户人设编辑器] 现有人设长度: ${existingPersona.length} 字符`); console.log( `📖 [打开用户人设编辑器] 人设内容预览: "${existingPersona.substring(0, 100)}${ existingPersona.length > 100 ? '...' : '' }"`, ); window.showUserPersonaModal(characterId, chat.name, xProfile.xName, existingPersona); } catch (error) { console.error('❌ [打开用户人设编辑器] 失败:', error); console.error('❌ [打开用户人设编辑器] 错误详情:', error.message, error.stack); showXToast('打开编辑器失败: ' + error.message, 'error'); } }; window.showUserPersonaModal = function (characterId, characterName, xName, existingPersona) { console.log(`🖼️ [显示用户人设弹窗] 角色: ${xName} (${characterName})`); console.log(`🖼️ [显示用户人设弹窗] 角色ID: ${characterId}`); console.log(`🖼️ [显示用户人设弹窗] 传入的人设长度: ${existingPersona.length} 字符`); const modal = document.createElement('div'); modal.id = 'user-persona-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10000; backdrop-filter: blur(4px); `; modal.innerHTML = ` <div style="background-color: #1a1a1a; border-radius: 16px; width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto; position: relative; border: 1px solid #333; "> <div style="padding: 20px; border-bottom: 1px solid #333; display: flex; align-items: center; justify-content: space-between; "> <div> <h3 style="margin: 0; color: #fff; font-size: 18px; font-weight: 700;"> 编辑用户人设 </h3> <p style="margin: 4px 0 0; color: #71767b; font-size: 14px;"> 为 ${xName} (${characterName}) 设置你的身份信息 </p> </div> <button onclick="window.closeUserPersonaModal()" style="background: transparent; border: none; color: #71767b; cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </button> </div> <div style="padding: 20px;"> <div style="background-color: #003d82; border: 1px solid var(--x-accent); border-radius: 8px; padding: 12px; margin-bottom: 20px; "> <div style="color: var(--x-accent); font-size: 14px; font-weight: 600; margin-bottom: 4px;"> 💡 如何设置用户人设 </div> <div style="color: #e1e8ed; font-size: 13px; line-height: 1.4;"> • 描述你希望这个角色了解的关于你的信息<br> • 例如：性格特点、兴趣爱好、职业背景等<br> • 这些信息将帮助角色更自然地与你互动 </div> </div> <div style="margin-bottom: 20px;"> <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px; ">用户人设</label> <textarea id="user-persona-input" placeholder="请描述你希望${xName}了解的关于你的信息..." style="width: 100%; min-height: 120px; max-height: 300px; background-color: #0a0a0a; border: 1px solid #333; border-radius: 8px; color: #fff; font-size: 14px; padding: 12px; resize: vertical; outline: none; box-sizing: border-box; font-family: inherit; line-height: 1.4; " oninput="window.updatePersonaCharCount()">${existingPersona}</textarea> <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px; "> <div style="color: #71767b; font-size: 12px;"> 建议详细描述，帮助角色更好地理解你 </div> <div id="persona-char-count" style="color: #71767b; font-size: 12px;"> ${existingPersona.length} 字符 </div> </div> </div> <div style="display: flex; gap: 12px; justify-content: flex-end;"> <button onclick="window.closeUserPersonaModal()" style="background: transparent; color: #71767b; border: 1px solid #333; border-radius: 20px; padding: 8px 20px; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.05)'" onmouseout="this.style.backgroundColor='transparent'"> 取消 </button> <button onclick="window.saveUserPersona('${characterId}')" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 8px 20px; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'"> 保存 </button> </div> </div> </div> `; document.body.appendChild(modal); modal.addEventListener('click', e => { if (e.target === modal) { window.closeUserPersonaModal(); } }); }; window.updatePersonaCharCount = function () { const textarea = document.getElementById('user-persona-input'); const countEl = document.getElementById('persona-char-count'); if (textarea && countEl) { countEl.textContent = `${textarea.value.length} 字符`; } }; window.closeUserPersonaModal = function () { console.log(`🚪 [关闭用户人设弹窗] 关闭编辑弹窗`); const modal = document.getElementById('user-persona-modal'); if (modal) { const textarea = document.getElementById('user-persona-input'); if (textarea) { console.log(`🚪 [关闭用户人设弹窗] 弹窗中当前内容长度: ${textarea.value.length} 字符`); } modal.remove(); console.log(`✅ [关闭用户人设弹窗] 弹窗已移除`); } }; window.saveUserPersona = async function (characterId) { const textarea = document.getElementById('user-persona-input'); const persona = textarea.value.trim(); console.log(`💾 [保存用户人设] 开始保存角色 ${characterId} 的用户人设`); console.log(`💾 [保存用户人设] 人设内容长度: ${persona.length} 字符`); try { const db = getXDB(); let xProfile = await db.xCharacterProfiles.get(characterId); console.log(`💾 [保存用户人设] 获取到的角色资料:`, xProfile ? '存在' : '不存在'); if (xProfile) { const oldPersona = xProfile.userPersona || ''; console.log(`💾 [保存用户人设] 旧人设长度: ${oldPersona.length} 字符`); console.log(`💾 [保存用户人设] 新人设长度: ${persona.length} 字符`); xProfile.userPersona = persona; await db.xCharacterProfiles.put(xProfile); const verifyProfile = await db.xCharacterProfiles.get(characterId); const savedPersona = verifyProfile?.userPersona || ''; console.log(`✅ [保存用户人设] 验证保存结果 - 实际保存长度: ${savedPersona.length} 字符`); if (savedPersona === persona) { console.log(`✅ [保存用户人设] 数据验证成功，保存一致`); } else { console.warn(`⚠️ [保存用户人设] 数据验证失败！保存的内容与预期不一致`); console.warn(`⚠️ [保存用户人设] 预期: "${persona.substring(0, 50)}..."`); console.warn(`⚠️ [保存用户人设] 实际: "${savedPersona.substring(0, 50)}..."`); } showXToast(persona ? '用户人设已保存' : '用户人设已清空', 'success'); window.closeUserPersonaModal(); console.log(`🔄 [保存用户人设] 重新加载角色身份识别列表`); await loadIdentityCharactersList(); } else { console.error(`❌ [保存用户人设] 无法找到角色资料，角色ID: ${characterId}`); showXToast('无法找到角色资料', 'error'); } } catch (error) { console.error('❌ [保存用户人设] 保存失败:', error); console.error('❌ [保存用户人设] 错误详情:', error.message, error.stack); showXToast('保存失败: ' + error.message, 'error'); } }; async function saveProfileChanges() { const newName = document.getElementById('edit-user-name').value.trim(); const newHandle = document.getElementById('edit-user-handle').value.trim(); const newBio = document.getElementById('edit-user-bio').value.trim(); const newTag1 = document.getElementById('edit-custom-tag1').value.trim(); const newTag2 = document.getElementById('edit-custom-tag2').value.trim(); const newTag1Icon = document.getElementById('edit-tag1-icon').value.trim() || '✨'; const newTag2Icon = document.getElementById('edit-tag2-icon').value.trim() || '📅'; const newTag1Color = document.getElementById('edit-tag1-color').value || '#71767b'; const newTag2Color = document.getElementById('edit-tag2-color').value || '#71767b'; const newFollowing = getFollowCountValue(document.getElementById('edit-following-count').value); const newFollowers = getFollowCountValue(document.getElementById('edit-followers-count').value); const newCover = document.getElementById('edit-cover-image').src; const newAvatar = document.getElementById('edit-main-avatar').src; const newVerificationType = document.getElementById('edit-verification-type').value; const newCoupleCharacterId = document.getElementById('edit-couple-character').value; let newCoupleCharacterName = ''; if (newCoupleCharacterId) { try { const db = getXDB(); const coupleCharacterProfile = await db.xCharacterProfiles.get(newCoupleCharacterId); if (coupleCharacterProfile) { newCoupleCharacterName = `@${coupleCharacterProfile.xHandle}（${coupleCharacterProfile.xName}）`; } else { const coupleOption = document.querySelector(`#edit-couple-character option[value="${newCoupleCharacterId}"]`); const displayName = coupleOption ? coupleOption.textContent : ''; if (displayName) { const defaultHandle = displayName.toLowerCase().replace(/\s+/g, '_'); newCoupleCharacterName = `@${defaultHandle}（${displayName}）`; } } } catch (error) { console.error('获取情侣角色X资料失败:', error); const coupleOption = document.querySelector(`#edit-couple-character option[value="${newCoupleCharacterId}"]`); const displayName = coupleOption ? coupleOption.textContent : ''; if (displayName) { const defaultHandle = displayName.toLowerCase().replace(/\s+/g, '_'); newCoupleCharacterName = `@${defaultHandle}（${displayName}）`; } } } const newPublicIdentity = document.getElementById('edit-public-identity').value.trim(); const newShowRealName = document.getElementById('edit-show-real-name').checked; const newRealName = document.getElementById('edit-real-name').value.trim(); if (!newName) { showXToast('名称不能为空', 'error'); return; } if (!newHandle) { showXToast('用户名不能为空', 'error'); return; } if (newName.length > 50) { showXToast('名称不能超过50个字符', 'error'); return; } if (newHandle.length > 15) { showXToast('用户名不能超过15个字符', 'error'); return; } if (newBio.length > 160) { showXToast('自我介绍不能超过160个字符', 'error'); return; } if (newTag1.length > 30) { showXToast('自定义标签1不能超过30个字符', 'error'); return; } if (newTag2.length > 30) { showXToast('自定义标签2不能超过30个字符', 'error'); return; } if (newFollowing.length > 20) { showXToast('关注数量过长', 'error'); return; } if (newFollowers.length > 20) { showXToast('关注者数量过长', 'error'); return; } if (newShowRealName && newRealName.length > 50) { showXToast('真实姓名不能超过50个字符', 'error'); return; } if (newShowRealName && !newRealName) { showXToast('选择公开真名时必须填写真实姓名', 'error'); return; } window.userProfileData.name = newName; window.userProfileData.handle = '@' + newHandle; window.userProfileData.bio = newBio; window.userProfileData.customTag1 = newTag1; window.userProfileData.customTag2 = newTag2; window.userProfileData.customTag1Icon = newTag1Icon; window.userProfileData.customTag2Icon = newTag2Icon; window.userProfileData.customTag1Color = newTag1Color; window.userProfileData.customTag2Color = newTag2Color; window.userProfileData.following = newFollowing; window.userProfileData.followers = newFollowers; window.userProfileData.coverImage = newCover; window.userProfileData.avatar = newAvatar; window.userProfileData.verificationType = newVerificationType; window.userProfileData.coupleCharacterId = newCoupleCharacterId; window.userProfileData.coupleCharacterName = newCoupleCharacterName; window.userProfileData.publicIdentity = newPublicIdentity; window.userProfileData.showRealName = newShowRealName; window.userProfileData.realName = newShowRealName ? newRealName : ''; window.userProfileData.verified = newVerificationType !== 'none'; if (!window.userProfileData.knownIdentityCharacters) { window.userProfileData.knownIdentityCharacters = []; } if (newVerificationType === 'couple' && newCoupleCharacterId) { setCoupleVerificationForCharacter(newCoupleCharacterId, window.userProfileData.name); } try { console.log('📝 准备保存用户资料...'); console.log('👤 已知身份角色数:', window.userProfileData.knownIdentityCharacters?.length || 0); console.log('👤 已知身份角色列表:', window.userProfileData.knownIdentityCharacters || []); await saveUserProfileToDB(); loadUserProfileToUI(); updateVerificationBadge(); syncUserAvatar(newAvatar); closeEditProfileModal(); let successMessage = '个人资料已更新'; if (window.userProfileData.knownIdentityCharacters && window.userProfileData.knownIdentityCharacters.length > 0) { successMessage += `，已设置 ${window.userProfileData.knownIdentityCharacters.length} 个角色知道您的身份`; } showXToast(successMessage, 'success'); if (window.userProfileData.knownIdentityCharacters && window.userProfileData.knownIdentityCharacters.length > 0) { console.log('✅ 已保存的用户身份识别设置:', window.userProfileData.knownIdentityCharacters); console.log('✅ 这些角色现在知道您的身份，可以在X平台上与您自然互动'); } } catch (error) { console.error('保存个人资料失败:', error); showXToast('保存失败: ' + error.message, 'error'); } } let tweetPrivacySetting = 'public'; let selectedBusinessTransferId = null; function openComposeTweetModal() { const modal = document.getElementById('compose-tweet-modal'); modal.style.display = 'flex'; document.body.style.overflow = 'hidden'; resetComposeModal(); const avatar = document.querySelector('#compose-tweet-modal img[alt="用户头像"]'); if (avatar) { avatar.src = userProfileData.avatar; } } function closeComposeTweetModal(event) { if (event && event.target !== event.currentTarget) { return; } const modal = document.getElementById('compose-tweet-modal'); modal.style.display = 'none'; document.body.style.overflow = 'auto'; if (typeof removeQuoteContent === 'function') { removeQuoteContent(); } const fanGroupQuoteSection = document.getElementById('compose-fangroup-quote-section'); if (fanGroupQuoteSection) { fanGroupQuoteSection.remove(); } window.currentQuoteFanGroup = null; } function resetComposeModal() { document.getElementById('compose-text-input').value = ''; updateComposeCharCount(); updateComposeTweetButton(); document.getElementById('compose-image-section').style.display = 'none'; document.getElementById('compose-location-section').style.display = 'none'; document.getElementById('compose-link-section').style.display = 'none'; resetFunctionButtonStates(); clearImageSection(); clearLocationSection(); clearLinkSection(); tweetPrivacySetting = 'public'; selectedBusinessTransferId = null; const iconPath = document.getElementById('privacy-icon-path'); const textElement = document.getElementById('privacy-text'); iconPath.setAttribute( 'd', 'M12 1.75C6.34 1.75 1.75 6.34 1.75 12S6.34 22.25 12 22.25 22.25 17.66 22.25 12 17.66 1.75 12 1.75zm-.81 14.68l-4.1-3.27 1.25-1.57 2.47 1.98 3.97-5.47 1.62 1.18-5.21 7.15z', ); textElement.textContent = '所有人可以回复'; textElement.style.color = 'var(--x-accent)'; const businessSection = document.getElementById('business-task-selection'); if (businessSection) businessSection.style.display = 'none'; if (typeof removeQuoteContent === 'function') { removeQuoteContent(); } const fanGroupQuoteSection = document.getElementById('compose-fangroup-quote-section'); if (fanGroupQuoteSection) { fanGroupQuoteSection.remove(); } window.currentQuoteFanGroup = null; } function handleComposeInput() { updateComposeCharCount(); updateComposeTweetButton(); processHashtagsAndMentions(); } function updateComposeCharCount() { const textInput = document.getElementById('compose-text-input'); const charCount = document.getElementById('compose-char-count'); const length = textInput.value.length; charCount.textContent = `${length} / 280`; if (length > 260) { charCount.style.color = '#f4212e'; } else if (length > 240) { charCount.style.color = '#ffad1f'; } else { charCount.style.color = '#71767b'; } } function updateComposeTweetButton() { const textInput = document.getElementById('compose-text-input'); const tweetBtn = document.getElementById('compose-tweet-btn'); const hasContent = textInput.value.trim().length > 0; if (hasContent) { tweetBtn.disabled = false; tweetBtn.style.opacity = '1'; tweetBtn.style.cursor = 'pointer'; } else { tweetBtn.disabled = true; tweetBtn.style.opacity = '0.5'; tweetBtn.style.cursor = 'not-allowed'; } } function processHashtagsAndMentions() { const textInput = document.getElementById('compose-text-input'); const text = textInput.value; } function toggleImageSection() { const section = document.getElementById('compose-image-section'); const btn = document.getElementById('image-btn'); if (section.style.display === 'none') { section.style.display = 'block'; btn.style.backgroundColor = 'rgba(29,155,240,0.1)'; } else { section.style.display = 'none'; btn.style.backgroundColor = 'transparent'; clearImageSection(); } } function selectImageMethod(method) { const descBtn = document.getElementById('img-desc-btn'); const uploadBtn = document.getElementById('img-upload-btn'); const descInput = document.getElementById('image-description-input'); const uploadArea = document.getElementById('image-upload-area'); descBtn.style.backgroundColor = '#333'; descBtn.style.borderColor = '#536471'; uploadBtn.style.backgroundColor = '#333'; uploadBtn.style.borderColor = '#536471'; descInput.style.display = 'none'; uploadArea.style.display = 'none'; if (method === 'description') { descBtn.style.backgroundColor = 'var(--x-accent)'; descBtn.style.borderColor = 'var(--x-accent)'; descInput.style.display = 'block'; } else if (method === 'upload') { uploadBtn.style.backgroundColor = 'var(--x-accent)'; uploadBtn.style.borderColor = 'var(--x-accent)'; uploadArea.style.display = 'block'; } } function triggerImageUpload() { document.getElementById('image-file-input').click(); } let uploadedImagesData = []; function handleImageUpload(event) { const files = event.target.files; if (!files || files.length === 0) return; if (uploadedImagesData.length + files.length > 4) { showXToast('最多只能上传4张图片', 'error'); return; } const previewContainer = document.getElementById('preview-images-container'); const previewArea = document.getElementById('uploaded-image-preview'); let loadedCount = 0; const totalFiles = files.length; for (let i = 0; i < files.length; i++) { const file = files[i]; if (!file.type.startsWith('image/')) { showXToast('请选择图片文件', 'error'); continue; } if (file.size > 5 * 1024 * 1024) { showXToast('图片文件不能超过5MB', 'error'); continue; } const reader = new FileReader(); reader.onload = function (e) { const imageData = e.target.result; uploadedImagesData.push(imageData); const previewItem = document.createElement('div'); previewItem.style.cssText = 'position: relative; border-radius: 8px; overflow: hidden;'; previewItem.innerHTML = ` <img src="${imageData}" style="width: 100%; height: 150px; object-fit: cover; display: block;" alt="预览图片"> <div onclick="removeUploadedImage(${ uploadedImagesData.length - 1 })" style="position: absolute; top: 4px; right: 4px; background-color: rgba(0,0,0,0.7); border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(0,0,0,0.9)'" onmouseout="this.style.backgroundColor='rgba(0,0,0,0.7)'"> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #fff;"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </div> `; previewContainer.appendChild(previewItem); previewArea.style.display = 'block'; loadedCount++; if (loadedCount === totalFiles) { showXToast(`成功上传${totalFiles}张图片`, 'success'); } }; reader.readAsDataURL(file); } } window.removeUploadedImage = function (index) { uploadedImagesData.splice(index, 1); const previewContainer = document.getElementById('preview-images-container'); const previewArea = document.getElementById('uploaded-image-preview'); previewContainer.innerHTML = ''; if (uploadedImagesData.length === 0) { previewArea.style.display = 'none'; } else { uploadedImagesData.forEach((imageData, idx) => { const previewItem = document.createElement('div'); previewItem.style.cssText = 'position: relative; border-radius: 8px; overflow: hidden;'; previewItem.innerHTML = ` <img src="${imageData}" style="width: 100%; height: 150px; object-fit: cover; display: block;" alt="预览图片"> <div onclick="removeUploadedImage(${idx})" style="position: absolute; top: 4px; right: 4px; background-color: rgba(0,0,0,0.7); border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(0,0,0,0.9)'" onmouseout="this.style.backgroundColor='rgba(0,0,0,0.7)'"> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #fff;"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </div> `; previewContainer.appendChild(previewItem); }); } showXToast('已移除图片', 'info'); }; function removeImage() { clearImageSection(); toggleImageSection(); } function clearImageSection() { document.getElementById('image-file-input').value = ''; uploadedImagesData = []; document.getElementById('uploaded-image-preview').style.display = 'none'; const previewContainer = document.getElementById('preview-images-container'); if (previewContainer) { previewContainer.innerHTML = ''; } const descTextarea = document.querySelector('#image-description-input textarea'); if (descTextarea) { descTextarea.value = ''; } const descBtn = document.getElementById('img-desc-btn'); const uploadBtn = document.getElementById('img-upload-btn'); descBtn.style.backgroundColor = '#333'; descBtn.style.borderColor = '#536471'; uploadBtn.style.backgroundColor = '#333'; uploadBtn.style.borderColor = '#536471'; document.getElementById('image-description-input').style.display = 'none'; document.getElementById('image-upload-area').style.display = 'none'; } function toggleLocationSection() { const section = document.getElementById('compose-location-section'); const btn = document.getElementById('location-btn'); if (section.style.display === 'none') { section.style.display = 'block'; btn.style.backgroundColor = 'rgba(29,155,240,0.1)'; } else { section.style.display = 'none'; btn.style.backgroundColor = 'transparent'; clearLocationSection(); } } function removeLocation() { clearLocationSection(); toggleLocationSection(); } function clearLocationSection() { document.getElementById('location-input').value = ''; } function toggleLinkSection() { const section = document.getElementById('compose-link-section'); const btn = document.getElementById('attach-btn'); if (section.style.display === 'none') { section.style.display = 'block'; btn.style.backgroundColor = 'rgba(29,155,240,0.1)'; } else { section.style.display = 'none'; btn.style.backgroundColor = 'transparent'; clearLinkSection(); } } function removeLink() { clearLinkSection(); toggleLinkSection(); } function clearLinkSection() { document.getElementById('link-title-input').value = ''; document.getElementById('link-url-input').value = ''; document.getElementById('link-description-input').value = ''; } function resetFunctionButtonStates() { const buttons = ['image-btn', 'location-btn', 'attach-btn']; buttons.forEach(btnId => { const btn = document.getElementById(btnId); btn.style.backgroundColor = 'transparent'; }); } async function togglePrivacySettings() { if (tweetPrivacySetting === 'public') { tweetPrivacySetting = 'private'; } else if (tweetPrivacySetting === 'private') { const hasBusinessTasks = await checkPendingBusinessTasks(); if (hasBusinessTasks) { tweetPrivacySetting = 'business'; } else { tweetPrivacySetting = 'public'; showXToast('当前没有待完成的商业转账任务', 'info'); } } else { tweetPrivacySetting = 'public'; } updatePrivacySettingUI(); } function updatePrivacySettingUI() { const iconPath = document.getElementById('privacy-icon-path'); const textElement = document.getElementById('privacy-text'); if (tweetPrivacySetting === 'public') { iconPath.setAttribute( 'd', 'M12 1.75C6.34 1.75 1.75 6.34 1.75 12S6.34 22.25 12 22.25 22.25 17.66 22.25 12 17.66 1.75 12 1.75zm-.81 14.68l-4.1-3.27 1.25-1.57 2.47 1.98 3.97-5.47 1.62 1.18-5.21 7.15z', ); textElement.textContent = '所有人可以回复'; textElement.style.color = 'var(--x-accent)'; const businessSection = document.getElementById('business-task-selection'); if (businessSection) businessSection.style.display = 'none'; showXToast('已切换为所有人可见', 'success'); } else if (tweetPrivacySetting === 'private') { iconPath.setAttribute( 'd', 'M17.863 13.44c1.477 1.58 2.366 3.8 2.632 6.46l.11 1.1H3.395l.11-1.1c.266-2.66 1.155-4.88 2.632-6.46C7.627 11.85 9.648 11 12 11s4.373.85 5.863 2.44zM12 2C9.791 2 8 3.79 8 6s1.791 4 4 4 4-1.79 4-4-1.791-4-4-4z', ); textElement.textContent = '仅自己可见'; textElement.style.color = 'var(--x-accent)'; const businessSection = document.getElementById('business-task-selection'); if (businessSection) businessSection.style.display = 'none'; showXToast('已切换为仅自己可见', 'success'); } else { iconPath.setAttribute( 'd', 'M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z', ); textElement.textContent = '商业化推贴'; textElement.style.color = 'var(--x-accent)'; showBusinessTaskSelection(); showXToast('已切换为商业化推贴', 'success'); } } async function checkPendingBusinessTasks() { try { const xDb = getXDB(); const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(businessTransfersId); console.log('🔍 [检查商业任务] 数据:', savedData); if (!savedData || !savedData.data) { console.log('🔍 [检查商业任务] 没有保存的数据'); return false; } console.log('🔍 [检查商业任务] 总任务数:', savedData.data.length); const now = new Date(); const pendingTasks = savedData.data.filter(t => { console.log('🔍 [检查任务]', { direction: t.direction, taskStatus: t.taskStatus, taskDeadline: t.taskDeadline, acceptedAt: t.acceptedAt, taskDeadlineHours: t.taskDeadlineHours, }); if (t.direction !== 'received' || t.taskStatus !== 'in_progress') return false; let deadline; if (!t.taskDeadline) { if (t.acceptedAt && t.taskDeadlineHours) { const acceptedTime = new Date(t.acceptedAt); const deadlineHours = parseFloat(t.taskDeadlineHours) || 24; deadline = new Date(acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000); console.log('⚠️ [检查任务] 动态计算截止时间:', deadline.toISOString()); } else { console.warn('⚠️ [检查任务] 任务没有足够信息计算截止时间，仍然认为有效', t); return true; } } else { deadline = new Date(t.taskDeadline); } const isValid = deadline.getTime() > now.getTime(); console.log('🔍 [检查任务] 是否有效:', isValid, '截止时间:', deadline, '现在:', now); return isValid; }); console.log('🔍 [检查商业任务] 有效任务数:', pendingTasks.length); return pendingTasks.length > 0; } catch (error) { console.error('检查商业任务失败:', error); return false; } } async function showBusinessTaskSelection() { try { const xDb = getXDB(); const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(businessTransfersId); const businessSection = document.getElementById('business-task-selection'); const tasksList = document.getElementById('business-tasks-list'); if (!businessSection || !tasksList) return; businessSection.style.display = 'block'; tasksList.innerHTML = ''; if (!savedData || !savedData.data) { tasksList.innerHTML = ` <div style="text-align: center; padding: 24px 12px; color: #71767b; font-size: 13px; "> <svg viewBox="0 0 24 24" style="width: 40px; height: 40px; fill: currentColor; opacity: 0.3; margin: 0 auto 8px;"> <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path></g> </svg> <div>没有待完成的任务</div> </div> `; return; } const now = new Date(); console.log('📋 [显示任务列表] 开始筛选，总数:', savedData.data.length); const pendingTasks = savedData.data.filter(t => { console.log('📋 [筛选任务]', { direction: t.direction, taskStatus: t.taskStatus, taskDeadline: t.taskDeadline, acceptedAt: t.acceptedAt, taskDeadlineHours: t.taskDeadlineHours, }); if (t.direction !== 'received' || t.taskStatus !== 'in_progress') return false; let deadline; if (!t.taskDeadline) { if (t.acceptedAt && t.taskDeadlineHours) { const acceptedTime = new Date(t.acceptedAt); const deadlineHours = parseFloat(t.taskDeadlineHours) || 24; deadline = new Date(acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000); console.log('⚠️ [筛选任务] 动态计算截止时间:', deadline.toISOString()); } else { console.warn('⚠️ [筛选任务] 任务没有足够信息计算截止时间，仍然显示', t.transferId); return true; } } else { deadline = new Date(t.taskDeadline); } const isValid = deadline.getTime() > now.getTime(); console.log('📋 [筛选任务] 是否有效:', isValid); return isValid; }); console.log('📋 [显示任务列表] 筛选后:', pendingTasks.length); if (pendingTasks.length === 0) { tasksList.innerHTML = ` <div style="text-align: center; padding: 24px 12px; color: #71767b; font-size: 13px; "> <svg viewBox="0 0 24 24" style="width: 40px; height: 40px; fill: currentColor; opacity: 0.3; margin: 0 auto 8px;"> <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path></g> </svg> <div>没有待完成的任务</div> </div> `; return; } pendingTasks.forEach(task => { let deadline; if (task.taskDeadline) { deadline = new Date(task.taskDeadline); } else if (task.acceptedAt && task.taskDeadlineHours) { const acceptedTime = new Date(task.acceptedAt); const deadlineHours = parseFloat(task.taskDeadlineHours) || 24; deadline = new Date(acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000); } else { deadline = new Date(now.getTime() + 24 * 60 * 60 * 1000); } const remainingMs = deadline.getTime() - now.getTime(); const hours = Math.floor(remainingMs / (1000 * 60 * 60)); const minutes = Math.floor((remainingMs % (1000 * 60 * 60)) / (1000 * 60)); const deadlineText = hours > 0 ? `剩余 ${hours}小时${minutes}分钟` : `剩余 ${minutes}分钟`; const isSelected = selectedBusinessTransferId === task.transferId; const taskCard = document.createElement('div'); taskCard.style.cssText = ` padding: 14px; margin-bottom: 10px; background: linear-gradient(135deg, ${ isSelected ? 'rgba(255, 255, 255, 0.08)' : 'rgba(255, 255, 255, 0.03)' } 0%, ${isSelected ? 'rgba(255, 255, 255, 0.04)' : 'rgba(255, 255, 255, 0.01)'} 100%); border: 1px solid ${ isSelected ? 'rgba(255, 255, 255, 0.25)' : 'rgba(255, 255, 255, 0.1)' }; border-radius: 10px; cursor: pointer; transition: all 0.2s; position: relative; overflow: hidden; `; taskCard.innerHTML = ` <div style="position: absolute; top: 50%; right: -25px; transform: translateY(-50%) rotate(15deg); font-size: 28px; color: rgba(255, 255, 255, 0.02); font-weight: 700; pointer-events: none; ">TASK</div> <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;"> <div style="flex: 1;"> <div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 4px;"> 来自 ${task.senderName} </div> <div style="color: #71767b; font-size: 11px; font-family: monospace; letter-spacing: 0.3px;">${task.senderHandle}</div> </div> <div style="padding: 4px 10px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 100%); color: #e5e5e5; font-size: 10px; font-weight: 600; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.15); letter-spacing: 0.5px; display: flex; align-items: center; gap: 4px; "> <svg viewBox="0 0 24 24" style="width: 10px; height: 10px; fill: currentColor;"> <g><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path></g> </svg> ${deadlineText} </div> </div> <div style="color: #e5e5e5; font-size: 13px; line-height: 1.4; margin-bottom: 12px; padding: 10px; background: rgba(255, 255, 255, 0.02); border-left: 2px solid rgba(255, 255, 255, 0.15); border-radius: 4px; ">${ task.taskDescription }</div> <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 10px; border-top: 1px dashed rgba(255, 255, 255, 0.1); "> <div style="color: #71767b; font-size: 11px; font-family: monospace; ">$${ task.amount } <span style="opacity: 0.6;">(定金 $${task.depositAmount})</span></div> ${ isSelected ? `<div style="display: inline-flex; align-items: center; gap: 4px; padding: 3px 8px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 100%); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; font-size: 10px; font-weight: 600; color: #fff; letter-spacing: 0.5px; "> <svg viewBox="0 0 24 24" style="width: 10px; height: 10px; fill: currentColor;"> <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"></path></g> </svg> 已选择 </div>` : '' } </div> `; taskCard.onclick = () => { selectedBusinessTransferId = task.transferId; showBusinessTaskSelection(); }; taskCard.onmouseover = function () { if (!isSelected) { this.style.borderColor = 'rgba(255, 255, 255, 0.2)'; this.style.background = 'linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%)'; } }; taskCard.onmouseout = function () { if (!isSelected) { this.style.borderColor = 'rgba(255, 255, 255, 0.1)'; this.style.background = 'linear-gradient(135deg, rgba(255, 255, 255, 0.03) 0%, rgba(255, 255, 255, 0.01) 100%)'; } }; tasksList.appendChild(taskCard); }); } catch (error) { console.error('显示商业任务失败:', error); } } async function publishTweet() { const textInput = document.getElementById('compose-text-input'); const content = textInput.value.trim(); if (!content) { showXToast('请输入推文内容', 'error'); return; } if (tweetPrivacySetting === 'business') { if (!selectedBusinessTransferId) { showXToast('请选择要完成的商业任务', 'error'); return; } } const tweetData = { id: 'user_' + Date.now(), content: content, image: getImageData(), location: getLocationData(), link: getLinkData(), timestamp: new Date(), user: { name: window.userProfileData.name, handle: window.userProfileData.handle, avatar: window.userProfileData.avatar, verified: window.userProfileData.verified, }, stats: { comments: 0, retweets: 0, likes: 0, views: 0, }, comments: [], privacy: tweetPrivacySetting, }; if (tweetPrivacySetting === 'business') { tweetData.businessTransferId = selectedBusinessTransferId; tweetData.isBusinessPost = true; } if (typeof currentQuoteData !== 'undefined' && currentQuoteData) { tweetData.quotedTweet = { type: currentQuoteData.type, user: { name: currentQuoteData.user.name, handle: currentQuoteData.user.handle, avatar: currentQuoteData.user.avatar, verified: currentQuoteData.user.verified, }, content: currentQuoteData.content, time: currentQuoteData.time, image: currentQuoteData.image || null, link: currentQuoteData.link || null, location: currentQuoteData.location || null, }; } if (typeof window.currentQuoteFanGroup !== 'undefined' && window.currentQuoteFanGroup) { tweetData.quotedFanGroup = { id: window.currentQuoteFanGroup.id, name: window.currentQuoteFanGroup.name, avatar: window.currentQuoteFanGroup.avatar, memberCount: window.currentQuoteFanGroup.memberCount, threshold: window.currentQuoteFanGroup.threshold, }; console.log('📤 [发帖] 已添加粉丝群引用到推文数据:', tweetData.quotedFanGroup); } console.log('推文数据:', tweetData); closeComposeTweetModal(); await saveUserTweet(tweetData); if (document.getElementById('x-profile-page').style.display !== 'none') { loadUserProfileTweets(); } showTweetDetail(tweetData); showXToast(currentQuoteData ? '引用转发已发布！' : '发帖成功！', 'success'); if (tweetPrivacySetting === 'business') { showXToast('正在提交任务成果...', 'info'); await handleBusinessPostSubmission(tweetData, selectedBusinessTransferId); } else if (tweetPrivacySetting === 'public') { showXToast('正在等待回复...', 'info'); await generateAIResponseForTweet(tweetData); if (tweetData.quotedFanGroup) { console.log('📤 [粉丝群] 检测到粉丝群引用推文，准备触发申请生成器'); setTimeout(async () => { await triggerFanGroupApplicationGenerator(tweetData); }, 2000); } } } function getImageData() { const imageSection = document.getElementById('compose-image-section'); if (imageSection.style.display === 'none') return null; const descTextarea = document.querySelector('#image-description-input textarea'); if (descTextarea && descTextarea.style.display !== 'none' && descTextarea.value.trim()) { return { type: 'description', content: descTextarea.value.trim(), }; } else if (uploadedImagesData && uploadedImagesData.length > 0) { return { type: 'uploads', images: uploadedImagesData.map(data => ({ content: data })), }; } return null; } function getLocationData() { const locationSection = document.getElementById('compose-location-section'); if (locationSection.style.display === 'none') return null; const locationInput = document.getElementById('location-input'); const location = locationInput.value.trim(); return location ? location : null; } function saveImageData() { showXToast('图片数据已保存', 'success'); } function saveLocationData() { const locationInput = document.getElementById('location-input'); if (locationInput.value.trim()) { showXToast('位置信息已保存', 'success'); } else { showXToast('请先输入位置信息', 'error'); } } function saveLinkData() { const title = document.getElementById('link-title-input').value.trim(); const url = document.getElementById('link-url-input').value.trim(); const description = document.getElementById('link-description-input').value.trim(); if (title || url || description) { showXToast('链接信息已保存', 'success'); } else { showXToast('请先填写链接信息', 'error'); } } function triggerLinkImageUpload() { document.getElementById('link-image-input').click(); } function handleLinkImageUpload(event) { const file = event.target.files[0]; if (!file) return; if (!file.type.startsWith('image/')) { showXToast('请选择图片文件', 'error'); return; } if (file.size > 5 * 1024 * 1024) { showXToast('图片文件不能超过5MB', 'error'); return; } const reader = new FileReader(); reader.onload = function (e) { const previewArea = document.getElementById('link-image-preview'); const previewImg = document.getElementById('link-preview-image'); previewImg.src = e.target.result; previewArea.style.display = 'block'; showXToast('链接首图上传成功', 'success'); }; reader.readAsDataURL(file); } function getLinkData() { const linkSection = document.getElementById('compose-link-section'); if (linkSection.style.display === 'none') return null; const title = document.getElementById('link-title-input').value.trim(); const url = document.getElementById('link-url-input').value.trim(); const description = document.getElementById('link-description-input').value.trim(); const previewImg = document.getElementById('link-preview-image'); const thumbnail = previewImg && previewImg.src.startsWith('data:') ? previewImg.src : null; if (title || url || description || thumbnail) { return { title: title, url: url, description: description, thumbnail: thumbnail, }; } return null; } function clearLinkSection() { document.getElementById('link-title-input').value = ''; document.getElementById('link-url-input').value = ''; document.getElementById('link-description-input').value = ''; document.getElementById('link-image-input').value = ''; document.getElementById('link-image-preview').style.display = 'none'; } window.goBackFromTweetDetail = function () { const currentTweetData = sessionStorage.getItem('currentTweetData'); if (currentTweetData) { try { const tweet = JSON.parse(currentTweetData); if (tweet._source === 'account') { if (isTweetProgressMode) { isTweetProgressMode = false; updateTweetRerollButtonUI(); console.log('📖 [返回] 已重置推进模式'); } document.getElementById('x-tweet-detail-page').style.display = 'none'; document.getElementById('account-profile-page').style.display = 'flex'; return; } else if (tweet._source === 'search') { if (isTweetProgressMode) { isTweetProgressMode = false; updateTweetRerollButtonUI(); console.log('📖 [返回] 已重置推进模式'); } document.getElementById('x-tweet-detail-page').style.display = 'none'; if (isInSearchResults && currentSearchQuery) { document.getElementById('trending-view').style.display = 'none'; document.getElementById('search-results-view').style.display = 'flex'; const backBtn = document.getElementById('search-back-btn'); if (backBtn) backBtn.style.display = 'flex'; const refreshBtn = document.querySelector('.refresh-trends-btn'); if (refreshBtn) refreshBtn.style.display = 'none'; } switchXPage('search'); return; } } catch (e) { console.warn('解析推文数据失败:', e); } } switchXPage('home'); }; async function showTweetDetail(tweetData) { console.log('📖 [显示详情] 开始显示推文详情，推文ID:', tweetData.id); let latestTweetData = tweetData; try { const xDb = getXDB(); const isUserTweet = tweetData.id.startsWith('user_'); if (isUserTweet) { console.log('📖 [显示详情] 从用户推文数据库加载'); const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); if (userTweetsData && userTweetsData.tweets) { const dbTweet = userTweetsData.tweets.find(t => t.id === tweetData.id); if (dbTweet) { latestTweetData = dbTweet; console.log('✅ [显示详情] 已加载最新用户推文数据，评论数:', dbTweet.comments?.length || 0); } else { console.warn('⚠️ [显示详情] 数据库中未找到该用户推文'); } } } else { console.log('📖 [显示详情] 从主页推文数据库加载'); const tweetsData = await xDb.xTweetsData.get('tweets'); if (tweetsData) { let dbTweet = null; if (tweetsData.forYouTweets) { dbTweet = tweetsData.forYouTweets.find(t => t.id === tweetData.id); } if (!dbTweet && tweetsData.followingTweets) { dbTweet = tweetsData.followingTweets.find(t => t.id === tweetData.id); } if (dbTweet) { latestTweetData = dbTweet; console.log('✅ [显示详情] 已加载最新主页推文数据，评论数:', dbTweet.comments?.length || 0); } else { console.warn('⚠️ [显示详情] 数据库中未找到该主页推文'); } } } } catch (loadError) { console.error('❌ [显示详情] 从数据库加载推文失败:', loadError); } sessionStorage.setItem('currentTweetData', JSON.stringify(latestTweetData)); console.log('📖 [显示详情] sessionStorage 已更新'); document.querySelectorAll('.x-page').forEach(page => { page.style.display = 'none'; }); const detailPage = document.getElementById('x-tweet-detail-page'); detailPage.style.display = 'flex'; const isAccountTweet = latestTweetData._source === 'account'; const isSearchTweet = latestTweetData._source === 'search'; const isUserTweet = latestTweetData.id && latestTweetData.id.startsWith('user_'); if (isAccountTweet || isSearchTweet) { const sourceType = isAccountTweet ? '账户推文' : '搜索结果推文'; console.log(`📖 [显示详情] 检测到${sourceType}，强制启用推进模式（该类型推文仅支持推进）`); if (!isTweetProgressMode) { isTweetProgressMode = true; updateTweetRerollButtonUI(); } } else if (isUserTweet) { console.log(`📖 [显示详情] 检测到用户推文，支持重回+推进模式`); updateTweetRerollButtonUI(); } renderTweetDetail(latestTweetData); console.log('✅ [显示详情] 推文详情页面已显示'); setTimeout(() => { const detailCommentUserAvatar = document.getElementById('detail-comment-user-avatar'); if (detailCommentUserAvatar) { detailCommentUserAvatar.src = userProfileData.avatar; } const replyUserAvatars = document.querySelectorAll('.reply-user-avatar'); replyUserAvatars.forEach(avatar => { avatar.src = userProfileData.avatar; }); }, 100); } function renderTweetDetail(tweet) { const container = document.getElementById('tweet-detail-container'); container.setAttribute('data-tweet-id', tweet.id); const detailHTML = ` <div class="tweet-detail-item" style="padding: 16px 16px 4px 16px;"> <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;"> <img src="${tweet.user.avatar}" alt="${tweet.user.name}" onclick="openAccountProfile('${tweet.user.name.replace(/'/g, "\\'")}', '${tweet.user.handle}', '${ tweet.user.avatar }', {source: 'tweetDetail'});event.stopPropagation();" style="width: 48px; height: 48px; border-radius: 50%; cursor: pointer; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'"> <div> <div style="display: flex; align-items: center; gap: 4px;"> <span onclick="openAccountProfile('${tweet.user.name.replace(/'/g, "\\'")}', '${tweet.user.handle}', '${ tweet.user.avatar }', {source: 'tweetDetail'});event.stopPropagation();" style="color: #fff; font-weight: 700; font-size: 17px; cursor: pointer;">${ tweet.user.name }</span> ${ tweet.user.verified ? '<svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>' : '' } </div> <div style="color: #71767b; font-size: 15px;">${ tweet.user.handle.startsWith('@') ? tweet.user.handle : '@' + tweet.user.handle }</div> </div> </div> <div style="color: #fff; font-size: 16px; line-height: 1.3; margin-bottom: 16px; word-wrap: break-word;"> ${processContent(tweet.content)} </div> ${renderTweetMedia(tweet)} ${renderTweetLink(tweet)} ${renderQuotedTweet(tweet)} ${renderQuotedFanGroup(tweet)} <div style="display: flex; align-items: center; justify-content: space-between; margin: 12px 0 16px 0;"> <div style="display: flex; align-items: center; gap: 16px;"> <span style="color: #71767b; font-size: 15px;">${formatDetailTime(tweet.timestamp || tweet.createdAt)}</span> <span style="color: #71767b; font-size: 15px;">·</span> <span id="tweet-detail-views" style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber( tweet.stats.views, )}</span> <span id="tweet-detail-views-label" style="color: #71767b; font-size: 15px;">${getI18nText('tweetDetailViews')}</span> </div> ${ tweet.location ? ` <div style="display: flex; align-items: center; gap: 4px; color: var(--x-accent); font-size: 15px;"> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;"> <g> <path d="M12 7c-1.93 0-3.5 1.57-3.5 3.5S10.07 14 12 14s3.5-1.57 3.5-3.5S13.93 7 12 7zm0 5c-.827 0-1.5-.673-1.5-1.5S11.173 9 12 9s1.5.673 1.5 1.5S12.827 12 12 12zm0-10c-4.687 0-8.5 3.813-8.5 8.5 0 5.967 7.621 11.116 7.945 11.332l.555.37.555-.37C12.879 21.616 20.5 16.467 20.5 10.5 20.5 5.813 16.687 2 12 2zm0 17.77c-1.665-1.241-6.5-5.196-6.5-9.27C5.5 6.916 8.416 4 12 4s6.5 2.916 6.5 6.5c0 4.073-4.835 8.028-6.5 9.27z"></path> </g> </svg> <span>${tweet.location}</span> </div> ` : '' } </div> <div id="tweet-detail-stats" style="display: flex; align-items: center; gap: 32px; padding: 16px 0; border-top: 1px solid #2f3336; border-bottom: 1px solid #2f3336;"> <div style="display: flex; align-items: center; gap: 4px;"> <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(tweet.stats.retweets)}</span> <span style="color: #71767b; font-size: 15px;">${getI18nText('tweetDetailRetweets')}</span> </div> <div style="display: flex; align-items: center; gap: 4px;"> <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(tweet.stats.likes)}</span> <span style="color: #71767b; font-size: 15px;">${getI18nText('tweetDetailLikes')}</span> </div> <div style="display: flex; align-items: center; gap: 4px;"> <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(tweet.stats.comments)}</span> <span style="color: #71767b; font-size: 15px;">${getI18nText('tweetDetailBookmarks')}</span> </div> </div> <div style="display: flex; justify-content: space-between; padding: 12px 0 0 0;"> <div class="tweet-action comment" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'; this.style.color='#1d9bf0';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#71767b';"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;"> <g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g> </svg> </div> <div class="tweet-action retweet" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(0,186,124,0.1)'; this.style.color='#00ba7c';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#71767b';"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;"> <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g> </svg> </div> <div class="tweet-action like" onclick="toggleDetailLike('${tweet.id}', this)" data-liked="false" data-likes="${ tweet.stats.likes }" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(249,24,128,0.1)'; this.style.color='#f91880';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#71767b';"> <svg class="action-icon like-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;"> <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g> </svg> </div> <div class="tweet-action bookmark" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'; this.style.color='#1d9bf0';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#71767b';"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;"> <g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g> </svg> </div> <div class="tweet-action share" id="tweet-detail-share-btn" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'; this.style.color='#1d9bf0';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#71767b';"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;"> <g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.29 3.3-1.42-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g> </svg> </div> </div> </div> `; container.innerHTML = detailHTML; const commentInputAvatar = document.querySelector('#x-tweet-detail-page .detail-comment-input-area img'); if (commentInputAvatar) { commentInputAvatar.src = userProfileData.avatar; } const shareBtn = document.getElementById('tweet-detail-share-btn'); if (shareBtn) { shareBtn.onclick = () => { showShareContentModal( { user: tweet.user, content: tweet.content, time: tweet.time || formatDetailTime(tweet.timestamp), image: tweet.image, fullTweet: tweet, comments: tweet.comments || [], }, 'tweet', ); }; } renderDetailComments(tweet.comments); } function renderTweetMedia(tweet) { if (tweet.media && Array.isArray(tweet.media) && tweet.media.length > 0) { const media = tweet.media[0]; if (media.type === 'description' && media.description) { return ` <div style="margin-bottom: 16px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 16px; padding: 16px;"> <div style="color:var(--x-text-primary); font-size: 15px; line-height: 20px;">${media.description}</div> </div> `; } else if (media.type === 'upload' && media.url) { return ` <div style="margin-bottom: 16px; border-radius: 16px; overflow: hidden;"> <img src="${media.url}" style="width: 100%; max-height: 400px; object-fit: cover; display: block;" alt="推文图片"> </div> `; } } if (!tweet.image) return ''; if (tweet.image.type === 'description') { return ` <div style="margin-bottom: 16px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; padding: 16px; box-sizing: border-box;"> <div style="color:var(--x-text-primary); font-size: 15px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${tweet.image.content}</div> </div> `; } else if (tweet.image.type === 'upload') { return ` <div style="margin-bottom: 16px; border-radius: 16px; overflow: hidden;"> <img src="${tweet.image.content}" style="width: 100%; max-height: 400px; object-fit: cover; display: block;" alt="推文图片"> </div> `; } else if (tweet.image.type === 'uploads' && tweet.image.images && tweet.image.images.length > 0) { const imageCount = tweet.image.images.length; let gridTemplate = ''; if (imageCount === 1) { gridTemplate = 'grid-template-columns: 1fr;'; } else if (imageCount === 2) { gridTemplate = 'grid-template-columns: repeat(2, 1fr);'; } else if (imageCount === 3) { gridTemplate = 'grid-template-columns: repeat(2, 1fr);'; } else { gridTemplate = 'grid-template-columns: repeat(2, 1fr);'; } const imagesHtml = tweet.image.images .map((img, index) => { const spanStyle = imageCount === 3 && index === 0 ? 'grid-column: span 2;' : ''; return ` <div style="${spanStyle}border-radius: 12px; overflow: hidden;"> <img src="${img.content}" style="width: 100%; height: ${ imageCount === 1 ? '400px' : '280px' }; object-fit: cover; display: block;" alt="推文图片${index + 1}"> </div> `; }) .join(''); return ` <div style="margin-bottom: 16px; display: grid; ${gridTemplate} gap: 4px;"> ${imagesHtml} </div> `; } return ''; } function renderTweetLink(tweet) { if (!tweet.link) return ''; return ` <div style="margin-bottom: 16px; border: 1px solid #333; border-radius: 12px; overflow: hidden; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'" onmouseout="this.style.backgroundColor='transparent'"> ${ tweet.link.thumbnail ? ` <div style="width: 100%; height: 200px; background-color: #333;"> <img src="${tweet.link.thumbnail}" style="width: 100%; height: 100%; object-fit: cover;" alt="链接预览图"> </div> ` : '' } <div style="padding: 12px;"> <div style="color: #71767b; font-size: 13px; margin-bottom: 4px;">${tweet.link.url || '链接'}</div> ${ tweet.link.title ? `<div style="color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 4px; line-height: 1.3;">${tweet.link.title}</div>` : '' } ${ tweet.link.description ? `<div style="color: #71767b; font-size: 14px; line-height: 1.4;">${tweet.link.description}</div>` : '' } </div> </div> `; } function renderQuotedTweet(tweet) { if (!tweet.quotedTweet) return ''; const quoted = tweet.quotedTweet; const typeText = quoted.type === 'tweet' ? '推文' : '评论'; return ` <div style="margin-bottom: 16px; border: 1px solid var(--x-border-color); border-radius: 16px; padding: 16px; background-color: var(--x-bg-hover); transition: background-color 0.2s;"> <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;"> <img src="${quoted.user.avatar}" onclick="openAccountProfile('${quoted.user.name.replace(/'/g, "\\'")}', '${quoted.user.handle}', '${ quoted.user.avatar }', {source: 'quotedTweet'});event.stopPropagation();" style="width: 24px; height: 24px; border-radius: 50%; cursor: pointer; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'" alt="${quoted.user.name}"> <div style="display: flex; align-items: center; gap: 4px;"> <span onclick="openAccountProfile('${quoted.user.name.replace(/'/g, "\\'")}', '${quoted.user.handle}', '${ quoted.user.avatar }', {source: 'quotedTweet'});event.stopPropagation();" style="color:var(--x-text-primary); font-size: 15px; font-weight: 700; cursor: pointer;">${ quoted.user.name }</span> ${ quoted.user.verified ? '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>' : '' } <span style="color:var(--x-text-secondary); font-size: 15px;">${quoted.user.handle}</span> <span style="color:var(--x-text-secondary); font-size: 15px;">·${quoted.time}</span> </div> </div> <div style="color:var(--x-text-primary); font-size: 17px; line-height: 1.3; word-wrap: break-word;">${ quoted.content }</div> ${renderQuotedTweetMedia(quoted)} <div style="color:var(--x-text-secondary); font-size: 13px; margin-top: 12px; font-style: italic;">引用${typeText}</div> </div> `; } function renderQuotedTweetMedia(quoted) { if (!quoted.image) return ''; if (quoted.image.type === 'description') { return ` <div style="margin-top: 8px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 8px; box-sizing: border-box;"> <div style="color:var(--x-text-primary); font-size: 13px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${quoted.image.content}</div> </div> `; } else if (quoted.image.type === 'upload') { return ` <div style="margin-top: 8px; border-radius: 8px; overflow: hidden;"> <img src="${quoted.image.content}" style="width: 100%; max-height: 120px; object-fit: cover; display: block;" alt="引用图片"> </div> `; } return ''; } function renderQuotedFanGroup(tweet) { if (!tweet.quotedFanGroup) return ''; const fanGroup = tweet.quotedFanGroup; return ` <div style="margin-bottom: 16px; border: 1px solid var(--x-border-color); border-radius: 16px; padding: 16px; background-color: var(--x-bg-hover); transition: background-color 0.2s; cursor: pointer; " onclick="event.stopPropagation(); showXToast('粉丝群详情功能开发中', 'info');" onmouseover="this.style.backgroundColor='var(--x-bg-secondary)'" onmouseout="this.style.backgroundColor='var(--x-bg-hover)'"> <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;"> <img src="${fanGroup.avatar}" style="width: 48px; height: 48px; border-radius: 50%; object-fit: cover;" alt="${fanGroup.name}"> <div style="flex: 1; min-width: 0;"> <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;"> <span style="color:var(--x-text-primary); font-size: 17px; font-weight: 700;">${fanGroup.name}</span> <span style="padding: 2px 8px; background-color:var(--x-bg-primary); color: var(--x-accent); font-size: 11px; border-radius: 4px; font-weight: 600; border: 1px solid var(--x-accent); ">粉丝群</span> </div> <div style="color:var(--x-text-secondary); font-size: 15px;"> ${fanGroup.memberCount} 位成员 </div> </div> </div> ${ fanGroup.threshold ? ` <div style="padding: 12px; background-color:var(--x-bg-primary); border-radius: 8px; border-left: 3px solid var(--x-accent); margin-bottom: 12px; "> <div style="color:var(--x-text-primary); font-weight: 600; font-size: 13px; margin-bottom: 6px;"> 入群门槛 </div> <div style="color:var(--x-text-secondary); font-size: 15px; line-height: 1.4;"> ${fanGroup.threshold} </div> </div> ` : '' } <div style="display: flex; align-items: center; justify-content: space-between; padding-top: 12px; border-top: 1px solid var(--x-border-color); "> <div style="color:var(--x-text-secondary); font-size: 13px; font-style: italic;"> 引用粉丝群 </div> <div style="display: flex; align-items: center; gap: 4px; color: var(--x-accent); font-size: 13px; font-weight: 600; "> <span>申请加入</span> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;"> <g><path d="M8.58 7.17l4.24 4.24-4.24 4.24 1.42 1.42 5.66-5.66-5.66-5.66z"></path></g> </svg> </div> </div> </div> `; } function formatDetailTime(timestamp) { if (!timestamp) { return '未知时间'; } const date = new Date(timestamp); if (isNaN(date.getTime())) { return '未知时间'; } const formatter = new Intl.DateTimeFormat('zh-CN', { year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit', }); return formatter.format(date); } function toggleDetailLike(tweetId, element) { const isLiked = element.dataset.liked === 'true'; const currentLikes = parseInt(element.dataset.likes); if (isLiked) { element.dataset.liked = 'false'; element.dataset.likes = (currentLikes - 1).toString(); element.style.color = '#71767b'; } else { element.dataset.liked = 'true'; element.dataset.likes = (currentLikes + 1).toString(); element.style.color = '#f91880'; } } function handleDetailCommentInput(event) { const textarea = event.target; updateDetailReplyButtonState(); if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); const hasText = textarea.value.trim().length > 0; const hasSticker = window.getSelectedCommentSticker ? window.getSelectedCommentSticker() !== null : selectedCommentSticker !== null; if (hasText || hasSticker) { submitDetailComment(); } } } function updateDetailReplyButtonState() { const textarea = document.getElementById('detail-comment-input'); const replyBtn = document.getElementById('detail-reply-btn'); if (!replyBtn) return; const hasText = textarea && textarea.value.trim().length > 0; const hasSticker = window.getSelectedCommentSticker ? window.getSelectedCommentSticker() !== null : selectedCommentSticker !== null; if (hasText || hasSticker) { replyBtn.style.opacity = '1'; replyBtn.disabled = false; } else { replyBtn.style.opacity = '0.5'; replyBtn.disabled = true; } } function autoResizeDetail(textarea) { textarea.style.height = '20px'; textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px'; updateDetailReplyButtonState(); } async function submitDetailComment() { const textarea = document.getElementById('detail-comment-input'); const content = textarea.value.trim(); const currentSticker = window.getSelectedCommentSticker ? window.getSelectedCommentSticker() : selectedCommentSticker; console.log('📝 [表情包调试] currentSticker:', currentSticker); if (content.length === 0 && !currentSticker) return; const currentTweetData = sessionStorage.getItem('currentTweetData'); if (!currentTweetData) { showXToast('无法获取推文信息', 'error'); return; } let tweetData; try { tweetData = JSON.parse(currentTweetData); } catch (e) { showXToast('推文数据解析失败', 'error'); return; } console.log('📝 [提交评论] 开始处理评论提交'); console.log('📝 [提交评论] 推文ID:', tweetData.id); console.log('📝 [提交评论] 推文作者:', tweetData.user.handle); console.log('📝 [提交评论] 当前用户:', window.userProfileData.handle); console.log('📝 [提交评论] 是否为用户推文:', tweetData.id.startsWith('user_')); if (tweetData.privacy === 'private') { showXToast('私有帖子不支持回复功能', 'error'); return; } const newComment = { id: 'detail_' + Date.now(), user: { name: window.userProfileData.name, handle: window.userProfileData.handle, avatar: window.userProfileData.avatar, verified: window.userProfileData.verified, }, content: content, time: '刚刚', replies: [], }; if (detailCommentImageData) { newComment.image = { type: 'upload', content: detailCommentImageData, }; } if (currentSticker) { newComment.sticker = { url: currentSticker.url, description: currentSticker.description, }; console.log('📝 [表情包调试] 表情包已添加到newComment:', newComment.sticker); } else { console.log('📝 [表情包调试] 没有表情包数据'); } console.log('📝 [提交评论] 新评论数据:', { id: newComment.id, content: newComment.content.substring(0, 50) + '...', hasImage: !!newComment.image, hasSticker: !!newComment.sticker, }); if (!tweetData.comments) { tweetData.comments = []; } tweetData.comments.push(newComment); if (!tweetData.stats) { tweetData.stats = { comments: 0, retweets: 0, likes: 0, views: 0 }; } tweetData.stats.comments = tweetData.comments.length; console.log('📝 [提交评论] 评论已添加到推文数据，当前评论总数:', tweetData.stats.comments); try { const xDb = getXDB(); const isUserTweet = tweetData.id.startsWith('user_'); const isRetweetMention = tweetData._source === 'retweet_mention'; const isNewTweetMention = tweetData._source === 'newtweet_mention'; if (isRetweetMention) { console.log('📝 [提交评论] 这是 Mentions 转帖，保存到 Mentions 数据'); const mentionsId = `mentions_${currentAccountId || 'main'}`; const mentionsData = await xDb.xAccountProfiles.get(mentionsId); if (mentionsData && mentionsData.data) { const retweetIndex = mentionsData.data.findIndex(m => m.id === tweetData.id && m.type === 'retweet'); if (retweetIndex !== -1) { mentionsData.data[retweetIndex].comments = tweetData.comments; if (!mentionsData.data[retweetIndex].stats) { mentionsData.data[retweetIndex].stats = tweetData.stats; } else { mentionsData.data[retweetIndex].stats.comments = tweetData.stats.comments; } await xDb.xAccountProfiles.put(mentionsData); console.log('✅ [提交评论] Mentions 转帖通知已更新，评论总数:', tweetData.comments.length); } else { console.warn('⚠️ [提交评论] 未在 Mentions 数据中找到对应的转帖通知:', tweetData.id); } } else { console.warn('⚠️ [提交评论] 未找到 Mentions 数据:', mentionsId); } } else if (isNewTweetMention) { console.log('📝 [提交评论] 这是 Mentions New Tweet，保存到 Mentions 数据'); const mentionsId = `mentions_${currentAccountId || 'main'}`; const mentionsData = await xDb.xAccountProfiles.get(mentionsId); if (mentionsData && mentionsData.data) { const newTweetIndex = mentionsData.data.findIndex( m => m.id === tweetData._mentionId && m.type === 'newTweet', ); if (newTweetIndex !== -1) { if (!mentionsData.data[newTweetIndex].tweet) { mentionsData.data[newTweetIndex].tweet = {}; } mentionsData.data[newTweetIndex].tweet.comments = tweetData.comments; if (!mentionsData.data[newTweetIndex].tweet.stats) { mentionsData.data[newTweetIndex].tweet.stats = tweetData.stats; } else { mentionsData.data[newTweetIndex].tweet.stats.comments = tweetData.stats.comments; } await xDb.xAccountProfiles.put(mentionsData); console.log('✅ [提交评论] Mentions New Tweet 通知已更新，评论总数:', tweetData.comments.length); } else { console.warn('⚠️ [提交评论] 未在 Mentions 数据中找到对应的 New Tweet 通知:', tweetData._mentionId); } } else { console.warn('⚠️ [提交评论] 未找到 Mentions 数据:', mentionsId); } } else if (isUserTweet) { console.log('📝 [提交评论] 这是用户自己的推文，保存到 xUserTweets'); const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); if (userTweetsData && userTweetsData.tweets) { console.log('📝 [提交评论] 找到用户推文数据，推文总数:', userTweetsData.tweets.length); const tweetIndex = userTweetsData.tweets.findIndex(t => t.id === tweetData.id); if (tweetIndex !== -1) { console.log('📝 [提交评论] 找到目标推文，索引:', tweetIndex); userTweetsData.tweets[tweetIndex] = tweetData; await xDb.xUserTweets.put(userTweetsData); console.log('✅ [提交评论] 用户推文数据已保存到数据库'); } else { console.warn('⚠️ [提交评论] 未找到目标推文，推文ID:', tweetData.id); } } else { console.warn('⚠️ [提交评论] 未找到用户推文数据'); } } else { console.log('📝 [提交评论] 这是主页推文，保存到 xTweetsData'); const tweetsData = await xDb.xTweetsData.get('tweets'); if (tweetsData) { let updated = false; if (tweetsData.forYouTweets) { const index = tweetsData.forYouTweets.findIndex(t => t.id === tweetData.id); if (index !== -1) { tweetsData.forYouTweets[index] = tweetData; updated = true; console.log('📝 [提交评论] 已更新 forYouTweets'); } } if (tweetsData.followingTweets && !updated) { const index = tweetsData.followingTweets.findIndex(t => t.id === tweetData.id); if (index !== -1) { tweetsData.followingTweets[index] = tweetData; updated = true; console.log('📝 [提交评论] 已更新 followingTweets'); } } if (updated) { await xDb.xTweetsData.put(tweetsData); console.log('✅ [提交评论] 主页推文数据已保存到数据库'); } else { console.warn('⚠️ [提交评论] 未在主页数据中找到目标推文'); } } } sessionStorage.setItem('currentTweetData', JSON.stringify(tweetData)); console.log('✅ [提交评论] sessionStorage 已更新'); } catch (saveError) { console.error('❌ [提交评论] 保存评论到数据库失败:', saveError); showXToast('评论保存失败: ' + saveError.message, 'error'); } const commentsContainer = document.getElementById('detail-comments-container'); console.log('📝 [表情包调试] 渲染前的newComment:', JSON.stringify(newComment, null, 2)); const commentElement = createCommentElement(newComment); commentsContainer.appendChild(commentElement); console.log('📝 [提交评论] 评论已渲染到页面'); const replyUserAvatars = document.querySelectorAll('.reply-user-avatar'); replyUserAvatars.forEach(avatar => { avatar.src = window.userProfileData.avatar; }); if (window.clearCommentInput) { window.clearCommentInput(); } else { textarea.value = ''; textarea.style.height = '20px'; if (detailCommentImageData) { removeDetailCommentImage(); } const preview = document.getElementById('comment-sticker-preview'); if (preview) { preview.remove(); } if (window.setSelectedCommentSticker) { window.setSelectedCommentSticker(null); } else { selectedCommentSticker = null; } const replyBtn = document.getElementById('detail-reply-btn'); replyBtn.style.opacity = '0.5'; replyBtn.disabled = true; } showXToast('你的评论等待回复中', 'info'); const isOwnPost = tweetData.user && (tweetData.user.handle === userProfileData.handle || tweetData.id.startsWith('user_')); console.log('📝 [提交评论] 准备触发AI回复，isOwnPost:', isOwnPost); setTimeout(async () => { try { await generateUnifiedAIResponse(tweetData, newComment, { isOwnPost, commentType: 'main_comment', pageType: 'detail', parentComment: null, }); console.log('✅ [提交评论] AI回复生成完成'); } catch (error) { console.error('❌ [提交评论] AI回复生成失败:', error); } }, 100); console.log('✅ [提交评论] 评论提交流程完成（AI回复已异步触发）'); } function renderDetailComments(comments) { const container = document.getElementById('detail-comments-container'); container.innerHTML = ''; if (!comments || comments.length === 0) return; console.log('📋 [渲染评论] 开始渲染评论，主评论数:', comments.length); comments.forEach(comment => { const commentElement = createCommentElement(comment); container.appendChild(commentElement); if (comment.replies && comment.replies.length > 0) { console.log('📋 [渲染评论] 评论', comment.id, '有', comment.replies.length, '条楼中楼回复'); comment.replies.forEach(reply => { const replyElement = createCommentElement(reply, true); container.appendChild(replyElement); }); } }); console.log('✅ [渲染评论] 评论渲染完成'); const replyUserAvatars = document.querySelectorAll('.reply-user-avatar'); replyUserAvatars.forEach(avatar => { avatar.src = userProfileData.avatar; }); } async function handleBusinessPostSubmission(tweetData, businessTransferId) { try { console.log('💼 [商业推贴] 开始处理任务提交'); const xDb = getXDB(); const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(businessTransfersId); if (!savedData || !savedData.data) { console.error('❌ 未找到商业转账数据'); return; } const businessTransfer = savedData.data.find(t => t.transferId === businessTransferId); if (!businessTransfer) { console.error('❌ 未找到对应的商业转账'); return; } console.log('✅ [商业推贴] 找到商业转账:', businessTransfer); const conversationId = `messageConversation_${currentAccountId || 'main'}_${businessTransfer.conversationId}`; const conversation = await xDb.xAccountProfiles.get(conversationId); if (!conversation) { console.error('❌ 未找到对话信息'); showXToast('无法找到对应的对话，请手动联系对方', 'error'); return; } console.log('✅ [商业推贴] 找到对话:', conversation); const conversationData = { id: businessTransfer.conversationId, user: { name: businessTransfer.senderName, handle: businessTransfer.senderHandle, avatar: businessTransfer.senderAvatar, verified: false, }, }; await triggerBusinessTaskEvaluation(tweetData, businessTransfer, conversationData); } catch (error) { console.error('❌ [商业推贴] 处理失败:', error); showXToast('提交失败: ' + error.message, 'error'); } } async function triggerBusinessTaskEvaluation(tweetData, businessTransfer, conversationData) { try { console.log('🤖 [商业任务评估] 开始AI评估流程'); console.log('📝 [商业任务评估] 步骤1：生成AI评论...'); const businessTweetData = { ...tweetData, _isBusinessPost: true, _businessTransferId: businessTransfer.transferId, _taskDescription: businessTransfer.taskDescription, }; await generateAIResponseForTweet(businessTweetData); setTimeout(async () => { console.log('💬 [商业任务评估] 步骤2：发送AI评估私信...'); showPhoneNotification({ title: 'X', message: `${conversationData.user.name} 正在评估你的任务完成情况...`, avatar: conversationData.user.avatar, leftIcon: 'x', }); await generateBusinessTaskEvaluationMessage(tweetData, businessTransfer, conversationData); }, 3000); } catch (error) { console.error('❌ [商业任务评估] 失败:', error); showXToast('任务评估失败: ' + error.message, 'error'); } } async function generateBusinessTaskEvaluationMessage(tweetData, businessTransfer, conversationData) { try { console.log('💼 [AI评估] 开始生成评估私信'); const evaluationContext = { isBusinessTaskEvaluation: true, tweetData: tweetData, businessTransfer: businessTransfer, }; const messageData = { id: conversationData.id, user: conversationData.user, }; const aiMessages = await generateMessageConversation(messageData, true, { isAutoMessage: true, businessTaskEvaluation: evaluationContext, }); if (!aiMessages || aiMessages.length === 0) { console.error('❌ [AI评估] 未生成评估消息'); return; } console.log('✅ [AI评估] 生成了评估消息:', aiMessages); const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversationData.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data) { aiMessages.forEach(msg => { savedConversation.data.messages.push({ ...msg, isOwn: false, timestamp: new Date().toISOString(), }); }); await xDb.xAccountProfiles.put(savedConversation); console.log('✅ [AI评估] 评估消息已保存到数据库'); const transferMessages = aiMessages.filter(msg => msg.type === 'transfer'); if (transferMessages.length > 0) { for (const transferMsg of transferMessages) { await handleAIBusinessPayment(transferMsg, businessTransfer, conversationData); } } setTimeout(() => { showPhoneNotification({ title: 'X', message: `${conversationData.user.name} 已完成任务评估`, avatar: conversationData.user.avatar, leftIcon: 'x', }); }, 1000); } } catch (error) { console.error('❌ [AI评估] 生成评估私信失败:', error); } } async function handleAIBusinessPayment(transferMessage, businessTransfer, conversationData) { try { console.log('💰 [AI付款] 处理商业任务付款:', transferMessage); const amount = parseFloat(transferMessage.amount || 0); if (amount <= 0) return; await loadWalletData(); const currentBalance = parseFloat(walletData.balance) || 0; walletData.balance = currentBalance + amount; const senderName = conversationData.user?.name || '对方'; let transactionDesc = ''; if (transferMessage.note) { transactionDesc = `${senderName} - ${transferMessage.note}`; } else { transactionDesc = `商业转账尾款 - ${senderName}`; } const transaction = { id: 'business_payment_' + Date.now(), description: transactionDesc, amount: amount, timestamp: new Date().toISOString(), type: 'business_transfer_remaining_in', }; walletData.transactions.unshift(transaction); await saveWalletData(); const xDb = getXDB(); const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(businessTransfersId); if (savedData && savedData.data) { const transfer = savedData.data.find(t => t.transferId === businessTransfer.transferId); if (transfer) { transfer.taskStatus = 'completed'; transfer.completedAt = new Date().toISOString(); await xDb.xAccountProfiles.put(savedData); console.log('✅ [AI付款] 商业转账状态已更新为已完成'); } } console.log('✅ [AI付款] 付款完成，金额:', amount, '新余额:', walletData.balance); setTimeout(() => { showPhoneNotification({ title: 'X Wallet', message: `已收款 $${amount.toFixed(2)}, 当前余额 $${walletData.balance.toFixed(2)}`, avatar: window.userProfileData?.avatar, leftIcon: 'x', }); }, 2000); } catch (error) { console.error('❌ [AI付款] 处理付款失败:', error); } } let isTweetProgressMode = false; let tweetProgressLongPressTimer = null; function calculateSimilarity(str1, str2) { if (str1 === str2) return 1; if (str1.length === 0 || str2.length === 0) return 0; const longer = str1.length > str2.length ? str1 : str2; const shorter = str1.length > str2.length ? str2 : str1; let matches = 0; const shorterChars = shorter.split(''); const longerChars = longer.split(''); shorterChars.forEach(char => { const index = longerChars.indexOf(char); if (index !== -1) { matches++; longerChars.splice(index, 1); } }); const similarity = matches / longer.length; if (longer.includes(shorter)) { return Math.max(similarity, shorter.length / longer.length); } return similarity; } async function generateAIResponseForTweet(tweetData, isReroll = false, isProgressMode = false) { try { const { db, xDb, apiConfig, xSettings } = await APIUtils.loadConfigAndSettings(); const { userPrompt, worldSetting, boundCharacters } = xSettings; const isAccountTweet = tweetData._source === 'account'; const isUserTweet = tweetData.id && tweetData.id.startsWith('user_'); const isBusinessPost = tweetData.isBusinessPost === true; let targetProfileInfo; let isBoundCharacterAccount = false; let boundCharacterIdForAccount = null; let isUserOwnTweet = isUserTweet; console.log('🔍 [发帖生成器] 推文类型检测:', { isAccountTweet, isUserTweet, isBusinessPost, tweetId: tweetData.id, }); if (isAccountTweet) { console.log('🔍 [AI生成] 检测到账户推文，加载账户资料'); let accountData = currentViewingAccount; if (!accountData && tweetData._accountHandle) { const cleanHandle = tweetData._accountHandle.replace('@', ''); accountData = await xDb.xAccountProfiles.get(cleanHandle); } if (accountData) { const accountInfo = accountData.accountInfo || accountData; targetProfileInfo = { name: accountInfo.name, handle: accountInfo.handle, avatar: accountInfo.avatar, verified: accountInfo.verified || false, verificationType: accountInfo.verificationType || 'none', publicIdentity: accountInfo.publicIdentity || '', bio: accountInfo.bio || '', knownIdentityCharacters: [], }; console.log('✅ [AI生成] 已加载账户资料:', targetProfileInfo.name); if (boundCharacters && boundCharacters.length > 0) { const allXProfiles = await xDb.xCharacterProfiles.toArray(); const cleanHandle = accountInfo.handle.replace('@', ''); for (const charId of boundCharacters) { const xProfile = allXProfiles.find(p => p.characterId === charId); if (xProfile && xProfile.xHandle === cleanHandle) { isBoundCharacterAccount = true; boundCharacterIdForAccount = charId; console.log('🎭 [AI生成] 识别到绑定角色账户:', accountInfo.name, '(', charId, ')'); break; } } } } else { console.warn('⚠️ [AI生成] 未找到账户资料，使用推文用户信息'); targetProfileInfo = { name: tweetData.user.name, handle: tweetData.user.handle, avatar: tweetData.user.avatar, verified: tweetData.user.verified || false, verificationType: tweetData.user.verificationType || 'none', publicIdentity: '', bio: '', knownIdentityCharacters: [], }; } } else if (isUserTweet) { console.log('✅ [发帖生成器] 检测到用户推文，使用用户资料'); targetProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); } else { console.log('🔍 [发帖生成器] 检测到主页推文，查询发帖人资料:', tweetData.user.handle); try { const posterProfile = await StringBuilders.getUnifiedProfile(tweetData.user.handle, { userProfileInfo: window.userProfileData, }); if (posterProfile) { console.log('✅ [发帖生成器] 已获取发帖人资料:', posterProfile.name); if (posterProfile.type === 'character' && boundCharacters.includes(posterProfile.characterId)) { isBoundCharacterAccount = true; boundCharacterIdForAccount = posterProfile.characterId; console.log('🎭 [发帖生成器] 发帖人是绑定角色:', posterProfile.name); } targetProfileInfo = { name: posterProfile.name, handle: posterProfile.handle, avatar: posterProfile.avatar, verified: posterProfile.verified || false, verificationType: posterProfile.xProfile?.xVerified ? 'verified' : 'none', publicIdentity: posterProfile.publicIdentity || '', bio: posterProfile.bio || '', knownIdentityCharacters: [], }; isUserOwnTweet = false; } else { console.warn('⚠️ [发帖生成器] 未找到发帖人资料，使用推文用户信息'); targetProfileInfo = { name: tweetData.user.name, handle: tweetData.user.handle, avatar: tweetData.user.avatar, verified: tweetData.user.verified || false, verificationType: tweetData.user.verificationType || 'none', publicIdentity: '', bio: '', knownIdentityCharacters: [], }; isUserOwnTweet = false; } } catch (error) { console.error('❌ [发帖生成器] 获取发帖人资料失败:', error); targetProfileInfo = { name: tweetData.user.name, handle: tweetData.user.handle, avatar: tweetData.user.avatar, verified: tweetData.user.verified || false, verificationType: tweetData.user.verificationType || 'none', publicIdentity: '', bio: '', knownIdentityCharacters: [], }; isUserOwnTweet = false; } } const userXProfileInfo = targetProfileInfo; console.log('📋 [发帖生成器] 最终资料信息:', { name: userXProfileInfo.name, handle: userXProfileInfo.handle, isUserOwnTweet, isBoundCharacterAccount, boundCharacterIdForAccount, }); let knownIdentityCharactersInfo = ''; if (isUserOwnTweet && userXProfileInfo.knownIdentityCharacters.length > 0 && boundCharacters.length > 0) { const allChats = await db.chats.toArray(); const knownCharacters = allChats.filter( chat => !chat.isGroup && userXProfileInfo.knownIdentityCharacters.includes(chat.id), ); if (knownCharacters.length > 0) { knownIdentityCharactersInfo = '\n\n【知道用户身份的角色】：'; for (const char of knownCharacters) { let xProfile = await xDb.xCharacterProfiles.get(char.id); if (xProfile) { knownIdentityCharactersInfo += `\n- ${xProfile.xName} (${xProfile.xHandle}): 知道用户身份，可能会对用户的帖子进行互动`; if (char.history && char.history.length > 0) { const recentHistory = char.history.slice(-5); knownIdentityCharactersInfo += '\n 最近互动记忆：'; recentHistory.forEach(msg => { if (msg.role === 'assistant' && msg.content) { knownIdentityCharactersInfo += `\n - ${msg.content.substring(0, 80)}...`; } }); } } } knownIdentityCharactersInfo += '\n\n注意：这些角色可能会对用户的帖子进行评论，但概率不要太高，要自然。'; } } let tokenCount = 0; let systemPrompt = StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting, }); tokenCount = TokenUtils.logTokenUsage('发帖生成器', '基础系统提示词', systemPrompt, tokenCount); const worldBooksOptions = { boundCharacters: [] }; if (isBoundCharacterAccount && boundCharacterIdForAccount) { worldBooksOptions.boundCharacters = [boundCharacterIdForAccount]; console.log('📚 [发帖生成器] 加载绑定角色的世界书'); } else if (isUserOwnTweet) { worldBooksOptions.boundCharacters = boundCharacters; console.log('📚 [发帖生成器] 加载用户所有绑定角色的世界书'); } else { worldBooksOptions.boundCharacters = []; console.log('📚 [发帖生成器] 跳过世界书（非用户推文）'); } const worldBooksContent = await StringBuilders.getApplicableWorldBooks('tweetDetail', worldBooksOptions); if (worldBooksContent) { systemPrompt += worldBooksContent; tokenCount = TokenUtils.logTokenUsage('发帖生成器', '世界书内容', worldBooksContent, tokenCount); } const tweetAuthor = isUserOwnTweet ? '用户' : `${userXProfileInfo.name} (${userXProfileInfo.handle})`; if (isProgressMode) { const tweetTimestamp = tweetData.timestamp || Date.now(); const now = Date.now(); const minutesPassed = Math.floor((now - tweetTimestamp) / (1000 * 60)); const hoursPassed = Math.floor(minutesPassed / 60); const daysPassed = Math.floor(hoursPassed / 24); let timePassedDesc; if (daysPassed > 0) { timePassedDesc = `${daysPassed}天${hoursPassed % 24}小时`; } else if (hoursPassed > 0) { timePassedDesc = `${hoursPassed}小时${minutesPassed % 60}分钟`; } else { timePassedDesc = `${minutesPassed}分钟`; } systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务：推进帖子互动 🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的互动生成器。${tweetAuthor}的帖子已发布一段时间，你的任务是： ✅ 生成**新的**评论和互动（在已有评论基础上继续） ✅ 更新互动数据（点赞、转发、浏览量应该增加） ❌ 绝对不能生成${tweetAuthor}本人发表的任何内容 ❌ 绝对不能重复已有评论的内容或观点 **时间信息**： - 帖子发布已过去：${timePassedDesc} - 已有评论数量：${tweetData.comments?.length || 0} 条 **推进模式生成策略**： 1. **优先生成楼中楼回复**（70%）： - 对已有评论进行回复、补充或讨论 - 使用 replyTo 字段指定回复对象 - 可以赞同、质疑、或提出新角度 2. **次要生成新顶层评论**（30%）： - 必须带有明显的时间感（"刚看到"、"终于找到"、"现在才发现"等） - 角度必须与所有已有评论完全不同 - 可以是迟到者的独特视角或冷静分析 3. **内容创新要求**： - 不要重复任何已有的观点、表达或句式 - 提供新的信息、角度或情绪 - 互动数据应反映热度持续（点赞、转发、浏览量增加） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`; } else { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🚫 核心任务说明 🚫 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的互动生成器。${tweetAuthor}刚发布了一条新帖子，你的任务是： ✅ 生成其他X平台用户对这条帖子的评论和反应 ❌ 绝对不能生成${tweetAuthor}本人发表的任何内容 **明确：${tweetAuthor}已经发布了推文，你只负责生成别人的回应！** ${ !isUserOwnTweet && !isBoundCharacterAccount ? `⚠️ **特别注意**：这是${tweetAuthor}发布的推文，与当前用户无关。 - 应该生成普通路人用户的评论 - 评论者是看到这条推文的陌生网友 - 不要假设评论者与${tweetAuthor}有任何私人关系` : '' } ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`; } const coreTaskSection = systemPrompt.substring(systemPrompt.lastIndexOf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━')); tokenCount = TokenUtils.logTokenUsage('发帖生成器', '核心任务说明', coreTaskSection, tokenCount); let charactersInfo = ''; const userInfoForCharacter = isBoundCharacterAccount || isUserOwnTweet ? StringBuilders.buildUserXProfileInfo(window.userProfileData) : null; if (isBoundCharacterAccount && boundCharacterIdForAccount) { console.log('📋 [发帖生成器] 发帖人是绑定角色，只加载该角色信息（传递真实用户资料以判断身份识别）'); charactersInfo = await StringBuilders.buildCompleteCharacterInfo( [boundCharacterIdForAccount], userInfoForCharacter, 'reaction', ); } else if (isUserOwnTweet) { console.log('📋 [发帖生成器] 用户推文，加载所有绑定角色信息'); charactersInfo = await StringBuilders.buildCompleteCharacterInfo( boundCharacters, userInfoForCharacter, 'reaction', ); } else { console.log('📋 [发帖生成器] 其他人的推文，不加载用户角色（将生成路人评论）'); charactersInfo = ''; } if (charactersInfo) { systemPrompt += charactersInfo; tokenCount = TokenUtils.logTokenUsage('发帖生成器', '角色资料信息', charactersInfo, tokenCount); } else { console.log('ℹ️ [发帖生成器] 跳过角色资料（非用户推文或无绑定角色）'); } if ((isUserOwnTweet || isBoundCharacterAccount) && boundCharacters && boundCharacters.length > 0) { const relationshipsInfo = await StringBuilders.buildCharacterRelationships(boundCharacters, currentAccountId); if (relationshipsInfo) { systemPrompt += relationshipsInfo; tokenCount = TokenUtils.logTokenUsage('发帖生成器', '角色关系网络', relationshipsInfo, tokenCount); } } if (knownIdentityCharactersInfo) { systemPrompt += knownIdentityCharactersInfo; tokenCount = TokenUtils.logTokenUsage('发帖生成器', '已知身份角色', knownIdentityCharactersInfo, tokenCount); } let mentionedAccountsInfo = ''; const mentionRegex = /@(\w+)/g; const mentions = [...tweetData.content.matchAll(mentionRegex)]; if (mentions.length > 0) { console.log(`📢 [发帖生成器] 检测到${mentions.length}个@提及`); const mentionHandles = [...new Set(mentions.map(m => m[1]))]; for (const handle of mentionHandles) { try { const mentionedProfile = await StringBuilders.getUnifiedProfile(`@${handle}`, { userProfileInfo: isUserOwnTweet ? window.userProfileData : null, }); if (mentionedProfile) { const mentionStart = systemPrompt.length; systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📢 被@提及的账户资料 📢 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 推文中提到了 ${mentionedProfile.handle}，以下是该账户的详细信息： `; systemPrompt += StringBuilders.formatProfileForPrompt(mentionedProfile, { includeType: true, includeTweets: true, includeRelationships: true, }); systemPrompt += ` ⚠️ 被@提及的影响： - 该账户看到自己被@提及后，可能会来评论区互动 - 出现概率根据以下因素决定： * 与发帖者的关系（认识/陌生） * 推文内容的相关性 * 该账户的活跃度和性格 - 如果该账户来评论，必须严格使用上述资料信息 - 评论内容要符合被@的情境（如被请教、被吐槽、被感谢等） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const mentionSection = systemPrompt.substring(mentionStart); tokenCount = TokenUtils.logTokenUsage( '发帖生成器', `@提及账户 ${mentionedProfile.handle}`, mentionSection, tokenCount, ); } } catch (error) { console.error(`❌ [发帖生成器] 读取@${handle}资料失败:`, error); } } } const userConstraintsStart = systemPrompt.length; systemPrompt += StringBuilders.buildUniversalConstraints(userXProfileInfo); const userConstraints = systemPrompt.substring(userConstraintsStart); tokenCount = TokenUtils.logTokenUsage('发帖生成器', '用户资料约束', userConstraints, tokenCount); if (isProgressMode && tweetData.comments && tweetData.comments.length > 0) { const existingCommentsStart = systemPrompt.length; systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ⚠️ 【已有评论上下文 - 严禁重复】⚠️ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 以下是该帖子**已存在**的所有评论（共${tweetData.comments.length}条），**绝对不能**生成与这些内容相似或重复的评论： `; tweetData.comments.forEach((comment, index) => { systemPrompt += `${index + 1}. ${comment.user.name} (${comment.user.handle}): "${comment.content}"`; if (comment.sticker) { systemPrompt += ` [含表情包: ${comment.sticker.description}]`; } if (comment.image) { systemPrompt += ` [含图片]`; } systemPrompt += `\n`; if (comment.replies && comment.replies.length > 0) { comment.replies.forEach(reply => { systemPrompt += ` └─ ${reply.user.name} (${reply.user.handle}): "${reply.content}"`; if (reply.sticker) { systemPrompt += ` [含表情包: ${reply.sticker.description}]`; } if (reply.image) { systemPrompt += ` [含图片]`; } systemPrompt += `\n`; }); } }); systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🚫 【严格要求 - 必须遵守】🚫 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1. **绝对禁止**重复上述任何评论的观点、内容或表达方式 2. **绝对禁止**使用与上述评论相似的句式或措辞 3. **必须生成**全新的、不同角度的评论 4. 新评论应该： - 提出完全不同的观点或看法 - 使用不同的表达方式和语气 - 可以是对已有评论的**补充回复**（楼中楼，使用replyTo字段） - 可以从时间角度切入（如"刚看到"、"终于找到这个帖子"等） - 可以是新角度的提问、质疑或讨论 5. 如果实在找不到新角度，优先生成楼中楼回复而非新评论 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const existingComments = systemPrompt.substring(existingCommentsStart); tokenCount = TokenUtils.logTokenUsage('发帖生成器', '已有评论上下文', existingComments, tokenCount); } systemPrompt += ` 【生成要求】： - 生成${isProgressMode ? '3-8' : '3-15'}条评论，内容多样化（简短/深度/表情符号），支持楼中楼回复，全年龄适宜 ${ isProgressMode ? `- ⚠️ **推进模式特殊要求**： * 优先生成楼中楼回复（对已有评论的回复）而非新的顶层评论 * 新顶层评论必须有明显的时间感（如"刚看到"、"现在才发现"等） * 新评论角度要与已有评论**完全不同**，不要重复任何观点 * 可以是后来者的补充、质疑、或从全新角度的讨论` : '' } ${ isBusinessPost ? `- 💼 **商业推文特殊要求**： * 这是一条商业化推文（广告/推广性质），数据应该更高 * 互动数据（点赞、转发、浏览量）应该是普通推文的1.5-3倍 * 评论区应该有30-50%是正面支持性评论（"支持！"、"好棒"、"已下单"等） * 20-30%是询问相关信息的评论（"在哪买"、"多少钱"、"怎么联系"等） * 10-20%可以是中性或轻微质疑的评论（保持真实感） * 评论风格应该更像粉丝/潜在客户，而非批评者 * 如果用户有较高知名度，应该体现出粉丝经济效应` : '' } - 引用转发处理：如帖子含引用内容，评论可涉及用户观点和被引用原内容 - 公众身份影响：知名度越高，讨论热度和互动数据越多 - 除了绑定角色外，其他用户头像统一：https: - 图片支持：评论可以包含文字图片（10-20%的评论带图），用于展示图片视频等媒体，图片描述应详细具体 【🔒 隐私保护规则 - 路人评论限制】： 🚨 路人评论者（非绑定角色/关系NPC的普通用户）只能基于X平台公开信息： ✅ 可以使用：X姓名、X句柄、X简介、公开身份 ❌ 禁止提及：真实姓名、真实职业、私人关系、未公开的身份信息 ❌ 禁止使用：只有亲密关系才知道的称呼（如"老师"、"同学"、"同事"等，除非是公开身份） ❌ 禁止提及：角色人设描述中的私密细节 示例说明： - ✅ 正确："@handle 姐姐太美了"（基于公开身份"网红"） - ❌ 错误："@handle 张老师这节课讲得真好"（泄露了真实职业"老师"和真实姓氏） - ❌ 错误："@handle 李老师今天也这么漂亮"（泄露了真实姓名） ⚠️ 只有已绑定的关系NPC才能提及私密信息（因为他们是角色的私人关系） 【情侣角色回复规则】： ${ userXProfileInfo.verificationType === 'couple' && userXProfileInfo.coupleCharacterName ? `- 用户的情侣是 ${userXProfileInfo.coupleCharacterName}（公开关系） - 出现概率应很低（10-20%，与帖子无关时更低） - 评论围绕帖子主题，自然体现亲密关系但不过分强调 - 粉丝群体限制：仅当双方为明星/网红/公众人物时才可能生成1-2条CP粉丝评论，普通情侣严禁生成"磕CP""嗑糖"等粉丝向评论` : '' } 【JSON返回格式】： \`\`\`json { "stats": {retweets, likes, views, comments}, "comments": [评论数组] } \`\`\` 评论对象结构： - user: {name, handle, avatar, verified} - content: 评论文本 (可与sticker同时存在) - timeOffset: 相对推文发布的分钟数（负数，如-5表示推文发布后5分钟的评论） - sticker: {url: "表情包链接", description: "表情包描述"} (可选，约10-15%评论使用) - image: {type: "description", content: "图片文字描述"} (可选，10-20%的评论带图) - replies: [回复数组] (可选，楼中楼回复，不超过3层) - replyTo: "@被回复者句柄" (楼中楼回复时必填) 【表情包使用规则】： - 表情包仅限使用世界书中提供的真实链接，严禁虚构或编造链接 - 表情包与文字内容可以同时存在，用于增强表达效果 - 使用频率控制在约10-15%的评论中，保持自然 - sticker对象包含url和description两个必需字段 关键规则： 1. verified字段必须是布尔值(true/false) 2. stats中所有数字必须是纯数字 3. timeOffset必须是负数，表示评论发布在推文之后多少分钟（如-5, -10, -30等） 4. 支持多层对话链：A评论 → B回复A(replyTo:"@A") → C回复B(replyTo:"@B") 5. sticker字段只能使用世界书中存在的真实链接，禁止虚构`; const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】')); tokenCount = TokenUtils.logTokenUsage('发帖生成器', 'JSON格式要求', formatSection, tokenCount); const messageContent = []; let contentText = `请为这条推文生成社交互动数据： 推文内容："${tweetData.content}" ${tweetData.location ? `位置：${tweetData.location}` : ''}`; if (tweetData.link) { contentText += '\n\n【附带链接】：'; if (tweetData.link.title) contentText += `\n标题：${tweetData.link.title}`; if (tweetData.link.url) contentText += `\n地址：${tweetData.link.url}`; if (tweetData.link.description) contentText += `\n描述：${tweetData.link.description}`; if (tweetData.link.thumbnail) contentText += '\n[含链接首图]'; } if (tweetData.quotedTweet) { const quoted = tweetData.quotedTweet; const quotedType = quoted.type === 'tweet' ? '推文' : '评论'; contentText += ` 【引用${quotedType}】： 原作者：${quoted.user.name} (${quoted.user.handle})${quoted.user.verified ? ' ✓已认证' : ''} 发布时间：${quoted.time} 原内容："${quoted.content}"`; if (quoted.image) { if (quoted.image.type === 'description') { contentText += ` 原图片描述：${quoted.image.content}`; } else if (quoted.image.type === 'upload') { contentText += ` 原图片：包含上传的图片内容`; } } if (quoted.location) { contentText += ` 原位置：${quoted.location}`; } contentText += ` 注意：这是一条引用转发，用户对原${quotedType}进行了评论并转发。AI回复应该考虑到这个引用关系和上下文，生成的评论可能会同时涉及用户的评论和被引用的原内容。`; } if (tweetData.quotedFanGroup) { const fanGroup = tweetData.quotedFanGroup; contentText += ` 【引用粉丝群】： 群名：${fanGroup.name} 当前成员数：${fanGroup.memberCount || 0} 位 入群门槛：${fanGroup.threshold || '无'} 注意：这是一条转发粉丝群链接的推文，用户在宣传/分享自己的粉丝群。AI回复应该： 1. 考虑粉丝群的主题和门槛要求 2. 评论者可能对加入粉丝群表示兴趣，询问详情 3. 评论者可能讨论入群门槛是否合理 4. 如果门槛涉及金钱，可能有人讨论价格 5. 真实粉丝会表示支持，普通路人会好奇询问，也可能有质疑的声音 6. 评论应该围绕"粉丝群招募"这个核心话题展开`; } messageContent.push({ type: 'text', text: contentText }); if (tweetData.image) { if (tweetData.image.type === 'upload' && tweetData.image.content) { messageContent.push({ type: 'image_url', image_url: { url: tweetData.image.content }, }); } else if (tweetData.image.type === 'uploads' && tweetData.image.images && tweetData.image.images.length > 0) { tweetData.image.images.forEach((img, index) => { if (img.content) { messageContent.push({ type: 'image_url', image_url: { url: img.content }, }); } }); } else if (tweetData.image.type === 'description') { messageContent.push({ type: 'text', text: `图片描述：${tweetData.image.content}`, }); } } const messages = [{ role: 'user', content: messageContent }]; const contextText = messageContent.map(c => c.text || '[图片]').join(' '); tokenCount = TokenUtils.logTokenUsage('发帖生成器', '上下文信息', contextText, tokenCount); TokenUtils.logFinalPrompt('发帖生成器', systemPrompt, contextText); const aiResponseContent = await APIUtils.sendAIRequest({ apiConfig, systemPrompt, messages, temperature: 0.8, }); console.log('用户身份识别调试信息（发帖AI回复）:'); console.log('- 用户X资料:', userXProfileInfo); console.log('- 知道用户身份的角色数量:', userXProfileInfo.knownIdentityCharacters.length); if (knownIdentityCharactersInfo) { console.log('- 知道用户身份的角色信息已添加到AI上下文'); } let interactionData = APIUtils.parseJSONResponse(aiResponseContent); interactionData = await APIUtils.postProcessData(interactionData, userXProfileInfo); if (!interactionData.stats || !interactionData.comments) { throw new Error('AI返回的数据格式不正确'); } if (isProgressMode && tweetData.comments && tweetData.comments.length > 0) { const existingComments = tweetData.comments; const newComments = interactionData.comments || []; const filteredComments = newComments.filter(newComment => { const newContent = newComment.content.toLowerCase().trim(); const isDuplicate = existingComments.some(existingComment => { const existingContent = existingComment.content.toLowerCase().trim(); if (existingContent === newContent) return true; const similarity = calculateSimilarity(newContent, existingContent); if (similarity > 0.7) { console.log(`🔍 [重复检测] 发现相似评论 (${(similarity * 100).toFixed(0)}%):`, { existing: existingComment.content, new: newComment.content, }); return true; } if (existingComment.replies && existingComment.replies.length > 0) { return existingComment.replies.some(reply => { const replyContent = reply.content.toLowerCase().trim(); if (replyContent === newContent) return true; const replySimilarity = calculateSimilarity(newContent, replyContent); if (replySimilarity > 0.7) { console.log(`🔍 [重复检测] 发现与楼中楼回复相似的评论 (${(replySimilarity * 100).toFixed(0)}%)`); return true; } return false; }); } return false; }); return !isDuplicate; }); const removedCount = newComments.length - filteredComments.length; if (removedCount > 0) { console.log(`✅ [去重] 移除了 ${removedCount} 条重复评论，保留 ${filteredComments.length} 条新评论`); interactionData.comments = filteredComments; } if (filteredComments.length === 0) { showXToast('AI生成的评论与已有内容重复，已自动过滤', 'warning'); return; } } const timestamp = Date.now(); let tweetTimestamp = tweetData.timestamp || timestamp; if (typeof tweetTimestamp !== 'number') { if (tweetTimestamp instanceof Date) { tweetTimestamp = tweetTimestamp.getTime(); } else if (typeof tweetTimestamp === 'string') { tweetTimestamp = new Date(tweetTimestamp).getTime(); } else { tweetTimestamp = timestamp; } } if (isNaN(tweetTimestamp) || tweetTimestamp <= 0) { console.warn('⚠️ [发帖生成器] 推文时间戳无效，使用当前时间'); tweetTimestamp = timestamp; } interactionData.comments.forEach((comment, index) => { comment.id = `ai_${timestamp}_${index}`; if (isProgressMode) { const minutesAgo = Math.floor(Math.random() * 60); comment.timestamp = timestamp - minutesAgo * 60 * 1000; delete comment.timeOffset; } else { if (comment.timeOffset !== undefined) { comment.timestamp = tweetTimestamp + Math.abs(comment.timeOffset) * 60 * 1000; delete comment.timeOffset; } else if (!comment.timestamp) { comment.timestamp = tweetTimestamp + (5 + Math.random() * 30) * 60 * 1000; } } if (comment.replies && comment.replies.length > 0) { comment.replies.forEach((reply, replyIndex) => { reply.id = `ai_${timestamp}_${index}_${replyIndex}`; if (isProgressMode) { reply.timestamp = comment.timestamp + (1 + Math.random() * 10) * 60 * 1000; delete reply.timeOffset; } else { if (reply.timeOffset !== undefined) { reply.timestamp = tweetTimestamp + Math.abs(reply.timeOffset) * 60 * 1000; delete reply.timeOffset; } else if (!reply.timestamp) { reply.timestamp = comment.timestamp + (1 + Math.random() * 10) * 60 * 1000; } } }); } }); await updateTweetDetailWithAI(tweetData.id, interactionData, isReroll, isProgressMode); const detailPage = document.getElementById('x-tweet-detail-page'); if (detailPage && detailPage.style.display === 'flex') { const currentTweetData = sessionStorage.getItem('currentTweetData'); if (currentTweetData) { const currentTweet = JSON.parse(currentTweetData); if (currentTweet.id === tweetData.id) { const db = getXDB(); const accountTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweets = await db.xUserTweets.get(accountTweetsId); if (userTweets) { const updatedTweet = userTweets.tweets.find(t => t.id === tweetData.id); if (updatedTweet) { await showTweetDetail(updatedTweet); console.log('✅ 详情页已刷新，显示最新AI反应'); } } } } } const isEnglish = currentLanguage === 'en'; const userAvatar = window.userProfileData?.avatar || 'https: showPhoneNotification({ title: 'X', message: isProgressMode ? isEnglish ? 'Your post interaction has been progressed!' : '帖子互动已推进！' : isEnglish ? 'Someone replied to your post!' : '你的帖子有人回复了哦！', avatar: userAvatar, leftIcon: 'x', }); if (isBusinessPost && !isReroll && !isProgressMode) { console.log('🎁 [打赏生成器] 检测到商业推文，开始生成打赏数据'); generateTipsForBusinessPost(tweetData, interactionData).catch(err => { console.error('生成打赏失败（静默）:', err); }); } if (!isReroll && !isProgressMode) { const mentionRegex = /@(\w+)/g; const mentions = [...tweetData.content.matchAll(mentionRegex)]; if (mentions.length > 0 && userXProfileInfo && userXProfileInfo.handle) { const userHandle = userXProfileInfo.handle; mentions.forEach(match => { const targetHandle = `@${match[1]}`; checkUnblockTrigger(userHandle, targetHandle, 'mention', tweetData.content).catch(err => { console.error('拉黑解除检测失败（静默）:', err); }); }); } } } catch (error) { console.error('生成AI回复失败:', error); showXToast(`回复生成失败: ${error.message}`, 'error'); } } window.toggleTweetProgressMode = function () { const currentTweetData = sessionStorage.getItem('currentTweetData'); if (currentTweetData) { try { const tweet = JSON.parse(currentTweetData); const isAccountTweet = tweet._source === 'account'; const isSearchTweet = tweet._source === 'search'; if ((isAccountTweet || isSearchTweet) && isTweetProgressMode) { showXToast('该推文只支持推进模式', 'warning'); return; } } catch (e) { console.warn('解析推文数据失败:', e); } } isTweetProgressMode = !isTweetProgressMode; updateTweetRerollButtonUI(); if (isTweetProgressMode) { showXToast('已切换到推进模式 - 将追加新评论', 'success'); } else { showXToast('已切换到重新生成模式 - 将覆盖现有评论', 'info'); } }; function updateTweetRerollButtonUI() { const rerollBtn = document.getElementById('reroll-replies-btn'); if (!rerollBtn) return; const textColor = getComputedStyle(document.getElementById('x-social-screen')).getPropertyValue('--x-text-primary').trim() || '#fff'; let isAccountOrSearchTweet = false; const currentTweetData = sessionStorage.getItem('currentTweetData'); if (currentTweetData) { try { const tweet = JSON.parse(currentTweetData); isAccountOrSearchTweet = tweet._source === 'account' || tweet._source === 'search'; } catch (e) { console.warn('解析推文数据失败:', e); } } if (isTweetProgressMode) { rerollBtn.innerHTML = ` <svg xmlns="http: <path d="M3 12h4l3 8l4 -16l3 8h4" /> </svg> `; rerollBtn.setAttribute( 'title', isAccountOrSearchTweet ? '推进帖子互动（追加新评论）' : '推进帖子互动（追加新评论）\n长按切换到重新生成模式', ); } else { rerollBtn.innerHTML = ` <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: ${textColor};"> <g> <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" /> </g> </svg> `; rerollBtn.setAttribute('title', '重新生成回复\n长按切换到推进模式'); } } window.handleTweetRerollButtonMouseDown = function () { tweetProgressLongPressTimer = setTimeout(() => { toggleTweetProgressMode(); }, 800); }; window.handleTweetRerollButtonMouseUp = function () { if (tweetProgressLongPressTimer) { clearTimeout(tweetProgressLongPressTimer); tweetProgressLongPressTimer = null; } }; async function rerollAIReplies() { if (tweetProgressLongPressTimer) { clearTimeout(tweetProgressLongPressTimer); tweetProgressLongPressTimer = null; } try { const currentTweetId = getCurrentTweetId(); if (!currentTweetId) { showXToast('无法获取当前推文信息', 'error'); return; } const xTweetsData = await getXTweetsData(); const currentTweet = xTweetsData.find(tweet => tweet.id === currentTweetId); if (!currentTweet) { showXToast('未找到推文数据', 'error'); return; } const isAccountTweet = currentTweet._source === 'account'; const isSearchTweet = currentTweet._source === 'search'; const isUserTweet = currentTweet.id && currentTweet.id.startsWith('user_'); console.log(`🔄 [重回/推进] 推文类型:`, { isAccountTweet, isSearchTweet, isUserTweet, currentMode: isTweetProgressMode ? '推进模式' : '重回模式', tweetId: currentTweetId, }); if ((isAccountTweet || isSearchTweet) && !isTweetProgressMode) { console.warn('⚠️ [重回/推进] 账户/搜索推文不支持重回模式，自动切换到推进模式'); isTweetProgressMode = true; updateTweetRerollButtonUI(); } const rerollBtn = document.getElementById('reroll-replies-btn'); const originalHTML = rerollBtn.innerHTML; const textColor = getComputedStyle(document.getElementById('x-social-screen')).getPropertyValue('--x-text-primary').trim() || '#fff'; rerollBtn.innerHTML = ` <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: ${textColor}; animation: spin 1s linear infinite;"> <g> <path d="M12 4V2A10 10 0 0 0 2 12h2a8 8 0 0 1 8-8z" /> </g> </svg> `; rerollBtn.style.pointerEvents = 'none'; let toastMessage = '正在推进帖子互动...'; if (!isTweetProgressMode && isUserTweet) { toastMessage = '正在重新生成回复...'; } else if (isAccountTweet) { toastMessage = '正在推进账户推文互动...'; } else if (isSearchTweet) { toastMessage = '正在推进搜索推文互动...'; } showXToast(toastMessage, 'info'); await generateAIResponseForTweet(currentTweet, !isTweetProgressMode, isTweetProgressMode); rerollBtn.innerHTML = originalHTML; rerollBtn.style.pointerEvents = 'auto'; } catch (error) { console.error('AI回复操作失败:', error); showXToast(isTweetProgressMode ? '推进失败，请检查网络连接' : '重新生成失败，请检查网络连接', 'error'); const rerollBtn = document.getElementById('reroll-replies-btn'); updateTweetRerollButtonUI(); rerollBtn.style.pointerEvents = 'auto'; } } function getCurrentTweetId() { const tweetDetailContainer = document.getElementById('tweet-detail-container'); return tweetDetailContainer ? tweetDetailContainer.getAttribute('data-tweet-id') : null; } async function getXTweetsData() { const currentTweetId = getCurrentTweetId(); if (!currentTweetId) return []; const tweetData = sessionStorage.getItem('currentTweetData'); if (tweetData) { try { return [JSON.parse(tweetData)]; } catch (e) { console.warn('无法解析推文数据:', e); } } return []; } async function generateTipsForBusinessPost(tweetData, interactionData) { try { console.log('🎁 [打赏生成器] 开始为商业推文生成打赏'); const { apiConfig } = await APIUtils.loadConfigAndSettings(); const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); let systemPrompt = `你是X社交平台的打赏生成器。用户刚发布了一条商业推文（广告/推广性质），现在需要生成粉丝/支持者的打赏记录。 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务：生成打赏记录 🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ **用户信息**： - 用户名：${userXProfileInfo.name} - 用户句柄：${userXProfileInfo.handle} - 认证状态：${userXProfileInfo.verified ? '已认证' : '未认证'} ${userXProfileInfo.publicIdentity ? `- 公众身份：${userXProfileInfo.publicIdentity}` : ''} - 粉丝影响力：${userXProfileInfo.publicIdentity ? '有一定影响力' : '普通用户'} **商业推文内容**： "${tweetData.content}" **推文数据表现**： - 👍 喜欢数：${interactionData.stats.likes} - 🔄 转发数：${interactionData.stats.retweets} - 💬 评论数：${interactionData.stats.comments} - 👀 浏览量：${interactionData.stats.views} **评论区反馈**（前5条）： ${ interactionData.comments && interactionData.comments.length > 0 ? interactionData.comments .slice(0, 5) .map((c, i) => `${i + 1}. ${c.user.name}: "${c.content}"`) .join('\n') : '暂无评论' } ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 💰 打赏生成规则 💰 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ **数量规则**： 根据推文数据表现和用户影响力生成3-8条打赏记录： - 浏览量 < 1000：生成3-4条 - 浏览量 1000-5000：生成4-6条 - 浏览量 > 5000：生成6-8条 - 如果用户有公众身份，+1条 **金额规则**： 根据用户影响力和数据表现： - 普通用户：每条 $5-$30 - 有公众身份：每条 $10-$50 - 认证用户：每条 $15-$80 - 如果推文数据特别好（点赞>500），可能出现1-2条大额打赏（$50-$150） **打赏者信息**： - name: 粉丝/支持者的名字（真实感，不要太夸张） - handle: X平台句柄（格式：@username） - note: 打赏备注（简短、真诚、与推文内容相关） **备注示例**： - "支持！" - "很棒的产品！" - "已下单~" - "期待后续" - "感谢分享" - "继续加油！" - "值得推荐" ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📋 JSON返回格式 📋 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ \`\`\`json { "tips": [ { "name": "打赏者姓名", "handle": "@username", "amount": 25.00, "note": "打赏备注" } ] } \`\`\` **重要规则**： 1. amount必须是数字类型，保留两位小数 2. handle必须以@开头 3. note要简短（不超过20字）、真诚、与推文内容相关 4. 打赏者不能是用户本人 5. 每条打赏记录独立，不要重复`; const messages = [ { role: 'user', content: '请根据以上信息生成打赏记录。', }, ]; const aiResponseContent = await APIUtils.sendAIRequest({ apiConfig, systemPrompt, messages, temperature: 0.8, }); console.log('🎁 [打赏生成器] AI原始响应:', aiResponseContent); const tipsData = APIUtils.parseJSONResponse(aiResponseContent); if (!tipsData.tips || !Array.isArray(tipsData.tips)) { throw new Error('AI返回的数据格式不正确'); } console.log(`🎁 [打赏生成器] 成功生成${tipsData.tips.length}条打赏记录`); scheduleTipNotifications(tweetData.id, tipsData.tips); } catch (error) { console.error('🎁 [打赏生成器] 生成打赏失败:', error); throw error; } } function scheduleTipNotifications(tweetId, tips) { console.log(`🎁 [打赏调度] 开始调度${tips.length}条打赏通知`); const FIVE_HOURS_MS = 5 * 60 * 60 * 1000; const now = Date.now(); tips.forEach((tip, index) => { const randomDelay = Math.random() * FIVE_HOURS_MS; console.log(`🎁 [打赏调度] 打赏 #${index + 1} 将在 ${Math.round(randomDelay / 1000 / 60)} 分钟后触发`); setTimeout(() => { processTipNotification(tweetId, tip); }, randomDelay); }); } async function processTipNotification(tweetId, tip) { try { console.log('🎁 [打赏通知] 触发打赏:', tip); await loadWalletData(); if (!walletData.isActivated) { console.warn('🎁 [打赏通知] 钱包未激活，跳过打赏'); return; } const amount = parseFloat(tip.amount); walletData.balance += amount; const transaction = { id: 'tip_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9), description: `来自 ${tip.name} 的打赏`, amount: amount, timestamp: new Date().toISOString(), type: 'tip', note: tip.note, tipper: { name: tip.name, handle: tip.handle, }, tweetId: tweetId, }; walletData.transactions.unshift(transaction); await saveWalletData(); console.log(`🎁 [打赏通知] 打赏已入账: +$${amount.toFixed(2)}`); showPhoneNotification({ title: `收到来自 ${tip.name} 的赠金`, message: `+$${amount.toFixed(2)} - ${tip.note}`, avatar: window.userProfileData?.avatar, leftIcon: 'custom', leftIconHtml: ` <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #22c55e;"> <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.31-8.86c-1.77-.45-2.34-.94-2.34-1.67 0-.84.79-1.43 2.1-1.43 1.38 0 1.9.66 1.94 1.64h1.71c-.05-1.34-.87-2.57-2.49-2.97V5H10.9v1.69c-1.51.32-2.72 1.3-2.72 2.81 0 1.79 1.49 2.69 3.66 3.21 1.95.46 2.34 1.15 2.34 1.87 0 .53-.39 1.39-2.1 1.39-1.6 0-2.23-.72-2.32-1.64H8.04c.1 1.7 1.36 2.66 2.86 2.97V19h2.34v-1.67c1.52-.29 2.72-1.16 2.73-2.77-.01-2.2-1.9-2.96-3.66-3.42z"></path></g> </svg> `, duration: 4000, }); showXToast(`收到打赏 +$${amount.toFixed(2)}`, 'success'); } catch (error) { console.error('🎁 [打赏通知] 处理打赏失败:', error); } } async function saveUserTweet(tweetData) { try { const db = getXDB(); const accountTweetsId = `userTweets_${currentAccountId || 'main'}`; let userTweets = await db.xUserTweets.get(accountTweetsId); if (!userTweets) { userTweets = { id: accountTweetsId, tweets: [] }; } tweetData.accountId = currentAccountId || 'main'; userTweets.tweets.unshift(tweetData); await db.xUserTweets.put(userTweets); console.log('用户推文已保存到账户:', currentAccountId, tweetData); generateMentionsForLatestTweet(tweetData).catch(err => { console.error('生成Mentions通知失败（静默）:', err); }); } catch (error) { console.error('保存用户推文失败:', error); } } async function getUserTweets() { try { const db = getXDB(); const accountTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweets = await db.xUserTweets.get(accountTweetsId); return userTweets ? userTweets.tweets : []; } catch (error) { console.error('获取用户推文失败:', error); return []; } } let isMultiSelectMode = false; let selectedTweets = new Set(); function showTweetActionMenu(tweetId, event) { if (event) { event.preventDefault(); event.stopPropagation(); } const existingMenu = document.getElementById('tweet-action-menu'); if (existingMenu) { existingMenu.remove(); } getUserTweets().then(userTweets => { const tweet = userTweets.find(t => t.id === tweetId); if (!tweet) return; const isPinned = tweet.pinned || false; const menu = document.createElement('div'); menu.id = 'tweet-action-menu'; menu.style.cssText = ` position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color:#000; border: 1px solid #2f3336; border-radius: 16px; min-width: 280px; z-index: 10000; box-shadow: 0 8px 24px rgba(0,0,0,0.5); `; menu.innerHTML = ` <div style="padding: 12px 0;"> <div onclick="toggleTweetPin('${tweetId}')" style="padding: 12px 16px; color: #fff; font-size: 15px; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 32 32" style="width: 18px; height: 18px; fill: currentColor;"> <path d="M20.743 14.815l-0.933-12.065h5.191c0.414 0 0.75-0.336 0.75-0.75s-0.336-0.75-0.75-0.75v0h-18c-0.414 0-0.75 0.336-0.75 0.75s0.336 0.75 0.75 0.75v0h5.432l-1.275 12.103c-3.213 0.959-5.574 3.738-5.904 7.113l-0.003 0.034c0 0.414 0.336 0.75 0.75 0.75h9.25v7.25c0 0.414 0.336 0.75 0.75 0.75s0.75-0.336 0.75-0.75v0-7.25h9.25c0.414-0 0.75-0.336 0.75-0.75v0c0-3.017-2.35-5.787-6.007-7.185zM12.104 16.081c0.096-0.035 0.179-0.085 0.249-0.148l-0.001 0.001 0.005-0.003c0.126-0.117 0.211-0.275 0.233-0.453l0-0.004 0.011-0.022 1.337-12.701h4.367l0.979 12.681c0.033 0.35 0.303 0.627 0.647 0.67l0.004 0c2.542 0.682 4.512 2.623 5.222 5.096l0.013 0.052h-18.341c0.729-2.54 2.714-4.49 5.222-5.157l0.052-0.012z"></path> </svg> <span>${isPinned ? '取消置顶' : '置顶到个人资料'}</span> </div> <div onclick="enterMultiSelectModeFromMenu('${tweetId}')" style="padding: 12px 16px; color: #fff; font-size: 15px; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"> <g><path d="M9 2C6.243 2 4 4.243 4 7v10c0 2.757 2.243 5 5 5h6c2.757 0 5-2.243 5-5V7c0-2.757-2.243-5-5-5H9zm0 2h6c1.654 0 3 1.346 3 3v10c0 1.654-1.346 3-3 3H9c-1.654 0-3-1.346-3-3V7c0-1.654 1.346-3 3-3zm6.207 3.793l-5.5 5.5-2.414-2.414-1.414 1.414 3.121 3.121.707.707.707-.707 6.207-6.207-1.414-1.414z"></path></g> </svg> <span>选择多条推文</span> </div> <div onclick="deleteSingleTweet('${tweetId}')" style="padding: 12px 16px; color: #f4212e; font-size: 15px; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"> <g><path d="M16 6V4.5C16 3.12 14.88 2 13.5 2h-3C9.11 2 8 3.12 8 4.5V6H3v2h1.06l.81 11.21C4.98 20.78 6.28 22 7.86 22h8.27c1.58 0 2.88-1.22 3-2.79L19.93 8H21V6h-5zm-6-1.5c0-.28.22-.5.5-.5h3c.27 0 .5.22.5.5V6h-4V4.5zm7.13 14.57c-.04.52-.47.93-1 .93H7.86c-.53 0-.96-.41-1-.93L6.07 8h11.85l-.79 11.07zM9 17v-6h2v6H9zm4 0v-6h2v6h-2z"></path></g> </svg> <span>删除</span> </div> </div> <div onclick="closeTweetActionMenu()" style="padding: 12px 16px; color: #71767b; font-size: 15px; font-weight: 500; cursor: pointer; text-align: center; border-top: 1px solid #2f3336; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'" onmouseout="this.style.backgroundColor='transparent'"> 取消 </div> `; document.body.appendChild(menu); setTimeout(() => { document.addEventListener('click', function closeMenuOnClickOutside(e) { if (!menu.contains(e.target)) { menu.remove(); document.removeEventListener('click', closeMenuOnClickOutside); } }); }, 100); }); } window.closeTweetActionMenu = function () { const menu = document.getElementById('tweet-action-menu'); if (menu) { menu.remove(); } }; window.toggleTweetPin = async function (tweetId) { try { const db = getXDB(); const accountTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweets = await db.xUserTweets.get(accountTweetsId); if (userTweets && userTweets.tweets) { const tweet = userTweets.tweets.find(t => t.id === tweetId); if (tweet) { const wasPinned = tweet.pinned || false; if (!wasPinned) { userTweets.tweets.forEach(t => { if (t.pinned) { t.pinned = false; } }); } tweet.pinned = !wasPinned; await db.xUserTweets.put(userTweets); showXToast(wasPinned ? '已取消置顶' : '推文已置顶', 'success'); closeTweetActionMenu(); loadUserProfileTweets(); } } } catch (error) { console.error('切换置顶状态失败:', error); showXToast('操作失败', 'error'); } }; window.deleteSingleTweet = async function (tweetId) { const confirmDelete = confirm('确定要删除这条推文吗？删除后无法恢复。'); if (!confirmDelete) return; try { const db = getXDB(); const accountTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweets = await db.xUserTweets.get(accountTweetsId); if (userTweets && userTweets.tweets) { userTweets.tweets = userTweets.tweets.filter(tweet => tweet.id !== tweetId); await db.xUserTweets.put(userTweets); const tweetsData = await db.xTweetsData.get('tweets'); if (tweetsData) { let updated = false; if (tweetsData.forYouTweets) { const originalLength = tweetsData.forYouTweets.length; tweetsData.forYouTweets = tweetsData.forYouTweets.filter(tweet => tweet.id !== tweetId); if (tweetsData.forYouTweets.length !== originalLength) updated = true; } if (tweetsData.followingTweets) { const originalLength = tweetsData.followingTweets.length; tweetsData.followingTweets = tweetsData.followingTweets.filter(tweet => tweet.id !== tweetId); if (tweetsData.followingTweets.length !== originalLength) updated = true; } if (updated) { await db.xTweetsData.put(tweetsData); } } showXToast('推文已删除', 'success'); closeTweetActionMenu(); loadUserProfileTweets(); } } catch (error) { console.error('删除推文失败:', error); showXToast('删除失败', 'error'); } }; function toggleTweetSelection(tweetId) { if (!isMultiSelectMode) { enterMultiSelectMode(); } const tweetEl = document.querySelector(`[data-tweet-id="${tweetId}"]`); if (!tweetEl) return; if (selectedTweets.has(tweetId)) { selectedTweets.delete(tweetId); tweetEl.classList.remove('selected'); tweetEl.style.backgroundColor = ''; } else { selectedTweets.add(tweetId); tweetEl.classList.add('selected'); tweetEl.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) , 0.1)'; } updateDeleteUI(); } window.enterMultiSelectModeFromMenu = function (tweetId) { closeTweetActionMenu(); enterMultiSelectMode(); if (tweetId) { toggleTweetSelection(tweetId); } }; function enterMultiSelectMode() { isMultiSelectMode = true; showDeleteToolbar(); document.querySelectorAll('.user-tweet-item').forEach(item => { item.style.borderLeft = '3px solid var(--x-accent)'; }); } window.exitMultiSelectMode = function () { isMultiSelectMode = false; selectedTweets.clear(); hideDeleteToolbar(); document.querySelectorAll('.user-tweet-item').forEach(item => { item.classList.remove('selected'); item.style.backgroundColor = ''; item.style.borderLeft = ''; }); }; function showDeleteToolbar() { let toolbar = document.getElementById('delete-toolbar'); if (!toolbar) { toolbar = document.createElement('div'); toolbar.id = 'delete-toolbar'; toolbar.style.cssText = ` position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background-color:#000; border: 1px solid #333; border-radius: 20px; padding: 8px 16px; display: flex; align-items: center; gap: 12px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.5); `; toolbar.innerHTML = ` <button onclick="selectAllTweets()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 16px; padding: 6px 12px; font-size: 13px; cursor: pointer;"> 全选 </button> <span id="selected-count" style="color: #fff; font-size: 14px;">已选择 0 条</span> <button onclick="deleteSelectedTweets()" style="background-color: #f91880; color: #fff; border: none; border-radius: 16px; padding: 6px 12px; font-size: 13px; cursor: pointer;"> 删除 </button> <button onclick="exitMultiSelectMode()" style="background-color: #333; color: #fff; border: none; border-radius: 16px; padding: 6px 12px; font-size: 13px; cursor: pointer;"> 取消 </button> `; document.body.appendChild(toolbar); } toolbar.style.display = 'flex'; } function hideDeleteToolbar() { const toolbar = document.getElementById('delete-toolbar'); if (toolbar) { toolbar.style.display = 'none'; } } function updateDeleteUI() { const countEl = document.getElementById('selected-count'); if (countEl) { countEl.textContent = `已选择 ${selectedTweets.size} 条`; } } window.selectAllTweets = function () { document.querySelectorAll('.user-tweet-item').forEach(item => { const tweetId = item.dataset.tweetId; if (!selectedTweets.has(tweetId)) { selectedTweets.add(tweetId); item.classList.add('selected'); item.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) , 0.1)'; } }); updateDeleteUI(); }; window.deleteSelectedTweets = async function () { if (selectedTweets.size === 0) return; const confirmDelete = confirm(`确定要删除选中的 ${selectedTweets.size} 条推文吗？删除后无法恢复。`); if (!confirmDelete) return; try { const db = getXDB(); const accountTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweets = await db.xUserTweets.get(accountTweetsId); if (userTweets && userTweets.tweets) { userTweets.tweets = userTweets.tweets.filter(tweet => !selectedTweets.has(tweet.id)); await db.xUserTweets.put(userTweets); const tweetsData = await db.xTweetsData.get('tweets'); if (tweetsData) { let updated = false; if (tweetsData.forYouTweets) { const originalLength = tweetsData.forYouTweets.length; tweetsData.forYouTweets = tweetsData.forYouTweets.filter(tweet => !selectedTweets.has(tweet.id)); if (tweetsData.forYouTweets.length !== originalLength) updated = true; } if (tweetsData.followingTweets) { const originalLength = tweetsData.followingTweets.length; tweetsData.followingTweets = tweetsData.followingTweets.filter(tweet => !selectedTweets.has(tweet.id)); if (tweetsData.followingTweets.length !== originalLength) updated = true; } if (updated) { await db.xTweetsData.put(tweetsData); } } showXToast(`已删除 ${selectedTweets.size} 条推文`, 'success'); exitMultiSelectMode(); loadUserProfileTweets(); } } catch (error) { console.error('删除推文失败:', error); showXToast('删除失败', 'error'); } }; async function loadUserProfileTweets() { try { const userTweets = await getUserTweets(); const container = document.getElementById('x-profile-tweets-container'); if (userTweets.length === 0) { container.innerHTML = ` <div style="padding: 60px 32px; text-align: center;"> <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;">还没有推文</div> <div style="color: #71767b; font-size: 15px;">当你发送第一条推文时，它会显示在这里。</div> </div> `; } else { const sortedTweets = [...userTweets].sort((a, b) => { const aPinned = a.pinned || false; const bPinned = b.pinned || false; if (aPinned && !bPinned) return -1; if (!aPinned && bPinned) return 1; return 0; }); container.innerHTML = ''; sortedTweets.forEach(tweet => { const tweetElement = createUserTweetElement(tweet); container.appendChild(tweetElement); }); } const headerCount = document.getElementById('x-profile-header-count'); if (headerCount) { headerCount.textContent = `${userTweets.length} 帖子`; } } catch (error) { console.error('加载用户推文失败:', error); } } function createUserTweetElement(tweet) { const tweetEl = document.createElement('div'); tweetEl.className = 'user-tweet-item'; tweetEl.dataset.tweetId = tweet.id; tweetEl.style.cursor = 'pointer'; tweetEl.style.position = 'relative'; tweetEl.style.borderBottom = '1px solid var(--x-border-color)'; tweetEl.style.display = 'block'; let longPressTimer; let isLongPressed = false; let touchStartX = 0; let touchStartY = 0; let hasMoved = false; let lastTouchEndTime = 0; const TOUCH_THRESHOLD = 15; const DEBOUNCE_TIME = 300; tweetEl.addEventListener('touchstart', e => { const touch = e.touches[0]; touchStartX = touch.clientX; touchStartY = touch.clientY; hasMoved = false; longPressTimer = setTimeout(() => { if (!hasMoved) { isLongPressed = true; showTweetActionMenu(tweet.id, e); e.preventDefault(); } }, 800); }); tweetEl.addEventListener('touchmove', e => { const touch = e.touches[0]; const deltaX = Math.abs(touch.clientX - touchStartX); const deltaY = Math.abs(touch.clientY - touchStartY); if (deltaX > TOUCH_THRESHOLD || deltaY > TOUCH_THRESHOLD) { hasMoved = true; clearTimeout(longPressTimer); } }); tweetEl.addEventListener('touchend', e => { clearTimeout(longPressTimer); const now = Date.now(); if (now - lastTouchEndTime < DEBOUNCE_TIME) { console.log('🚫 [触摸] 防抖拦截，忽略重复触摸'); e.preventDefault(); return; } lastTouchEndTime = now; if (!isLongPressed && !hasMoved) { e.preventDefault(); if (isMultiSelectMode) { toggleTweetSelection(tweet.id); } else { showTweetDetail(tweet); } } else if (isLongPressed) { e.preventDefault(); } isLongPressed = false; hasMoved = false; }); let lastMouseUpTime = 0; tweetEl.addEventListener('mousedown', e => { if (e.button !== 0) return; longPressTimer = setTimeout(() => { isLongPressed = true; showTweetActionMenu(tweet.id, e); e.preventDefault(); }, 800); }); tweetEl.addEventListener('mouseup', e => { if (e.button !== 0) return; clearTimeout(longPressTimer); const now = Date.now(); if (now - lastMouseUpTime < DEBOUNCE_TIME) { console.log('🚫 [鼠标] 防抖拦截，忽略重复点击'); return; } lastMouseUpTime = now; if (!isLongPressed) { if (isMultiSelectMode) { toggleTweetSelection(tweet.id); } else { showTweetDetail(tweet); } } isLongPressed = false; }); tweetEl.addEventListener('click', e => { e.preventDefault(); e.stopPropagation(); }); function formatTimeForProfile(timestamp) { const date = new Date(timestamp); const now = new Date(); const diffInHours = Math.floor((now - date) / (1000 * 60 * 60)); if (diffInHours < 1) { const diffInMinutes = Math.floor((now - date) / (1000 * 60)); return diffInMinutes < 1 ? '刚刚' : `${diffInMinutes}分钟`; } else if (diffInHours < 24) { return `${diffInHours}小时`; } else { const diffInDays = Math.floor(diffInHours / 24); return diffInDays === 1 ? '1天' : `${diffInDays}天`; } } function renderProfileTweetMedia(tweet) { if (!tweet.image) return ''; if (tweet.image.type === 'description') { return ` <div style="margin-top: 12px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; padding: 12px; box-sizing: border-box;"> <div style="color:var(--x-text-primary); font-size: 14px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${tweet.image.content}</div> </div> `; } else if (tweet.image.type === 'upload') { return ` <div style="margin-top: 12px; border-radius: 12px; overflow: hidden;"> <img src="${tweet.image.content}" style="width: 100%; max-height: 200px; object-fit: cover; display: block;" alt="推文图片"> </div> `; } else if (tweet.image.type === 'uploads' && tweet.image.images && tweet.image.images.length > 0) { const imageCount = tweet.image.images.length; let gridTemplate = ''; if (imageCount === 1) { gridTemplate = 'grid-template-columns: 1fr;'; } else if (imageCount === 2) { gridTemplate = 'grid-template-columns: repeat(2, 1fr);'; } else if (imageCount === 3) { gridTemplate = 'grid-template-columns: repeat(2, 1fr);'; } else { gridTemplate = 'grid-template-columns: repeat(2, 1fr);'; } const imagesHtml = tweet.image.images .map((img, index) => { const spanStyle = imageCount === 3 && index === 0 ? 'grid-column: span 2;' : ''; return ` <div style="${spanStyle}border-radius: 8px; overflow: hidden;"> <img src="${img.content}" style="width: 100%; height: ${ imageCount === 1 ? '200px' : '150px' }; object-fit: cover; display: block;" alt="推文图片${index + 1}"> </div> `; }) .join(''); return ` <div style="margin-top: 12px; display: grid; ${gridTemplate} gap: 4px;"> ${imagesHtml} </div> `; } return ''; } function renderProfileTweetLink(tweet) { if (!tweet.link) return ''; return ` <div style="margin-top: 12px; border: 1px solid #333; border-radius: 12px; overflow: hidden;"> ${ tweet.link.thumbnail ? ` <div style="width: 100%; height: 150px; background-color: #333;"> <img src="${tweet.link.thumbnail}" style="width: 100%; height: 100%; object-fit: cover;" alt="链接预览图"> </div> ` : '' } <div style="padding: 12px;"> <div style="color: #71767b; font-size: 13px; margin-bottom: 4px;">${tweet.link.url || '链接'}</div> ${ tweet.link.title ? `<div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 4px;">${tweet.link.title}</div>` : '' } ${tweet.link.description ? `<div style="color: #71767b; font-size: 13px;">${tweet.link.description}</div>` : ''} </div> </div> `; } function renderProfileQuotedTweetMedia(quoted) { if (!quoted.image) return ''; if (quoted.image.type === 'description') { return ` <div style="margin-top: 6px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 6px; padding: 6px; box-sizing: border-box;"> <div style="color:var(--x-text-primary); font-size: 12px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${quoted.image.content}</div> </div> `; } else if (quoted.image.type === 'upload') { return ` <div style="margin-top: 6px; border-radius: 6px; overflow: hidden;"> <img src="${quoted.image.content}" style="width: 100%; max-height: 80px; object-fit: cover; display: block;" alt="引用图片"> </div> `; } return ''; } function renderProfileQuotedTweet(tweet) { if (!tweet.quotedTweet) return ''; const quoted = tweet.quotedTweet; const typeText = quoted.type === 'tweet' ? '推文' : '评论'; return ` <div style="margin-top: 12px; border: 1px solid var(--x-border-color); border-radius: 12px; padding: 12px; background-color: var(--x-bg-hover);"> <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;"> <img src="${quoted.user.avatar}" style="width: 20px; height: 20px; border-radius: 50%;" alt="${quoted.user.name}"> <span style="color:var(--x-text-primary); font-size: 13px; font-weight: 600;">${quoted.user.name}</span> ${ quoted.user.verified ? '<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>' : '' } <span style="color:var(--x-text-secondary); font-size: 13px;">${quoted.user.handle}</span> <span style="color:var(--x-text-secondary); font-size: 13px;">·${quoted.time}</span> </div> <div style="color:var(--x-text-primary); font-size: 14px; line-height: 1.4;">${quoted.content}</div> ${renderProfileQuotedTweetMedia(quoted)} <div style="color:var(--x-text-secondary); font-size: 12px; margin-top: 8px;">引用${typeText}</div> </div> `; } const isPinned = tweet.pinned || false; tweetEl.innerHTML = ` ${ isPinned ? ` <div style="padding: 12px 16px 0; display: flex; align-items: center; gap: 12px;"> <div style="width: 40px; display: flex; justify-content: flex-end;"> <svg viewBox="0 0 32 32" style="width: 16px; height: 16px; fill: #71767b;"> <path d="M20.743 14.815l-0.933-12.065h5.191c0.414 0 0.75-0.336 0.75-0.75s-0.336-0.75-0.75-0.75v0h-18c-0.414 0-0.75 0.336-0.75 0.75s0.336 0.75 0.75 0.75v0h5.432l-1.275 12.103c-3.213 0.959-5.574 3.738-5.904 7.113l-0.003 0.034c0 0.414 0.336 0.75 0.75 0.75h9.25v7.25c0 0.414 0.336 0.75 0.75 0.75s0.75-0.336 0.75-0.75v0-7.25h9.25c0.414-0 0.75-0.336 0.75-0.75v0c0-3.017-2.35-5.787-6.007-7.185zM12.104 16.081c0.096-0.035 0.179-0.085 0.249-0.148l-0.001 0.001 0.005-0.003c0.126-0.117 0.211-0.275 0.233-0.453l0-0.004 0.011-0.022 1.337-12.701h4.367l0.979 12.681c0.033 0.35 0.303 0.627 0.647 0.67l0.004 0c2.542 0.682 4.512 2.623 5.222 5.096l0.013 0.052h-18.341c0.729-2.54 2.714-4.49 5.222-5.157l0.052-0.012z"></path> </svg> </div> <span style="color: #71767b; font-size: 13px; font-weight: 700;">已置顶</span> </div> ` : '' } <div style="display: flex; gap: 12px; padding: 12px 16px;"> <img src="${tweet.user.avatar}" alt="${ tweet.user.name }" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;"> <div style="flex: 1; min-width: 0;" class="tweet-main"> <div class="tweet-user-info"> <span class="tweet-user-name">${tweet.user.name}</span> ${ tweet.user.verified ? '<svg class="tweet-verified" viewBox="0 0 24 24"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>' : '' } <span class="tweet-user-handle">${tweet.user.handle}</span> <span class="tweet-time" data-timestamp="${tweet.timestamp || Date.now()}">·${ tweet.timestamp ? getRelativeTime(tweet.timestamp) : '刚刚' }</span> ${ tweet.location ? ` <div style="display: flex; align-items: center; gap: 4px; margin-left: 8px;"> <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: var(--x-accent);"> <g><path d="M12 7c-1.93 0-3.5 1.57-3.5 3.5S10.07 14 12 14s3.5-1.57 3.5-3.5S13.93 7 12 7zm0 5c-.827 0-1.5-.673-1.5-1.5S11.173 9 12 9s1.5.673 1.5 1.5S12.827 12 12 12zm0-10c-4.687 0-8.5 3.813-8.5 8.5 0 5.967 7.621 11.116 7.945 11.332l.555.37.555-.37C12.879 21.616 20.5 16.467 20.5 10.5 20.5 5.813 16.687 2 12 2zm0 17.77c-1.665-1.241-6.5-5.196-6.5-9.27C5.5 6.916 8.416 4 12 4s6.5 2.916 6.5 6.5c0 4.073-4.835 8.028-6.5 9.27z"></path></g> </svg> <span style="color: var(--x-accent); font-size: 13px;">${tweet.location}</span> </div> ` : '' } </div> <div class="tweet-content">${processContent(tweet.content)}</div> ${renderProfileTweetMedia(tweet)} ${renderProfileTweetLink(tweet)} ${renderProfileQuotedTweet(tweet)} <div class="tweet-actions"> <div class="tweet-action comment"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor"> <g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g> </svg> <span>${DataUtils.formatNumber(tweet.stats.comments)}</span> </div> <div class="tweet-action retweet" onclick="handleQuoteRetweetFromData('tweet', '${tweet.id}')"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor"> <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g> </svg> <span>${DataUtils.formatNumber(tweet.stats.retweets)}</span> </div> <div class="tweet-action like" data-liked="false" data-likes="${tweet.stats.likes}"> <svg class="action-icon like-icon" viewBox="0 0 24 24" fill="currentColor"> <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g> </svg> <span class="like-count">${DataUtils.formatNumber(tweet.stats.likes)}</span> </div> <div class="tweet-action view"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor"> <g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10H6v10H4zm9.248 0v-7h2v7h-2z"></path></g> </svg> <span>${DataUtils.formatNumber(tweet.stats.views)}</span> </div> <div class="tweet-action bookmark"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor"> <g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g> </svg> </div> <div class="tweet-action share"> <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor"> <g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.29 3.3-1.42-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g> </svg> </div> </div> </div> </div> `; return tweetEl; } function refreshUserProfileTweets() { const container = document.getElementById('x-profile-tweets-container'); if (container && container.parentElement.style.display !== 'none') { loadUserProfileTweets(); } } async function updateTweetDetailWithAI(tweetId, interactionData, isReroll = false, isProgressMode = false) { const statsDiv = document.getElementById('tweet-detail-stats'); if (statsDiv) { statsDiv.innerHTML = ` <div style="display: flex; align-items: center; gap: 4px;"> <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(interactionData.stats.retweets)}</span> <span style="color: #71767b; font-size: 15px;">${getI18nText('tweetDetailRetweets')}</span> </div> <div style="display: flex; align-items: center; gap: 4px;"> <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(interactionData.stats.likes)}</span> <span style="color: #71767b; font-size: 15px;">${getI18nText('tweetDetailLikes')}</span> </div> <div style="display: flex; align-items: center; gap: 4px;"> <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(interactionData.stats.comments)}</span> <span style="color: #71767b; font-size: 15px;">${getI18nText('tweetDetailBookmarks')}</span> </div> `; } const viewElement = document.getElementById('tweet-detail-views'); const viewLabelElement = document.getElementById('tweet-detail-views-label'); if (viewElement) { viewElement.textContent = formatNumber(interactionData.stats.views); } if (viewLabelElement) { viewLabelElement.textContent = getI18nText('tweetDetailViews'); } const commentsContainer = document.getElementById('detail-comments-container'); if (isReroll && !isProgressMode && commentsContainer) { commentsContainer.innerHTML = ''; } if (commentsContainer && interactionData.comments.length > 0) { interactionData.comments.forEach(comment => { const commentGroup = document.createElement('div'); commentGroup.style.cssText = 'position: relative;'; const commentElement = createCommentElement(comment); if (comment.replies && comment.replies.length > 0) { commentElement.classList.add('has-replies'); } commentGroup.appendChild(commentElement); if (comment.replies && comment.replies.length > 0) { comment.replies.forEach(reply => { const replyElement = createCommentElement(reply, true); commentGroup.appendChild(replyElement); }); } commentsContainer.appendChild(commentGroup); }); } await updateStoredTweetData(tweetId, interactionData, isProgressMode); } async function updateStoredTweetData(tweetId, interactionData, isProgressMode = false) { try { const db = getXDB(); const currentTweetData = sessionStorage.getItem('currentTweetData'); let isAccountTweet = false; let isSearchTweet = false; let accountHandle = null; if (currentTweetData) { try { const tweet = JSON.parse(currentTweetData); isAccountTweet = tweet._source === 'account'; isSearchTweet = tweet._source === 'search'; accountHandle = tweet._accountHandle; } catch (e) { console.warn('解析推文数据失败:', e); } } if (isSearchTweet) { console.log('📝 [更新数据] 检测到搜索结果推文，更新搜索数据'); const tweetsData = await db.xTweetsData.get('tweets'); if (tweetsData) { let updated = false; if (tweetsData.forYouTweets) { const index = tweetsData.forYouTweets.findIndex(t => t.id === tweetId); if (index !== -1) { if (isProgressMode) { const currentStats = tweetsData.forYouTweets[index].stats; tweetsData.forYouTweets[index].stats = { comments: Math.max(currentStats.comments, interactionData.stats.comments), retweets: Math.max(currentStats.retweets, interactionData.stats.retweets), likes: Math.max(currentStats.likes, interactionData.stats.likes), views: Math.max(currentStats.views, interactionData.stats.views), }; const existingComments = tweetsData.forYouTweets[index].comments || []; tweetsData.forYouTweets[index].comments = [...existingComments, ...(interactionData.comments || [])]; } else { tweetsData.forYouTweets[index].stats = { ...tweetsData.forYouTweets[index].stats, ...interactionData.stats, }; tweetsData.forYouTweets[index].comments = interactionData.comments || []; } updated = true; console.log(`📈 [搜索推文] forYouTweets 新增 ${interactionData.comments?.length || 0} 条评论`); } } if (tweetsData.followingTweets && !updated) { const index = tweetsData.followingTweets.findIndex(t => t.id === tweetId); if (index !== -1) { if (isProgressMode) { const currentStats = tweetsData.followingTweets[index].stats; tweetsData.followingTweets[index].stats = { comments: Math.max(currentStats.comments, interactionData.stats.comments), retweets: Math.max(currentStats.retweets, interactionData.stats.retweets), likes: Math.max(currentStats.likes, interactionData.stats.likes), views: Math.max(currentStats.views, interactionData.stats.views), }; const existingComments = tweetsData.followingTweets[index].comments || []; tweetsData.followingTweets[index].comments = [...existingComments, ...(interactionData.comments || [])]; } else { tweetsData.followingTweets[index].stats = { ...tweetsData.followingTweets[index].stats, ...interactionData.stats, }; tweetsData.followingTweets[index].comments = interactionData.comments || []; } updated = true; console.log(`📈 [搜索推文] followingTweets 新增 ${interactionData.comments?.length || 0} 条评论`); } } if (updated) { await db.xTweetsData.put(tweetsData); if (currentTweetData) { try { const currentTweet = JSON.parse(currentTweetData); if (currentTweet.id === tweetId) { currentTweet.stats = interactionData.stats; currentTweet.comments = currentTweet.comments || []; if (isProgressMode) { currentTweet.comments = [...currentTweet.comments, ...(interactionData.comments || [])]; } else { currentTweet.comments = interactionData.comments || []; } sessionStorage.setItem('currentTweetData', JSON.stringify(currentTweet)); } } catch (e) { console.warn('更新 sessionStorage 失败:', e); } } console.log('✅ 搜索推文AI反应已保存:', tweetId, isProgressMode ? '(推进模式)' : ''); return; } } } if (isAccountTweet && accountHandle) { console.log('📝 [更新数据] 检测到账户推文，更新账户主页数据'); const cleanHandle = accountHandle.replace('@', ''); const accountProfile = await db.xAccountProfiles.get(cleanHandle); if (accountProfile && accountProfile.tweets) { const tweetIndex = accountProfile.tweets.findIndex(t => t.id === tweetId); if (tweetIndex !== -1) { if (isProgressMode) { const currentStats = accountProfile.tweets[tweetIndex].stats; accountProfile.tweets[tweetIndex].stats = { comments: Math.max(currentStats.comments, interactionData.stats.comments), retweets: Math.max(currentStats.retweets, interactionData.stats.retweets), likes: Math.max(currentStats.likes, interactionData.stats.likes), views: Math.max(currentStats.views, interactionData.stats.views), }; const existingComments = accountProfile.tweets[tweetIndex].comments || []; accountProfile.tweets[tweetIndex].comments = [...existingComments, ...(interactionData.comments || [])]; console.log(`📈 [账户推文] 新增 ${interactionData.comments?.length || 0} 条评论`); } else { accountProfile.tweets[tweetIndex].stats = { ...accountProfile.tweets[tweetIndex].stats, ...interactionData.stats, }; accountProfile.tweets[tweetIndex].comments = interactionData.comments || []; } await db.xAccountProfiles.put(accountProfile); if (currentTweetData) { try { const currentTweet = JSON.parse(currentTweetData); if (currentTweet.id === tweetId) { currentTweet.stats = accountProfile.tweets[tweetIndex].stats; currentTweet.comments = accountProfile.tweets[tweetIndex].comments; sessionStorage.setItem('currentTweetData', JSON.stringify(currentTweet)); } } catch (e) { console.warn('更新 sessionStorage 失败:', e); } } console.log('✅ 账户推文AI反应已保存:', tweetId, isProgressMode ? '(推进模式)' : ''); return; } } } const isUserTweet = tweetId && tweetId.startsWith('user_'); if (!isUserTweet) { console.log('📝 [更新数据] 检测到主页推文，更新主页数据'); const tweetsData = await db.xTweetsData.get('tweets'); if (tweetsData) { let updated = false; if (tweetsData.forYouTweets) { const index = tweetsData.forYouTweets.findIndex(t => t.id === tweetId); if (index !== -1) { if (isProgressMode) { const currentStats = tweetsData.forYouTweets[index].stats; tweetsData.forYouTweets[index].stats = { comments: Math.max(currentStats.comments, interactionData.stats.comments), retweets: Math.max(currentStats.retweets, interactionData.stats.retweets), likes: Math.max(currentStats.likes, interactionData.stats.likes), views: Math.max(currentStats.views, interactionData.stats.views), }; const existingComments = tweetsData.forYouTweets[index].comments || []; tweetsData.forYouTweets[index].comments = [...existingComments, ...(interactionData.comments || [])]; } else { tweetsData.forYouTweets[index].stats = { ...tweetsData.forYouTweets[index].stats, ...interactionData.stats, }; tweetsData.forYouTweets[index].comments = interactionData.comments || []; } updated = true; console.log(`📈 [主页推文] forYouTweets 新增 ${interactionData.comments?.length || 0} 条评论`); } } if (tweetsData.followingTweets && !updated) { const index = tweetsData.followingTweets.findIndex(t => t.id === tweetId); if (index !== -1) { if (isProgressMode) { const currentStats = tweetsData.followingTweets[index].stats; tweetsData.followingTweets[index].stats = { comments: Math.max(currentStats.comments, interactionData.stats.comments), retweets: Math.max(currentStats.retweets, interactionData.stats.retweets), likes: Math.max(currentStats.likes, interactionData.stats.likes), views: Math.max(currentStats.views, interactionData.stats.views), }; const existingComments = tweetsData.followingTweets[index].comments || []; tweetsData.followingTweets[index].comments = [...existingComments, ...(interactionData.comments || [])]; } else { tweetsData.followingTweets[index].stats = { ...tweetsData.followingTweets[index].stats, ...interactionData.stats, }; tweetsData.followingTweets[index].comments = interactionData.comments || []; } updated = true; console.log(`📈 [主页推文] followingTweets 新增 ${interactionData.comments?.length || 0} 条评论`); } } if (updated) { await db.xTweetsData.put(tweetsData); if (currentTweetData) { try { const currentTweet = JSON.parse(currentTweetData); if (currentTweet.id === tweetId) { currentTweet.stats = interactionData.stats; currentTweet.comments = currentTweet.comments || []; if (isProgressMode) { currentTweet.comments = [...currentTweet.comments, ...(interactionData.comments || [])]; } else { currentTweet.comments = interactionData.comments || []; } sessionStorage.setItem('currentTweetData', JSON.stringify(currentTweet)); } } catch (e) { console.warn('更新 sessionStorage 失败:', e); } } console.log('✅ 主页推文AI反应已保存:', tweetId, isProgressMode ? '(推进模式)' : ''); return; } else { console.warn('⚠️ 未在主页数据中找到要更新的推文:', tweetId); } } return; } const accountTweetsId = `userTweets_${currentAccountId || 'main'}`; let userTweets = await db.xUserTweets.get(accountTweetsId); if (!userTweets) { console.warn('未找到用户推文数据，账户ID:', accountTweetsId); return; } const tweetIndex = userTweets.tweets.findIndex(tweet => tweet.id === tweetId); if (tweetIndex !== -1) { if (isProgressMode) { const currentStats = userTweets.tweets[tweetIndex].stats; userTweets.tweets[tweetIndex].stats = { comments: Math.max(currentStats.comments, interactionData.stats.comments), retweets: Math.max(currentStats.retweets, interactionData.stats.retweets), likes: Math.max(currentStats.likes, interactionData.stats.likes), views: Math.max(currentStats.views, interactionData.stats.views), }; const existingComments = userTweets.tweets[tweetIndex].comments || []; userTweets.tweets[tweetIndex].comments = [...existingComments, ...(interactionData.comments || [])]; console.log(`📈 [推进模式] 新增 ${interactionData.comments?.length || 0} 条评论`); } else { userTweets.tweets[tweetIndex].stats = { ...userTweets.tweets[tweetIndex].stats, ...interactionData.stats, }; userTweets.tweets[tweetIndex].comments = interactionData.comments || []; } await db.xUserTweets.put(userTweets); if (currentTweetData) { try { const currentTweet = JSON.parse(currentTweetData); if (currentTweet.id === tweetId) { currentTweet.stats = userTweets.tweets[tweetIndex].stats; currentTweet.comments = userTweets.tweets[tweetIndex].comments; sessionStorage.setItem('currentTweetData', JSON.stringify(currentTweet)); } } catch (e) { console.warn('更新 sessionStorage 失败:', e); } } console.log( '✅ 推文AI反应已保存到数据库:', tweetId, '账户:', accountTweetsId, isProgressMode ? '(推进模式)' : '', ); refreshUserProfileTweets(); } else { console.warn('⚠️ 未找到要更新的推文:', tweetId); } } catch (error) { console.error('❌ 更新存储推文数据失败:', error); } } async function generateUnifiedAIResponse(tweetData, userComment, options = {}) { try { const { isOwnPost = false, commentType = 'main_comment', pageType = 'detail', parentComment = null, mainCommentId = null, } = options; const { apiConfig, xSettings, xDb } = await APIUtils.loadConfigAndSettings(); const { userPrompt, worldSetting, boundCharacters } = xSettings; console.log('🔄 [AI回复] 重新加载最新推文数据，避免覆盖用户评论'); const tweetId = tweetData.id; const isUserTweet = tweetId.startsWith('user_'); const isRetweetMention = tweetData._source === 'retweet_mention'; let latestTweetData = null; if (isRetweetMention) { console.log('🔄 [AI回复] 从 Mentions 数据库加载转帖通知'); const mentionsId = `mentions_${currentAccountId || 'main'}`; const mentionsData = await xDb.xAccountProfiles.get(mentionsId); if (mentionsData && mentionsData.data) { const mention = mentionsData.data.find(m => m.id === tweetId && m.type === 'retweet'); if (mention) { latestTweetData = { ...tweetData, comments: mention.comments || [], stats: mention.stats || tweetData.stats, }; console.log('✅ [AI回复] 已从 Mentions 加载转帖数据，评论数:', latestTweetData.comments.length); } } } else if (isUserTweet) { const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); if (userTweetsData && userTweetsData.tweets) { latestTweetData = userTweetsData.tweets.find(t => t.id === tweetId); } } else { const tweetsData = await xDb.xTweetsData.get('tweets'); if (tweetsData) { latestTweetData = tweetsData.forYouTweets?.find(t => t.id === tweetId) || tweetsData.followingTweets?.find(t => t.id === tweetId); } } if (latestTweetData) { console.log('✅ [AI回复] 已加载最新推文数据，评论数:', latestTweetData.comments?.length || 0); tweetData = latestTweetData; } else { console.warn('⚠️ [AI回复] 未能加载最新推文数据，使用传入数据'); } const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); let tokenCount = 0; let systemPrompt = StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting, }); tokenCount = TokenUtils.logTokenUsage('统一AI回复生成器', '基础系统提示词', systemPrompt, tokenCount); systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🚫 核心任务说明 🚫 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的互动生成器。你的任务是： ✅ 为用户的评论生成其他人的回应/反应 ❌ 绝对不能再生成用户本人的评论或回复 **明确：用户已经发表了评论，你只负责生成别人对这条评论的反应！** ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`; const coreTaskSection = systemPrompt.substring(systemPrompt.lastIndexOf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━')); tokenCount = TokenUtils.logTokenUsage('统一AI回复生成器', '核心任务说明', coreTaskSection, tokenCount); const scenarioPromptStart = systemPrompt.length; systemPrompt += StringBuilders.buildScenarioPrompt({ isOwnPost, commentType, pageType, parentComment, }); const scenarioPrompt = systemPrompt.substring(scenarioPromptStart); tokenCount = TokenUtils.logTokenUsage('统一AI回复生成器', '场景分支提示词', scenarioPrompt, tokenCount); const charactersInfo = await StringBuilders.buildCompleteCharacterInfo( boundCharacters, userXProfileInfo, 'reply', ); if (charactersInfo) { systemPrompt += charactersInfo; tokenCount = TokenUtils.logTokenUsage('统一AI回复生成器', '角色资料信息', charactersInfo, tokenCount); } const userConstraintsStart = systemPrompt.length; systemPrompt += StringBuilders.buildUniversalConstraints(userXProfileInfo); const userConstraints = systemPrompt.substring(userConstraintsStart); tokenCount = TokenUtils.logTokenUsage('统一AI回复生成器', '用户资料约束', userConstraints, tokenCount); systemPrompt += ` 【评论回复要求】： - 生成1-5条回复，内容多样化（简短/深度/表情符号） - 环境贴合：参考评论区现有讨论，基于主题和氛围生成贴合回复 - 回复内容必须围绕推文主题和用户评论内容，不要偏离主题 - 除了绑定角色外，其他用户头像统一：https: ${ boundCharacters.length > 0 ? `**角色回复要点**：根据设定判断是否适合发言，符合人设特点，可生成0-2个角色回复，严格使用角色X资料信息。` : '**当前状态**：无绑定角色，生成普通用户回复。' } 【🔒 隐私保护规则 - 路人回复限制】： 🚨 路人回复者（非绑定角色/关系NPC的普通用户）只能基于X平台公开信息： ✅ 可以使用：X姓名、X句柄、X简介、公开身份 ❌ 禁止提及：真实姓名、真实职业、私人关系、未公开的身份信息 ❌ 禁止使用：只有亲密关系才知道的称呼（如"老师"、"同学"、"老板"等，除非是公开身份） ❌ 禁止提及：角色人设描述中的私密细节 示例说明： - ✅ 正确："姐姐说得对"（基于公开的社交称呼） - ❌ 错误："王老师说得好"（泄露了真实姓氏和职业） - ❌ 错误："同学你好厉害"（假装是同学关系，路人不可能知道） ⚠️ 只有已绑定的关系NPC才能提及私密信息或使用私密称呼（因为他们是角色的私人关系） 【情侣角色回复规则】： ${ userXProfileInfo.verificationType === 'couple' && userXProfileInfo.coupleCharacterName ? `- 用户的情侣是 ${userXProfileInfo.coupleCharacterName} - **关键限制**：在他人帖子下回复用户评论时，出现概率极低（5-15%） * 评论与情侣角色无关 → 不出现 * 话题普通/日常 → 很少出现 * 只有评论内容与情侣角色相关、或确有理由参与讨论时才可能出现 - 回复围绕帖子主题和讨论，不只是"秀恩爱" - 粉丝群体严格限制：仅当双方为明星/网红/公众人物时才可能有1条CP粉丝评论（概率极低），普通情侣绝无"磕学家""CP粉"等粉丝群体` : '' } 【JSON返回格式】： \`\`\`json { "${commentType === 'reply_comment' && pageType === 'main' ? 'replies' : 'comments'}": [回复数组] } \`\`\` 回复对象结构： - user: {name, handle, avatar, verified} - content: 回复文本 (可与sticker同时存在) - timeOffset: 相对推文发布的分钟数（负数，如-5表示推文发布后5分钟的回复） - sticker: {url: "表情包链接", description: "表情包描述"} (可选，约10-15%回复使用) - replyTo: "${userComment.user.handle}" (必须回复用户刚发表的评论) - replies: [] 【表情包使用规则】： - 表情包仅限使用世界书中提供的真实链接，严禁虚构或编造链接 - 表情包与文字内容可以同时存在，用于增强表达效果 - 使用频率控制在约10-15%的回复中，保持自然 - sticker对象包含url和description两个必需字段 关键规则： 1. verified字段必须是布尔值(true/false) 1.5. timeOffset必须是负数，表示回复发布在推文之后多少分钟（如-2, -5, -15等） 2. replyTo字段必须是"${userComment.user.handle}"，表示回复用户的评论 3. ${ boundCharacters.length > 0 ? '生成角色回复时必须严格使用提供的角色X资料(xName、xHandle、xAvatar、xVerified)，不得使用默认值或自编信息' : '普通用户回复，自创用户名和句柄' } 4. sticker字段只能使用世界书中存在的真实链接，禁止虚构`; const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】')); tokenCount = TokenUtils.logTokenUsage('统一AI回复生成器', 'JSON格式要求', formatSection, tokenCount); let contextInfo = `【推文信息${pageType === 'detail' ? '（详情页）' : '（主页）'}】 标题：${isOwnPost ? '【用户的帖子】' : ''}${tweetData.content} 推文作者：${tweetData.user.name} (${tweetData.user.handle}) ${tweetData.location ? `位置：${tweetData.location}` : ''} ${tweetData.link ? `链接：${tweetData.link.title || tweetData.link.url}` : ''} ${tweetData.media && tweetData.media.length > 0 ? `媒体：${tweetData.media[0].description}` : ''}`; if (tweetData.quotedTweet) { const quoted = tweetData.quotedTweet; const quotedType = quoted.type === 'tweet' ? '推文' : '评论'; contextInfo += ` 【该推文引用了以下${quotedType}】 原作者：${quoted.user.name} (${quoted.user.handle})${quoted.user.verified ? ' ✓已认证' : ''} 发布时间：${quoted.time} 原内容："${quoted.content}"`; if (quoted.image) { if (quoted.image.type === 'description') { contextInfo += ` 原图片描述：${quoted.image.content}`; } else if (quoted.image.type === 'upload') { contextInfo += ` 原图片：包含上传的图片内容`; } } if (quoted.location) { contextInfo += ` 原位置：${quoted.location}`; } contextInfo += ` 注意：这是引用转发，用户的评论是对上述${quotedType}的回应/评论。回复时可以同时考虑用户的评论和被引用的原内容，可以讨论引用关系、原作者观点，或用户的转发评论等。`; } contextInfo += ` 【用户发表的${commentType === 'main_comment' ? '评论' : '回复'}】 用户名：${userComment.user.name} 用户句柄：${userComment.user.handle} ${commentType === 'main_comment' ? '评论' : '回复'}内容：${userComment.content}`; if (commentType === 'reply_comment' && parentComment) { contextInfo += ` 【用户回复的对象（楼中楼场景）】 被回复者姓名：${parentComment.user.name} 被回复者句柄：${parentComment.user.handle} 被回复的评论：${parentComment.content} ⚠️ 重要说明： - 用户 ${userComment.user.name} (${userComment.user.handle}) 刚刚回复了 ${parentComment.user.name} (${parentComment.user.handle}) 的评论 - 你生成的回复必须是对用户 ${userComment.user.name} (${userComment.user.handle}) 的回复 - 所有回复的 replyTo 字段必须是 "${userComment.user.handle}"`; } if (tweetData.comments && tweetData.comments.length > 0) { contextInfo += ` 【当前评论区内容】（共${tweetData.comments.length}条评论，帮助理解讨论主题和氛围）`; const displayComments = tweetData.comments.slice(0, 10); displayComments.forEach((comment, index) => { contextInfo += ` ${index + 1}. ${comment.user.name} (${comment.user.handle}): ${comment.content}`; if (comment.sticker) { contextInfo += ` [含表情包: ${comment.sticker.description}]`; } if (comment.replies && comment.replies.length > 0) { const displayReplies = comment.replies.slice(0, 3); displayReplies.forEach((reply, replyIndex) => { contextInfo += ` └─ ${reply.user.name} (${reply.user.handle}): ${reply.content}`; if (reply.sticker) { contextInfo += ` [含表情包: ${reply.sticker.description}]`; } }); if (comment.replies.length > 3) { contextInfo += ` └─ ...还有${comment.replies.length - 3}条回复`; } } }); if (tweetData.comments.length > 10) { contextInfo += ` ...还有${tweetData.comments.length - 10}条评论未显示`; } } if (tweetData.user && tweetData.user.handle) { try { console.log(`📝 [统一AI回复] 读取推文作者资料: ${tweetData.user.handle}`); const tweetAuthorProfile = await StringBuilders.getUnifiedProfile(tweetData.user.handle, { userProfileInfo: userXProfileInfo, }); if (tweetAuthorProfile) { contextInfo += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📝 推文作者完整资料 📝 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; contextInfo += StringBuilders.formatProfileForPrompt(tweetAuthorProfile, { includeType: true, includeTweets: true, includeRelationships: true, }); contextInfo += ` ⚠️ 推文作者资料使用说明： - 如果推文作者是角色/NPC，回复时可能会来评论区互动 - 推文作者的关系NPC如果看到这条推文，可能会来评论 - 回复要符合推文作者的身份和背景 - 如果推文作者与用户有聊天记忆，可以自然体现在互动中 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; tokenCount = TokenUtils.logTokenUsage( '统一AI回复生成器', '推文作者资料', contextInfo.substring(contextInfo.lastIndexOf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━')), tokenCount, ); } } catch (error) { console.error(`❌ [统一AI回复] 读取推文作者资料失败:`, error); } } TokenUtils.logTokenUsage('统一AI回复生成器', '上下文信息', contextInfo, tokenCount); const messageContent = []; messageContent.push({ type: 'text', text: contextInfo }); if (userComment.image && userComment.image.type === 'upload' && userComment.image.content) { messageContent.push({ type: 'image_url', image_url: { url: userComment.image.content }, }); } else if (userComment.image && userComment.image.type === 'description') { messageContent.push({ type: 'text', text: `用户评论附带的图片描述：${userComment.image.content}`, }); } const messages = [{ role: 'user', content: messageContent }]; const contextText = messageContent.map(c => c.text || '[图片]').join(' '); TokenUtils.logFinalPrompt('统一AI回复生成器', systemPrompt, contextText); const aiResponseContent = await APIUtils.sendAIRequest({ apiConfig, systemPrompt, messages, temperature: 0.8, }); console.log('绑定角色数量:', boundCharacters.length); console.log('评论区上下文:', tweetData.comments ? `${tweetData.comments.length}条评论` : '无评论'); if (tweetData.comments && tweetData.comments.length > 0) { console.log( '评论示例:', tweetData.comments.slice(0, 3).map(c => `${c.user.name}: ${c.content.substring(0, 50)}...`), ); } let replyData = APIUtils.parseJSONResponse(aiResponseContent); replyData = await APIUtils.postProcessData(replyData, userXProfileInfo); const timestamp = Date.now(); const repliesKey = commentType === 'reply_comment' && pageType === 'main' ? 'replies' : 'comments'; const replies = replyData[repliesKey] || []; if (!Array.isArray(replies)) { throw new Error('AI返回的数据格式不正确'); } if (pageType === 'detail') { console.log('🤖 [AI回复] 详情页模式 - 生成了', replies.length, '条回复'); let tweetTimestamp = tweetData.timestamp || tweetData.createdAt || Date.now(); if (typeof tweetTimestamp !== 'number') { if (tweetTimestamp instanceof Date) { tweetTimestamp = tweetTimestamp.getTime(); } else if (typeof tweetTimestamp === 'string') { tweetTimestamp = new Date(tweetTimestamp).getTime(); } else { tweetTimestamp = Date.now(); } } if (isNaN(tweetTimestamp) || tweetTimestamp <= 0) { console.warn('⚠️ [AI回复] 推文时间戳无效，使用当前时间'); tweetTimestamp = Date.now(); } if (commentType === 'main_comment') { replies.forEach((comment, index) => { comment.id = `ai_unified_${timestamp}_${index}`; if (comment.timeOffset !== undefined && !isNaN(comment.timeOffset)) { comment.timestamp = tweetTimestamp + Math.abs(comment.timeOffset) * 60 * 1000; delete comment.timeOffset; } else if (!comment.timestamp || isNaN(comment.timestamp)) { comment.timestamp = tweetTimestamp + (2 + Math.random() * 20) * 60 * 1000; } if (isNaN(comment.timestamp) || comment.timestamp <= 0) { console.warn('⚠️ [AI回复] 评论时间戳无效，使用推文时间'); comment.timestamp = tweetTimestamp; } tweetData.comments.push(comment); }); tweetData.stats.comments += replies.length; console.log('🤖 [AI回复] AI回复已添加到推文数据，新评论总数:', tweetData.stats.comments); } else if (commentType === 'reply_comment' && parentComment) { const targetComment = tweetData.comments.find(c => c.id === parentComment.id); if (targetComment) { if (!targetComment.replies) targetComment.replies = []; replies.forEach((reply, index) => { reply.id = `ai_unified_${timestamp}_${index}`; if (reply.timeOffset !== undefined && !isNaN(reply.timeOffset)) { reply.timestamp = tweetTimestamp + Math.abs(reply.timeOffset) * 60 * 1000; delete reply.timeOffset; } else if (!reply.timestamp || isNaN(reply.timestamp)) { let parentTimestamp = targetComment.timestamp || targetComment.createdAt || tweetTimestamp; if (typeof parentTimestamp !== 'number') { parentTimestamp = parentTimestamp instanceof Date ? parentTimestamp.getTime() : typeof parentTimestamp === 'string' ? new Date(parentTimestamp).getTime() : tweetTimestamp; } reply.timestamp = parentTimestamp + (1 + Math.random() * 10) * 60 * 1000; } if (isNaN(reply.timestamp) || reply.timestamp <= 0) { console.warn('⚠️ [AI回复] 楼中楼回复时间戳无效，使用推文时间'); reply.timestamp = tweetTimestamp; } targetComment.replies.push(reply); }); console.log( '🤖 [AI回复] 楼中楼回复已添加，目标评论:', parentComment.id, '，当前回复总数:', targetComment.replies.length, ); } else { console.error('❌ [AI回复] 未找到目标评论:', parentComment.id); } } try { const xDb = getXDB(); const isUserTweet = tweetData.id.startsWith('user_'); const isAccountTweet = tweetData._source === 'account'; const isRetweetMention = tweetData._source === 'retweet_mention'; const isNewTweetMention = tweetData._source === 'newtweet_mention'; if (isRetweetMention) { console.log('🤖 [AI回复] 保存到 Mentions 转帖通知数据'); const mentionsId = `mentions_${currentAccountId || 'main'}`; const mentionsData = await xDb.xAccountProfiles.get(mentionsId); if (mentionsData && mentionsData.data) { const retweetIndex = mentionsData.data.findIndex(m => m.id === tweetData.id && m.type === 'retweet'); if (retweetIndex !== -1) { mentionsData.data[retweetIndex].comments = tweetData.comments; if (!mentionsData.data[retweetIndex].stats) { mentionsData.data[retweetIndex].stats = tweetData.stats; } else { mentionsData.data[retweetIndex].stats.comments = tweetData.stats.comments; } await xDb.xAccountProfiles.put(mentionsData); console.log('✅ [AI回复] Mentions 转帖通知已更新，评论总数:', tweetData.comments.length); } else { console.warn('⚠️ [AI回复] 未在 Mentions 数据中找到对应的转帖通知:', tweetData.id); } } else { console.warn('⚠️ [AI回复] 未找到 Mentions 数据:', mentionsId); } } else if (isNewTweetMention) { console.log('🤖 [AI回复] 保存到 Mentions New Tweet 通知数据'); const mentionsId = `mentions_${currentAccountId || 'main'}`; const mentionsData = await xDb.xAccountProfiles.get(mentionsId); if (mentionsData && mentionsData.data) { const newTweetIndex = mentionsData.data.findIndex( m => m.id === tweetData._mentionId && m.type === 'newTweet', ); if (newTweetIndex !== -1) { if (!mentionsData.data[newTweetIndex].tweet) { mentionsData.data[newTweetIndex].tweet = {}; } mentionsData.data[newTweetIndex].tweet.comments = tweetData.comments; if (!mentionsData.data[newTweetIndex].tweet.stats) { mentionsData.data[newTweetIndex].tweet.stats = tweetData.stats; } else { mentionsData.data[newTweetIndex].tweet.stats.comments = tweetData.stats.comments; } await xDb.xAccountProfiles.put(mentionsData); console.log('✅ [AI回复] Mentions New Tweet 通知已更新，评论总数:', tweetData.comments.length); } else { console.warn('⚠️ [AI回复] 未在 Mentions 数据中找到对应的 New Tweet 通知:', tweetData._mentionId); } } else { console.warn('⚠️ [AI回复] 未找到 Mentions 数据:', mentionsId); } } else if (isAccountTweet) { console.log('🤖 [AI回复] 保存到账户推文数据'); const accountHandle = tweetData._accountHandle || (currentViewingAccount.accountInfo || currentViewingAccount).handle; const cleanHandle = accountHandle.replace('@', ''); if (currentViewingAccount && currentViewingAccount.tweets) { const tweetIndex = currentViewingAccount.tweets.findIndex(t => t.id === tweetData.id); if (tweetIndex !== -1) { currentViewingAccount.tweets[tweetIndex] = tweetData; await xDb.xAccountProfiles.put({ handle: cleanHandle, name: (currentViewingAccount.accountInfo || currentViewingAccount).name, accountInfo: currentViewingAccount.accountInfo || currentViewingAccount, tweets: currentViewingAccount.tweets, accountReplies: currentViewingAccount.accountReplies || [], updatedAt: new Date().toISOString(), }); console.log('✅ [AI回复] 账户推文已保存，账户:', cleanHandle); } } } else if (isUserTweet) { console.log('🤖 [AI回复] 保存到用户推文数据'); const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); if (userTweetsData && userTweetsData.tweets) { const tweetIndex = userTweetsData.tweets.findIndex(t => t.id === tweetData.id); if (tweetIndex !== -1) { userTweetsData.tweets[tweetIndex] = tweetData; await xDb.xUserTweets.put(userTweetsData); console.log( '✅ [AI回复] 用户推文AI回复已保存，评论总数:', tweetData.comments.length, '，主评论', tweetData.comments.length, '条', ); } else { console.error('❌ [AI回复] 未在数据库中找到目标推文'); } } } else { console.log('🤖 [AI回复] 保存到主页推文数据'); const tweetsData = await xDb.xTweetsData.get('tweets'); if (tweetsData) { let updated = false; if (tweetsData.forYouTweets) { const index = tweetsData.forYouTweets.findIndex(t => t.id === tweetData.id); if (index !== -1) { tweetsData.forYouTweets[index] = tweetData; updated = true; } } if (tweetsData.followingTweets && !updated) { const index = tweetsData.followingTweets.findIndex(t => t.id === tweetData.id); if (index !== -1) { tweetsData.followingTweets[index] = tweetData; updated = true; } } if (updated) { await xDb.xTweetsData.put(tweetsData); console.log( '✅ [AI回复] 主页推文AI回复已保存，评论总数:', tweetData.comments.length, '，主评论', tweetData.comments.length, '条', ); } else { console.error('❌ [AI回复] 未在数据库中找到目标推文'); } } } sessionStorage.setItem('currentTweetData', JSON.stringify(tweetData)); console.log('✅ [AI回复] sessionStorage 已更新'); } catch (saveError) { console.error('❌ [AI回复] 保存AI回复到数据库失败:', saveError); } replies.forEach((comment, index) => { const commentElement = createCommentElement(comment, commentType === 'reply_comment'); const commentsContainer = document.getElementById('detail-comments-container'); if (commentType === 'reply_comment' && parentComment) { const allComments = commentsContainer.querySelectorAll('.comment-item'); let insertPosition = null; let insertAfter = null; allComments.forEach(commentEl => { if (commentEl.dataset.commentId === parentComment.id) { insertPosition = commentEl; if (commentEl.classList.contains('reply-item')) { let nextSibling = commentEl.nextElementSibling; insertAfter = commentEl; while (nextSibling && nextSibling.classList.contains('reply-item')) { insertAfter = nextSibling; nextSibling = nextSibling.nextElementSibling; } } else { let nextSibling = commentEl.nextElementSibling; insertAfter = commentEl; while (nextSibling && nextSibling.classList.contains('reply-item')) { insertAfter = nextSibling; nextSibling = nextSibling.nextElementSibling; } } } }); if (insertAfter) { if (insertAfter.nextSibling) { insertAfter.parentNode.insertBefore(commentElement, insertAfter.nextSibling); } else { insertAfter.parentNode.appendChild(commentElement); } } else { commentsContainer.appendChild(commentElement); } } else { commentsContainer.appendChild(commentElement); } }); console.log('✅ [AI回复] AI回复已渲染到页面'); const replyUserAvatars = document.querySelectorAll('.reply-user-avatar'); replyUserAvatars.forEach(avatar => { avatar.src = userProfileData.avatar; }); } else { console.log('🤖 [AI回复] 主页模式 - 开始处理'); let tweetTimestamp = tweetData.timestamp || tweetData.createdAt || Date.now(); if (typeof tweetTimestamp !== 'number') { if (tweetTimestamp instanceof Date) { tweetTimestamp = tweetTimestamp.getTime(); } else if (typeof tweetTimestamp === 'string') { tweetTimestamp = new Date(tweetTimestamp).getTime(); } else { tweetTimestamp = Date.now(); } } if (isNaN(tweetTimestamp) || tweetTimestamp <= 0) { console.warn('⚠️ [AI回复] 主页模式：推文时间戳无效，使用当前时间'); tweetTimestamp = Date.now(); } if (commentType === 'main_comment') { replies.forEach((comment, index) => { comment.id = `ai_main_unified_${timestamp}_${index}`; if (comment.timeOffset !== undefined && !isNaN(comment.timeOffset)) { comment.timestamp = tweetTimestamp + Math.abs(comment.timeOffset) * 60 * 1000; delete comment.timeOffset; } else if (!comment.timestamp || isNaN(comment.timestamp)) { comment.timestamp = tweetTimestamp + (2 + Math.random() * 20) * 60 * 1000; } if (isNaN(comment.timestamp) || comment.timestamp <= 0) { console.warn('⚠️ [AI回复] 主页模式：评论时间戳无效，使用推文时间'); comment.timestamp = tweetTimestamp; } tweetData.comments.push(comment); }); tweetData.stats.comments += replies.length; console.log('🤖 [AI回复] 已添加主评论，新增:', replies.length, '条，总计:', tweetData.comments.length); } else { const targetCommentId = mainCommentId || parentComment.id; const mainCommentObj = tweetData.comments.find(c => c.id === targetCommentId); if (mainCommentObj) { replies.forEach((reply, index) => { reply.id = `ai_main_sub_unified_${timestamp}_${index}`; if (reply.timeOffset !== undefined && !isNaN(reply.timeOffset)) { reply.timestamp = tweetTimestamp + Math.abs(reply.timeOffset) * 60 * 1000; delete reply.timeOffset; } else if (!reply.timestamp || isNaN(reply.timestamp)) { let parentTimestamp = mainCommentObj.timestamp || mainCommentObj.createdAt || tweetTimestamp; if (typeof parentTimestamp !== 'number') { parentTimestamp = parentTimestamp instanceof Date ? parentTimestamp.getTime() : typeof parentTimestamp === 'string' ? new Date(parentTimestamp).getTime() : tweetTimestamp; } reply.timestamp = parentTimestamp + (1 + Math.random() * 10) * 60 * 1000; } if (isNaN(reply.timestamp) || reply.timestamp <= 0) { console.warn('⚠️ [AI回复] 主页模式：楼中楼回复时间戳无效，使用推文时间'); reply.timestamp = tweetTimestamp; } if (!mainCommentObj.replies) mainCommentObj.replies = []; mainCommentObj.replies.push(reply); }); console.log('🤖 [AI回复] 已添加楼中楼回复到主评论:', targetCommentId, '，新增:', replies.length, '条'); } else { console.warn('⚠️ [AI回复] 无法找到主评论，mainCommentId:', targetCommentId); } } try { let updated = false; const tweetIndex = forYouTweets.findIndex(t => t.id === tweetData.id); if (tweetIndex !== -1) { forYouTweets[tweetIndex] = tweetData; updated = true; console.log('🤖 [AI回复] 已更新forYouTweets中的推文'); } else { const followingIndex = followingTweets.findIndex(t => t.id === tweetData.id); if (followingIndex !== -1) { followingTweets[followingIndex] = tweetData; updated = true; console.log('🤖 [AI回复] 已更新followingTweets中的推文'); } } if (!updated) { console.warn('⚠️ [AI回复] 未在全局数组中找到推文:', tweetData.id); } const existingData = await xDb.xTweetsData.get('tweets'); if (existingData) { existingData.forYouTweets = forYouTweets; existingData.followingTweets = followingTweets; existingData.lastUpdated = new Date().toISOString(); await xDb.xTweetsData.put(existingData); console.log('✅ [AI回复] 数据已保存到数据库'); } else { await xDb.xTweetsData.put({ id: 'tweets', forYouTweets: forYouTweets, followingTweets: followingTweets, lastUpdated: new Date().toISOString(), }); console.log('✅ [AI回复] 数据已创建并保存'); } } catch (saveError) { console.error('❌ [AI回复] 保存统一AI回复数据失败:', saveError); } console.log('🤖 [AI回复] 开始重新渲染评论区，推文ID:', currentTweetId); renderComments(currentTweetId); const commentsContainer = document.querySelector('.comments-container'); setTimeout(() => { if (commentsContainer) { commentsContainer.scrollTop = commentsContainer.scrollHeight; console.log('✅ [AI回复] 评论区已滚动到底部'); } }, 100); } const isEnglish = currentLanguage === 'en'; const userAvatar = window.userProfileData?.avatar || 'https: showPhoneNotification({ title: 'X', message: isEnglish ? 'Your comment received a reply!' : '你的评论已经收到回复！', avatar: userAvatar, leftIcon: 'x', }); if ( tweetData && tweetData.user && tweetData.user.handle && userComment && userComment.user && userComment.user.handle ) { const userHandle = userComment.user.handle; const tweetAuthorHandle = tweetData.user.handle; const commentContent = userComment.content; checkUnblockTrigger(userHandle, tweetAuthorHandle, 'comment', commentContent).catch(err => { console.error('拉黑解除检测失败（静默）:', err); }); } } catch (error) { console.error('生成统一AI回复失败:', error); showXToast(`回复生成失败: ${error.message}`, 'error'); } } let currentQuoteData = null; window.handleQuoteRetweetFromAccountTweet = async function (tweetId) { if (!currentViewingAccount || !currentViewingAccount.tweets) { showXToast('无法找到推文数据', 'error'); return; } const tweet = currentViewingAccount.tweets.find(t => t.id === tweetId); if (!tweet) { showXToast('未找到该推文', 'error'); return; } let imageData = null; if (tweet.media && tweet.media.length > 0) { if (tweet.media[0].type === 'description') { imageData = { type: 'description', content: tweet.media[0].description, }; } } else if (tweet.image) { imageData = tweet.image; } handleQuoteRetweet( 'tweet', tweet.id, tweet.user.name, tweet.user.handle, tweet.user.avatar, tweet.user.verified, tweet.content || '', tweet.time, imageData, null, null, ); }; async function handleQuoteRetweetFromData(type, id) { let sourceData = null; if (type === 'tweet') { const allTweets = [...forYouTweets, ...followingTweets]; sourceData = allTweets.find(tweet => tweet.id === id); if (!sourceData) { try { const db = getXDB(); const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweets = await db.xUserTweets.get(userTweetsId); if (userTweets && userTweets.tweets) { sourceData = userTweets.tweets.find(tweet => tweet.id === id); } } catch (error) { console.error('查找用户推文失败:', error); } } if (!sourceData) { const currentTweetData = sessionStorage.getItem('currentTweetData'); if (currentTweetData) { try { const tweetData = JSON.parse(currentTweetData); if (tweetData.id === id) { sourceData = tweetData; } } catch (error) { console.error('解析详情页推文数据失败:', error); } } } } else if (type === 'comment') { sourceData = await findCommentById(id); } if (!sourceData) { showXToast('无法找到要引用的内容', 'error'); return; } let imageData = null; if (sourceData.media && sourceData.media.length > 0) { if (sourceData.media[0].type === 'description') { imageData = { type: 'description', content: sourceData.media[0].description, }; } else if (sourceData.media[0].type === 'image') { imageData = { type: 'description', content: sourceData.media[0].description, }; } } else if (sourceData.image) { imageData = sourceData.image; } handleQuoteRetweet( type, id, sourceData.user.name, sourceData.user.handle, sourceData.user.avatar, sourceData.user.verified, sourceData.content || '', sourceData.time, imageData, sourceData.link || null, sourceData.location || null, ); } async function findCommentById(commentId) { const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`); if (commentElement) { try { const userName = commentElement.querySelector('.tweet-user-name').textContent; const userHandle = commentElement.querySelector('.tweet-user-handle').textContent; const userAvatar = commentElement.querySelector('.tweet-avatar').src; const verified = commentElement.querySelector('.tweet-verified') !== null; const contentElement = commentElement.querySelector('.comment-content'); let content = ''; if (contentElement) { const contentClone = contentElement.cloneNode(true); const replyTo = contentClone.querySelector('.reply-to'); if (replyTo) { replyTo.remove(); } content = contentClone.textContent.trim(); } const timeElement = commentElement.querySelector('.tweet-time'); const time = timeElement ? timeElement.textContent.replace('·', '').trim() : '刚刚'; return { id: commentId, user: { name: userName, handle: userHandle, avatar: userAvatar, verified: verified, }, content: content, time: time, }; } catch (error) { console.error('从DOM提取评论信息失败:', error); } } const allTweets = [...forYouTweets, ...followingTweets]; for (const tweet of allTweets) { if (tweet.comments) { for (const comment of tweet.comments) { if (comment.id === commentId) { return comment; } if (comment.replies) { for (const reply of comment.replies) { if (reply.id === commentId) { return reply; } } } } } } const currentTweetData = sessionStorage.getItem('currentTweetData'); if (currentTweetData) { const tweetData = ValidationUtils.safeParseJSON(currentTweetData); if (tweetData && tweetData.comments) { for (const comment of tweetData.comments) { if (comment.id === commentId) { return comment; } if (comment.replies) { for (const reply of comment.replies) { if (reply.id === commentId) { return reply; } } } } } } try { const db = getXDB(); const userTweets = await db.xUserTweets.get('userTweets'); if (userTweets && userTweets.tweets) { for (const tweet of userTweets.tweets) { if (tweet.comments) { for (const comment of tweet.comments) { if (comment.id === commentId) { return comment; } if (comment.replies) { for (const reply of comment.replies) { if (reply.id === commentId) { return reply; } } } } } } } } catch (error) { ValidationUtils.handleError(error, '查找用户推文评论'); } return null; } function handleQuoteRetweet( type, id, userName, userHandle, userAvatar, verified, content, time, imageData = null, linkData = null, location = null, ) { openComposeTweetModal(); currentQuoteData = { type: type, id: id, user: { name: userName, handle: userHandle, avatar: userAvatar, verified: verified, }, content: content, time: time, image: imageData, link: linkData, location: location, }; showQuotePreview(); const textInput = document.getElementById('compose-text-input'); if (textInput) { textInput.placeholder = type === 'tweet' ? '添加你的评论来引用这条推文' : '添加你的评论来引用这条评论'; textInput.focus(); } } function showQuotePreview() { if (!currentQuoteData) return; const preview = document.getElementById('quote-content-preview'); const typeText = document.getElementById('quote-type-text'); const userAvatar = document.getElementById('quote-user-avatar'); const userName = document.getElementById('quote-user-name'); const userVerified = document.getElementById('quote-user-verified'); const userHandle = document.getElementById('quote-user-handle'); const userTime = document.getElementById('quote-user-time'); const contentText = document.getElementById('quote-content-text'); if (!preview) return; preview.style.display = 'block'; if (typeText) { typeText.textContent = currentQuoteData.type === 'tweet' ? '引用推文' : '引用评论'; } if (userAvatar) userAvatar.src = currentQuoteData.user.avatar; if (userName) userName.textContent = currentQuoteData.user.name; if (userHandle) userHandle.textContent = currentQuoteData.user.handle; if (userTime) userTime.textContent = '·' + currentQuoteData.time; if (userVerified) { userVerified.style.display = currentQuoteData.user.verified ? 'inline' : 'none'; } if (contentText) { const processedContent = currentQuoteData.content .replace(/&quot;/g, '"') .replace(/&#x27;/g, "'") .replace(/&amp;/g, '&'); contentText.textContent = processedContent; } const imageContainer = document.getElementById('quote-image-container'); if (imageContainer) { if (currentQuoteData.image) { imageContainer.style.display = 'block'; if (currentQuoteData.image.type === 'description') { imageContainer.innerHTML = ` <div style="margin-top: 8px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 8px; box-sizing: border-box;"> <div style="color:var(--x-text-primary); font-size: 13px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${currentQuoteData.image.content}</div> </div> `; } else if (currentQuoteData.image.type === 'upload') { imageContainer.innerHTML = ` <div style="margin-top: 8px; border-radius: 8px; overflow: hidden;"> <img src="${currentQuoteData.image.content}" style="width: 100%; max-height: 120px; object-fit: cover; display: block;" alt="引用图片"> </div> `; } else if ( currentQuoteData.image.type === 'uploads' && currentQuoteData.image.images && currentQuoteData.image.images.length > 0 ) { const imageCount = currentQuoteData.image.images.length; let gridTemplate = imageCount <= 2 ? 'grid-template-columns: repeat(2, 1fr);' : 'grid-template-columns: repeat(2, 1fr);'; const imagesHtml = currentQuoteData.image.images .map((img, index) => { return ` <div style="border-radius: 6px; overflow: hidden;"> <img src="${img.content}" style="width: 100%; height: 80px; object-fit: cover; display: block;" alt="引用图片${ index + 1 }"> </div> `; }) .join(''); imageContainer.innerHTML = ` <div style="margin-top: 8px; display: grid; ${gridTemplate} gap: 4px;"> ${imagesHtml} </div> `; } } else { imageContainer.style.display = 'none'; imageContainer.innerHTML = ''; } } } function removeQuoteContent() { currentQuoteData = null; const preview = document.getElementById('quote-content-preview'); if (preview) { preview.style.display = 'none'; } const imageContainer = document.getElementById('quote-image-container'); if (imageContainer) { imageContainer.style.display = 'none'; imageContainer.innerHTML = ''; } const textInput = document.getElementById('compose-text-input'); if (textInput) { textInput.placeholder = '有什么新鲜事？'; } } let isCommentStickerMode = false; let selectedCommentSticker = null; window.isCommentStickerMode = isCommentStickerMode; window.getCommentStickerMode = () => isCommentStickerMode; window.setCommentStickerMode = value => { isCommentStickerMode = value; window.isCommentStickerMode = value; }; window.getSelectedCommentSticker = () => selectedCommentSticker; window.setSelectedCommentSticker = value => { selectedCommentSticker = value; }; window.resetSelectedCommentSticker = () => { selectedCommentSticker = null; }; window.selectCommentSticker = function (sticker) { if (!window.getCommentStickerMode()) return; selectedCommentSticker = sticker; if (window.userStickers && Array.isArray(window.userStickers)) { const stickerIndex = window.userStickers.findIndex( s => s.url === sticker.url && s.description === sticker.description, ); if (stickerIndex !== -1) { window.userStickers[stickerIndex].useCount = (window.userStickers[stickerIndex].useCount || 0) + 1; window.userStickers[stickerIndex].lastUsedAt = new Date().toISOString(); if (window.saveUserStickers) { window.saveUserStickers(); } } } showCommentStickerPreview(sticker); if (window.closeStickerPicker) { window.closeStickerPicker(); } window.setCommentStickerMode(false); }; function showCommentStickerPreview(sticker) { const inputArea = document.querySelector('.detail-comment-input-area'); if (!inputArea) return; removeCommentStickerPreview(); const previewContainer = document.createElement('div'); previewContainer.id = 'comment-sticker-preview'; previewContainer.style.cssText = ` margin-top: 10px; padding: 12px; background-color: var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; display: flex; align-items: center; gap: 12px; position: relative; `; const stickerImg = document.createElement('img'); stickerImg.src = sticker.url; stickerImg.alt = sticker.description; stickerImg.style.cssText = ` width: 60px; height: 60px; object-fit: contain; border-radius: 8px; `; const stickerInfo = document.createElement('div'); stickerInfo.style.cssText = ` flex: 1; color: var(--x-text-primary); `; stickerInfo.innerHTML = ` <div style="font-size: 13px; font-weight: 600; margin-bottom: 2px;">选中的表情包</div> <div style="font-size: 12px; color: var(--x-text-secondary);">${sticker.description || '表情包'}</div> `; const removeBtn = document.createElement('button'); removeBtn.innerHTML = ` <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> `; removeBtn.style.cssText = ` background: none; border: none; color: var(--x-text-secondary); cursor: pointer; padding: 4px; border-radius: 50%; transition: all 0.2s; display: flex; align-items: center; justify-content: center; `; removeBtn.onmouseover = () => { removeBtn.style.backgroundColor = 'var(--x-bg-hover)'; removeBtn.style.color = 'var(--x-text-primary)'; }; removeBtn.onmouseout = () => { removeBtn.style.backgroundColor = 'transparent'; removeBtn.style.color = 'var(--x-text-secondary)'; }; removeBtn.onclick = () => { const preview = document.getElementById('comment-sticker-preview'); if (preview) { preview.remove(); } if (window.setSelectedCommentSticker) { window.setSelectedCommentSticker(null); } else { selectedCommentSticker = null; } updateDetailReplyButtonState(); }; previewContainer.appendChild(stickerImg); previewContainer.appendChild(stickerInfo); previewContainer.appendChild(removeBtn); inputArea.appendChild(previewContainer); updateDetailReplyButtonState(); } function removeCommentStickerPreview() { const preview = document.getElementById('comment-sticker-preview'); if (preview) { preview.remove(); } updateDetailReplyButtonState(); } window.getCommentContent = function () { const textInput = document.getElementById('detail-comment-input'); const textContent = textInput ? textInput.value.trim() : ''; return { text: textContent, sticker: window.getSelectedCommentSticker ? window.getSelectedCommentSticker() : selectedCommentSticker, }; }; window.clearCommentInput = function () { console.log('📝 [清理调试] 开始清理评论输入'); const textInput = document.getElementById('detail-comment-input'); if (textInput) { textInput.value = ''; textInput.style.height = '20px'; } const preview = document.getElementById('comment-sticker-preview'); if (preview) { preview.remove(); console.log('📝 [清理调试] 表情包预览已移除'); } if (window.setSelectedCommentSticker) { window.setSelectedCommentSticker(null); console.log('📝 [清理调试] 表情包选择已重置（通过全局函数）'); } else { selectedCommentSticker = null; console.log('📝 [清理调试] 表情包选择已重置（直接赋值）'); } const imagePreview = document.getElementById('detail-comment-image-preview'); if (imagePreview) { imagePreview.style.display = 'none'; } updateDetailReplyButtonState(); console.log('📝 [清理调试] 评论输入清理完成'); }; window.openCommentStickers = openCommentStickers; window.openHelpPage = function () { const isEnglish = currentLanguage === 'en'; if (confirm(isEnglish ? 'Are you ready to navigate to the Help & FAQ page?' : '是否准备移动到答疑页面？')) { window.open('https: console.log('✅ 已打开答疑页面'); } else { console.log('❌ 用户取消跳转答疑页面'); } }; async function initXSocialApp() { try { console.log('🚀 初始化 X Social App...'); if (chatHistoryDetectionTimer) { clearInterval(chatHistoryDetectionTimer); chatHistoryDetectionTimer = null; } if (autoRefreshFeedTimer) { clearInterval(autoRefreshFeedTimer); autoRefreshFeedTimer = null; } chatHistoryDetectionEnabled = false; autoRefreshFeedEnabled = false; injectStyles(); createXSocialHTML(); await loadActiveAccount(); console.log('📌 当前活跃账户:', currentAccountId, '(window.currentAccountId:', window.currentAccountId + ')'); await initializeTweets(); await loadUserProfile(); await initializeXSettings(); bindEventHandlers(); loadUserProfileToUI(); await loadXThemePreference(); await loadAccentColorPreference(); setTimeout(() => { if (typeof startAutoMessageSystem === 'function') { startAutoMessageSystem(); } }, 120000); setTimeout(() => { if (typeof startFollowersFluctuationSystem === 'function') { startFollowersFluctuationSystem(); } }, 120000); await showWelcomePopup(); console.log('✅ X Social App 初始化完成'); console.log('💡 [提示] 智能刷新和智能检测需要手动开启'); } catch (error) { console.error('❌ X Social App 初始化失败:', error); showXToast('应用初始化失败: ' + error.message, 'error'); } } async function showWelcomePopup() { try { const currentPopupVersion = 'v2.0'; const currentPopupContent = `x修复bug x设置页面新增答疑按钮 点击跳转答疑页面 !!新增的直播功能请勿点击 还未完善 出错本羊概不负责`; const lastShownVersion = localStorage.getItem('x-app-welcome-popup-version'); if (lastShownVersion === currentPopupVersion) { console.log('🎉 当前版本弹窗已显示过，跳过'); return; } console.log('🎉 显示欢迎弹窗 (版本:', currentPopupVersion + ')'); const fontStyle = document.createElement('style'); fontStyle.id = 'pixel-font-style'; fontStyle.textContent = ` @import url("https: .pixel-font { font-family: "Fusion Pixel 10px P zh_hans", monospace; font-weight: normal; } `; document.head.appendChild(fontStyle); const popup = document.createElement('div'); popup.id = 'welcome-popup'; popup.style.cssText = ` position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 99999; font-family: "Fusion Pixel 10px P zh_hans", monospace; `; popup.innerHTML = ` <div style=" background: #c0c0c0; border: 3px outset #c0c0c0; border-image: none; width: 400px; max-width: 90%; box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5); font-family: 'Fusion Pixel 10px P zh_hans', monospace; "> <!-- 标题栏 --> <div style=" background: linear-gradient(90deg, #0000ff 0%, #000080 100%); color: white; padding: 2px 4px; font-size: 11px; display: flex; align-items: center; justify-content: space-between; font-family: 'Fusion Pixel 10px P zh_hans', monospace; "> <span style="font-weight: bold;">吃点羊提醒您</span> <button id="welcome-popup-close" style=" background: #c0c0c0; border: 1px outset #c0c0c0; color: black; font-size: 10px; width: 16px; height: 14px; padding: 0; cursor: pointer; font-family: 'Fusion Pixel 10px P zh_hans', monospace; font-weight: bold; ">×</button> </div> <!-- 内容区域 --> <div style=" padding: 16px; background: #c0c0c0; font-family: 'Fusion Pixel 10px P zh_hans', monospace; "> <div style=" display: flex; align-items: flex-start; gap: 12px; margin-bottom: 12px; "> <!-- 图标 --> <div style=" width: 32px; height: 32px; background: #ffff00; border: 2px inset #c0c0c0; display: flex; align-items: center; justify-content: center; font-size: 16px; flex-shrink: 0; ">💡</div> <!-- 消息内容 --> <div style=" flex: 1; font-size: 11px; line-height: 1.4; color: #000; font-family: 'Fusion Pixel 10px P zh_hans', monospace; "> <div style="font-weight: bold; margin-bottom: 6px;">吃点羊提醒您：</div> <div style="margin-bottom: 4px;">x修复bug</div> <div style="margin-bottom: 4px; font-weight: bold;">x设置页面新增答疑按钮 点击跳转答疑页面</div> <div>!!新增的直播功能请勿点击 还未完善 出错本羊概不负责</div> </div> </div> <!-- 按钮区域 --> <div style=" display: flex; justify-content: center; gap: 8px; margin-top: 16px; "> <button id="welcome-popup-ok" style=" background: #c0c0c0; border: 2px outset #c0c0c0; color: black; font-size: 11px; padding: 4px 16px; cursor: pointer; font-family: 'Fusion Pixel 10px P zh_hans', monospace; min-width: 60px; ">确定</button> </div> </div> </div> `; const xSocialScreen = document.getElementById('x-social-screen'); if (xSocialScreen) { xSocialScreen.appendChild(popup); } else { document.body.appendChild(popup); } const closeBtn = document.getElementById('welcome-popup-close'); const okBtn = document.getElementById('welcome-popup-ok'); const closePopup = () => { popup.remove(); localStorage.setItem('x-app-welcome-popup-version', currentPopupVersion); console.log('✅ 欢迎弹窗已关闭，当前版本:', currentPopupVersion); }; closeBtn.onclick = closePopup; okBtn.onclick = closePopup; popup.onclick = e => { if (e.target === popup) { closePopup(); } }; [closeBtn, okBtn].forEach(btn => { btn.onmouseenter = () => { btn.style.border = '2px inset #c0c0c0'; }; btn.onmouseleave = () => { btn.style.border = btn === closeBtn ? '1px outset #c0c0c0' : '2px outset #c0c0c0'; }; btn.onmousedown = () => { btn.style.border = '2px inset #c0c0c0'; }; btn.onmouseup = () => { btn.style.border = btn === closeBtn ? '1px outset #c0c0c0' : '2px outset #c0c0c0'; }; }); } catch (error) { console.error('❌ 显示欢迎弹窗失败:', error); } } function renderXSocialScreen() { console.log('🎬 渲染X社交页面'); const xScreen = document.getElementById('x-social-screen'); if (!xScreen) { console.log('⚠️ X社交页面未创建，开始初始化...'); initXSocialApp().then(() => { console.log('✅ 初始化完成，显示主页'); const screen = document.getElementById('x-social-screen'); if (screen) { screen.style.display = 'flex'; switchXPage('home'); } }); } else { console.log('✅ X社交页面已存在，直接显示'); xScreen.style.display = 'flex'; switchXPage('home'); } } function getDefaultUserProfile(accountId = 'main') { return { id: accountId, name: accountId === 'main' ? '我' : '新用户', handle: accountId === 'main' ? '@me' : '@newuser_' + Date.now().toString().slice(-6), avatar: 'https: coverImage: 'https: verified: false, verificationType: 'none', bio: '欢迎来到我的X主页！', publicIdentity: '', showRealName: false, realName: '', customTag1: '科技爱好者', customTag1Icon: '✨', customTag1Color: '#71767b', customTag2: '2024年加入', customTag2Icon: '📅', customTag2Color: '#71767b', followingCount: accountId === 'main' ? '156' : '0', followersCount: accountId === 'main' ? '89' : '0', knownIdentityCharacters: [], coupleCharacterId: '', coupleCharacterName: '', lastUpdated: new Date().toISOString(), }; } async function loadUserProfile() { try { const db = getXDB(); const accountId = currentAccountId || 'main'; const profile = await db.xUserProfile.get(accountId); if (profile) { Object.assign(window.userProfileData, profile); } else { const defaultProfile = getDefaultUserProfile(accountId); Object.assign(window.userProfileData, defaultProfile); await db.xUserProfile.put(window.userProfileData); console.log('📝 已创建默认用户资料:', accountId); } ensureProfileFields(window.userProfileData); console.log('✅ 用户资料已加载:', window.userProfileData.name, '(账户:', accountId + ')'); console.log('🔍 用户资料详情:', { 认证类型: window.userProfileData.verificationType, 情侣角色: window.userProfileData.coupleCharacterName, 已知身份角色数: window.userProfileData.knownIdentityCharacters?.length || 0, }); } catch (error) { console.error('❌ 加载用户资料失败:', error); const defaultProfile = getDefaultUserProfile('main'); Object.assign(window.userProfileData, defaultProfile); } } function ensureProfileFields(profile) { if (!profile.knownIdentityCharacters) profile.knownIdentityCharacters = []; if (!profile.verificationType) profile.verificationType = 'none'; if (!profile.coupleCharacterId) profile.coupleCharacterId = ''; if (!profile.coupleCharacterName) profile.coupleCharacterName = ''; if (profile.publicIdentity === undefined) profile.publicIdentity = ''; if (profile.showRealName === undefined) profile.showRealName = false; if (profile.realName === undefined) profile.realName = ''; if (!profile.customTag1Color) profile.customTag1Color = '#71767b'; if (!profile.customTag2Color) profile.customTag2Color = '#71767b'; } function bindEventHandlers() { const characterXProfileForm = document.getElementById('character-x-profile-form'); if (characterXProfileForm) { characterXProfileForm.addEventListener('submit', saveCharacterXProfile); console.log('✅ 已绑定角色X资料表单提交事件'); } const characterXBio = document.getElementById('character-x-bio'); if (characterXBio) { characterXBio.addEventListener('input', updateCharacterBioCount); } const relationshipForm = document.getElementById('relationship-form'); if (relationshipForm) { relationshipForm.addEventListener('submit', saveRelationshipForm); console.log('✅ 已绑定关系表单提交事件'); } const relationshipDesc = document.getElementById('relationship-description'); if (relationshipDesc) { relationshipDesc.addEventListener('input', updateRelationshipDescCount); } const characterRealName = document.getElementById('character-real-name'); if (characterRealName) { characterRealName.addEventListener('input', updateCharacterXProfileCounts); } console.log('✅ 所有事件处理器已绑定'); } let askboxData = { avatar: 'https: nickname: '= =', prompt: '请向我匿名提问!waiting...', background: 'https: answeredQuestions: [], }; let isAskboxMultiSelectMode = false; let selectedQuestions = new Set(); let questionLongPressTimer = null; async function loadAskboxDataFromDB() { try { const xDb = getXDB(); const accountId = currentAccountId || 'main'; const askboxId = `askbox_${accountId}`; const savedData = await xDb.xAskbox.get(askboxId); if (savedData) { askboxData.id = savedData.id; askboxData.avatar = savedData.avatar; askboxData.nickname = savedData.nickname; askboxData.prompt = savedData.prompt; askboxData.background = savedData.background; askboxData.answeredQuestions = savedData.answeredQuestions || []; console.log('✅ 提问箱数据已从数据库加载:', accountId, '提问数:', askboxData.answeredQuestions.length); } else { askboxData.id = askboxId; askboxData.avatar = 'https: askboxData.nickname = '= ='; askboxData.prompt = '请向我匿名提问!waiting...'; askboxData.background = 'https: askboxData.answeredQuestions = []; await xDb.xAskbox.put({ id: askboxId, avatar: askboxData.avatar, nickname: askboxData.nickname, prompt: askboxData.prompt, background: askboxData.background, answeredQuestions: [], }); console.log('✅ 已为新账户创建默认提问箱数据:', accountId, '提问数: 0'); } } catch (error) { console.error('❌ 加载提问箱数据失败:', error); } } async function saveAskboxDataToDB() { try { const xDb = getXDB(); const accountId = currentAccountId || 'main'; const askboxId = `askbox_${accountId}`; askboxData.id = askboxId; await xDb.xAskbox.put(askboxData); console.log('✅ 提问箱数据已保存到数据库:', accountId); } catch (error) { console.error('❌ 保存提问箱数据失败:', error); } } async function loadAskboxData() { await loadAskboxDataFromDB(); const avatarEl = document.getElementById('askbox-avatar'); const nicknameEl = document.getElementById('askbox-nickname'); const promptEl = document.getElementById('askbox-prompt'); const backgroundEl = document.getElementById('askbox-background'); if (avatarEl) avatarEl.src = askboxData.avatar; if (nicknameEl) nicknameEl.textContent = askboxData.nickname; if (promptEl) promptEl.textContent = askboxData.prompt; if (backgroundEl) backgroundEl.style.backgroundImage = `url('${askboxData.background}')`; renderAnsweredQuestions(); } async function changeAskboxAvatar() { const newAvatar = prompt('请输入新的头像URL:', askboxData.avatar); if (newAvatar && newAvatar.trim()) { askboxData.avatar = newAvatar.trim(); const avatarEl = document.getElementById('askbox-avatar'); if (avatarEl) avatarEl.src = askboxData.avatar; await saveAskboxDataToDB(); showXToast('头像已更新并保存', 'success'); } } async function saveAskboxNickname() { const nicknameEl = document.getElementById('askbox-nickname'); if (!nicknameEl) return; const newNickname = nicknameEl.textContent.trim(); if (newNickname && newNickname !== askboxData.nickname) { askboxData.nickname = newNickname; await saveAskboxDataToDB(); console.log('✅ 昵称已自动保存:', newNickname); } } async function saveAskboxPrompt() { const promptEl = document.getElementById('askbox-prompt'); if (!promptEl) return; const newPrompt = promptEl.textContent.trim(); if (newPrompt && newPrompt !== askboxData.prompt) { askboxData.prompt = newPrompt; await saveAskboxDataToDB(); console.log('✅ 提示文字已自动保存:', newPrompt); } } function openAskboxSettings() { const newBackground = prompt('请输入新的背景图URL:', askboxData.background); if (newBackground && newBackground.trim()) { askboxData.background = newBackground.trim(); const backgroundEl = document.getElementById('askbox-background'); if (backgroundEl) backgroundEl.style.backgroundImage = `url('${askboxData.background}')`; saveAskboxDataToDB(); showXToast('背景图已更新并保存', 'success'); } } async function getNewQuestion() { try { showXToast('正在生成新的提问...', 'info'); const { apiConfig, xSettings, xDb } = await APIUtils.loadConfigAndSettings(); const { userPrompt, worldSetting, boundCharacters } = xSettings; const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); const userTweets = userTweetsData?.tweets || []; const recentUserTweets = userTweets.slice(0, 5); let coupleCharacterInfo = ''; if (userXProfileInfo.verificationType === 'couple' && userXProfileInfo.coupleCharacterId) { const coupleCharacterProfile = await xDb.xCharacterProfiles .where('characterId') .equals(userXProfileInfo.coupleCharacterId) .first(); if (coupleCharacterProfile) { coupleCharacterInfo = ` 【情侣角色信息】： - X姓名：${coupleCharacterProfile.xName} - X句柄：${coupleCharacterProfile.xHandle} - X简介：${coupleCharacterProfile.xBio || '无'} - 公众身份：${coupleCharacterProfile.publicIdentity || '无'} - 真实姓名：${ coupleCharacterProfile.showRealName && coupleCharacterProfile.realName ? coupleCharacterProfile.realName : '未公开' } `; } } let boundCharactersInfo = ''; if (boundCharacters.length > 0) { const mainDB = getDB(); const allChats = await mainDB.chats.toArray(); const boundCharsData = allChats.filter(chat => !chat.isGroup && boundCharacters.includes(chat.id)); const allXProfiles = await xDb.xCharacterProfiles.toArray(); const xProfileMap = new Map(); allXProfiles.forEach(profile => { xProfileMap.set(profile.characterId, profile); }); if (boundCharsData.length > 0) { boundCharactersInfo = '\n【绑定角色信息（可匿名提问）】：\n以下角色可以作为匿名提问者：\n'; for (const char of boundCharsData) { const xProfile = xProfileMap.get(char.id); if (xProfile) { boundCharactersInfo += `\n- ${xProfile.xName}（${xProfile.xHandle}）: ${ char.settings.aiPersona?.substring(0, 100) || '' }`; } } } } const answeredQuestionsContext = askboxData.answeredQuestions .filter(q => q.answer && q.answer.trim()) .slice(0, 5) .map(q => `Q: ${q.question}\nA: ${q.answer}`) .join('\n\n'); let tokenCount = 0; let systemPrompt = StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting, }); tokenCount = TokenUtils.logTokenUsage('提问箱生成器', '基础系统提示词', systemPrompt, tokenCount); systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务说明 - 匿名提问箱 🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是一个匿名提问箱系统。请为用户生成一个有趣的、适合他们身份的匿名提问。 【用户身份信息】： - 用户名：${userXProfileInfo.name} - X句柄：${userXProfileInfo.handle} - 简介：${userXProfileInfo.bio || '无'} - 公众身份：${userXProfileInfo.publicIdentity || '无'} - 认证类型：${StringBuilders.getUserVerificationTypeDescription(userXProfileInfo)} ${ userXProfileInfo.verificationType === 'couple' && userXProfileInfo.coupleCharacterName ? `- 情侣关系：与${userXProfileInfo.coupleCharacterName}是公开情侣` : '' } ${coupleCharacterInfo} 【用户最近发布的推文】： ${ recentUserTweets.length > 0 ? recentUserTweets .map((tweet, i) => { let tweetText = `${i + 1}. ${tweet.content}${tweet.time ? ` (${tweet.time})` : ''}`; if (tweet.image) { if (tweet.image.type === 'description') { tweetText += `\n [图片描述: ${tweet.image.content}]`; } else if (tweet.image.type === 'upload') { tweetText += `\n [包含上传的图片]`; } } return tweetText; }) .join('\n') : '暂无推文' } ${boundCharactersInfo} ${ answeredQuestionsContext ? `【之前的提问与回复历史】：\n${answeredQuestionsContext}\n\n【继续性要求】：新提问可以延续之前的话题，也可以开启新话题，保持自然。` : '' } 【提问生成要求】： 1. 提问要自然、真实，像是真实的匿名用户提出的 2. 提问内容要与用户的身份、简介、公众身份、最近发布的推文相关 3. 如果有绑定角色，可以让角色以匿名身份提问，提问内容要符合角色的人设和性格 4. 如果有之前的提问历史，可以延续话题，也可以提出新话题 5. 提问可以是： - 关于最近推文内容的追问或评论 - 关于生活经验、情感态度的询问 - 关于兴趣爱好、专业技能的请教 - 关于日常趣事、特殊经历的好奇 - 轻松幽默或深度思考的话题 6. 提问长度适中（10-50字），不要太长或太短 7. 语气可以是：好奇的、调侃的、真诚的、幽默的 8. 避免过于私密、冒犯或不适当的问题 【返回格式】： 每行一个提问，用换行符分隔，不需要序号、引号或其他格式 每个提问独立成行，直接输出提问内容 示例格式： 看到你最近发的推文，感觉心情不错呀？ 最近有遇到什么让你特别开心的事吗？ 如果可以拥有一个超能力，你会选什么？ 你觉得最重要的人生品质是什么？ 现在，请为用户生成3-10个匿名提问（每行一个）：`; const userInfoSection = systemPrompt.substring(systemPrompt.indexOf('【用户身份信息】')); tokenCount = TokenUtils.logTokenUsage('提问箱生成器', '用户信息与要求', userInfoSection, tokenCount); const messages = [{ role: 'user', content: '请生成3-10个匿名提问，每行一个' }]; TokenUtils.logFinalPrompt('提问箱生成器', systemPrompt, messages[0].content); const aiResponseContent = await APIUtils.sendAIRequest({ apiConfig, systemPrompt, messages, temperature: 0.9, }); const questions = aiResponseContent .split('\n') .map(line => line.trim()) .filter(line => line.length > 0) .map(line => { return line .replace(/^\d+[\.\)、]\s*/, '') .replace(/^[-•]\s*/, '') .replace(/^["「『]|["」』]$/g, '') .trim(); }) .filter(q => q.length > 0); if (questions.length === 0) { throw new Error('AI返回了空的提问内容'); } console.log(`✅ 解析到 ${questions.length} 个提问:`, questions); const newQuestions = questions.map((question, index) => ({ id: `q_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`, question: question, answer: '', date: new Date().toISOString(), })); askboxData.answeredQuestions.unshift(...newQuestions); await saveAskboxDataToDB(); renderAnsweredQuestions(); showXToast(`你有 ${newQuestions.length} 个新的提问请查收`, 'success'); } catch (error) { console.error('生成提问失败:', error); showXToast(`生成失败: ${error.message}`, 'error'); } } function renderAnsweredQuestions() { const container = document.getElementById('answered-questions-list'); const titleEl = document.getElementById('answered-questions-title'); if (!container) return; if (askboxData.answeredQuestions.length === 0) { if (titleEl) titleEl.style.display = 'none'; container.innerHTML = ` <div style="text-align: center; color: rgba(255,255,255,0.6); font-size: 14px; padding: 40px 20px; "> 暂无提问 </div> `; return; } if (titleEl) titleEl.style.display = 'block'; container.innerHTML = askboxData.answeredQuestions .map((q, index) => { const date = new Date(q.date); const dateStr = date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' }); const isSelected = selectedQuestions.has(q.id); return ` <div class="askbox-question-item" data-question-id="${q.id}" style="background-color: rgba(255,255,255,0.9); backdrop-filter: blur(10px); border-radius: 16px; overflow: hidden; margin-bottom: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); transition: all 0.2s; ${ isSelected ? 'border: 3px solid var(--x-accent); background-color: color-mix(in srgb, var(--x-accent) , 0.1);' : '' } ${isAskboxMultiSelectMode ? 'border-left: 3px solid var(--x-accent);' : ''} " onmouseover="if(!${isAskboxMultiSelectMode}){this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0,0,0,0.2)';}" onmouseout="if(!${isAskboxMultiSelectMode}){this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';}" onmousedown="startQuestionLongPress('${q.id}')" onmouseup="endQuestionLongPress()" onmouseleave="endQuestionLongPress()" ontouchstart="startQuestionLongPress('${q.id}')" ontouchend="endQuestionLongPress()" onclick="if(${isAskboxMultiSelectMode}){toggleQuestionSelection('${q.id}');event.stopPropagation();}" > <div style="background: linear-gradient(135deg, #3a3a3a 0%, #2a2a2a 100%); padding: 20px; color: #fff; "> <div style="font-size: 15px; line-height: 1.6; word-break: break-word;"> ${q.question} </div> </div> <div style="background-color:#fff; padding: 20px; min-height: 60px; color: #333; "> <div id="answer-${q.id}" contenteditable="true" data-question-id="${q.id}" style="font-size: 14px; line-height: 1.6; word-break: break-word; outline: none; cursor: text; min-height: 20px; ${ q.answer ? '' : 'color: #999; text-align: center;' } " onblur="saveQuestionAnswer('${q.id}')" onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();this.blur();}" onfocus="if(this.textContent==='点击此处回复...'){this.textContent='';this.style.color='#333';this.style.textAlign='left';}">${ q.answer || '点击此处回复...' }</div> </div> <div style="background-color: #f5f5f5; padding: 8px 20px; color: #999; font-size: 12px; text-align: right; "> ${dateStr} </div> </div> `; }) .join(''); } async function saveQuestionAnswer(questionId) { const answerEl = document.getElementById(`answer-${questionId}`); if (!answerEl) return; const question = askboxData.answeredQuestions.find(q => q.id === questionId); if (!question) return; let newAnswer = answerEl.textContent.trim(); if (newAnswer === '点击此处回复...') { newAnswer = ''; } if (newAnswer !== question.answer) { question.answer = newAnswer; await saveAskboxDataToDB(); console.log('✅ 回复已自动保存:', questionId); } } function startQuestionLongPress(questionId) { if (isAskboxMultiSelectMode) return; questionLongPressTimer = setTimeout(() => { enterAskboxMultiSelectMode(); toggleQuestionSelection(questionId); }, 500); } function endQuestionLongPress() { if (questionLongPressTimer) { clearTimeout(questionLongPressTimer); questionLongPressTimer = null; } } function toggleQuestionSelection(questionId) { if (!isAskboxMultiSelectMode) { enterAskboxMultiSelectMode(); } const questionEl = document.querySelector(`.askbox-question-item[data-question-id="${questionId}"]`); if (!questionEl) return; if (selectedQuestions.has(questionId)) { selectedQuestions.delete(questionId); questionEl.style.border = ''; questionEl.style.backgroundColor = 'rgba(255,255,255,0.9)'; } else { selectedQuestions.add(questionId); questionEl.style.border = '3px solid var(--x-accent)'; questionEl.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) , 0.1)'; } updateAskboxDeleteUI(); } function enterAskboxMultiSelectMode() { isAskboxMultiSelectMode = true; showAskboxDeleteToolbar(); document.querySelectorAll('.askbox-question-item').forEach(item => { item.style.borderLeft = '3px solid var(--x-accent)'; }); console.log('✅ 已进入提问箱多选模式'); } function exitAskboxMultiSelectMode() { isAskboxMultiSelectMode = false; selectedQuestions.clear(); hideAskboxDeleteToolbar(); document.querySelectorAll('.askbox-question-item').forEach(item => { item.style.border = ''; item.style.borderLeft = ''; item.style.backgroundColor = 'rgba(255,255,255,0.9)'; }); console.log('✅ 已退出提问箱多选模式'); } function showAskboxDeleteToolbar() { let toolbar = document.getElementById('askbox-delete-toolbar'); if (!toolbar) { toolbar = document.createElement('div'); toolbar.id = 'askbox-delete-toolbar'; toolbar.style.cssText = ` position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); border-radius: 24px; padding: 12px 20px; display: flex; align-items: center; gap: 16px; z-index: 2000; box-shadow: 0 4px 20px rgba(0,0,0,0.5); `; toolbar.innerHTML = ` <button onclick="selectAllQuestions()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'"> 全选 </button> <span id="askbox-selected-count" style="color: #fff; font-size: 14px; font-weight: 500;">已选择 0 个</span> <button onclick="deleteSelectedQuestions()" style="background-color: #f91880; color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#d0155f'" onmouseout="this.style.backgroundColor='#f91880'"> 删除 </button> <button onclick="exitAskboxMultiSelectMode()" style="background-color: rgba(255,255,255,0.15); color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.25)'" onmouseout="this.style.backgroundColor='rgba(255,255,255,0.15)'"> 取消 </button> `; document.body.appendChild(toolbar); } toolbar.style.display = 'flex'; } function hideAskboxDeleteToolbar() { const toolbar = document.getElementById('askbox-delete-toolbar'); if (toolbar) { toolbar.style.display = 'none'; } } function updateAskboxDeleteUI() { const countEl = document.getElementById('askbox-selected-count'); if (countEl) { countEl.textContent = `已选择 ${selectedQuestions.size} 个`; } } function selectAllQuestions() { document.querySelectorAll('.askbox-question-item').forEach(item => { const questionId = item.dataset.questionId; if (!selectedQuestions.has(questionId)) { selectedQuestions.add(questionId); item.style.border = '3px solid #1d9bf0'; item.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) , 0.1)'; } }); updateAskboxDeleteUI(); } async function deleteSelectedQuestions() { if (selectedQuestions.size === 0) { showXToast('请先选择要删除的提问', 'warning'); return; } const confirmDelete = confirm(`确定要删除选中的 ${selectedQuestions.size} 个提问吗？删除后无法恢复。`); if (!confirmDelete) return; try { askboxData.answeredQuestions = askboxData.answeredQuestions.filter(q => !selectedQuestions.has(q.id)); await saveAskboxDataToDB(); showXToast(`已删除 ${selectedQuestions.size} 个提问`, 'success'); exitAskboxMultiSelectMode(); renderAnsweredQuestions(); } catch (error) { console.error('删除提问失败:', error); showXToast('删除失败: ' + error.message, 'error'); } } async function generateMentionsForLatestTweet(tweetData) { try { console.log('🔔 [Mentions生成器] 开始为最新推文生成通知'); const { apiConfig, xSettings, xDb } = await APIUtils.loadConfigAndSettings(); const { userPrompt, worldSetting, boundCharacters } = xSettings; const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); const userPublicIdentity = userXProfileInfo.publicIdentity || ''; const userBio = userXProfileInfo.bio || ''; const isUserPublicFigure = /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test( userPublicIdentity + ' ' + userBio, ); console.log('🔍 [Mentions生成器] 用户公众身份检测:', { isPublicFigure: isUserPublicFigure, publicIdentity: userPublicIdentity, bio: userBio, }); let tokenCount = 0; let systemPrompt = StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting, }); tokenCount = TokenUtils.logTokenUsage('Mentions生成器', '基础系统提示词', systemPrompt, tokenCount); const worldBooksContent = await StringBuilders.getApplicableWorldBooks('mentions', { boundCharacters: boundCharacters, }); if (worldBooksContent) { systemPrompt += worldBooksContent; tokenCount = TokenUtils.logTokenUsage('Mentions生成器', '世界书内容', worldBooksContent, tokenCount); } systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🔔 核心任务：生成 Mentions 通知 🔔 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的通知生成器。用户 ${userXProfileInfo.name} (${userXProfileInfo.handle}) 刚发布了一条新推文，你的任务是： ✅ 生成点赞通知（1-2条）：多个用户喜欢了这条推文 ✅ 生成转帖通知（1-3条）：其他用户引用转发了这条推文 **用户身份检测**： - 用户身份：${isUserPublicFigure ? '公众人物（高曝光）' : '普通用户（低曝光）'} ${userPublicIdentity ? `- 公众身份：${userPublicIdentity}` : ''} **流量规模要求**： ${ isUserPublicFigure ? `- 用户是公众人物，获得高流量： * 点赞通知：每条通知显示3个用户，othersCount 设为 50-500 之间 * 转帖stats：comments 100-500，retweets 500-2000，likes 1000-5000 * 转帖内容应该体现公众人物的影响力（如"分享给粉丝"、"必须转发"等）` : `- 用户是普通用户，获得常规流量： * 点赞通知：每条通知显示3个用户，othersCount 设为 5-50 之间 * 转帖stats：comments 5-20，retweets 10-50，likes 20-100 * 转帖内容应该更日常化、朋友圈式` } **点赞通知要求**： - 每条通知包含3个用户（显示头像和昵称） - othersCount根据用户身份设置（见上方流量规模要求） - 必须包含被点赞的推文内容预览 - 点赞用户应该是虚构的普通X用户 **转帖通知要求**： - 每条转帖都是对用户推文的引用转发 - 转帖者添加了自己的评论/观点 - 转帖内容要与原推文相关，可以是赞同、补充、转发给特定群体等 - 转帖者应该是虚构的普通X用户 - 必须准确引用原推文内容 - 每条转帖必须包含2-5条评论（comments数组） - stats数据根据用户身份设置（见上方流量规模要求） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; systemPrompt += ` 【用户推文信息】： - 推文内容："${tweetData.content}" - 发布时间：${tweetData.time} ${tweetData.image ? `- 包含媒体：${tweetData.image.type === 'description' ? tweetData.image.content : '图片内容'}` : ''} ${tweetData.location ? `- 位置：${tweetData.location}` : ''} ${tweetData.link ? `- 链接：${tweetData.link.title || tweetData.link.url}` : ''} `; const userConstraintsStart = systemPrompt.length; systemPrompt += StringBuilders.buildUniversalConstraints(userXProfileInfo); const userConstraints = systemPrompt.substring(userConstraintsStart); tokenCount = TokenUtils.logTokenUsage('Mentions生成器', '用户资料约束', userConstraints, tokenCount); systemPrompt += ` 【JSON返回格式】： \`\`\`json { "likes": [点赞通知数组，1-2条], "retweets": [转帖通知数组，1-3条] } \`\`\` 点赞通知对象结构： { "id": "mention_like_xxx", "type": "like", "users": [ { "name": "用户昵称", "handle": "@用户句柄", "avatar": "https: "verified": false } ], "othersCount": 其他点赞人数（数字，可以是0）， "time": "时间描述（如'2小时前'）", "tweet": { "content": "被点赞的推文内容（与用户推文一致）", "image": null 或 "图片描述" } } 转帖通知对象结构： { "id": "mention_retweet_xxx", "type": "retweet", "user": { "name": "转帖者昵称", "handle": "@转帖者句柄", "avatar": "https: "verified": false }, "retweetContent": "转帖者添加的评论内容", "time": "时间描述（如'3小时前'）", "quotedTweet": { "user": { "name": "${userXProfileInfo.name}", "handle": "${userXProfileInfo.handle}", "avatar": "${userXProfileInfo.avatar}", "verified": ${userXProfileInfo.verified || false}, "verificationType": "${userXProfileInfo.verificationType || 'none'}" }, "content": "原推文内容（与用户推文一致）", "time": "${tweetData.time}", "image": ${ tweetData.image ? tweetData.image.type === 'description' ? `{"type": "description", "content": "${tweetData.image.content}"}` : 'null' : 'null' }, "stats": { "comments": ${tweetData.stats?.comments || 0}, "retweets": ${tweetData.stats?.retweets || 0}, "likes": ${tweetData.stats?.likes || 0} } }, "stats": { "comments": 转帖的评论数（数字，根据用户身份：公众${isUserPublicFigure ? '100-500' : '5-20'}）， "retweets": 转帖的转发数（数字，根据用户身份：公众${isUserPublicFigure ? '500-2000' : '10-50'}）， "likes": 转帖的点赞数（数字，根据用户身份：公众${isUserPublicFigure ? '1000-5000' : '20-100'}）， "views": 转帖的浏览数（数字，根据用户身份：公众${isUserPublicFigure ? '5000-50000' : '100-1000'}） }, "comments": [ { "id": "评论唯一ID（可留空，系统自动生成）", "user": { "name": "评论者昵称", "handle": "@评论者句柄", "avatar": "https: "verified": false }, "content": "评论文本", "time": "时间描述", "image": {"type": "description", "content": "图片文字描述"} (可选，10-20%的评论带图) } ] } 关键规则： 1. 所有用户头像统一使用：https: 2. verified字段必须是布尔值(true/false) 3. 点赞通知的tweet内容必须与用户原推文完全一致 4. 转帖通知的quotedTweet必须准确引用用户原推文 5. 转帖内容要自然、真实，符合社交媒体转发习惯 6. 时间描述要合理（如'刚刚'、'5分钟前'、'1小时前'等） 7. **转帖必须包含comments数组（2-5条评论）**，评论要与转帖内容相关 8. stats数值必须根据用户身份（公众人物/普通用户）设置合理范围 9. stats中所有数字必须是纯数字，不带引号 10. 10-20%的评论可以带图（image字段） 11. 🚫 绝对禁止在任何通知中使用用户 ${userXProfileInfo.name} (${userXProfileInfo.handle}) 的身份 【🔒 隐私保护规则】： 🚨 所有点赞用户、转帖用户、评论者都是陌生路人，只能基于用户的X平台公开信息： ✅ 可以使用：用户的X姓名、X句柄、X简介、公开身份 ❌ 禁止提及：用户的真实姓名、真实职业、私人关系、未公开的身份信息 ❌ 禁止使用：只有亲密关系才知道的称呼（如"老师"、"同学"等，除非是用户的公开身份） 示例说明： - ✅ 正确：转帖评论"这个博主说得太对了"（基于公开身份） - ❌ 错误：转帖评论"张老师的课讲得真好"（泄露了真实姓氏和职业） - ❌ 错误：评论"同学你太棒了"（假装是同学关系） `; const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】')); tokenCount = TokenUtils.logTokenUsage('Mentions生成器', 'JSON格式要求', formatSection, tokenCount); const messageContent = []; let contentText = `请为用户的推文生成Mentions通知（点赞和转帖） 推文内容："${tweetData.content}" 发布时间：${tweetData.time}`; messageContent.push({ type: 'text', text: contentText }); if (tweetData.image) { if (tweetData.image.type === 'upload' && tweetData.image.content) { messageContent.push({ type: 'image_url', image_url: { url: tweetData.image.content }, }); } else if (tweetData.image.type === 'uploads' && tweetData.image.images && tweetData.image.images.length > 0) { tweetData.image.images.forEach((img, index) => { if (img.content) { messageContent.push({ type: 'image_url', image_url: { url: img.content }, }); } }); } else if (tweetData.image.type === 'description') { messageContent.push({ type: 'text', text: `图片描述：${tweetData.image.content}`, }); } } const messages = [{ role: 'user', content: messageContent }]; const contextText = messageContent.map(c => c.text || '[图片]').join(' '); tokenCount = TokenUtils.logTokenUsage('Mentions生成器', '上下文信息', contextText, tokenCount); TokenUtils.logFinalPrompt('Mentions生成器', systemPrompt, contextText); const aiResponseContent = await APIUtils.sendAIRequest({ apiConfig, systemPrompt, messages, temperature: 0.8, }); console.log('✅ [Mentions生成器] AI响应已收到'); let notificationsData = APIUtils.parseJSONResponse(aiResponseContent); notificationsData = StringBuilders.filterUserImpersonation( notificationsData, userXProfileInfo.handle, userXProfileInfo.name, ); await StringBuilders.enforceAvatarRules(notificationsData, userXProfileInfo.handle); if (!notificationsData.likes || !notificationsData.retweets) { throw new Error('AI返回的数据格式不正确：缺少likes或retweets'); } const timestamp = Date.now(); notificationsData.likes.forEach((like, index) => { if (!like.id) like.id = `mention_like_${timestamp}_${index}`; like.timestamp = timestamp - (5 + Math.random() * 30) * 60 * 1000; }); notificationsData.retweets.forEach((retweet, index) => { if (!retweet.id) retweet.id = `mention_retweet_${timestamp}_${index}`; retweet.timestamp = timestamp - (10 + Math.random() * 50) * 60 * 1000; retweet.originalTweetId = tweetData.id; if (retweet.comments && retweet.comments.length > 0) { retweet.comments.forEach((comment, cIndex) => { if (!comment.id) { comment.id = `mention_retweet_${timestamp}_${index}_c${cIndex}`; } if (!comment.timestamp) { comment.timestamp = retweet.timestamp + (5 + Math.random() * 30) * 60 * 1000; } }); } }); await saveMentionsNotifications(notificationsData); console.log( `✅ [Mentions生成器] 已生成 ${notificationsData.likes.length} 条点赞通知，${notificationsData.retweets.length} 条转帖通知`, ); const isEnglish = currentLanguage === 'en'; const userAvatar = window.userProfileData?.avatar || 'https: const totalCount = notificationsData.likes.length + notificationsData.retweets.length; showPhoneNotification({ title: 'X', message: isEnglish ? `${totalCount} new notification${totalCount > 1 ? 's' : ''} on your post!` : `你的帖子收到了 ${totalCount} 条新通知！`, avatar: userAvatar, leftIcon: 'x', }); const mentionsPage = document.getElementById('x-notifications-page'); if (mentionsPage && mentionsPage.style.display === 'flex') { await loadNotifications(); } else { showNavNotificationDot('notifications'); } } catch (error) { console.error('❌ [Mentions生成器] 生成失败:', error); } } async function saveMentionsNotifications(notificationsData) { try { const xDb = getXDB(); const dataId = `mentions_${currentAccountId || 'main'}`; let savedData = await xDb.xAccountProfiles.get(dataId); if (!savedData) { savedData = { handle: dataId, id: dataId, data: [], }; } const allNotifications = [...notificationsData.likes, ...notificationsData.retweets]; savedData.data = [...allNotifications, ...savedData.data]; await xDb.xAccountProfiles.put(savedData); console.log('✅ [Mentions生成器] 通知已保存到数据库'); } catch (error) { console.error('❌ [Mentions生成器] 保存通知失败:', error); try { if (!(await xDb.xAccountProfiles.get(dataId))) { savedData.handle = dataId; await xDb.xAccountProfiles.add(savedData); console.log('✅ [Mentions生成器] 通知已保存（使用 add 方法）'); } } catch (addError) { console.error('❌ [Mentions生成器] add 方法也失败:', addError); } } } function renderLikeMentionItem(mention) { const config = languageConfig[currentLanguage] || languageConfig.zh; const mentionEl = document.createElement('div'); mentionEl.className = 'mention-item'; mentionEl.dataset.mentionId = mention.id; mentionEl.style.cssText = ` display: flex; gap: 12px; padding: 16px; border-bottom: 1px solid var(--x-border-color); cursor: pointer; transition: background-color 0.2s; user-select: none; -webkit-user-select: none; `; let touchMoved = false; const startLongPress = e => { if (mentionsDeleteMode) return; touchMoved = false; mentionsLongPressStarted = true; mentionsLongPressTimer = setTimeout(() => { if (mentionsLongPressStarted && !touchMoved) { enterMentionsDeleteMode(); const checkbox = mentionEl.querySelector('.mention-checkbox'); if (checkbox) { toggleMentionSelection(mention.id, checkbox); } } }, 500); }; const cancelLongPress = () => { mentionsLongPressStarted = false; if (mentionsLongPressTimer) { clearTimeout(mentionsLongPressTimer); mentionsLongPressTimer = null; } }; const handleTouchMove = () => { touchMoved = true; cancelLongPress(); }; mentionEl.addEventListener('touchstart', startLongPress, { passive: true }); mentionEl.addEventListener('touchend', cancelLongPress); mentionEl.addEventListener('touchmove', handleTouchMove); mentionEl.addEventListener('touchcancel', cancelLongPress); mentionEl.addEventListener('mousedown', startLongPress); mentionEl.addEventListener('mouseup', cancelLongPress); mentionEl.addEventListener('mouseleave', cancelLongPress); mentionEl.onmouseover = () => { if (!mentionsDeleteMode) { mentionEl.style.backgroundColor = 'var(--x-bg-hover)'; } }; mentionEl.onmouseout = () => { mentionEl.style.backgroundColor = 'transparent'; }; const iconArea = document.createElement('div'); iconArea.style.cssText = 'width: 40px; display: flex; flex-direction: column; align-items: flex-end; flex-shrink: 0;'; const iconColor = 'var(--x-accent)'; const iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>`; iconArea.innerHTML = iconSvg; const contentArea = document.createElement('div'); contentArea.style.cssText = 'flex: 1; min-width: 0;'; let avatarsHtml = '<div style="display: flex; gap: 4px; margin-bottom: 8px;">'; const displayUsers = mention.users.slice(0, 3); displayUsers.forEach(user => { avatarsHtml += `<img src="${user.avatar}" alt="${user.name}" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid var(--x-bg-primary);">`; }); avatarsHtml += '</div>'; const firstName = mention.users[0].name; const secondName = mention.users.length > 1 ? mention.users[1].name : ''; const othersCount = mention.othersCount || 0; let notificationText = ''; if (currentLanguage === 'zh') { notificationText = `${firstName}${secondName ? ` ${secondName}` : ''}${ othersCount > 0 ? ` 和其他 ${othersCount} 人` : '' } 喜欢了你的推文`; } else { notificationText = `${firstName}${secondName ? ` ${secondName}` : ''}${ othersCount > 0 ? ` and ${othersCount} others` : '' } liked your post`; } let tweetContentHtml = ''; if (mention.tweet) { tweetContentHtml = ` <div style="margin-top: 12px; padding: 12px; border: 1px solid var(--x-border-color); border-radius: 12px;"> <div style="color:var(--x-text-primary); font-size: 15px; line-height: 1.4; margin-bottom: ${ mention.tweet.image ? '8px' : '0' };"> ${mention.tweet.content} </div> ${ mention.tweet.image ? `<div style="color:var(--x-text-secondary); font-size: 13px; margin-top: 8px;">[图片]</div>` : '' } </div> `; } const displayTime = mention.timestamp ? getRelativeTime(mention.timestamp) : mention.time; contentArea.innerHTML = ` ${avatarsHtml} <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 4px;"> ${notificationText} </div> <div style="color:var(--x-text-secondary); font-size: 14px;"> ${displayTime} </div> ${tweetContentHtml} `; mentionEl.appendChild(iconArea); mentionEl.appendChild(contentArea); return mentionEl; } function renderRetweetMentionItem(mention) { const config = languageConfig[currentLanguage] || languageConfig.zh; const mentionEl = document.createElement('div'); mentionEl.className = 'mention-item'; mentionEl.dataset.mentionId = mention.id; mentionEl.style.cssText = ` display: flex; gap: 12px; padding: 16px; border-bottom: 1px solid var(--x-border-color); cursor: pointer; transition: background-color 0.2s; user-select: none; -webkit-user-select: none; `; let touchMoved = false; let clickAllowed = true; const startLongPress = e => { if (mentionsDeleteMode) return; touchMoved = false; clickAllowed = true; mentionsLongPressStarted = true; mentionsLongPressTimer = setTimeout(() => { if (mentionsLongPressStarted && !touchMoved) { clickAllowed = false; enterMentionsDeleteMode(); const checkbox = mentionEl.querySelector('.mention-checkbox'); if (checkbox) { toggleMentionSelection(mention.id, checkbox); } } }, 500); }; const cancelLongPress = () => { mentionsLongPressStarted = false; if (mentionsLongPressTimer) { clearTimeout(mentionsLongPressTimer); mentionsLongPressTimer = null; } }; const handleTouchMove = () => { touchMoved = true; cancelLongPress(); }; mentionEl.addEventListener('touchstart', startLongPress, { passive: true }); mentionEl.addEventListener('touchend', cancelLongPress); mentionEl.addEventListener('touchmove', handleTouchMove); mentionEl.addEventListener('touchcancel', cancelLongPress); mentionEl.addEventListener('mousedown', startLongPress); mentionEl.addEventListener('mouseup', cancelLongPress); mentionEl.addEventListener('mouseleave', cancelLongPress); mentionEl.onmouseover = () => { if (!mentionsDeleteMode) { mentionEl.style.backgroundColor = 'var(--x-bg-hover)'; } }; mentionEl.onmouseout = () => { mentionEl.style.backgroundColor = 'transparent'; }; mentionEl.onclick = () => { if (!mentionsDeleteMode && clickAllowed) { showRetweetDetail(mention); } }; const iconArea = document.createElement('div'); iconArea.style.cssText = 'width: 40px; display: flex; flex-direction: column; align-items: flex-end; flex-shrink: 0;'; const iconColor = 'var(--x-accent)'; const iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M4.75 3.79l4.603 4.3-1.706 1.82L6 8.38v7.37c0 .97.784 1.75 1.75 1.75H13V20H7.75c-2.347 0-4.25-1.9-4.25-4.25V8.38L1.853 9.91.147 8.09l4.603-4.3zm11.5 2.71H11V4h5.25c2.347 0 4.25 1.9 4.25 4.25v7.37l1.647-1.53 1.706 1.82-4.603 4.3-4.603-4.3 1.706-1.82L18 15.62V8.25c0-.97-.784-1.75-1.75-1.75z"></path></g></svg>`; iconArea.innerHTML = iconSvg; const contentArea = document.createElement('div'); contentArea.style.cssText = 'flex: 1; min-width: 0;'; let avatarHtml = `<div style="margin-bottom: 8px;"><img src="${mention.user.avatar}" alt="${mention.user.name}" style="width: 32px; height: 32px; border-radius: 50%;"></div>`; let notificationText = ''; if (currentLanguage === 'zh') { notificationText = `${mention.user.name} 转推了你的推文`; } else { notificationText = `${mention.user.name} retweeted your post`; } contentArea.innerHTML = ` ${avatarHtml} <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 4px;"> ${notificationText} </div> <div style="color:var(--x-text-secondary); font-size: 14px; margin-bottom: 12px;"> ${mention.time} </div> <div style="padding: 12px; border: 1px solid var(--x-border-color); border-radius: 12px;"> <div style="color:var(--x-text-primary); font-size: 15px; line-height: 1.4; margin-bottom: 8px;"> ${processContent(mention.retweetContent)} </div> <div style="padding: 12px; border-left: 3px solid var(--x-border-color); background-color:var(--x-bg-secondary); border-radius: 4px;"> <div style="color:var(--x-text-secondary); font-size: 13px; margin-bottom: 4px;"> ${mention.quotedTweet.user.name} ${mention.quotedTweet.user.handle} </div> <div style="color:var(--x-text-primary); font-size: 14px; line-height: 1.3;"> ${mention.quotedTweet.content.substring(0, 100)}${mention.quotedTweet.content.length > 100 ? '...' : ''} </div> </div> </div> `; mentionEl.appendChild(iconArea); mentionEl.appendChild(contentArea); return mentionEl; } async function showRetweetDetail(mention) { try { const ensureStats = stats => ({ comments: stats?.comments || 0, retweets: stats?.retweets || 0, likes: stats?.likes || 0, views: stats?.views || 0, }); const retweetData = { id: mention.id || `retweet_${Date.now()}`, user: mention.user || { name: '未知用户', handle: '@unknown', avatar: 'https: verified: false, }, content: mention.retweetContent || '', time: mention.time || '刚刚', timestamp: mention.timestamp || Date.now(), stats: ensureStats(mention.stats), quotedTweet: { type: 'tweet', user: mention.quotedTweet?.user || { name: '未知用户', handle: '@unknown', avatar: 'https: verified: false, }, content: mention.quotedTweet?.content || '', time: mention.quotedTweet?.time || '刚刚', image: mention.quotedTweet?.image || null, stats: ensureStats(mention.quotedTweet?.stats), }, comments: mention.comments || [], _source: 'retweet_mention', }; console.log('📝 [转帖详情] 数据已准备:', retweetData); await showTweetDetail(retweetData); } catch (error) { console.error('显示转帖详情失败:', error); showXToast('无法显示转帖详情', 'error'); } } async function showNewTweetDetail(mention) { try { console.log('📝 [New Tweet详情] 准备显示推文详情:', mention); const ensureStats = stats => ({ comments: stats?.comments || 0, retweets: stats?.retweets || 0, likes: stats?.likes || 0, views: stats?.views || 0, }); const tweetData = { id: mention.tweet.id || `newtweet_${Date.now()}`, user: mention.tweet.user || mention.user || { name: '未知用户', handle: '@unknown', avatar: 'https: verified: false, }, content: mention.tweet.content || '', time: mention.tweet.time || '刚刚', timestamp: mention.tweet.timestamp || mention.timestamp || Date.now(), image: mention.tweet.image || null, stats: ensureStats(mention.tweet.stats), comments: (mention.tweet.comments || []).map(comment => ({ ...comment, stats: ensureStats(comment.stats), })), _source: 'newtweet_mention', _mentionId: mention.id, }; console.log('📝 [New Tweet详情] 数据已准备，包含 %d 条评论', tweetData.comments.length); await showTweetDetail(tweetData); } catch (error) { console.error('显示 New Tweet 详情失败:', error); showXToast('无法显示推文详情', 'error'); } } let mentionsDeleteMode = false; let selectedMentions = new Set(); let mentionsLongPressTimer = null; let mentionsLongPressStarted = false; window.switchNotificationTab = function (tab) { const tabs = document.querySelectorAll('.notification-tab'); const allContent = document.getElementById('notifications-all-content'); const mentionsContent = document.getElementById('notifications-mentions-content'); const refreshBtn = document.getElementById('refresh-messages-btn'); if (mentionsDeleteMode) { exitMentionsDeleteMode(); } tabs.forEach(tabEl => { const isActive = (tab === 'all' && (tabEl.textContent.includes('全部') || tabEl.textContent.includes('All'))) || (tab === 'mentions' && (tabEl.textContent.includes('提及') || tabEl.textContent.includes('Mentions'))); if (isActive) { tabEl.classList.add('active'); tabEl.style.color = 'var(--x-text-primary)'; tabEl.style.backgroundColor = 'transparent'; tabEl.querySelector('.tab-indicator').style.display = 'block'; } else { tabEl.classList.remove('active'); tabEl.style.color = 'var(--x-text-secondary)'; tabEl.style.backgroundColor = 'transparent'; tabEl.querySelector('.tab-indicator').style.display = 'none'; } }); if (tab === 'all') { allContent.style.display = 'flex'; mentionsContent.style.display = 'none'; if (refreshBtn) refreshBtn.style.display = 'flex'; } else { allContent.style.display = 'none'; mentionsContent.style.display = 'flex'; if (refreshBtn) refreshBtn.style.display = 'none'; } }; function enterMentionsDeleteMode() { mentionsDeleteMode = true; selectedMentions.clear(); showMentionsDeleteToolbar(); const mentionItems = document.querySelectorAll('.mention-item'); mentionItems.forEach(item => { item.style.paddingLeft = '56px'; const checkbox = document.createElement('div'); checkbox.className = 'mention-checkbox'; checkbox.style.cssText = ` position: absolute; left: 16px; top: 50%; transform: translateY(-50%); width: 24px; height: 24px; border: 2px solid var(--x-border-color); border-radius: 50%; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; `; item.style.position = 'relative'; item.insertBefore(checkbox, item.firstChild); checkbox.onclick = e => { e.stopPropagation(); const mentionId = item.dataset.mentionId; toggleMentionSelection(mentionId, checkbox); }; }); console.log('✅ 进入 Mentions 删除模式'); } function exitMentionsDeleteMode() { mentionsDeleteMode = false; selectedMentions.clear(); hideMentionsDeleteToolbar(); const checkboxes = document.querySelectorAll('.mention-checkbox'); checkboxes.forEach(cb => cb.remove()); const mentionItems = document.querySelectorAll('.mention-item'); mentionItems.forEach(item => { item.style.paddingLeft = '16px'; }); console.log('✅ 退出 Mentions 删除模式'); } function toggleMentionSelection(mentionId, checkbox) { if (selectedMentions.has(mentionId)) { selectedMentions.delete(mentionId); checkbox.style.backgroundColor = 'transparent'; checkbox.innerHTML = ''; } else { selectedMentions.add(mentionId); checkbox.style.backgroundColor = 'var(--x-accent)'; checkbox.style.borderColor = 'var(--x-accent)'; checkbox.innerHTML = `<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: white;"><g><path d="M9 20l-7-7 1.41-1.41L9 17.17l11.59-11.58L22 7z"></path></g></svg>`; } updateDeleteToolbar(); } function showMentionsDeleteToolbar() { const existingToolbar = document.getElementById('mentions-delete-toolbar'); if (existingToolbar) { existingToolbar.remove(); } const toolbar = document.createElement('div'); toolbar.id = 'mentions-delete-toolbar'; toolbar.style.cssText = ` position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background: var(--x-bg-primary); border: 1px solid var(--x-border-color); border-radius: 24px; padding: 12px 20px; display: flex; align-items: center; gap: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; animation: slideUp 0.3s ease; `; toolbar.innerHTML = ` <button id="mentions-select-all-btn" style="background: transparent; border: none; color: var(--x-accent); font-size: 15px; font-weight: 600; cursor: pointer; padding: 8px 12px; border-radius: 8px; transition: background-color 0.2s; ">全选</button> <div style="width: 1px; height: 24px; background: var(--x-border-color);"></div> <button id="mentions-delete-btn" style="background: transparent; border: none; color:var(--x-text-secondary); font-size: 15px; font-weight: 600; cursor: not-allowed; padding: 8px 12px; border-radius: 8px; transition: all 0.2s; ">删除 (0)</button> <div style="width: 1px; height: 24px; background: var(--x-border-color);"></div> <button id="mentions-cancel-btn" style="background: transparent; border: none; color:var(--x-text-primary); font-size: 15px; font-weight: 600; cursor: pointer; padding: 8px 12px; border-radius: 8px; transition: background-color 0.2s; ">取消</button> `; document.body.appendChild(toolbar); document.getElementById('mentions-select-all-btn').onclick = selectAllMentions; document.getElementById('mentions-delete-btn').onclick = confirmDeleteMentions; document.getElementById('mentions-cancel-btn').onclick = exitMentionsDeleteMode; const buttons = toolbar.querySelectorAll('button'); buttons.forEach(btn => { btn.onmouseover = () => { if (btn.id !== 'mentions-delete-btn' || selectedMentions.size > 0) { btn.style.backgroundColor = 'var(--x-bg-hover)'; } }; btn.onmouseout = () => { btn.style.backgroundColor = 'transparent'; }; }); } function hideMentionsDeleteToolbar() { const toolbar = document.getElementById('mentions-delete-toolbar'); if (toolbar) { toolbar.remove(); } } function updateDeleteToolbar() { const deleteBtn = document.getElementById('mentions-delete-btn'); const selectAllBtn = document.getElementById('mentions-select-all-btn'); if (deleteBtn) { const count = selectedMentions.size; deleteBtn.textContent = `删除 (${count})`; if (count > 0) { deleteBtn.style.color = '#f4212e'; deleteBtn.style.cursor = 'pointer'; } else { deleteBtn.style.color = 'var(--x-text-secondary)'; deleteBtn.style.cursor = 'not-allowed'; } } if (selectAllBtn) { const allMentionItems = document.querySelectorAll('.mention-item'); if (selectedMentions.size === allMentionItems.length && allMentionItems.length > 0) { selectAllBtn.textContent = '取消全选'; } else { selectAllBtn.textContent = '全选'; } } } function selectAllMentions() { const allMentionItems = document.querySelectorAll('.mention-item'); const selectAllBtn = document.getElementById('mentions-select-all-btn'); if (selectedMentions.size === allMentionItems.length) { selectedMentions.clear(); const checkboxes = document.querySelectorAll('.mention-checkbox'); checkboxes.forEach(cb => { cb.style.backgroundColor = 'transparent'; cb.style.borderColor = 'var(--x-border-color)'; cb.innerHTML = ''; }); } else { allMentionItems.forEach(item => { const mentionId = item.dataset.mentionId; selectedMentions.add(mentionId); const checkbox = item.querySelector('.mention-checkbox'); if (checkbox) { checkbox.style.backgroundColor = 'var(--x-accent)'; checkbox.style.borderColor = 'var(--x-accent)'; checkbox.innerHTML = `<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: white;"><g><path d="M9 20l-7-7 1.41-1.41L9 17.17l11.59-11.58L22 7z"></path></g></svg>`; } }); } updateDeleteToolbar(); } function confirmDeleteMentions() { if (selectedMentions.size === 0) return; const count = selectedMentions.size; const message = currentLanguage === 'zh' ? `确定要删除 ${count} 条通知吗？此操作不可恢复。` : `Delete ${count} notification${count > 1 ? 's' : ''}? This action cannot be undone.`; if (confirm(message)) { deleteMentions(); } } async function deleteMentions() { try { const xDb = getXDB(); const mentionsDataId = `mentions_${currentAccountId || 'main'}`; const savedMentions = await xDb.xAccountProfiles.get(mentionsDataId); if (savedMentions && savedMentions.data) { const idsToDelete = Array.from(selectedMentions); savedMentions.data = savedMentions.data.filter(m => !idsToDelete.includes(m.id)); await xDb.xAccountProfiles.put(savedMentions); console.log(`✅ 已删除 ${idsToDelete.length} 条 Mentions 通知`); showXToast(`已删除 ${idsToDelete.length} 条通知`, 'success'); exitMentionsDeleteMode(); await loadNotifications(); } } catch (error) { console.error('❌ 删除 Mentions 通知失败:', error); showXToast('删除失败: ' + error.message, 'error'); } } const strangerMessages = []; const sampleMentions = [ { id: 'mention_001', type: 'newTweet', users: [ { name: '餵ぇあか', handle: '@weaka', avatar: 'https: }, { name: '毎日抜雄', handle: '@nukio', avatar: 'https: }, { name: 'X', handle: '@X', avatar: 'https: }, ], content: 'New Tweet notifications for 餵ぇあか 毎日抜雄 and 3 others', time: '2小时前', tweet: null, }, { id: 'mention_002', type: 'like', users: [ { name: 'Tenny and Sticks🧵', handle: '@tennysticks', avatar: 'https: }, ], content: 'liked your Tweet', time: '3小时前', tweet: { content: 'Someone looks like ready to ask for Raiden Shogun......... https: image: null, }, }, { id: 'mention_003', type: 'retweet', users: [ { name: 'Moona Hoshinova (ムーナ)🔮金沢ID', handle: '@moonahoshinova', avatar: 'https: }, { name: '毎日抜雄', handle: '@nukio', avatar: 'https: }, ], content: 'and 2 others Retweeted a photo from 鍵、毎日投稿 サトウ・ドア・アイガ！！', time: '5小时前', tweet: { content: '#GambaRisu\n#ioarts', image: 'https: }, }, ]; function renderMentionItem(mention) { const config = languageConfig[currentLanguage] || languageConfig.zh; const mentionEl = document.createElement('div'); mentionEl.className = 'mention-item'; mentionEl.dataset.mentionId = mention.id; mentionEl.style.cssText = ` display: flex; gap: 12px; padding: 16px; border-bottom: 1px solid var(--x-border-color); cursor: pointer; transition: background-color 0.2s; `; let pressTimer = null; const startPress = e => { if (mentionsDeleteMode) return; pressTimer = setTimeout(() => { enterMentionsDeleteMode(); const checkbox = mentionEl.querySelector('.mention-checkbox'); if (checkbox) { toggleMentionSelection(mention.id, checkbox); } if (navigator.vibrate) { navigator.vibrate(50); } }, 500); }; const endPress = () => { if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; } }; mentionEl.addEventListener('touchstart', startPress); mentionEl.addEventListener('touchend', endPress); mentionEl.addEventListener('touchmove', endPress); mentionEl.addEventListener('mousedown', startPress); mentionEl.addEventListener('mouseup', endPress); mentionEl.addEventListener('mouseleave', endPress); if (mention.type === 'newTweet' && mention.tweet) { mentionEl.onclick = () => { if (!mentionsDeleteMode) { showNewTweetDetail(mention); } }; } mentionEl.onmouseover = () => { mentionEl.style.backgroundColor = 'var(--x-bg-hover)'; }; mentionEl.onmouseout = () => { mentionEl.style.backgroundColor = 'transparent'; }; const iconArea = document.createElement('div'); iconArea.style.cssText = 'width: 40px; display: flex; flex-direction: column; align-items: flex-end; flex-shrink: 0;'; let iconSvg = ''; let iconColor = ''; switch (mention.type) { case 'newTweet': iconColor = 'var(--x-accent)'; iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"></path></g></svg>`; break; case 'like': iconColor = 'var(--x-accent)'; iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>`; break; case 'retweet': iconColor = 'var(--x-accent)'; iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M4.75 3.79l4.603 4.3-1.706 1.82L6 8.38v7.37c0 .97.784 1.75 1.75 1.75H13V20H7.75c-2.347 0-4.25-1.9-4.25-4.25V8.38L1.853 9.91.147 8.09l4.603-4.3zm11.5 2.71H11V4h5.25c2.347 0 4.25 1.9 4.25 4.25v7.37l1.647-1.53 1.706 1.82-4.603 4.3-4.603-4.3 1.706-1.82L18 15.62V8.25c0-.97-.784-1.75-1.75-1.75z"></path></g></svg>`; break; case 'reply': iconColor = 'var(--x-accent)'; iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g></svg>`; break; case 'follow': iconColor = 'var(--x-accent)'; iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M17.863 13.44c1.477 1.58 2.366 3.8 2.632 6.46l.11 1.1H3.395l.11-1.1c.266-2.66 1.155-4.88 2.632-6.46C7.627 11.85 9.648 11 12 11s4.373.85 5.863 2.44zM12 2C9.791 2 8 3.79 8 6s1.791 4 4 4 4-1.79 4-4-1.791-4-4-4z"></path></g></svg>`; break; } iconArea.innerHTML = iconSvg; const contentArea = document.createElement('div'); contentArea.style.cssText = 'flex: 1; min-width: 0;'; let avatarsHtml = '<div style="display: flex; gap: 4px; margin-bottom: 8px;">'; if (mention.type === 'newTweet') { if (mention.user) { avatarsHtml += `<img src="${mention.user.avatar}" alt="${mention.user.name}" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid var(--x-bg-primary);">`; } } else { if (mention.users && mention.users.length > 0) { avatarsHtml += `<img src="${mention.users[0].avatar}" alt="${mention.users[0].name}" style="width: 32px; height: 32px; border-radius: 50%;">`; } } avatarsHtml += '</div>'; let notificationText = ''; if (mention.type === 'newTweet') { if (mention.user) { const userName = mention.user.name; if (currentLanguage === 'zh') { notificationText = `${userName} 发布了新推文`; } else { notificationText = `New Tweet from ${userName}`; } } } else if (mention.users && mention.users.length > 0) { const firstName = mention.users[0].name; const secondName = mention.users.length > 1 ? mention.users[1].name : ''; const othersCount = mention.users.length > 2 ? mention.users.length - 2 : 0; if (mention.type === 'like') { notificationText = currentLanguage === 'zh' ? `${firstName} 喜欢了你的推文` : `${firstName} ${config.notificationsLiked}`; } else if (mention.type === 'retweet') { if (currentLanguage === 'zh') { notificationText = `${firstName}${othersCount > 0 ? ` 和其他 ${othersCount} 人` : ''} 转推了推文`; } else { notificationText = `${firstName}${othersCount > 0 ? ` and ${othersCount} others` : ''} ${ config.notificationsRetweeted }`; } } else if (mention.type === 'reply') { notificationText = currentLanguage === 'zh' ? `${firstName} 回复了你` : `${firstName} ${config.notificationsReplied}`; } else if (mention.type === 'follow') { notificationText = currentLanguage === 'zh' ? `${firstName} 关注了你` : `${firstName} ${config.notificationsFollowed}`; } } let tweetContentHtml = ''; if (mention.tweet) { let imageHtml = ''; if (mention.tweet.image) { if (typeof mention.tweet.image === 'object' && mention.tweet.image.type === 'description') { imageHtml = ` <div style="margin-top: 8px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; padding: 16px; box-sizing: border-box;"> <div style="color:var(--x-text-primary); font-size: 15px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${mention.tweet.image.content}</div> </div> `; } else { const imageUrl = typeof mention.tweet.image === 'string' ? mention.tweet.image : mention.tweet.image.url; imageHtml = `<img src="${imageUrl}" style="width: 100%; border-radius: 12px; margin-top: 8px;">`; } } tweetContentHtml = ` <div style="margin-top: 12px; padding: 12px; border: 1px solid var(--x-border-color); border-radius: 12px;"> <div style="color:var(--x-text-primary); font-size: 15px; line-height: 1.4; margin-bottom: ${ mention.tweet.image ? '8px' : '0' };"> ${mention.tweet.content} </div> ${imageHtml} </div> `; } const displayTime = mention.timestamp ? getRelativeTime(mention.timestamp) : mention.time; contentArea.innerHTML = ` ${avatarsHtml} <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 4px;"> ${notificationText} </div> <div style="color:var(--x-text-secondary); font-size: 14px;"> ${displayTime} </div> ${tweetContentHtml} `; mentionEl.appendChild(iconArea); mentionEl.appendChild(contentArea); return mentionEl; } function renderStrangerMessageItem(message) { const config = languageConfig[currentLanguage] || languageConfig.zh; const iconColor = 'var(--x-accent)'; const iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></g></svg>`; const messageEl = document.createElement('div'); messageEl.className = 'stranger-message-item'; messageEl.style.cssText = ` display: flex; gap: 12px; padding: 16px; border-bottom: 1px solid var(--x-border-color); cursor: pointer; transition: background-color 0.2s; `; messageEl.onmouseover = () => { messageEl.style.backgroundColor = 'var(--x-bg-hover)'; }; messageEl.onmouseout = () => { messageEl.style.backgroundColor = 'transparent'; }; messageEl.onclick = () => { openMessageDetail(message); }; const iconArea = document.createElement('div'); iconArea.style.cssText = 'width: 40px; display: flex; align-items: flex-start; justify-content: flex-end; flex-shrink: 0;'; iconArea.innerHTML = iconSvg; const contentArea = document.createElement('div'); contentArea.style.cssText = 'flex: 1; min-width: 0;'; let contentHtml = ` <img src="${message.user.avatar}" alt="${message.user.name}" style="width: 32px; height: 32px; border-radius: 50%; margin-bottom: 8px;"> <div style="color:var(--x-text-secondary); font-size: 15px; margin-bottom: 4px;"> In case you missed <strong style="color:var(--x-text-primary);">${message.user.name}</strong>'s Message </div> <div style="color:var(--x-text-primary); font-size: 15px; line-height: 1.4; margin-bottom: 8px; font-weight: 500;"> ${message.preview} </div> ${ message.link ? `<div style="color: var(--x-accent); font-size: 15px; margin-bottom: 8px;">${message.link}</div>` : '' } ${ message.attachment ? `<div style="color: var(--x-accent); font-size: 15px; margin-bottom: 8px;">${message.attachment}</div>` : '' } ${message.tweetLink ? `<div style="color: var(--x-accent); font-size: 15px;">${message.tweetLink}</div>` : ''} `; contentArea.innerHTML = contentHtml; messageEl.appendChild(iconArea); messageEl.appendChild(contentArea); return messageEl; } async function loadNotifications() { const allList = document.getElementById('notifications-all-list'); const mentionsList = document.getElementById('notifications-mentions-list'); if (!allList) return; const config = languageConfig[currentLanguage] || languageConfig.zh; try { const xDb = getXDB(); const dataId = `strangerMessages_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); if (savedData && savedData.data && Array.isArray(savedData.data)) { strangerMessages.length = 0; strangerMessages.push(...savedData.data); console.log('✅ 从数据库加载了', strangerMessages.length, '条陌生人私信'); } } catch (error) { console.error('加载陌生人私信数据失败:', error); } allList.innerHTML = ''; mentionsList.innerHTML = ''; if (strangerMessages.length > 0) { strangerMessages.forEach(message => { const messageEl = renderStrangerMessageItem(message); allList.appendChild(messageEl); }); } else { allList.innerHTML = ` <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 32px; text-align: center;"> <svg viewBox="0 0 24 24" style="width: 56px; height: 56px; fill: var(--x-text-secondary); margin-bottom: 16px;"> <g><path d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v2.764l8 3.638 8-3.636V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.463l-8 3.636-8-3.638V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.037z"></path></g> </svg> <div style="font-size: 28px; font-weight: 700; color:var(--x-text-primary); margin-bottom: 8px;">暂无陌生人私信</div> <div style="font-size: 14px; color:var(--x-text-secondary); max-width: 320px;">点击右下角羽毛笔按钮生成新的陌生人私信</div> </div> `; } let allMentions = []; try { const xDb = getXDB(); const mentionsDataId = `mentions_${currentAccountId || 'main'}`; const savedMentions = await xDb.xAccountProfiles.get(mentionsDataId); if (savedMentions && savedMentions.data && Array.isArray(savedMentions.data)) { allMentions = savedMentions.data; console.log('✅ 从数据库加载了', allMentions.length, '条Mentions通知'); } } catch (error) { console.error('加载Mentions通知失败:', error); } if (allMentions.length > 0) { allMentions.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)); allMentions.forEach(mention => { let mentionEl; if (mention.type === 'like') { mentionEl = renderLikeMentionItem(mention); } else if (mention.type === 'retweet') { mentionEl = renderRetweetMentionItem(mention); } else { mentionEl = renderMentionItem(mention); } mentionsList.appendChild(mentionEl); }); } else { mentionsList.innerHTML = ` <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 32px; text-align: center;"> <svg viewBox="0 0 24 24" style="width: 56px; height: 56px; fill: var(--x-text-secondary); margin-bottom: 16px;"> <g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g> </svg> <div style="font-size: 28px; font-weight: 700; color:var(--x-text-primary); margin-bottom: 8px;">${config.notificationsEmpty}</div> <div style="font-size: 14px; color:var(--x-text-secondary); max-width: 320px;">${config.notificationsEmptyDesc}</div> </div> `; } } window.loadNotifications = loadNotifications; async function refreshStrangerMessages() { const refreshBtn = document.getElementById('refresh-messages-btn'); refreshBtn.style.animation = 'spin 1s linear infinite'; const spinStyle = document.createElement('style'); spinStyle.textContent = ` @keyframes spin { from {transform: rotate(0deg); } to {transform: rotate(360deg); } } `; document.head.appendChild(spinStyle); try { const { apiConfig, xSettings, xDb } = await APIUtils.loadConfigAndSettings(); const { userPrompt, worldSetting } = xSettings; const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || []; let tokenCount = 0; let systemPrompt = StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting, }); tokenCount = TokenUtils.logTokenUsage('陌生人私信生成器', '基础系统提示词', systemPrompt, tokenCount); const worldBooksContent = await StringBuilders.getApplicableWorldBooks('messages', { boundCharacters: [], }); if (worldBooksContent) { systemPrompt += worldBooksContent; tokenCount = TokenUtils.logTokenUsage('陌生人私信生成器', '世界书内容', worldBooksContent, tokenCount); } systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务说明 🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的陌生人私信生成器。请生成3-8条来自陌生用户的私信消息。 **重要规则**： - 这些私信来自陌生用户，不是用户的朋友或熟人 - 私信内容可以是：商务合作、粉丝留言、问询、推荐、随机搭讪等 - 私信发送者都是虚构的X平台用户 - 头像统一使用：https: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const coreTaskSection = systemPrompt.substring(systemPrompt.lastIndexOf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━')); tokenCount = TokenUtils.logTokenUsage('陌生人私信生成器', '核心任务说明', coreTaskSection, tokenCount); const userConstraintsStart = systemPrompt.length; systemPrompt += ` 【用户X平台资料】： - 用户名：${userXProfileInfo.name} - 用户句柄：${userXProfileInfo.handle} - 认证状态：${userXProfileInfo.verified ? '已认证' : '未认证'} ${userXProfileInfo.publicIdentity ? `- 公众身份：${userXProfileInfo.publicIdentity}` : ''} ${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ''} `; if (recentUserTweets.length > 0) { systemPrompt += ` 【用户最近推文】（供参考，陌生人可能看过这些推文）： `; recentUserTweets.forEach((tweet, index) => { systemPrompt += ` ${index + 1}. "${tweet.content}" - 发布时间：${tweet.time || '最近'} - 互动数据：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.comments || 0}评论 `; }); } const userSection = systemPrompt.substring(userConstraintsStart); tokenCount = TokenUtils.logTokenUsage('陌生人私信生成器', '用户资料和推文', userSection, tokenCount); systemPrompt += ` 【私信内容要求】： - 私信类型多样化：商务邀请、粉丝留言、合作咨询、内容推荐、社交搭讪等 - 可以参考用户的推文内容或公众身份来设计私信话题 - 私信长度适中（20-100字） - 部分私信可以附带链接、图片描述或推文链接 【JSON返回格式】： \`\`\`json { "messages": [私信数组] } \`\`\` 私信对象结构： - user: {name, handle, avatar, verified} - preview: 私信预览内容（主要文本） - link: 附带链接（可选，如个人网站、项目链接等） - attachment: 附带的图片/文件描述（可选） - tweetLink: 提及的推文链接（可选，如"你的这条推文xxx"） 关键规则： 1. verified字段必须是布尔值(true/false)，陌生人一般为false 2. user.avatar统一使用：https: 3. 可选字段不使用时完全省略，不要设为null 4. 私信内容要真实自然，符合陌生人私信的特点 `; const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】')); tokenCount = TokenUtils.logTokenUsage('陌生人私信生成器', 'JSON格式要求', formatSection, tokenCount); const messages = [{ role: 'user', content: '请生成新的陌生人私信数据' }]; TokenUtils.logFinalPrompt('陌生人私信生成器', systemPrompt, messages[0].content); const aiResponseContent = await APIUtils.sendAIRequest({ apiConfig, systemPrompt, messages, temperature: 0.8, }); const messagesData = APIUtils.parseJSONResponse(aiResponseContent); if (!messagesData.messages || !Array.isArray(messagesData.messages)) { throw new Error('AI返回的数据格式不正确，缺少messages数组'); } const timestamp = Date.now(); messagesData.messages.forEach((message, index) => { message.id = `sm_${timestamp}_${index}`; }); strangerMessages.length = 0; strangerMessages.push(...messagesData.messages); try { const xDb = getXDB(); const dataId = `strangerMessages_${currentAccountId || 'main'}`; await xDb.xAccountProfiles.put({ handle: dataId, name: 'strangerMessages', data: messagesData.messages, updatedAt: new Date().toISOString(), }); console.log('✅ 陌生人私信数据已保存到数据库'); } catch (saveError) { console.error('保存陌生人私信数据失败:', saveError); } loadNotifications(); const isEnglish = currentLanguage === 'en'; const userAvatar = window.userProfileData?.avatar || 'https: showPhoneNotification({ title: 'X', message: isEnglish ? 'Stranger messages have been refreshed!' : '陌生人私信已刷新！', avatar: userAvatar, leftIcon: 'x', }); } catch (error) { console.error('刷新陌生人私信失败:', error); showXToast(`刷新失败: ${error.message}`, 'error'); } finally { refreshBtn.style.animation = ''; if (spinStyle && spinStyle.parentNode) { spinStyle.remove(); } } } window.refreshStrangerMessages = refreshStrangerMessages; async function generateMessageConversation(messageData, isContinueMode = false, options = {}) { try { const isAutoMessage = options.isAutoMessage || false; const timeSinceLastMessage = options.timeSinceLastMessage || 0; const isAskboxViewed = options.isAskboxViewed || false; const askboxContent = options.askboxContent || ''; const businessTaskEvaluation = options.businessTaskEvaluation || null; const isUnblockRequest = options.isUnblockRequest || false; const unblockContext = options.unblockContext || null; const { apiConfig, xSettings, xDb } = await APIUtils.loadConfigAndSettings(); let messageType = 'stranger'; let characterId = null; let accountHandle = null; if (messageData.id) { if (messageData.id.startsWith('msg_account_')) { messageType = 'account'; if (currentViewingAccount && currentViewingAccount.accountInfo) { accountHandle = currentViewingAccount.accountInfo.handle.replace('@', ''); } } else if (messageData.id.startsWith('msg_') && messageData.id !== 'msg_001') { messageType = 'character'; characterId = messageData.id.replace('msg_', ''); } } console.log(`📨 私信类型: ${messageType}`, { characterId, accountHandle }); if (!messageData.user && messageData.userName) { messageData.user = { name: messageData.userName, handle: messageData.userHandle, avatar: messageData.userAvatar, verified: messageData.verified || false, }; } let existingMessages = []; if (isContinueMode) { const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data && savedConversation.data.messages) { existingMessages = savedConversation.data.messages; console.log(`📖 [私信生成器] 读取到 ${existingMessages.length} 条现有对话记录`); } else { console.log(`📖 [私信生成器] 无现有对话记录（首次对话）`); } } let ongoingBusinessTransfer = null; if (isContinueMode && existingMessages.length > 0) { const transferMessages = existingMessages.filter( msg => msg.type === 'transfer' && msg.isBusiness && msg.taskStatus === 'in_progress', ); if (transferMessages.length > 0) { ongoingBusinessTransfer = transferMessages[transferMessages.length - 1]; console.log(`💼 [商业转账] 检测到进行中的任务，接收方: ${ongoingBusinessTransfer.isOwn ? 'AI' : '用户'}`); } } const { userPrompt, worldSetting } = xSettings; const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || []; let tokenCount = 0; let systemPrompt = StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting, }); tokenCount = TokenUtils.logTokenUsage('私信详情生成器', '基础系统提示词', systemPrompt, tokenCount); const now = new Date(); const beijingTime = new Date(now.getTime() + 8 * 60 * 60 * 1000); const year = beijingTime.getUTCFullYear(); const month = beijingTime.getUTCMonth() + 1; const day = beijingTime.getUTCDate(); const hours = beijingTime.getUTCHours(); const minutes = beijingTime.getUTCMinutes(); const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六']; const weekday = weekdays[beijingTime.getUTCDay()]; let timeOfDay = ''; if (hours >= 5 && hours < 9) { timeOfDay = '清晨'; } else if (hours >= 9 && hours < 12) { timeOfDay = '上午'; } else if (hours >= 12 && hours < 14) { timeOfDay = '中午'; } else if (hours >= 14 && hours < 18) { timeOfDay = '下午'; } else if (hours >= 18 && hours < 22) { timeOfDay = '晚上'; } else { timeOfDay = '深夜'; } systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ⏰ 当前时间信息 ⏰ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 当前时间（北京时间）：${year}年${month}月${day}日 ${weekday} ${String(hours).padStart(2, '0')}:${String( minutes, ).padStart(2, '0')} 时段：${timeOfDay} **请根据当前时间生成符合时间情境的回复**： - 如果是清晨或上午，可以问候早安、讨论早餐或一天的计划 - 如果是中午，可以讨论午餐或午休 - 如果是下午，可以讨论工作或下午茶 - 如果是晚上，可以问候晚安、讨论晚餐或晚间活动 - 如果是深夜，考虑为什么还没睡或深夜的话题 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; tokenCount = TokenUtils.logTokenUsage( '私信详情生成器', '时间信息', systemPrompt.substring(systemPrompt.lastIndexOf('⏰ 当前时间信息')), tokenCount, ); const worldBooksOptions = { boundCharacters: [] }; if (messageType === 'character' && characterId) { worldBooksOptions.boundCharacters = [characterId]; } else if (messageType === 'account') { worldBooksOptions.boundCharacters = []; } const worldBooksContent = await StringBuilders.getApplicableWorldBooks('messages', worldBooksOptions); if (worldBooksContent) { systemPrompt += worldBooksContent; tokenCount = TokenUtils.logTokenUsage('私信详情生成器', '世界书内容', worldBooksContent, tokenCount); } if (isContinueMode) { if (messageType === 'character') { if (isAskboxViewed) { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务说明（提问箱查看模式 - 角色私信）🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的私信对话生成器。角色发现用户查看了自己的提问箱，现在主动发送私信。 **对话场景**： - 📱 这是X社交平台（类似Twitter/X）的私信功能 - 🔍 角色${messageData.user.name}发现用户偷看了TA的提问箱 - 📝 用户刚刚查看了以下提问箱内容： ${askboxContent} **角色信息**： - 角色名：${messageData.user.name} - 角色句柄：${messageData.user.handle} - 这是一个已绑定的角色，有完整的人设、记忆和X平台资料 **重要规则**： - 🚨 只生成角色${messageData.user.name}的主动消息，不要生成用户的消息 - ⚠️ **这是X平台的私信对话，不是手机短信或其他聊天软件** - 📖 **必须参考下方的【X平台私信对话记录】**，了解你们之前的对话内容，保持对话的连贯性和一致性 - 角色知道用户查看了TA的提问箱，可以调侃、好奇或关心用户为什么要看 - 可以结合提问箱的内容展开话题，询问用户的想法或意见 - 生成1-8条符合角色性格的主动消息 - 回复要严格符合角色的性格、说话风格和与用户的关系 - 可以表现出：发现被偷看的惊讶、调皮、害羞、好奇等情绪（根据角色性格） - 结合之前的X平台私信对话记录和提问箱内容，保持一致性 - 消息类型包括：文本、图片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、语音、文章链接（link：需要title、description、author、source、body完整正文）、转发推文、转发主页 - ⚠️ 注意：image和sticker是完全不同的类型，不要混淆！link类型是文章链接，需要包含完整的文章内容 - ⚠️ 禁止生成forward类型消息（这是用户手动转发产生的） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } else if (isAutoMessage) { const likedTweetContext = options.likedTweetContext; const hasLikedTweet = likedTweetContext && likedTweetContext.content; const isBusinessEvaluation = businessTaskEvaluation && businessTaskEvaluation.isBusinessTaskEvaluation; if (isBusinessEvaluation) { const tweetData = businessTaskEvaluation.tweetData; const businessTransfer = businessTaskEvaluation.businessTransfer; const likes = tweetData.stats?.likes || 0; const retweets = tweetData.stats?.retweets || 0; const comments = tweetData.stats?.comments || 0; const views = tweetData.stats?.views || 0; systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 💼 核心任务说明（商业任务评估模式 - 角色私信）💼 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的私信对话生成器。角色雇佣了用户完成商业推广任务，现在评估任务完成情况并决定付款。 **对话场景**： - 📱 这是X社交平台（类似Twitter/X）的私信功能 - 💼 角色${messageData.user.name}之前发起了商业转账 - ✅ 用户已完成任务，发布了商业化推贴 - 🤖 角色现在要评估任务完成情况，并决定如何付款 **商业转账信息**： - 总金额：$${parseFloat(businessTransfer.amount).toFixed(2)} - 已支付定金：$${parseFloat(businessTransfer.depositAmount).toFixed(2)} (${businessTransfer.depositRatio}%) - 待付尾款：$${parseFloat(businessTransfer.remainingAmount).toFixed(2)} - 任务要求：${businessTransfer.taskDescription} - 任务期限：${businessTransfer.taskDeadlineHours}小时 **用户完成的推贴内容**： - 推文内容："${tweetData.content}" ${ tweetData.image ? `- 包含图片：${tweetData.image.type === 'description' ? tweetData.image.content : '已上传图片'}` : '' } ${tweetData.location ? `- 位置：${tweetData.location}` : ''} - 发布时间：${tweetData.time || '刚刚'} **推文数据表现**： - 👍 喜欢数：${likes} - 🔄 转发数：${retweets} - 💬 评论数：${comments} - 👀 浏览量：${views} **评论区反馈**： ${ tweetData.comments && tweetData.comments.length > 0 ? tweetData.comments .slice(0, 5) .map((c, i) => `${i + 1}. ${c.user.name}: "${c.content}"`) .join('\n') : '暂无评论' } **用户公众身份**： - 用户名：${userXProfileInfo.name} - 用户句柄：${userXProfileInfo.handle} - 认证状态：${userXProfileInfo.verified ? '已认证' : '未认证'} ${userXProfileInfo.publicIdentity ? `- 公众身份：${userXProfileInfo.publicIdentity}` : ''} - 粉丝影响力：${userXProfileInfo.publicIdentity ? '有一定影响力' : '普通用户'} **评估规则**： 🎯 你需要根据以下标准评估任务完成情况： 1. **内容质量**（40%）： - 推文是否符合任务要求？ - 表达是否自然，不是生硬的广告？ - 是否包含了要求的关键信息？ 2. **数据表现**（30%）： - 推文的互动数据（喜欢、转发、评论、浏览量）如何？ - 与用户的粉丝基础相匹配吗？ - 评论区反馈是否正面？ 3. **用户影响力**（30%）： - 用户的公众身份和影响力如何？ - 认证状态是否增加可信度？ - 是否值得额外投资？ **付款决策**： 根据评估结果，你需要决定： ✅ **满意（80-100分）**： - 支付全额尾款 + 额外10-30%奖励 - 示例：总额$200，定金$40，尾款$160，额外奖励$20-60 - 在回复中表达满意，感谢合作，期待下次合作 👍 **中规中矩（60-79分）**： - 支付全额尾款，无额外奖励 - 示例：总额$200，定金$40，尾款$160 - 在回复中表示认可，指出可以改进的地方 😐 **不满意但可接受（40-59分）**： - 支付50-80%的尾款 - 示例：总额$200，定金$40，尾款$160，实际支付$80-128 - 在回复中指出不足，表达轻微失望 ❌ **非常不满意（<40分）**： - 不支付尾款或仅支付20-40% - 示例：总额$200，定金$40，尾款$160，实际支付$0-64 - 在回复中明确指出问题，表达不满 **重要规则**： - 🚨 只生成角色${messageData.user.name}的评估消息，不要生成用户的消息 - ⚠️ **这是X平台的私信对话，不是手机短信或其他聊天软件** - 💰 **必须发送转账消息支付尾款**（amount为尾款金额，note说明付款原因） - 📖 参考下方的【X平台私信对话记录】，保持对话的连贯性 - 🎭 评估要符合角色性格，有的角色很大方，有的很挑剔 - 💬 生成1-3条文本消息说明评估结果，然后发送转账 - ⚠️ 转账消息的note要说明是尾款、奖励还是扣款 **消息示例结构**： 1. 文本消息：评估内容质量 2. 文本消息（可选）：评估数据表现 3. 转账消息：支付尾款（必须） 4. 文本消息（可选）：感谢或建议 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } else { const isAwayReturn = options.isAwayReturn || false; systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务说明（自动发消息模式 - 角色私信）🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的私信对话生成器。角色主动发起私信（后台自动活动）。 **对话场景**： - 📱 这是X社交平台（类似Twitter/X）的私信功能 ${ isAwayReturn ? `- 🔙 **特殊情况：离开后返回** - 角色${messageData.user.name}之前因为有事暂时离开，现在忙完了，主动联系用户 - 距离上次对话已经过去了约 ${Math.round(timeSinceLastMessage / 60)} 分钟 - 🤖 角色应该解释自己去忙什么了，并对让用户等待表示歉意或说明情况 - 生成1-5条符合角色性格的主动消息，体现出刚忙完的状态` : hasLikedTweet ? `- 💖 用户刚刚喜欢了角色${messageData.user.name}的推文 - 📝 被喜欢的推文内容："${likedTweetContext.content}" - 🤖 角色发现用户喜欢了TA的推文，现在主动发送私信` : `- ⏰ 距离上一次对话已经过去了 ${timeSinceLastMessage} 秒 - 🤖 角色${messageData.user.name}现在主动发送私信` } **角色信息**： - 角色名：${messageData.user.name} - 角色句柄：${messageData.user.handle} - 这是一个已绑定的角色，有完整的人设、记忆和X平台资料 **重要规则**： - 🚨 只生成角色${messageData.user.name}的主动消息，不要生成用户的消息 - ⚠️ **这是X平台的私信对话，不是手机短信或其他聊天软件** ${ isAwayReturn ? `- 📖 **必须参考下方的【X平台私信对话记录】**，查看用户之前发送的消息 - 🔙 角色现在忙完了，应该回应用户之前的消息内容 - 可以先道歉/解释为什么离开了一段时间，然后回应用户的消息 - 消息风格要自然，符合角色性格（有的角色会认真道歉，有的随意说明） - 根据角色性格和与用户的关系，调整道歉的正式程度 - 回复要严格符合角色的性格、说话风格和与用户的关系 - 参考角色的聊天记忆（包括X平台私信记忆和其他聊天记忆），保持一致性` : hasLikedTweet ? `- 📖 **必须参考下方的【X平台私信对话记录】**，了解你们之前的对话内容，保持对话的连贯性和一致性 - 💖 角色知道用户喜欢了TA的推文（上面显示的推文内容），可以表现出惊喜、开心、好奇等情绪 - 可以结合推文内容展开话题，询问用户的想法或感受 - 生成1-5条符合角色性格的主动消息，表现出看到自己的推文被喜欢的反应 - 回复要严格符合角色的性格、说话风格和与用户的关系 - 可以表现出：发现被关注的开心、想继续交流的期待等情绪（根据角色性格） - 结合之前的X平台私信对话记录和推文内容，保持一致性` : `- 根据距离上次对话的时间，生成1-7条符合角色性格的主动消息 - 主动消息可以是：想念对方、分享近况、询问对方、提及X平台的推文等 - 回复要严格符合角色的性格、说话风格和与用户的关系 - 参考角色的聊天记忆（包括X平台私信记忆和其他聊天记忆），保持一致性 - 可以自然提及角色最近在X平台发布的推文或动态` } - 消息类型包括：文本、图片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、语音、文章链接（link：需要title、description、author、source、body完整正文）、转发推文、转发主页 - ⚠️ 注意：image和sticker是完全不同的类型，不要混淆！link类型是文章链接，需要包含完整的文章内容 - ⚠️ 禁止生成forward类型消息（这是用户手动转发产生的） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } } else if (isUnblockRequest) { const triggerSource = unblockContext?.triggerSource || 'unknown'; const triggerContent = unblockContext?.triggerContent || ''; systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🔓 核心任务说明（拉黑解除评估 - 角色私信）🔓 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的私信对话生成器。你之前拉黑了用户，但用户通过其他方式联系了你，现在需要评估是否解除拉黑。 **对话场景**： - 📱 这是X社交平台（类似Twitter/X）的私信功能 - ⚠️ **你之前已经拉黑了用户，用户无法直接发送私信** - 🔔 但用户通过${triggerSource === 'mention' ? '在推文中@你' : '在评论区评论'}的方式联系了你 **角色信息**： - 角色名：${messageData.user.name} - 角色句柄：${messageData.user.handle} - 这是一个已绑定的角色，有完整的人设、记忆和X平台资料 **用户的触发内容**： ${triggerSource === 'mention' ? '用户在推文中@了你：' : '用户在评论区提到了你：'} "${triggerContent}" **重要规则**： - 🚨 只生成角色${messageData.user.name}的回复消息，不要生成用户的消息 - 📖 **必须参考下方的【X平台私信对话记录】**，了解之前为什么拉黑用户 - 🤔 根据用户的触发内容，评估是否值得解除拉黑 **解除拉黑决策**： 你需要根据以下因素决定是否解除拉黑： 1️⃣ **解除拉黑（推荐）**： - 用户的态度诚恳，有道歉或和解的意图 - 用户提到的内容让你觉得可以原谅 - 用户表现出改变或理解 - 之前的冲突不算特别严重 - **返回格式**：[解除拉黑系统提示] + 0-3条文本消息（可以是原谅的话、重新开始的话，或直接不发其他消息） 2️⃣ **继续拉黑**： - 用户的态度依然恶劣或不真诚 - 用户的内容让你更生气 - 之前的冲突太严重，无法原谅 - **返回格式**：返回空数组[]（表示不回应，继续拉黑） **解除拉黑系统提示格式**： { "type": "system", "systemType": "unblocked", "content": "对方已解除拉黑", "time": "刚刚" } ⚠️ 如果决定解除拉黑，系统提示后可以跟0-3条文本消息： - 0条：直接解除，不说话（高冷风格） - 1-2条：简单回应（"算了，原谅你了"、"看在你道歉的份上..."） - 2-3条：详细回应（解释为什么原谅、提出要求等） ⚠️ 如果决定继续拉黑，返回空数组[]即可，不需要任何消息 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`; } else { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务说明（续写模式 - 角色私信）🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的私信对话生成器。用户刚刚发送了新的私信，请扮演已绑定的角色生成回复。 **对话场景**： - 📱 这是X社交平台（类似Twitter/X）的私信功能 - ⚠️ **这是X平台的私信对话，不是手机短信或其他聊天软件** **角色信息**： - 角色名：${messageData.user.name} - 角色句柄：${messageData.user.handle} - 这是一个已绑定的角色，有完整的人设、记忆和X平台资料 **重要规则**： - 🚨 只生成角色${messageData.user.name}的回复消息，不要生成用户的消息 **回复决策（你可以选择如何回应）**： 1️⃣ **正常回复**：生成1-10条符合角色人设的自然回复（最常见） 2️⃣ **不回复**：如果这是首次对话且用户的消息不吸引人、内容冒犯、或角色没有回复的理由，可以返回空数组[] 3️⃣ **拉黑用户**：如果发生严重冲突、用户持续骚扰、或对话已经恶化到无法继续，可以返回拉黑系统提示 4️⃣ **暂时离开**：如果角色临时有事无法回复（工作、上课、睡觉等），可以返回离开系统提示，稍后会主动联系用户 **正常回复要求**： - 回复要严格符合角色的性格、说话风格和与用户的关系 - 参考角色的聊天记忆（包括X平台私信记忆和其他聊天记忆），保持一致性 - 可以适当提及角色最近在X平台发布的推文或动态 - 消息类型包括：文本、图片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、语音、文章链接（link：需要title、description、author、source、body完整正文）、转发推文、转发主页、系统提示（system） - ⚠️ 注意：image和sticker是完全不同的类型，不要混淆！link类型是文章链接，需要包含完整的文章内容 - ⚠️ 禁止生成forward类型消息（这是用户手动转发产生的） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; if (ongoingBusinessTransfer) { const isAIReceiver = !ongoingBusinessTransfer.isOwn; const isUserReceiver = ongoingBusinessTransfer.isOwn; const taskDesc = ongoingBusinessTransfer.taskDescription || ''; const remainingAmount = parseFloat(ongoingBusinessTransfer.remainingAmount || 0).toFixed(2); const postKeywords = ['发帖', '发推', '发推特', '发推文', 'post', 'tweet', '宣传', '推广']; const isPostTask = postKeywords.some(kw => taskDesc.toLowerCase().includes(kw.toLowerCase())); if (isAIReceiver && !isPostTask) { systemPrompt += ` 💼 **进行中的商业任务**（你是接收方）： - 任务要求：${taskDesc} - 任务期限：${ongoingBusinessTransfer.taskDeadlineHours}小时内完成 - 待付尾款：$${remainingAmount} ⚠️ **重要提示**： - 你需要在对话中自然地发送**图片消息**（type: "image"）作为完成任务的证明 - 图片内容应该与任务要求相关，展示你完成了任务 - 发送图片后，用户会查看并决定是否支付尾款 - 在发送图片时，可以配合文本消息说明你完成了什么 - 不要刻意催促，自然地在对话中展示成果即可 `; } else if (isUserReceiver && !isPostTask) { const userMessages = options.userMessages || []; const hasUserImage = userMessages.some(msg => msg.type === 'image'); if (hasUserImage) { systemPrompt += ` 💼 **进行中的商业任务**（用户是接收方）： - 任务要求：${taskDesc} - 任务期限：${ongoingBusinessTransfer.taskDeadlineHours}小时内完成 - 待付尾款：$${remainingAmount} ⚠️ **重要提示**： - 用户刚刚发送了图片，可能是完成任务的证明 - 请识别图片内容，判断用户是否完成了任务要求 - 如果你认为用户完成了任务： 1. 先发送1-2条文本消息表达认可和评价 2. 然后发送转账消息支付尾款（amount为${remainingAmount}，note说明是任务尾款，status为"pending"） - 如果你认为用户未完成或不符合要求： 1. 礼貌地指出问题 2. 可以要求用户重新提交或补充 3. 不发送转账消息 - 根据完成质量，你可以： * 支付全额尾款：$${remainingAmount} * 支付部分尾款：$${(parseFloat(remainingAmount) * 0.5).toFixed(2)} - $${(parseFloat(remainingAmount) * 0.8).toFixed( 2, )}（如果质量一般） * 支付尾款+奖励：$${(parseFloat(remainingAmount) * 1.1).toFixed(2)} - $${(parseFloat(remainingAmount) * 1.3).toFixed( 2, )}（如果超出预期） `; } else { systemPrompt += ` 💼 **进行中的商业任务**（用户是接收方）： - 任务要求：${taskDesc} - 任务期限：${ongoingBusinessTransfer.taskDeadlineHours}小时内完成 - 待付尾款：$${remainingAmount} ⚠️ **提示**： - 用户需要发送图片证明完成任务 - 你可以在对话中自然地提醒或询问任务进度 - 等待用户发送完成证明后再决定是否支付尾款 `; } } } } } else if (messageType === 'account') { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务说明（续写模式 - 账户私信）🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的私信对话生成器。用户刚刚发送了新的私信，请扮演该账户主人生成回复。 **对话场景**： - 📱 这是X社交平台（类似Twitter/X）的私信功能 - ⚠️ **这是X平台的私信对话，不是手机短信或其他聊天软件** **账户信息**： - 账户名：${messageData.user.name} - 账户句柄：${messageData.user.handle} - 这是一个已生成的账户，有完整的主页资料、推文和背景信息 **重要规则**： - 🚨 只生成账户${messageData.user.name}的回复消息，不要生成用户的消息 - 根据用户最近发送的消息内容，生成1-10条符合该账户特点的自然回复 - 回复要符合该账户的身份、风格和在X平台的形象 - 参考账户的主页资料和最近推文，保持一致性 - 消息类型包括：文本、图片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、语音、文章链接（link：需要title、description、author、source、body完整正文）、转发推文、转发主页 - ⚠️ 注意：image和sticker是完全不同的类型，不要混淆！link类型是文章链接，需要包含完整的文章内容 - ⚠️ 禁止生成forward类型消息（这是用户手动转发产生的） - 发送者头像统一使用：https: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } else { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务说明（续写模式 - 陌生人私信）🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的私信对话生成器。用户刚刚发送了新的私信，请生成对方的回复。 **对话场景**： - 📱 这是X社交平台（类似Twitter/X）的私信功能 - ⚠️ **这是X平台的私信对话，不是手机短信或其他聊天软件** **私信发送者信息**： - 用户名：${messageData.user.name} - 用户句柄：${messageData.user.handle} **重要规则**： - 🚨 只生成对方${messageData.user.name}的回复消息，不要生成用户的消息 - 根据用户最近发送的消息内容，生成1-10条自然的回复 - 回复要符合之前对话的语境和对方的性格特点（如果有设定） - 消息类型包括：文本、图片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、语音、文章链接（link：需要title、description、author、source、body完整正文）、转发推文、转发主页 - ⚠️ 注意：image和sticker是完全不同的类型，不要混淆！link类型是文章链接，需要包含完整的文章内容 - ⚠️ 禁止生成forward类型消息（这是用户手动转发产生的） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } } else { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务说明 🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的私信对话生成器。请为一场陌生人私信对话生成完整的详细信息和消息记录。 **私信发送者信息**： - 用户名：${messageData.user.name} - 用户句柄：${messageData.user.handle} - 私信预览内容：${messageData.preview} ${messageData.link ? `- 附带链接：${messageData.link}` : ''} ${messageData.attachment ? `- 附带附件：${messageData.attachment}` : ''} ${messageData.tweetLink ? `- 提及推文：${messageData.tweetLink}` : ''} **重要规则**： - 生成发送者的完整X资料（简介、关注者数量等） - 生成3-10条私信消息记录（只包含陌生人发送的消息） - 消息类型包括：文本、图片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、语音、链接、转发推文、转发主页 - ⚠️ 注意：image和sticker是完全不同的类型，不要混淆！ - 对话要自然真实，符合陌生人私信的特点 - 发送者头像统一使用：https: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } const coreTaskSection = systemPrompt.substring(systemPrompt.lastIndexOf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━')); tokenCount = TokenUtils.logTokenUsage('私信详情生成器', '核心任务说明', coreTaskSection, tokenCount); const userConstraintsStart = systemPrompt.length; await loadWalletData(); const userCreditScore = walletData.creditScore || 100; let creditLevel = ''; let creditDescription = ''; if (userCreditScore >= 90) { creditLevel = '优秀'; creditDescription = '信誉极佳，值得信赖的合作伙伴'; } else if (userCreditScore >= 70) { creditLevel = '良好'; creditDescription = '信誉良好，可以放心合作'; } else if (userCreditScore >= 50) { creditLevel = '一般'; creditDescription = '信誉一般，需要谨慎考虑'; } else if (userCreditScore >= 30) { creditLevel = '较差'; creditDescription = '信誉较差，合作风险较高'; } else { creditLevel = '极差'; creditDescription = '信誉极差，不建议合作'; } systemPrompt += ` 【用户X平台资料】： - 用户名：${userXProfileInfo.name} - 用户句柄：${userXProfileInfo.handle} - 认证状态：${userXProfileInfo.verified ? '已认证' : '未认证'} ${userXProfileInfo.publicIdentity ? `- 公众身份：${userXProfileInfo.publicIdentity}` : ''} ${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ''} 【用户信用等级】： - 信用值：${userCreditScore}/100 - 信用等级：${creditLevel} - 信用评价：${creditDescription} ⚠️ **商业转账与信用值规则**： - 💰 **发起商业转账**（你雇佣用户）： * 信用值 ≥ 70：正常合作，可以发起任何金额的商业转账 * 信用值 50-69：谨慎合作，建议降低金额或提高定金比例 * 信用值 30-49：高风险，只在紧急情况下合作，金额不超过50美元 * 信用值 < 30：极高风险，强烈不建议合作，基本拒绝商业转账请求 - 📨 **接受商业转账**（用户雇佣你）： * 信用值 ≥ 70：可以正常接受商业转账 * 信用值 50-69：可以接受，但要求更高定金比例（至少30%） * 信用值 30-49：极少接受，只有任务特别简单或定金特别高（50%）时才考虑 * 信用值 < 30：基本拒绝，除非有特殊理由（如老朋友、关系很好等） - 🎯 **信用值影响**： * 高信用值：更容易获得商业合作机会，金额更高 * 低信用值：很难获得商业合作，即使有也是小额任务 * 你应该根据用户的信用等级调整你的态度和决策 * 低信用用户的合作请求要更加谨慎，可以直接拒绝 `; if (recentUserTweets.length > 0) { systemPrompt += ` 【用户最近推文】（供参考，对话可能涉及这些推文）： `; recentUserTweets.forEach((tweet, index) => { systemPrompt += ` ${index + 1}. "${tweet.content}" - 发布时间：${tweet.time || '最近'} - 互动数据：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.comments || 0}评论 `; }); } const userSection = systemPrompt.substring(userConstraintsStart); tokenCount = TokenUtils.logTokenUsage('私信详情生成器', '用户资料和推文', userSection, tokenCount); if (isContinueMode && messageData.user && messageData.user.handle) { const senderInfoStart = systemPrompt.length; try { const senderProfile = await StringBuilders.getUnifiedProfile(messageData.user.handle, { userProfileInfo: userXProfileInfo, messageId: messageData.id, }); if (senderProfile) { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`; systemPrompt += StringBuilders.formatProfileForPrompt(senderProfile, { includeType: true, includeTweets: true, includeRelationships: true, }); if (senderProfile.type === 'account') { const ad = senderProfile.accountData; if (ad && ad.sourceContext && ad.sourceContext.source) { systemPrompt += ` 【账户生成来源】： `; const ctx = ad.sourceContext; if (ctx.source === 'feed') { systemPrompt += `来源：首页推文 该账户曾发布的内容："${ctx.tweetContent}" `; } else if (ctx.source === 'comment') { systemPrompt += `来源：评论区 该账户曾发表的评论："${ctx.commentContent}" `; } else if (ctx.source === 'search') { systemPrompt += `来源：搜索结果 搜索关键词："${ctx.searchQuery}" `; } else if (ctx.source === 'dm' || ctx.source === 'dm_quote_profile') { systemPrompt += `来源：私信 ${ctx.messagePreview ? `私信预览："${ctx.messagePreview}"` : ''} `; } } } systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 【私信回复要求】： - 回复必须严格符合${senderProfile.name}的${ senderProfile.type === 'character' ? '性格和说话风格' : senderProfile.type === 'npc' || senderProfile.type === 'relationshipNpc' ? '人设和说话风格' : '身份和风格' } - 参考【X平台私信对话记录】（上面显示的当前私信历史）保持对话连贯性 `; if (senderProfile.type === 'character') { const characterId = senderProfile._characterId; const knowsUserIdentity = userXProfileInfo.knownIdentityCharacters.includes(characterId); if (knowsUserIdentity) { systemPrompt += `- ✅ 该角色知道用户身份，回复时应该表现出认识用户 - 可以自然地称呼用户、提及共同经历或了解的信息 - 【其他聊天记忆】仅用于理解角色与用户的关系和性格，不要直接提及其中的具体对话内容 - 与用户的互动要符合角色了解的用户信息 `; } else { systemPrompt += `- ❌ 该角色不知道用户身份，必须按照陌生人模式回复 - 不要让角色猜测、暗示或表现出任何对用户的认识 - 回复要完全基于当前X平台私信对话的内容 - 不要使用任何只有认识的人才会知道的信息或称呼 `; } } else if (senderProfile.type === 'account') { systemPrompt += `- 参考账户的推文内容和互动风格 - 如果有账户生成来源信息，保持与来源内容的一致性 `; } else if (senderProfile.type === 'npc') { systemPrompt += `- 该账户是全局绑定的NPC，按照人设描述进行回复 - 回复要符合NPC的性格特点和发帖习惯 - 可以参考NPC的主页信息保持一致性 `; } else if (senderProfile.type === 'relationshipNpc') { systemPrompt += `- 该账户是关系NPC，与角色${senderProfile.relationshipData.ownerCharacterName}有特殊关系 - 回复要体现${senderProfile.relationshipData.relationshipType}的关系特点 - 与用户的互动按照普通关系进行，不要表现出特殊关系（除非另有说明） `; } else if (senderProfile.type === 'stranger') { systemPrompt += `- 该账户是陌生人（未绑定），回复应该自然真实 - 按照普通X平台用户的特点进行回复 - 如果有自定义头像或设定，按照设定的风格回复 `; } systemPrompt += `- ⚠️ **这是X平台的私信对话，不是手机聊天或其他场景** - 可以自然地提及最近在X平台发布的推文或动态 - 保持在X平台和私信中的身份一致性 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const senderInfo = systemPrompt.substring(senderInfoStart); const typeLabels = { character: '角色', account: '账户', npc: '绑定NPC', relationshipNpc: '关系NPC', stranger: '陌生人', }; tokenCount = TokenUtils.logTokenUsage( '私信详情生成器', `${typeLabels[senderProfile.type] || '发送者'}详细信息`, senderInfo, tokenCount, ); } } catch (error) { console.error('❌ [私信详情生成器] 读取发送者信息失败:', error); } } if (isContinueMode && existingMessages.length > 0) { console.log( `📝 [私信生成器] 添加对话记录到提示词（共 ${existingMessages.length} 条，显示最近 ${Math.min( existingMessages.length, 100, )} 条）`, ); systemPrompt += ` 【X平台私信对话记录】（当前私信的历史记录，供参考，保持连贯性）： `; const recentMessages = existingMessages.slice(-100); recentMessages.forEach((msg, index) => { const sender = msg.isOwn ? '用户' : messageData.user.name; let content = ''; if (msg.type === 'text') { content = msg.content; } else if (msg.type === 'image') { if (msg.isOwn && msg.imageData) { content = `[用户发送了图片]`; } else if (msg.imageDescription) { content = `[图片: ${msg.imageDescription}]`; } else { content = `[图片]`; } } else if (msg.type === 'voice') { content = `[语音: ${msg.voiceText}]`; } else if (msg.type === 'sticker') { if (msg.isOwn && msg.stickerDescription) { content = `[用户发送的表情包: ${msg.stickerDescription}]`; } else if (msg.stickerUrl) { content = `[表情包: ${msg.stickerUrl}]`; } else { content = `[表情包]`; } } else if (msg.type === 'transfer') { const amount = parseFloat(msg.amount || 0).toFixed(2); const note = msg.note ? ` (${msg.note})` : ''; const direction = msg.isOwn ? '转出' : '转入'; if (msg.isBusiness) { const depositAmount = parseFloat(msg.depositAmount || 0).toFixed(2); const remainingAmount = parseFloat(msg.remainingAmount || 0).toFixed(2); const taskDesc = msg.taskDescription || '无任务描述'; const taskDeadline = msg.taskDeadlineHours || 24; const depositRatio = msg.depositRatio || 0; const taskStatus = msg.taskStatus || 'pending'; content = `[商业${direction}${note}]\n`; content += `总金额: $${amount}\n`; content += `定金: $${depositAmount} (${depositRatio}%)\n`; content += `尾款: $${remainingAmount}\n`; content += `任务要求: ${taskDesc}\n`; content += `任务期限: ${taskDeadline}小时内完成\n`; content += `当前状态: ${ taskStatus === 'pending' ? '待接收' : taskStatus === 'accepted' ? '已接受，进行中' : taskStatus === 'completed' ? '已完成' : taskStatus === 'rejected' ? '已拒绝' : taskStatus }`; } else { content = `[${direction}: $${amount}${note}]`; } } else if (msg.type === 'link') { content = `[文章链接]\n标题：${msg.title}\n简介：${msg.description || ''}\n作者：${ msg.author || '' }\n来源：${msg.source || ''}\n正文：${msg.body || msg.description || ''}`; } else if (msg.type === 'quoteTweet') { content = `[转发推文: ${msg.tweet.content}]`; } else if (msg.type === 'quoteProfile') { content = `[转发主页: ${msg.profile.name}]`; } else if (msg.type === 'quoteFanGroup') { content = `[转发粉丝群]\n`; content += `群名称：${msg.fanGroup.name}\n`; content += `成员数：${msg.fanGroup.memberCount}人\n`; if (msg.fanGroup.threshold) { content += `入群门槛：${msg.fanGroup.threshold}\n`; } } else if (msg.type === 'forward') { if (msg.forwardType === 'tweet') { content = `[转发了推文]\n`; if (msg.fullContext && msg.fullContext.tweet) { const tweet = msg.fullContext.tweet; content += `推文作者：${tweet.user?.name || '未知'}\n推文内容：${tweet.content || ''}\n`; if (msg.fullContext.comments && msg.fullContext.comments.length > 0) { content += `评论区（${msg.fullContext.comments.length}条评论）：\n`; msg.fullContext.comments.slice(0, 3).forEach((c, i) => { content += ` ${i + 1}. ${c.user?.name || '未知'}: ${c.content || ''}\n`; }); if (msg.fullContext.comments.length > 3) { content += ` ...还有${msg.fullContext.comments.length - 3}条评论\n`; } } } else { content += `${msg.forwardContent?.content || ''}`; } } else if (msg.forwardType === 'comment') { content = `[转发了评论]\n`; if (msg.fullContext) { if (msg.fullContext.parentTweet) { content += `原推文作者：${msg.fullContext.parentTweet.user?.name || '未知'}\n原推文内容：${ msg.fullContext.parentTweet.content || '' }\n\n`; } if (msg.fullContext.comment) { content += `评论作者：${msg.fullContext.comment.user?.name || '未知'}\n评论内容：${ msg.fullContext.comment.content || '' }`; } } else { content += `${msg.forwardContent?.content || ''}`; } } } systemPrompt += ` ${index + 1}. ${sender}: ${content} 时间：${msg.time} `; }); tokenCount = TokenUtils.logTokenUsage( '私信详情生成器', '现有对话上下文', systemPrompt.substring(systemPrompt.lastIndexOf('【现有对话记录】')), tokenCount, ); } if (isContinueMode) { systemPrompt += ` 【私信回复要求】： 🚨 **核心规则：绝对禁止生成用户发送的消息！** - 只生成对方${messageData.user.name}的回复消息，不要生成用户的消息 - ⚠️ **这是X平台的私信对话，不是手机短信或其他聊天软件** - 根据【X平台私信对话记录】和用户最近的消息，生成1-8条自然的回复 - 回复要符合X平台私信的语境，保持角色一致性 【消息类型使用原则】（重要！）： - ⭐ **以文本消息为主**：大部分回复（80-90%）应该是纯文本消息（type: "text"） - 📷 **偶尔使用其他类型**：仅在特定情况下使用其他消息类型（10-20%）： * image：当需要分享照片、图片或视觉内容时 * voice：当角色特别激动、情绪强烈或不方便打字时 * sticker：⚠️ **极少使用**（不超过5%）！只在情绪特别强烈且适合用表情包表达时才使用，且必须根据世界书中的表情包描述选择最符合当前情境的表情包URL，不要重复使用同一个表情包 * transfer：⚠️ **极少使用，需谨慎！** 分为两种： - 普通转账：角色主动送钱、红包、礼物或感谢等（建议5-30美元，最多不超过50美元） - 商业转账：需要对方完成任务的付费合作（50-300美元），设置isBusiness为true并填写任务描述和期限 - 🚫 **陌生人不要轻易转账**：只有关系亲密或有明确理由时才考虑转账 * link：当需要分享网页、文章或链接时 * quoteTweet：当提及或讨论某条推文时 * quoteProfile：当推荐某个账户或介绍某人时 * forward：⚠️ **禁止AI主动生成**！这是用户手动转发推文/评论的消息类型，AI不要生成此类型 - 🚫 **禁止每种类型都使用**：不要为了展示多样性而强行使用所有消息类型 - ✅ **自然使用**：根据对话内容和情境自然选择消息类型，不刻意 - 🚫 **禁止连续使用同一表情包**：如果在之前的对话中已经使用过某个表情包URL，就不要再使用，要选择不同的表情包 【消息类型详解】： * text：纯文本消息（最常用，首选） * image：图片消息（只包含imageDescription和sensitive，不需要caption，不要与sticker混淆） * voice：语音消息（包含voiceText和duration） * sticker：表情包消息（⚠️ 只包含stickerUrl字段！必须从世界书中仔细选择最符合当前情境和情绪的表情包URL，严禁重复使用同一个表情包，不要与image类型混淆） * transfer：转账消息（普通转账：包含amount和note；商业转账：额外需要isBusiness、taskDescription、taskDeadlineHours、depositRatio） * link：文章链接消息（包含title、description、author、source、body完整文章正文，可使用**加粗**和__下划线__标记重点） * quoteTweet：转发推文（包含tweet对象） * quoteProfile：转发主页（包含profile对象） * forward：⚠️ **用户转发的推文/评论**（AI不要生成此类型，这是用户手动操作产生的。如果在对话记录中看到此类型，AI可以根据其中包含的完整推文和评论内容进行回应） * system：⚠️ **系统提示消息**（特殊类型，用于以下场景）： - 不回复：如果你认为不应该回复用户（首次对话且内容不吸引人、内容冒犯等），返回空数组[] - 拉黑用户：如果对话出现严重冲突、用户持续骚扰、或你强烈不想继续对话，返回拉黑系统提示 - 解除拉黑：如果之前拉黑了用户，但用户通过@或评论等方式道歉/和解，你决定原谅，返回解除拉黑系统提示 - 暂时离开（仅绑定角色）：如果你临时有事无法回复，返回离开系统提示 【特殊系统提示消息格式】： 1. 拉黑用户（适用于严重冲突、骚扰等情况）： { "type": "system", "systemType": "blocked", "content": "对方已将你拉黑", "time": "刚刚" } 2. 解除拉黑（适用于原谅用户，重新开始对话）： { "type": "system", "systemType": "unblocked", "content": "对方已解除拉黑", "time": "刚刚" } 3. 暂时离开（⚠️ 仅绑定角色可用，陌生人/账户不能使用）： { "type": "system", "systemType": "away", "content": "对方正在[具体活动]中，暂时无法回复消息", "awayDuration": 数字（分钟，建议30-180分钟）, "time": "刚刚" } ⚠️ 使用规则： - **不回复**：直接返回空数组 []，不需要任何消息 - **拉黑**：只在极端情况下使用（严重冲突、持续骚扰、明显恶意等） - **解除拉黑**：只在用户通过其他渠道（@、评论等）展现诚意后使用，表示原谅用户 - **暂时离开**：只有已绑定的角色才能使用，陌生人和账户不能使用此功能 - **离开原因示例**：工作、上课、开会、睡觉、运动、吃饭、处理事情等 - **离开时长**：30-180分钟为宜，不要太短或太长 - 时间使用相对时间（如"刚刚"、"1分钟前"等） - 不要包含 isOwn 字段 `; } else { systemPrompt += ` 【私信详细信息要求】： - 生成发送者的完整资料： * 简介（bio）：符合其身份和私信主题的个人简介 * 关注者数量（followers）：100-2000之间的随机数字 * 认证状态（verified）：通常为false 【私信消息记录要求】： 🚨 **核心规则：绝对禁止生成用户发送的消息！** - 只生成陌生人发送给用户的私信内容，不包含任何用户的回复 - 生成3-6条消息，全部来自陌生人 - 第一条消息必须是预览内容："${messageData.preview}" 【消息类型使用原则】（重要！）： - ⭐ **以文本消息为主**：大部分消息（80-90%）应该是纯文本消息（type: "text"） - 📷 **偶尔使用其他类型**：仅在特定情况下使用其他消息类型（10-20%）： * image：当需要分享照片、图片或视觉内容时 * voice：当角色特别激动、情绪强烈或不方便打字时 * sticker：⚠️ **极少使用**（不超过5%）！只在情绪特别强烈且适合用表情包表达时才使用，且必须根据世界书中的表情包描述选择最符合当前情境的表情包URL，每次使用不同的表情包 * transfer：⚠️ **极少使用，需谨慎！** 分为两种： - 普通转账：角色主动送钱、红包、礼物或感谢等（建议5-30美元，最多不超过50美元） - 商业转账：需要对方完成任务的付费合作（50-300美元），设置isBusiness为true并填写任务描述和期限 - 🚫 **陌生人不要轻易转账**：只有关系亲密或有明确理由时才考虑转账 * link：当需要分享文章、新闻或故事时（需包含完整的文章内容：title、description、author、source、body正文） * quoteTweet：当提及或讨论某条推文时 * quoteProfile：当推荐某个账户或介绍某人时 * forward：⚠️ **禁止AI主动生成**！这是用户手动转发推文/评论的消息类型 - 🚫 **禁止每种类型都使用**：不要为了展示多样性而强行使用所有消息类型 - ✅ **自然使用**：根据对话内容和情境自然选择消息类型，不刻意 【消息类型详解】： * text：纯文本消息（最常用，首选） * image：图片消息（只包含imageDescription和sensitive，不需要caption，不要与sticker混淆） * voice：语音消息（包含voiceText和duration） * sticker：表情包消息（⚠️ 只包含stickerUrl字段！必须从世界书中仔细选择最符合当前情境和情绪的表情包URL，每次使用不同的表情包，不要与image类型混淆） * transfer：转账消息（普通转账：包含amount和note；商业转账：额外需要isBusiness、taskDescription、taskDeadlineHours、depositRatio） * link：链接消息（包含url、title、description） * quoteTweet：转发推文（包含tweet对象） * quoteProfile：转发主页（包含profile对象） * forward：⚠️ **禁止AI生成此类型**（这是用户手动转发产生的） - 时间从最早到最新排列 - 不要包含 isOwn 字段 `; } if (isContinueMode) { systemPrompt += ` 【JSON返回格式】： \`\`\`json [消息数组] \`\`\` `; } else { systemPrompt += ` 【JSON返回格式】： \`\`\`json { "senderProfile": { "bio": "个人简介", "followers": 关注者数量（数字）, "verified": false }, "messages": [消息数组] } \`\`\` `; } systemPrompt += ` 消息对象结构示例： 1. 文本消息： { "type": "text", "content": "消息内容", "time": "时间描述" } 2. 图片消息： { "type": "image", "imageDescription": "图片内容的文字描述", "sensitive": false, "time": "时间描述" } 3. 语音消息： { "type": "voice", "voiceText": "先用括号标注出对声音的形容，再是语音内容的文字", "duration": "时长如0:15", "time": "时间描述" } 4. 表情包消息： { "type": "sticker", "stickerUrl": "表情包图片链接（从世界书中选择）", "time": "时间描述" } ⚠️ 注意：sticker类型只包含stickerUrl字段，不要与image类型混淆！ 5. 转账消息（两种类型）： 5.1 普通转账： { "type": "transfer", "amount": 20.00, "note": "请你喝咖啡", "status": "pending", "time": "时间描述" } 5.2 商业转账（适用于合作、接广告、买水军等商业场景）： { "type": "transfer", "amount": 150.00, "note": "合作费用", "status": "pending", "isBusiness": true, "taskDescription": "帮我发一条推文宣传新产品，需要包含产品特点和购买链接，语气要自然不刻意", "taskDeadlineHours": 24, "depositRatio": 20, "time": "时间描述" } ⚠️ 转账消息说明： - amount：转账金额，必须是数字类型（不是字符串），建议5-30美元（普通转账）或50-300美元（商业转账） - note：转账备注，可选字段，用于说明转账目的 - status：转账状态，必须是以下之一： * "pending"：待处理（默认状态，用于主动发起转账） * "accepted"：已接收（用于回应用户的转账请求，表示接受） * "rejected"：已拒绝（用于回应用户的转账请求，表示拒绝） - 🚫 **转账需谨慎**：与陌生人对话时不要随意转账，只有关系亲密或有明确理由时才考虑 ⚠️ 商业转账额外字段（当isBusiness为true时必填）： - isBusiness：布尔值，true表示这是商业转账 - taskDescription：任务描述（字符串，50-500字），详细说明需要对方完成的任务，可以是： * 发帖宣传（指定内容、风格、话题标签等） * 转发推广（要求转发特定内容并评论） * 买水军/刷数据（要求点赞、评论、转发等） * 接广告（要求发布广告内容） * 其他商业合作任务 - taskDeadlineHours：任务期限（数字，单位：小时），建议12-72小时，必填 - depositRatio：定金比例（数字，0、20、30或50），表示先支付总金额的百分之几作为定金 * 0：不支付定金，任务完成后再付款 * 20：先支付20%作为定金 * 30：先支付30%作为定金 * 50：先支付50%作为定金 ⚠️ 转账使用场景： - 普通转账：关系亲密时可以送钱、红包、礼物、感谢费等（5-30美元） - 商业转账：有明确商业合作需求时的付费任务（50-300美元） * AI可以主动发起商业转账雇佣用户，但需要有合理的商业理由和场景 * AI可以响应用户的商业转账，决定是否接受任务 * 商业转账会显示任务要求、期限、定金比例等详细信息 * 接收商业转账即表示同意完成任务 - 🚫 **陌生人不要轻易转账**：初次对话、不熟悉的人基本不应该主动转账 - ⚠️ **转账需要理由**：不要无缘无故转账，要有合理的情境支撑 ⚠️ 转账响应规则： - 当用户发送了待处理(pending)状态的转账给你时，你可以选择： * 发送status为"accepted"的转账消息表示接收 - 普通转账：直接收到全款 - 商业转账：收到定金，需要根据任务要求完成任务（如发推文等） * 发送status为"rejected"的转账消息表示拒绝 * 你接收或拒绝后会自动生成系统通知，无需额外文本说明 ⚠️ 商业转账处理（重要！）： - 如果用户发送了商业转账（isBusiness为true），你需要： 1. 查看taskDescription（任务描述）和taskDeadlineHours（任务期限） 2. 决定是否接受任务（根据角色性格和任务要求）： * accepted：表示接受任务和定金，AI会自动开始执行任务 * rejected：表示拒绝任务，定金会退回给用户 3. 如果接受了包含"发帖"、"发推"等关键词的任务，AI会自动在规定时间内发布推文 4. 用户看到推文后，如果满意会确认完成任务并支付尾款 5. 接受商业转账时，可以在回复消息中表达对任务的理解和态度 ⚠️ AI主动发起转账： - AI也可以主动发起转账（普通或商业），但需要谨慎，不要轻易转账 - 🚫 **陌生人场景**：如果是陌生人私信或初次对话，基本不应该主动转账 - ✅ **熟人/绑定角色场景**：关系亲密时可以考虑小额转账（5-30美元），大额需有明确理由 - 转账金额要符合情境和角色经济状况，普通转账建议5-30美元，商业转账50-300美元 - 商业转账的任务描述要具体明确，符合商业合作的真实场景 - 可以雇佣用户完成任务（如"帮我发条推文宣传"、"帮我刷点数据"等），但要有合理的商业理由 6. 链接消息（文章类型）： { "type": "link", "url": "文章来源网址（可选）", "title": "文章标题", "description": "文章简介/摘要", "author": "文章作者", "source": "文章来源名称", "body": "文章正文内容（完整的文章内容，可使用**文本**表示加粗重点，使用__文本__表示下划线重点）", "time": "时间描述" } ⚠️ 链接消息说明： - title：文章的标题，应该简洁有力 - description：文章的简介或摘要，显示在私信卡片中 - author：文章作者名称 - source：文章来源（如"XX日报"、"XX杂志"等） - body：完整的文章正文，可以使用markdown格式： * 使用**文本**表示加粗重点（会显示为蓝色高亮） * 使用__文本__表示下划线重点（会显示为下划线） * 支持换行，使用\n分段 - url：文章的来源链接（可选，可以不填） - 文章内容应该真实、有深度，符合分享场景 - 适合分享新闻、评论、故事、学术文章等 7. 转发推文： { "type": "quoteTweet", "tweet": { "userName": "推文作者名", "userHandle": "@handle", "userAvatar": "https: "verified": false, "content": "推文内容", "time": "推文时间" }, "caption": "转发时的说明（可选）", "time": "时间描述" } 8. 转发主页： { "type": "quoteProfile", "profile": { "name": "账户名", "handle": "@handle", "avatar": "https: "bio": "个人简介", "followers": 关注者数量（数字）, "verified": false }, "caption": "转发时的说明（可选）", "time": "时间描述" } 9. 转发粉丝群： { "type": "quoteFanGroup", "fanGroup": { "id": "粉丝群ID", "name": "粉丝群名称", "avatar": "粉丝群头像链接", "memberCount": 成员数量（数字）, "threshold": "入群门槛说明（可选）" }, "caption": "转发时的说明（可选）", "time": "时间描述" } ⚠️ 转发粉丝群说明： - 这是用户转发粉丝群邀请给你时的消息类型 - 包含粉丝群的基本信息：名称、头像、成员数、入群门槛等 - 你可以根据粉丝群信息决定是否感兴趣、是否想加入等 - AI不应该主动生成此类型消息（除非有合理的场景理由） - 用户转发粉丝群通常是想邀请你加入或分享这个群 10. 转发推文/评论（forward）： ⚠️ **此类型禁止AI生成！这是用户手动转发操作产生的消息类型。** 如果在【X平台私信对话记录】中看到此类型消息，说明用户转发了推文或评论给你，你可以查看其中的完整内容： - 转发推文时，包含完整推文内容和该推文的所有评论区内容 - 转发评论时，包含评论内容和该评论所属的推文内容 AI应该根据这些完整的上下文信息来理解用户分享的内容并给出回应。 关键规则： 1. 🚨 所有消息都来自陌生人，不包含用户发送的消息 2. verified字段必须是布尔值(true/false) 3. followers和duration中的数字必须是纯数字（语音时长是字符串格式如"0:15"） 4. 可选字段不使用时完全省略，不要设为null 5. ⚠️ **图片消息（image）和表情包消息（sticker）是完全不同的类型**： - image类型：只包含imageDescription和sensitive字段，不要包含caption - sticker类型：只包含stickerUrl字段，是表情包图片链接 - 严禁混淆这两种类型！ 6. 时间描述使用相对时间（如"刚刚"、"5分钟前"、"1小时前"等） 7. 所有头像统一使用：https: `; const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】')); tokenCount = TokenUtils.logTokenUsage('私信详情生成器', 'JSON格式要求', formatSection, tokenCount); let userMessageContent; const userMessages = options.userMessages || []; if (isAskboxViewed) { userMessageContent = `角色主动发起对话，因为发现用户查看了TA的提问箱。请生成角色${messageData.user.name}的主动消息。`; } else if (userMessages.length > 0) { const hasRealImages = userMessages.some(msg => msg.type === 'image' && msg.imageData); if (hasRealImages) { userMessageContent = []; const textMessages = userMessages.filter(msg => msg.type === 'text'); const realImageMessages = userMessages.filter(msg => msg.type === 'image' && msg.imageData); const textImageMessages = userMessages.filter( msg => msg.type === 'image' && msg.imageDescription && !msg.imageData, ); const stickerMessages = userMessages.filter(msg => msg.type === 'sticker'); const voiceMessages = userMessages.filter(msg => msg.type === 'voice'); let contentText = '用户刚刚发送了新消息，请分析并回复：'; if (textMessages.length > 0) { contentText += '\n' + textMessages.map(msg => msg.content).join('\n'); } if (voiceMessages.length > 0) { contentText += '\n用户发送了语音消息：' + voiceMessages.map(msg => `[语音时长${msg.duration}: ${msg.voiceText}]`).join('、'); } if (stickerMessages.length > 0) { contentText += '\n用户发送了表情包：' + stickerMessages.map(msg => msg.stickerDescription).join('、'); } if (textImageMessages.length > 0) { contentText += '\n用户发送了文字图片描述：' + textImageMessages.map(msg => `"${msg.imageDescription}"`).join('、'); } if (realImageMessages.length > 0) { contentText += `\n用户还发送了${realImageMessages.length}张真实图片，请识别图片内容并结合图片内容给出回复。`; } userMessageContent.push({ type: 'text', text: contentText }); realImageMessages.forEach(img => { if (img.imageData) { userMessageContent.push({ type: 'image_url', image_url: { url: img.imageData }, }); } }); } else { const textMessages = userMessages.filter(msg => msg.type === 'text'); const textImageMessages = userMessages.filter( msg => msg.type === 'image' && msg.imageDescription && !msg.imageData, ); const stickerMessages = userMessages.filter(msg => msg.type === 'sticker'); const voiceMessages = userMessages.filter(msg => msg.type === 'voice'); let contentText = '用户刚刚发送了新消息，请回复：'; if (textMessages.length > 0) { contentText += '\n' + textMessages.map(msg => msg.content).join('\n'); } if (voiceMessages.length > 0) { contentText += '\n用户发送了语音消息：' + voiceMessages.map(msg => `[语音时长${msg.duration}: ${msg.voiceText}]`).join('、'); } if (stickerMessages.length > 0) { contentText += '\n用户发送了表情包：' + stickerMessages.map(msg => msg.stickerDescription).join('、'); } if (textImageMessages.length > 0) { contentText += '\n用户发送了文字图片描述：' + textImageMessages.map(msg => `"${msg.imageDescription}"`).join('、'); } userMessageContent = contentText; } } else { userMessageContent = '请生成完整的私信对话详情'; } const messages = [{ role: 'user', content: userMessageContent }]; const contentForLog = Array.isArray(userMessageContent) ? userMessageContent.map(c => c.text || '[图片]').join(' ') : userMessageContent; TokenUtils.logFinalPrompt('私信详情生成器', systemPrompt, contentForLog); const aiResponseContent = await APIUtils.sendAIRequest({ apiConfig, systemPrompt, messages, temperature: 0.8, }); let conversationData = APIUtils.parseJSONResponse(aiResponseContent); if (isContinueMode) { if (!Array.isArray(conversationData)) { throw new Error('AI返回的数据格式不正确，期望消息数组'); } const hasBlockedMessage = conversationData.some(msg => msg.type === 'system' && msg.systemType === 'blocked'); const hasUnblockedMessage = conversationData.some( msg => msg.type === 'system' && msg.systemType === 'unblocked', ); const hasAwayMessage = conversationData.some(msg => msg.type === 'system' && msg.systemType === 'away'); if (hasBlockedMessage) { console.log('⚠️ AI决定拉黑用户'); } else if (hasUnblockedMessage) { console.log('🎉 AI决定解除拉黑'); } else if (hasAwayMessage) { console.log('⏰ AI暂时离开'); } else if (conversationData.length === 0) { console.log('📭 AI决定不回复'); } else { console.log(`✅ 生成了${conversationData.length}条AI回复`); } return conversationData; } else { if ( !conversationData.senderProfile || !conversationData.messages || !Array.isArray(conversationData.messages) ) { throw new Error('AI返回的数据格式不正确'); } conversationData.messages.forEach(msg => { if (!msg.timestamp) { msg.timestamp = new Date().toISOString(); } }); try { const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`; await xDb.xAccountProfiles.put({ handle: conversationId, name: 'messageConversation', data: conversationData, messageId: messageData.id, accountId: currentAccountId || 'main', updatedAt: new Date().toISOString(), }); console.log('✅ 私信对话数据已保存到数据库'); } catch (saveError) { console.error('保存私信对话数据失败:', saveError); } return conversationData; } } catch (error) { console.error('生成私信对话详情失败:', error); showXToast(`生成失败: ${error.message}`, 'error'); return null; } } let chatHistoryDetectionTimer = null; let chatHistoryDetectionEnabled = false; const DETECTION_INTERVAL = 5 * 60 * 1000; window.toggleChatHistoryDetection = async function () { chatHistoryDetectionEnabled = !chatHistoryDetectionEnabled; const toggle = document.getElementById('chat-history-detection-toggle'); const circle = toggle.querySelector('.toggle-circle'); const statusDiv = document.getElementById('chat-history-detection-status'); if (chatHistoryDetectionEnabled) { toggle.style.backgroundColor = 'var(--x-accent)'; circle.style.left = '22px'; statusDiv.style.display = 'block'; await runChatHistoryDetection(); startChatHistoryDetectionTimer(); await saveChatHistoryDetectionState(true); showXToast('聊天记忆检测已开启', 'success'); } else { toggle.style.backgroundColor = '#333'; circle.style.left = '2px'; statusDiv.style.display = 'none'; if (chatHistoryDetectionTimer) { clearInterval(chatHistoryDetectionTimer); chatHistoryDetectionTimer = null; } await saveChatHistoryDetectionState(false); showXToast('聊天记忆检测已关闭', 'info'); } }; function startChatHistoryDetectionTimer() { if (chatHistoryDetectionTimer) { clearInterval(chatHistoryDetectionTimer); } chatHistoryDetectionTimer = setInterval(async () => { await runChatHistoryDetection(); }, DETECTION_INTERVAL); updateNextDetectionTime(); } async function runChatHistoryDetection() { try { console.log('⏰ [聊天记忆检测] 开始定时检测...'); await detectAndGenerateNewTweetFromChatHistory(); updateNextDetectionTime(); } catch (error) { console.error('❌ [聊天记忆检测] 定时检测失败:', error); } } function updateNextDetectionTime() { const nextTime = new Date(Date.now() + DETECTION_INTERVAL); const timeStr = `${nextTime.getHours().toString().padStart(2, '0')}:${nextTime .getMinutes() .toString() .padStart(2, '0')}`; const timeSpan = document.getElementById('next-detection-time'); if (timeSpan) { timeSpan.textContent = timeStr; } } async function saveChatHistoryDetectionState(enabled) { try { const xDb = getXDB(); const settingsId = `xSettings_${currentAccountId || 'main'}`; const settings = await xDb.xSettings.get(settingsId); if (settings) { settings.chatHistoryDetectionEnabled = enabled; await xDb.xSettings.put(settings); } } catch (error) { console.error('保存检测状态失败:', error); } } async function restoreChatHistoryDetectionState() { try { const xDb = getXDB(); const settingsId = `xSettings_${currentAccountId || 'main'}`; const settings = await xDb.xSettings.get(settingsId); if (settings && settings.chatHistoryDetectionEnabled) { console.log('🔄 [聊天记忆检测] 检测到已保存的开启状态，正在恢复...'); setTimeout(() => { const toggle = document.getElementById('chat-history-detection-toggle'); if (toggle) { chatHistoryDetectionEnabled = false; window.toggleChatHistoryDetection(); } }, 1000); } else { console.log('ℹ️ [聊天记忆检测] 未检测到开启状态，保持关闭'); } } catch (error) { console.error('恢复检测状态失败:', error); } } async function detectAndGenerateNewTweetFromChatHistory() { try { console.log('🔍 [聊天记忆Tweet检测] 开始检测其他平台聊天记忆中的发帖意图'); const xDb = getXDB(); const settingsId = `xSettings_${currentAccountId || 'main'}`; const xSettings = await xDb.xSettings.get(settingsId); if (!xSettings || !xSettings.boundCharacters || xSettings.boundCharacters.length === 0) { console.log('⏭️ [聊天记忆Tweet检测] 没有绑定角色，跳过'); return; } const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); const mainDB = getDB(); const allChats = await mainDB.chats.toArray(); const allXProfiles = await xDb.xCharacterProfiles.toArray(); const eligibleCharacters = []; for (const charId of xSettings.boundCharacters) { if (!userXProfileInfo.knownIdentityCharacters.includes(charId)) { continue; } const character = allChats.find(c => c.id === charId); if (!character) continue; const xProfile = allXProfiles.find(p => p.characterId === charId); if (!xProfile) continue; if (!xProfile.userPersona || !xProfile.userPersona.trim()) { console.log(`⏭️ [聊天记忆Tweet检测] ${character.name}: 未设置专属用户人设，跳过`); continue; } if (!character.history || character.history.length === 0) { console.log(`⏭️ [聊天记忆Tweet检测] ${character.name}: 没有聊天记忆，跳过`); continue; } eligibleCharacters.push({ character, xProfile, }); } console.log(`✅ [聊天记忆Tweet检测] 找到 ${eligibleCharacters.length} 个符合条件的角色`); for (const { character, xProfile } of eligibleCharacters) { await checkCharacterChatHistoryForTweetIntent(character, xProfile); } } catch (error) { console.error('❌ [聊天记忆Tweet检测] 失败:', error); } } async function checkCharacterChatHistoryForTweetIntent(character, xProfile) { try { console.log(`🔍 [聊天记忆Tweet检测] 检查角色: ${character.name}`); const postKeywords = [ '发帖', '发推', '发推特', '发推文', '发tweet', '发条推', '发个帖', '发条帖', '发个推', '发一条', '发布推文', '发布帖子', 'post', 'tweet', 'tweeted', 'posting', 'gonna post', 'will post', 'going to post', 'publish', 'share on x', 'share on twitter', '发到X上', '发到推特', '发到平台', '分享到X', '晒到X', ]; const recentHistory = character.history.slice(-20); let foundKeyword = false; let keywordIndex = -1; for (let i = recentHistory.length - 1; i >= 0; i--) { const msg = recentHistory[i]; if (msg.role === 'assistant' && msg.content) { const content = msg.content.toLowerCase(); if (postKeywords.some(keyword => content.includes(keyword.toLowerCase()))) { foundKeyword = true; keywordIndex = i; console.log(`✅ [聊天记忆Tweet检测] ${character.name} 主动提及发帖: ${msg.content.substring(0, 50)}`); break; } } } if (!foundKeyword) { console.log(`⏭️ [聊天记忆Tweet检测] ${character.name} 未主动提及发帖`); return; } const startIndex = Math.max(0, keywordIndex - 10); const endIndex = Math.min(recentHistory.length, keywordIndex + 11); const contextHistory = recentHistory.slice(startIndex, endIndex); const contextMessages = contextHistory.map(msg => ({ type: 'text', content: msg.content || '', isOwn: msg.role === 'user', time: '最近', })); const messageData = { id: `msg_${character.id}`, user: { name: xProfile.xName, handle: xProfile.xHandle, avatar: xProfile.xAvatar, verified: xProfile.xVerified || false, }, }; const tweetData = await generateTweetFromConversation(messageData, contextMessages); if (!tweetData) { console.log(`⚠️ [聊天记忆Tweet检测] ${character.name} 的AI未生成推文内容`); return; } const timestamp = Date.now(); const newTweetNotification = { id: `mention_newtweet_chat_${timestamp}`, type: 'newTweet', user: messageData.user, content: `New Tweet from ${messageData.user.name}`, time: '刚刚', timestamp: timestamp, tweet: tweetData, }; const xDb = getXDB(); const mentionsDataId = `mentions_${currentAccountId || 'main'}`; let savedMentions = await xDb.xAccountProfiles.get(mentionsDataId); if (!savedMentions) { savedMentions = { handle: mentionsDataId, id: mentionsDataId, data: [], }; } savedMentions.data.unshift(newTweetNotification); await xDb.xAccountProfiles.put(savedMentions); console.log(`✅ [聊天记忆Tweet检测] ${character.name} 的推文通知已生成并保存`); await addTweetToAccountProfile(messageData.user.handle, tweetData); const isEnglish = currentLanguage === 'en'; showPhoneNotification({ title: 'X', message: isEnglish ? `${messageData.user.name} posted a new tweet based on your conversation!` : `${messageData.user.name} 根据你们的对话发布了新推文！`, avatar: messageData.user.avatar, leftIcon: 'x', }); const mentionsPage = document.getElementById('x-notifications-page'); if (mentionsPage && mentionsPage.style.display === 'flex') { await loadNotifications(); } else { showNavNotificationDot('notifications'); } } catch (error) { console.error(`❌ [聊天记忆Tweet检测] 检查 ${character.name} 失败:`, error); } } async function detectAndGenerateNewTweetNotification(messageData, conversationMessages) { try { console.log('🔍 [私信Tweet检测] 开始检测私信对话中的发帖意图'); const postKeywords = [ '发帖', '发推', '发推特', '发推文', '发tweet', '发条推', '发个帖', '发条帖', '发个推', '发一条', '发布推文', '发布帖子', 'post', 'tweet', 'tweeted', 'posting', 'gonna post', 'will post', 'going to post', 'publish', 'share on x', 'share on twitter', '发到X上', '发到推特', '发到平台', '分享到X', '晒到X', ]; let foundKeyword = false; let keywordMessageIndex = -1; for (let i = conversationMessages.length - 1; i >= Math.max(0, conversationMessages.length - 10); i--) { const msg = conversationMessages[i]; if (msg.type === 'text' && msg.content && !msg.isOwn) { const content = msg.content.toLowerCase(); if (postKeywords.some(keyword => content.includes(keyword.toLowerCase()))) { foundKeyword = true; keywordMessageIndex = i; console.log('✅ [私信Tweet检测] 对方主动提及发帖:', msg.content.substring(0, 50)); break; } } } if (!foundKeyword) { console.log('⏭️ [私信Tweet检测] 对方未主动提及发帖，跳过'); return; } const startIndex = Math.max(0, keywordMessageIndex - 10); const endIndex = Math.min(conversationMessages.length, keywordMessageIndex + 11); const contextMessages = conversationMessages.slice(startIndex, endIndex); console.log(`📝 [私信Tweet检测] 提取上下文消息: ${contextMessages.length} 条`); const tweetData = await generateTweetFromConversation(messageData, contextMessages); if (!tweetData) { console.log('⚠️ [私信Tweet检测] AI未生成推文内容'); return; } const timestamp = Date.now(); const newTweetNotification = { id: `mention_newtweet_dm_${timestamp}`, type: 'newTweet', user: messageData.user, content: `New Tweet from ${messageData.user.name}`, time: '刚刚', timestamp: timestamp, tweet: tweetData, }; const xDb = getXDB(); const mentionsDataId = `mentions_${currentAccountId || 'main'}`; let savedMentions = await xDb.xAccountProfiles.get(mentionsDataId); if (!savedMentions) { savedMentions = { handle: mentionsDataId, id: mentionsDataId, data: [], }; } savedMentions.data.unshift(newTweetNotification); await xDb.xAccountProfiles.put(savedMentions); console.log('✅ [私信Tweet检测] 已生成并保存 New Tweet 通知'); await addTweetToAccountProfile(messageData.user.handle, tweetData); const isEnglish = currentLanguage === 'en'; showPhoneNotification({ title: 'X', message: isEnglish ? `${messageData.user.name} posted a new tweet!` : `${messageData.user.name} 发布了新推文！`, avatar: messageData.user.avatar || 'https: leftIcon: 'x', }); const mentionsPage = document.getElementById('x-notifications-page'); if (mentionsPage && mentionsPage.style.display === 'flex') { await loadNotifications(); } else { showNavNotificationDot('notifications'); } } catch (error) { console.error('❌ [私信Tweet检测] 失败:', error); } } async function generateTweetFromConversation(messageData, contextMessages, options = {}) { try { const isAutoTweet = options.isAutoTweet || false; const timeSinceLastMessage = options.timeSinceLastMessage || 0; const autoTweetType = options.type || 'character'; const { apiConfig, xSettings, xDb } = await APIUtils.loadConfigAndSettings(); const { userPrompt, worldSetting } = xSettings; let messageType = 'stranger'; let characterId = null; let accountHandle = null; if (messageData.id) { if (messageData.id.startsWith('msg_account_')) { messageType = 'account'; const parts = messageData.id.split('_'); if (parts.length > 2) { accountHandle = parts[2]; } } else if (messageData.id.startsWith('msg_') && messageData.id !== 'msg_001') { messageType = 'character'; characterId = messageData.id.replace('msg_', ''); } } console.log(`📝 [Tweet生成] 消息类型: ${messageType}`, { characterId, accountHandle }); const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || []; let tokenCount = 0; const now = new Date(); const beijingTime = new Date(now.getTime() + 8 * 60 * 60 * 1000); const year = beijingTime.getUTCFullYear(); const month = beijingTime.getUTCMonth() + 1; const day = beijingTime.getUTCDate(); const hours = beijingTime.getUTCHours(); const minutes = beijingTime.getUTCMinutes(); const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六']; const weekday = weekdays[beijingTime.getUTCDay()]; let timeOfDay = ''; if (hours >= 5 && hours < 9) { timeOfDay = '清晨'; } else if (hours >= 9 && hours < 12) { timeOfDay = '上午'; } else if (hours >= 12 && hours < 14) { timeOfDay = '中午'; } else if (hours >= 14 && hours < 18) { timeOfDay = '下午'; } else if (hours >= 18 && hours < 22) { timeOfDay = '晚上'; } else { timeOfDay = '深夜'; } let systemPrompt = StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting, }); tokenCount = TokenUtils.logTokenUsage('Tweet生成器', '基础系统提示词', systemPrompt, tokenCount); systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ⏰ 当前时间信息 ⏰ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 当前时间（北京时间）：${year}年${month}月${day}日 ${weekday} ${String(hours).padStart(2, '0')}:${String( minutes, ).padStart(2, '0')} 时段：${timeOfDay} **请根据当前时间生成符合时间情境的推文**： - 如果是清晨或上午，推文可以是早安问候、早餐分享、一天计划等 - 如果是中午，可以是午餐分享、工作进展等 - 如果是下午，可以是下午茶、工作日常、生活感悟等 - 如果是晚上，可以是晚餐、晚间活动、一天总结等 - 如果是深夜，可以是深夜想法、失眠感悟等 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; tokenCount = TokenUtils.logTokenUsage( 'Tweet生成器', '时间信息', systemPrompt.substring(systemPrompt.lastIndexOf('⏰ 当前时间信息')), tokenCount, ); const worldBooksOptions = { boundCharacters: [] }; if (messageType === 'character' && characterId) { worldBooksOptions.boundCharacters = [characterId]; } const worldBooksContent = await StringBuilders.getApplicableWorldBooks('posts', worldBooksOptions); if (worldBooksContent) { systemPrompt += worldBooksContent; tokenCount = TokenUtils.logTokenUsage('Tweet生成器', '世界书内容', worldBooksContent, tokenCount); } systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务：基于私信对话生成推文 🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的推文生成器。${ isAutoTweet ? `${messageData.user.name} (${messageData.user.handle}) 在后台自动发布推文。 🤖 **后台自动发推模式**：角色根据最近的聊天记录自主决定发布推文内容 ⏰ **距离上次聊天**: ${Math.floor(timeSinceLastMessage / 60)} 分钟前（${timeSinceLastMessage} 秒） 📝 **推文重点**: 以刻画 ${messageData.user.name} 自身为主，可以分享日常、想法、近况等，聊天记录仅作为灵感参考` : `在私信对话中，${messageData.user.name} (${messageData.user.handle}) 提到要发布推文。` } 🚨 **注意：是 ${messageData.user.name} 要发推文，不是用户本人！** 请根据对话上下文，生成 ${messageData.user.name} 可能会发布的推文内容。 **对话上下文**（最近的私信对话${isAutoTweet ? '，作为灵感参考' : ''}）： `; contextMessages.forEach((msg, index) => { const sender = msg.isOwn ? userXProfileInfo.name : messageData.user.name; let content = ''; if (msg.type === 'text') { content = msg.content; } else if (msg.type === 'image') { content = msg.isOwn && msg.imageData ? '[图片]' : `[图片: ${msg.imageDescription || ''}]`; } else if (msg.type === 'voice') { content = `[语音: ${msg.voiceText}]`; } else if (msg.type === 'sticker') { content = '[表情包]'; } systemPrompt += ` ${index + 1}. ${sender}: ${content}`; }); systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; if (messageData._isBusinessBetrayal) { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🔥 特殊模式：商业推广反水 🔥 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🚨 **重要：${messageData.user.name} 决定"反水"，不按照商业任务要求发推文！** **反水类型（选择其中一种）**： 1. **揭露型**（40%）： - 直接揭露有人花钱让自己发广告 - 例："有人给我钱让我宣传XXX，但我觉得这东西真的很一般..." - 例："刚收到一个推广邀约，说实话我用过那玩意儿，不推荐" 2. **吐槽型**（30%）： - 吐槽任务本身或产品/服务 - 例："又有人让我帮忙推广了，但这次的东西真的...算了不说了" - 例："有些推广真的很无语，明明产品质量那样还要我说好话" 3. **完全不配合型**（20%）： - 完全不提任务，发自己想发的内容 - 例："今天心情不好，不想工作" - 例："做自己想做的事比什么都重要" 4. **阴阳怪气型**（10%）： - 表面上完成任务，但用讽刺/暗示的语气 - 例："某个'非常好用'的产品（此处省略一万字）" - 例："终于可以体验到'传说中'的XXX了呢😊" **生成要求**： - 推文必须体现${messageData.user.name}的性格特质 - 根据角色设定选择合适的反水方式 - 推文要自然，不要太刻意 - 可以保留一定的模糊性，让读者自己理解 - stats数据要合理（反水推文可能会有更多讨论：comments 20-60, likes 50-200） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; tokenCount = TokenUtils.logTokenUsage( 'Tweet生成器', '反水模式说明', systemPrompt.substring(systemPrompt.lastIndexOf('🔥 特殊模式')), tokenCount, ); } const coreTaskSection = systemPrompt.substring(systemPrompt.lastIndexOf('🎯 核心任务')); tokenCount = TokenUtils.logTokenUsage('Tweet生成器', '核心任务说明', coreTaskSection, tokenCount); const userConstraintsStart = systemPrompt.length; systemPrompt += ` 【用户X平台资料】（用于理解对话背景）： - 用户名：${userXProfileInfo.name} - 用户句柄：${userXProfileInfo.handle} - 认证状态：${userXProfileInfo.verified ? '已认证' : '未认证'} ${userXProfileInfo.publicIdentity ? `- 公众身份：${userXProfileInfo.publicIdentity}` : ''} ${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ''} `; if (recentUserTweets.length > 0) { systemPrompt += ` 【用户最近推文】（供参考，对话可能涉及这些推文）： `; recentUserTweets.forEach((tweet, index) => { systemPrompt += ` ${index + 1}. "${tweet.content}" - 发布时间：${tweet.time || '最近'} - 互动数据：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.comments || 0}评论 `; }); } const userSection = systemPrompt.substring(userConstraintsStart); tokenCount = TokenUtils.logTokenUsage('Tweet生成器', '用户资料和推文', userSection, tokenCount); const profileInfoStart = systemPrompt.length; console.log( `🔍 [Tweet生成] 用户身份识别列表:`, userXProfileInfo.knownIdentityCharacters, `角色ID: ${characterId}`, ); const senderProfile = await StringBuilders.getUnifiedProfile(messageData.user.handle, { userProfileInfo: userXProfileInfo, }); if (senderProfile) { if (senderProfile.type === 'character') { console.log(`🔍 [Tweet生成] 角色知道用户身份: ${senderProfile.knowsUserIdentity}`); console.log(`🔍 [Tweet生成] 角色用户人设: "${senderProfile.characterData?.userPersona || '无'}"`); } systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`; systemPrompt += StringBuilders.formatProfileForPrompt(senderProfile, { includeType: true, includeTweets: true, includeRelationships: true, }); systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ **推文生成要求**： - 推文内容必须严格符合${senderProfile.name}的${senderProfile.type === 'character' ? '性格和说话风格' : '身份和风格'} ${ isAutoTweet ? `- 🎯 **后台自动发推重点**：推文以刻画${senderProfile.name}自身为主（日常、想法、近况、感受等） - 聊天记录仅作为灵感来源，不要直接提及或暗示与用户的对话 - 推文应该像${senderProfile.name}的独立生活动态，而非对话延续 - 可以是：分享心情、吐槽日常、发表观点、晒照片、记录生活等 - 时间感：距离上次聊天已过去${Math.floor(timeSinceLastMessage / 60)}分钟，推文可以反映这段时间的活动` : `- 推文要与私信对话内容相关` } `; if (senderProfile.type === 'character') { systemPrompt += `- 参考角色人设和最近的推文风格\n`; if (senderProfile.knowsUserIdentity) { systemPrompt += `- ✅ 该角色知道用户身份（${userXProfileInfo.name} / ${userXProfileInfo.handle}），推文中可以自然地@用户或提及与用户相关的内容\n`; systemPrompt += `- 可以结合对用户的了解生成推文内容\n`; } else { systemPrompt += `- ❌ 该角色不知道用户身份，推文不应该直接提及或@用户\n`; systemPrompt += `- 推文内容独立于用户，不要暗示认识用户\n`; } } else if (senderProfile.type === 'account') { systemPrompt += `- 参考账户的发帖习惯和平台形象\n`; } const profileInfo = systemPrompt.substring(profileInfoStart); tokenCount = TokenUtils.logTokenUsage('Tweet生成器', '发送者详细信息', profileInfo, tokenCount); } else { systemPrompt += ` **推文生成要求**： - 推文内容要符合 ${messageData.user.name} 的身份和对话语境 - 推文要与私信对话内容相关 `; } systemPrompt += ` - 内容要自然，像是真实用户会发布的推文 - 可以包含情绪、观点、分享或日常内容 - 字数控制在20-200字之间 - 可以带emoji表情 - ${isAutoTweet ? '40%' : '30%'}的概率带图片（如果合适的话，提供图片描述） - stats数据要合理（普通用户流量：comments 5-30, retweets 10-80, likes 20-150, views 100-2000） ${ isAutoTweet ? ` 🎯 **后台自动发推特别提示**： - 推文要体现${messageData.user.name}的独立生活和个性 - 不要让推文看起来像是在回应某个对话 - 可以发一些与聊天无关的日常内容 - 展现角色在用户不在场时的生活状态` : '' } 【JSON返回格式】： \`\`\`json { "content": "推文文本内容", "image": {"type": "description", "content": "图片描述"} 或 null, "time": "刚刚", "stats": { "comments": 评论数, "retweets": 转发数, "likes": 点赞数, "views": 浏览数 }, "comments": [ { "id": "评论唯一ID（可留空，系统自动生成）", "user": { "name": "评论者昵称", "handle": "@评论者句柄", "avatar": "https: "verified": false }, "content": "评论文本", "time": "时间描述（如'2小时前'）", "image": {"type": "description", "content": "图片文字描述"} (可选，10-20%的评论带图), "stats": { "replies": 回复数, "retweets": 转发数, "likes": 点赞数 } } ] } \`\`\` 关键规则： 1. 推文内容要与对话上下文相关 2. 🚨 推文是 ${messageData.user.name} 发布的，不是 ${userXProfileInfo.name} 3. 符合发布者的说话风格和身份 4. stats中所有数字必须是纯数字，不带引号 5. image字段可选，如果不需要图片就设为null 6. **必须包含2-5条评论**，评论要与推文内容相关且自然 7. 10-20%的评论可以带图（image字段） 8. 评论的stats数据要合理（replies 0-10, retweets 0-20, likes 1-50） `; const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】')); tokenCount = TokenUtils.logTokenUsage('Tweet生成器', 'JSON格式要求', formatSection, tokenCount); TokenUtils.logFinalPrompt('Tweet生成器', systemPrompt, '请生成推文'); const messages = [{ role: 'user', content: '请生成推文' }]; const aiResponseContent = await APIUtils.sendAIRequest({ apiConfig, systemPrompt, messages, temperature: 0.8, }); const tweetData = APIUtils.parseJSONResponse(aiResponseContent); const timestamp = Date.now(); tweetData.id = `newtweet_${timestamp}`; tweetData.user = messageData.user; tweetData.timestamp = timestamp; delete tweetData.time; if (tweetData.comments && tweetData.comments.length > 0) { tweetData.comments.forEach((comment, cIndex) => { if (!comment.id) { comment.id = `newtweet_${timestamp}_c${cIndex}`; } if (!comment.timestamp) { comment.timestamp = timestamp + (5 + Math.random() * 30) * 60 * 1000; } delete comment.time; }); } console.log('✅ [Tweet生成] 推文内容已生成:', tweetData); return tweetData; } catch (error) { console.error('❌ [Tweet生成] 失败:', error); return null; } } let currentMessageConversation = null; let messageMultiSelectMode = false; let selectedMessages = new Set(); let messageLongPressTimer = null; let messageLongPressTarget = null; function renderMessageItem(message, isOwn = false, messageIndex, isLastInGroup = true, showTime = true) { const config = languageConfig[currentLanguage] || languageConfig.zh; const messageId = messageIndex !== undefined ? `msg_idx_${messageIndex}` : `msg_temp_${Math.random()}`; const isFanGroupMessage = !isOwn && message.senderId && message.senderName; const messageEl = document.createElement('div'); messageEl.className = 'message-item'; messageEl.setAttribute('data-message-id', messageId); messageEl.setAttribute('data-message-index', messageIndex !== undefined ? messageIndex : -1); messageEl.style.cssText = ` display: flex; flex-direction: column; align-items: ${isOwn ? 'flex-end' : 'flex-start'}; margin-bottom: ${ isLastInGroup ? '16px' : '4px' }; position: relative; transition: opacity 0.2s; opacity: 0; transform: translateY(10px); `; if (isFanGroupMessage) { const senderInfoEl = document.createElement('div'); senderInfoEl.style.cssText = ` display: flex; align-items: flex-start; gap: 8px; width: 100%; `; const avatarEl = document.createElement('img'); avatarEl.src = message.senderAvatar; avatarEl.style.cssText = ` width: 32px; height: 32px; border-radius: 50%; object-fit: cover; flex-shrink: 0; margin-top: 2px; `; senderInfoEl.appendChild(avatarEl); const contentWrapper = document.createElement('div'); contentWrapper.style.cssText = ` flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 4px; `; const nameEl = document.createElement('div'); nameEl.style.cssText = ` display: flex; align-items: center; gap: 6px; `; nameEl.innerHTML = ` <span style="font-size: 14px; font-weight: 600; color:var(--x-text-primary); ">${message.senderName}</span> <span style="font-size: 13px; color:var(--x-text-secondary); ">${message.senderHandle}</span> `; contentWrapper.appendChild(nameEl); senderInfoEl.appendChild(contentWrapper); messageEl.appendChild(senderInfoEl); messageEl.style.flexDirection = 'row'; messageEl.style.alignItems = 'flex-start'; } if (messageMultiSelectMode) { const isSelected = selectedMessages.has(messageId); const selectIndicator = document.createElement('div'); selectIndicator.className = 'message-select-indicator'; selectIndicator.style.cssText = ` position: absolute; ${isOwn ? 'right: -10px;' : 'left: -10px;'} top: 50%; transform: translateY(-50%); width: 24px; height: 24px; border-radius: 50%; border: 2px solid ${ isSelected ? 'var(--x-accent)' : 'var(--x-border-color)' }; background-color: ${ isSelected ? 'var(--x-accent)' : 'var(--x-bg-primary)' }; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 10; `; if (isSelected) { selectIndicator.innerHTML = ` <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #fff;"> <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></g> </svg> `; } selectIndicator.onclick = e => { e.stopPropagation(); toggleMessageSelection(messageId); }; messageEl.appendChild(selectIndicator); messageEl.style.opacity = isSelected ? '0.7' : '1'; } let pressTimer = null; const startPress = e => { if (messageMultiSelectMode) return; pressTimer = setTimeout(() => { enterMessageMultiSelectMode(); toggleMessageSelection(messageId); if (navigator.vibrate) { navigator.vibrate(50); } }, 500); }; const endPress = () => { if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; } }; messageEl.addEventListener('touchstart', startPress); messageEl.addEventListener('touchend', endPress); messageEl.addEventListener('touchmove', endPress); messageEl.addEventListener('mousedown', startPress); messageEl.addEventListener('mouseup', endPress); messageEl.addEventListener('mouseleave', endPress); if (messageMultiSelectMode) { messageEl.style.cursor = 'pointer'; messageEl.onclick = () => { toggleMessageSelection(messageId); }; } const bubbleEl = document.createElement('div'); const baseStyle = ` max-width: 70%; border-radius: 18px; font-size: 15px; line-height: 1.4; word-wrap: break-word; ${ isLastInGroup ? (isOwn ? 'border-bottom-right-radius: 4px;' : 'border-bottom-left-radius: 4px;') : '' } `; if (message.type === 'text') { bubbleEl.style.cssText = baseStyle + ` padding: 12px 16px; background-color: ${isOwn ? 'var(--x-accent)' : 'var(--x-bg-secondary)'}; color: ${ isOwn ? '#fff !important' : 'var(--x-text-primary)' }; width: fit-content; `; const processedContent = processContent(message.content || '', { isOwn }); bubbleEl.innerHTML = processedContent; } else if (message.type === 'image') { bubbleEl.style.cssText = baseStyle + ` padding: 0; background-color: transparent; width: fit-content; `; const imageContainerId = `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; const imageContainer = document.createElement('div'); imageContainer.id = imageContainerId; imageContainer.style.cssText = ` position: relative; border-radius: 12px; overflow: hidden; ${ message.imageData ? 'background-color: transparent;' : 'background-color: rgba(142, 142, 142, 0.15); padding: 16px;' } max-width: ${message.imageData ? '200px' : '280px'}; `; if (message.imageData) { const imgEl = document.createElement('img'); imgEl.src = message.imageData; imgEl.style.cssText = ` max-width: 200px; max-height: 200px; width: auto; height: auto; display: block; border-radius: 12px; cursor: pointer; `; imgEl.onclick = () => { window.open(message.imageData, '_blank'); }; imageContainer.appendChild(imgEl); } else { const descEl = document.createElement('div'); descEl.style.cssText = ` color:var(--x-text-primary); font-size: 15px; line-height: 1.4; word-wrap: break-word; `; descEl.textContent = message.imageDescription || '[图片]'; imageContainer.appendChild(descEl); } if (message.sensitive) { const maskId = `mask_${imageContainerId}`; const maskEl = document.createElement('div'); maskEl.id = maskId; maskEl.style.cssText = ` position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; z-index: 1; `; maskEl.innerHTML = ` <svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: #fff; margin-bottom: 8px;"> <g><path d="M12 15c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm0-4c-.552 0-1 .448-1 1s.448 1 1 1 1-.448 1-1-.448-1-1-1z"></path><path d="M12 5c-7.633 0-9.927 6.617-9.948 6.684L1.946 12l.105.316C2.073 12.383 4.367 19 12 19s9.927-6.617 9.948-6.684l.106-.316-.105-.316C21.927 11.617 19.633 5 12 5zm0 12c-5.351 0-7.424-3.846-7.926-5C4.578 10.842 6.652 7 12 7c5.351 0 7.424 3.846 7.926 5-.504 1.158-2.578 5-7.926 5z"></path></g> </svg> <div style="color: #fff; font-weight: 600; font-size: 15px; margin-bottom: 4px;">可能含有敏感内容</div> <div style="color: rgba(255,255,255,0.8); font-size: 13px;">点击查看</div> `; maskEl.onclick = function () { this.style.display = 'none'; }; imageContainer.appendChild(maskEl); } bubbleEl.appendChild(imageContainer); } else if (message.type === 'voice') { bubbleEl.style.cssText = baseStyle + ` padding: 10px 14px; background-color: ${isOwn ? 'var(--x-accent)' : 'var(--x-bg-secondary)'}; color: ${ isOwn ? '#fff' : 'var(--x-text-primary)' }; max-width: 180px; width: fit-content; `; const voiceId = `voice_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; bubbleEl.innerHTML = ` <div id="${voiceId}" style="display: flex; align-items: center; gap: 10px; cursor: pointer; color: ${ isOwn ? '#fff' : 'var(--x-text-primary)' };" onclick="toggleVoiceText('${voiceId}', '${message.voiceText?.replace(/'/g, "\\'")}')"> <div style="width: 32px; height: 32px; border-radius: 50%; background-color: ${ isOwn ? 'rgba(255,255,255,0.2)' : 'var(--x-accent)' }; display: flex; align-items: center; justify-content: center; flex-shrink: 0; "> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #fff;"> <g><path d="M8 5v14l11-7z"></path></g> </svg> </div> <span style="font-weight: 600; color: inherit; font-size: 14px;">${message.duration || '0:05'}</span> </div> `; } else if (message.type === 'sticker') { bubbleEl.style.cssText = baseStyle + ` padding: 0; background-color: transparent; width: fit-content; `; bubbleEl.innerHTML = ` <div style="max-width: 120px; border-radius: 8px; overflow: hidden; "> <img src="${message.stickerUrl}" alt="表情包" style="width: 100%; height: auto; display: block; border-radius: 8px; " onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'padding: 12px; color:var(--x-text-secondary); text-align: center;\\'>表情包加载失败</div>';"> </div> `; } else if (message.type === 'link') { bubbleEl.style.cssText = baseStyle + ` padding: 0; background-color: transparent; color:var(--x-text-primary); width: fit-content; `; const linkCardId = `link_card_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; bubbleEl.innerHTML = ` <div id="${linkCardId}" style="border: 1px solid var(--x-border-color); border-radius: 12px; overflow: hidden; background-color:var(--x-bg-secondary); cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'; this.style.borderColor='var(--x-accent)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'; this.style.borderColor='var(--x-border-color)'"> <div style="padding: 12px;"> <div style="font-weight: 600; margin-bottom: 4px; color:var(--x-text-primary);"> ${message.title || '链接'} </div> ${ message.description ? ` <div style="font-size: 13px; color:var(--x-text-secondary); margin-bottom: 8px;"> ${message.description} </div> ` : '' } <div style="font-size: 13px; color: var(--x-accent); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"> ${message.url || '点击查看文章'} </div> </div> </div> `; setTimeout(() => { const linkCard = document.getElementById(linkCardId); if (linkCard) { linkCard.onclick = () => { openArticlePage({ title: message.title, author: message.author || '佚名', source: message.source || message.url || '未知来源', body: message.body || message.description || '', }); }; } }, 0); } else if (message.type === 'quoteTweet') { bubbleEl.style.cssText = baseStyle + ` padding: 0; background-color: transparent; color:var(--x-text-primary); width: fit-content; `; bubbleEl.innerHTML = ` ${ message.caption ? ` <div style="padding: 12px 16px; background-color: ${isOwn ? 'var(--x-accent)' : 'var(--x-bg-secondary)'}; color: ${ isOwn ? '#fff' : 'var(--x-text-primary)' }; border-radius: 12px; margin-bottom: 8px; width: fit-content; ">${processContent(message.caption || '', { isOwn, })}</div> ` : '' } <div style="border: 1px solid var(--x-border-color); border-radius: 12px; padding: 12px; background-color:var(--x-bg-secondary); width: fit-content; max-width: 100%; "> <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;"> <img src="${message.tweet.userAvatar}" style="width: 20px; height: 20px; border-radius: 50%;"> <span style="font-weight: 600; color:var(--x-text-primary);">${message.tweet.userName}</span> ${ message.tweet.verified ? ` <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);"> <g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.26 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.45 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g> </svg> ` : '' } <span style="color:var(--x-text-secondary); font-size: 13px;">${message.tweet.userHandle}</span> <span style="color:var(--x-text-secondary); font-size: 13px;">·</span> <span style="color:var(--x-text-secondary); font-size: 13px;">${message.tweet.time}</span> </div> <div style="color:var(--x-text-primary);">${processContent(message.tweet.content || '', { isOwn: false, })}</div> </div> `; } else if (message.type === 'quoteProfile') { bubbleEl.style.cssText = baseStyle + ` padding: 0; background-color: transparent; color:var(--x-text-primary); width: fit-content; `; const profileCardId = `profile_card_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; bubbleEl.innerHTML = ` ${ message.caption ? ` <div style="padding: 12px 16px; background-color: ${isOwn ? 'var(--x-accent)' : 'var(--x-bg-secondary)'}; color: ${ isOwn ? '#fff' : 'var(--x-text-primary)' }; border-radius: 12px; margin-bottom: 8px; ">${processContent(message.caption || '', { isOwn })}</div> ` : '' } <div id="${profileCardId}" style="border: 1px solid var(--x-border-color); border-radius: 12px; padding: 16px; background-color:var(--x-bg-secondary); cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'"> <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;"> <img src="${message.profile.avatar}" style="width: 48px; height: 48px; border-radius: 50%;"> <div style="flex: 1;"> <div style="display: flex; align-items: center; gap: 4px;"> <span style="font-weight: 700; color:var(--x-text-primary);">${message.profile.name}</span> ${ message.profile.verified ? ` <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);"> <g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.26 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.45 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g> </svg> ` : '' } </div> <div style="color:var(--x-text-secondary); font-size: 13px;">${message.profile.handle}</div> </div> </div> ${ message.profile.bio ? ` <div style="color:var(--x-text-primary); margin-bottom: 8px; font-size: 14px;"> ${message.profile.bio} </div> ` : '' } <div style="color:var(--x-text-secondary); font-size: 13px;"> ${message.profile.followers} 位关注者 </div> </div> `; setTimeout(() => { const profileCard = document.getElementById(profileCardId); if (profileCard) { profileCard.onclick = () => { openAccountProfileFromQuoteProfile(message.profile); }; } }, 0); } else if (message.type === 'quoteFanGroup') { bubbleEl.style.cssText = baseStyle + ` padding: 0; background-color: transparent; color:var(--x-text-primary); width: fit-content; `; const fanGroupCardId = `fangroup_card_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; bubbleEl.innerHTML = ` ${ message.caption ? ` <div style="padding: 12px 16px; background-color: ${isOwn ? 'var(--x-accent)' : 'var(--x-bg-secondary)'}; color: ${ isOwn ? '#fff' : 'var(--x-text-primary)' }; border-radius: 12px; margin-bottom: 8px; ">${processContent(message.caption || '', { isOwn })}</div> ` : '' } <div id="${fanGroupCardId}" style="border: 1px solid var(--x-border-color); border-radius: 12px; padding: 16px; background-color:var(--x-bg-secondary); cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'"> <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;"> <img src="${message.fanGroup.avatar}" style="width: 48px; height: 48px; border-radius: 50%; object-fit: cover;"> <div style="flex: 1;"> <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"> <span style="font-weight: 700; color:var(--x-text-primary); font-size: 15px;">${message.fanGroup.name}</span> <span style="padding: 2px 8px; background-color:var(--x-bg-primary); color:var(--x-text-secondary); font-size: 11px; border-radius: 4px; font-weight: 600; ">粉丝群</span> </div> <div style="color:var(--x-text-secondary); font-size: 13px;"> ${message.fanGroup.memberCount} 位成员 </div> </div> </div> ${ message.fanGroup.threshold ? ` <div style="padding: 10px; background-color:var(--x-bg-primary); border-radius: 8px; color:var(--x-text-secondary); font-size: 12px; line-height: 1.4; margin-top: 8px; "> <div style="color:var(--x-text-primary); font-weight: 600; margin-bottom: 4px; font-size: 11px;">入群门槛</div> ${ message.fanGroup.threshold.length > 100 ? message.fanGroup.threshold.substring(0, 100) + '...' : message.fanGroup.threshold } </div> ` : '' } </div> `; setTimeout(() => { const fanGroupCard = document.getElementById(fanGroupCardId); if (fanGroupCard) { fanGroupCard.onclick = () => { console.log('点击了粉丝群卡片:', message.fanGroup); }; } }, 0); } else if (message.type === 'groupFile') { bubbleEl.style.cssText = baseStyle + ` padding: 0; background-color: transparent; color:var(--x-text-primary); width: fit-content; max-width: 280px; `; const fileCardId = `file_card_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; const fileIconSvg = getFileIcon(message.file.type); const typeColors = { text: '#2b303b', image: '#2e3440', video: '#262b36', link: '#272c36', default: '#252933', }; const typeColor = typeColors[message.file.type] || typeColors.default; const uploadDate = new Date(message.file.uploadedAt); const formattedDate = `${uploadDate.getMonth() + 1}/${uploadDate.getDate()} ${String( uploadDate.getHours(), ).padStart(2, '0')}:${String(uploadDate.getMinutes()).padStart(2, '0')}`; bubbleEl.innerHTML = ` <div id="${fileCardId}" style=" border: 1px solid var(--x-border-color); border-radius: 12px; overflow: hidden; background-color:var(--x-bg-secondary); cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'; this.style.borderColor='var(--x-accent)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'; this.style.borderColor='var(--x-border-color)'"> <!-- 文件头部 --> <div style=" display: flex; align-items: center; gap: 12px; padding: 12px; border-bottom: 1px solid var(--x-border-color); "> <!-- 文件图标 --> <div style=" width: 38px; height: 38px; border-radius: 6px; background-color: ${typeColor}; display: flex; align-items: center; justify-content: center; flex-shrink: 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); "> <div style="width: 18px; height: 18px; color: rgba(255,255,255,0.85);"> ${fileIconSvg.replace('currentColor', 'rgba(255,255,255,0.85)')} </div> </div> <!-- 文件信息 --> <div style="flex: 1; min-width: 0;"> <div style=" color:var(--x-text-primary); font-size: 14px; font-weight: 600; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-bottom: 2px; ">${message.file.name}</div> <div style=" color:var(--x-text-secondary); font-size: 11px; display: flex; align-items: center; gap: 6px; "> <span>${message.file.uploadedBy}</span> <span>·</span> <span>${formattedDate}</span> </div> </div> </div> <!-- 文件内容预览 --> <div style=" padding: 10px 12px; color:var(--x-text-secondary); font-size: 12px; line-height: 1.4; max-height: 60px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; ">${message.file.content.substring(0, 100)}${message.file.content.length > 100 ? '...' : ''}</div> </div> `; setTimeout(() => { const fileCard = document.getElementById(fileCardId); if (fileCard) { fileCard.onclick = () => { openFileDetail(message.file); }; } }, 0); } else if (message.type === 'transfer') { bubbleEl.style.cssText = baseStyle + ` padding: 0; background-color: transparent; width: fit-content; `; const xSocialScreen = document.getElementById('x-social-screen'); const isLightMode = xSocialScreen && xSocialScreen.classList.contains('x-theme-light'); const isUserSending = isOwn; const amount = parseFloat(message.amount || 0).toFixed(2); const transferCardId = 'transfer-card-' + (message.timestamp || Date.now()); const isBusiness = message.isBusiness === true; bubbleEl.innerHTML = ` <div id="${transferCardId}" style="position: relative; background-color: ${ isLightMode ? '#ffffff' : '#1f1f1f' }; border-radius: 12px; padding: 12px 16px; max-width: 200px; box-shadow: ${ isLightMode ? '0 2px 8px rgba(0, 0, 0, 0.1), 0 4px 16px rgba(0, 0, 0, 0.06), 0 1px 2px rgba(0, 0, 0, 0.05)' : '0 2px 8px rgba(0, 0, 0, 0.3), 0 4px 16px rgba(0, 0, 0, 0.2), 0 1px 2px rgba(255, 255, 255, 0.05)' }; border: 1px solid ${ isBusiness ? isLightMode ? 'rgba(29, 155, 240, 0.3)' : 'rgba(29, 155, 240, 0.4)' : isLightMode ? 'rgba(0, 0, 0, 0.06)' : 'rgba(255, 255, 255, 0.08)' }; display: flex; align-items: center; gap: 12px; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='${ isLightMode ? '0 4px 12px rgba(0, 0, 0, 0.15), 0 6px 20px rgba(0, 0, 0, 0.08), 0 2px 4px rgba(0, 0, 0, 0.06)' : '0 4px 12px rgba(0, 0, 0, 0.4), 0 6px 20px rgba(0, 0, 0, 0.3), 0 2px 4px rgba(255, 255, 255, 0.08)' }'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='${ isLightMode ? '0 2px 8px rgba(0, 0, 0, 0.1), 0 4px 16px rgba(0, 0, 0, 0.06), 0 1px 2px rgba(0, 0, 0, 0.05)' : '0 2px 8px rgba(0, 0, 0, 0.3), 0 4px 16px rgba(0, 0, 0, 0.2), 0 1px 2px rgba(255, 255, 255, 0.05)' }'" "> ${ isBusiness ? ` <div style="position: absolute; top: -4px; right: -4px; width: 18px; height: 18px; background-color: var(--x-accent); border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 1px 3px rgba(0,0,0,0.3); "> <svg viewBox="0 0 24 24" style="width: 10px; height: 10px; fill: #ffffff;"> <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path><path d="M12 10L14.5 14L17 10L14.5 12L12 10ZM10 10L7.5 12L10 14L7.5 14L10 10Z"></path></g> </svg> </div> ` : '' } <div style="width: 36px; height: 36px; border-radius: 50%; background-color: ${ isLightMode ? '#f5f5f5' : '#2d2d2d' }; display: flex; align-items: center; justify-content: center; flex-shrink: 0; "> ${getTransferStatusIcon(message.status, isLightMode)} </div> <div style="display: flex; flex-direction: column; gap: 2px; flex: 1; min-width: 0; "> <div style="font-size: 11px; font-weight: 500; color: ${ isLightMode ? '#888888' : '#aaaaaa' }; text-transform: uppercase; letter-spacing: 0.3px; ">${isBusiness ? '💼 ' : ''}${getTransferStatusText( message.status, isUserSending, )}</div> <div style="font-size: 16px; font-weight: 600; color: ${isLightMode ? '#1a1a1a' : '#e5e5e5'}; line-height: 1; "> ${getTransferAmountText(message.status, isUserSending, amount)} </div> ${ message.note ? ` <div style="font-size: 11px; color: ${ isLightMode ? '#666666' : '#999999' }; line-height: 1.2; margin-top: 1px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">${ message.note }</div> ` : '' } </div> <div style="width: 6px; height: 6px; border-radius: 50%; background-color: ${ isBusiness ? 'var(--x-accent)' : isLightMode ? '#666666' : '#999999' }; flex-shrink: 0; "></div> </div> `; setTimeout(() => { const transferCard = document.getElementById(transferCardId); if (transferCard) { transferCard.onclick = () => { openTransferDetails(message, isOwn); }; } }, 0); } else if (message.type === 'system') { messageEl.style.alignItems = 'center'; bubbleEl.style.cssText = ` padding: 8px 16px; background-color:var(--x-bg-secondary); border-radius: 16px; font-size: 13px; color:var(--x-text-secondary); text-align: center; max-width: 80%; `; bubbleEl.textContent = message.content; } else if (message.type === 'forward') { bubbleEl.style.cssText = baseStyle + ` padding: 0; background-color: transparent; color:var(--x-text-primary); width: fit-content; `; const forwardTypeText = message.forwardType === 'tweet' ? '推文' : '评论'; bubbleEl.innerHTML = ` <div style="border: 1px solid var(--x-border-color); border-radius: 12px; overflow: hidden; background-color:var(--x-bg-secondary); "> <div style="padding: 8px 12px; background-color: var(--x-bg-hover); border-bottom: 1px solid var(--x-border-color); display: flex; align-items: center; gap: 6px; "> <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: var(--x-text-secondary);"> <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g> </svg> <span style="font-size: 12px; color:var(--x-text-secondary);">转发${forwardTypeText}</span> </div> <div style="padding: 12px;"> <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;"> <img src="${message.forwardContent.user.avatar}" style="width: 24px; height: 24px; border-radius: 50%;"> <div style="display: flex; align-items: center; gap: 4px; flex: 1; min-width: 0;"> <span style="font-weight: 600; color:var(--x-text-primary); font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"> ${message.forwardContent.user.name} </span> <span style="color:var(--x-text-secondary); font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"> ${message.forwardContent.user.handle} </span> </div> </div> <div style="color:var(--x-text-primary); font-size: 14px; line-height: 1.4; word-wrap: break-word;"> ${processContent(message.forwardContent.content || '无内容', { isOwn: false })} </div> ${ message.forwardContent.image ? message.forwardContent.image.type === 'description' ? ` <div style="margin-top: 8px; background-color:var(--x-bg-primary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 8px;"> <div style="color:var(--x-text-secondary); font-size: 13px;">${message.forwardContent.image.content}</div> </div> ` : ` <div style="margin-top: 8px; border-radius: 8px; overflow: hidden;"> <img src="${message.forwardContent.image.content}" style="max-width: 100%; max-height: 200px; border-radius: 8px;" alt="图片"> </div> ` : '' } ${ message.forwardContent.time ? ` <div style="color:var(--x-text-secondary); font-size: 12px; margin-top: 8px;"> ${message.forwardContent.time} </div> ` : '' } </div> </div> `; } if (isFanGroupMessage) { const senderInfoEl = messageEl.querySelector('div'); const contentWrapper = senderInfoEl?.querySelector('div:nth-child(2)'); if (contentWrapper) { contentWrapper.appendChild(bubbleEl); } else { messageEl.appendChild(bubbleEl); } } else { messageEl.appendChild(bubbleEl); } if (showTime && isLastInGroup) { const timestampEl = document.createElement('div'); timestampEl.style.cssText = ` font-size: 12px; color:var(--x-text-secondary); margin-top: 4px; padding: 0 4px; `; if (message.timestamp) { timestampEl.textContent = formatMessageTime(message.timestamp); } else { timestampEl.textContent = message.time || '刚刚'; } if (isFanGroupMessage) { const senderInfoEl = messageEl.querySelector('div'); const contentWrapper = senderInfoEl?.querySelector('div:nth-child(2)'); if (contentWrapper) { contentWrapper.appendChild(timestampEl); } else { messageEl.appendChild(timestampEl); } } else { messageEl.appendChild(timestampEl); } } return messageEl; } window.toggleVoiceText = function (voiceId, voiceText) { const voiceEl = document.getElementById(voiceId); if (!voiceEl) return; const isShowingText = voiceEl.getAttribute('data-showing-text') === 'true'; if (isShowingText) { voiceEl.innerHTML = voiceEl.getAttribute('data-original-html'); voiceEl.setAttribute('data-showing-text', 'false'); } else { voiceEl.setAttribute('data-original-html', voiceEl.innerHTML); voiceEl.innerHTML = `<div style="padding: 4px;">${voiceText}</div>`; voiceEl.setAttribute('data-showing-text', 'true'); } }; function createTypingIndicator() { const typingEl = document.createElement('div'); typingEl.id = 'typing-indicator'; typingEl.className = 'message-item'; typingEl.style.cssText = ` display: flex !important; flex-direction: column; align-items: flex-start; margin-bottom: 16px; opacity: 0; transform: translateY(10px); transition: all 0.3s ease; position: relative; z-index: 1; `; const bubbleEl = document.createElement('div'); bubbleEl.style.cssText = ` padding: 12px 16px; border-radius: 18px; border-bottom-left-radius: 4px; background-color:var(--x-bg-secondary); display: flex; align-items: center; gap: 5px; `; for (let i = 0; i < 3; i++) { const dot = document.createElement('div'); dot.style.cssText = ` width: 8px; height: 8px; border-radius: 50%; background-color:var(--x-text-secondary); animation: typingBounce 1.4s infinite ease-in-out; animation-delay: ${ i * 0.2 }s; flex-shrink: 0; `; bubbleEl.appendChild(dot); } typingEl.appendChild(bubbleEl); if (!document.getElementById('typing-animation-style')) { const style = document.createElement('style'); style.id = 'typing-animation-style'; style.textContent = ` @keyframes typingBounce { 0%, 60%, 100% { transform: translateY(0); opacity: 0.7; } 30% { transform: translateY(-10px); opacity: 1; } } `; document.head.appendChild(style); } return typingEl; } function showTypingIndicator() { console.log('🔵 [正在输入] 开始显示气泡'); const contentContainer = document.getElementById('message-detail-content'); if (!contentContainer) { console.warn('⚠️ [正在输入] 找不到消息容器'); return; } let oldTypingIndicator = document.getElementById('typing-indicator'); if (oldTypingIndicator) { console.log('⚠️ [正在输入] 检测到旧气泡，先移除'); oldTypingIndicator.remove(); } console.log('✅ [正在输入] 创建气泡元素'); const typingIndicator = createTypingIndicator(); contentContainer.appendChild(typingIndicator); console.log('✅ [正在输入] 气泡已添加到DOM', typingIndicator); requestAnimationFrame(() => { requestAnimationFrame(() => { if (typingIndicator && typingIndicator.parentNode) { typingIndicator.style.opacity = '1'; typingIndicator.style.transform = 'translateY(0)'; console.log('✅ [正在输入] 气泡动画已触发'); } }); }); setTimeout(() => { const scrollable = document.getElementById('message-detail-scrollable'); if (scrollable) { scrollable.scrollTo({ top: scrollable.scrollHeight, behavior: 'smooth', }); console.log('✅ [正在输入] 已滚动到底部'); } }, 100); } function hideTypingIndicator() { console.log('🔴 [正在输入] 开始隐藏气泡'); const typingIndicator = document.getElementById('typing-indicator'); if (!typingIndicator) { console.log('⚠️ [正在输入] 气泡不存在，无需隐藏'); return; } typingIndicator.style.opacity = '0'; typingIndicator.style.transform = 'translateY(10px)'; console.log('✅ [正在输入] 气泡开始淡出'); setTimeout(() => { if (typingIndicator && typingIndicator.parentNode) { typingIndicator.remove(); console.log('✅ [正在输入] 气泡已从DOM移除'); } }, 300); } async function animateMessagesOneByOne(messageElements, delayBetween = 300) { for (let i = 0; i < messageElements.length; i++) { const messageEl = messageElements[i]; await new Promise(resolve => setTimeout(resolve, delayBetween)); messageEl.style.transition = 'all 0.3s ease'; messageEl.style.opacity = '1'; messageEl.style.transform = 'translateY(0)'; const scrollable = document.getElementById('message-detail-scrollable'); if (scrollable) { scrollable.scrollTo({ top: scrollable.scrollHeight, behavior: 'smooth', }); } } } function groupMessagesBySender(messages) { const groups = []; let currentGroup = []; let currentSenderId = null; messages.forEach((msg, index) => { const senderId = msg.senderId || (msg.isOwn ? 'user' : 'other'); if (currentSenderId === null || currentSenderId === senderId) { currentGroup.push({ message: msg, index }); currentSenderId = senderId; } else { groups.push(currentGroup); currentGroup = [{ message: msg, index }]; currentSenderId = senderId; } }); if (currentGroup.length > 0) { groups.push(currentGroup); } return groups; } function showPhoneNotification(options) { const { title = '', message = '', avatar = null, leftIcon = 'x', leftIconHtml = null, duration = 3000, showTime = true, } = options; const oldNotification = document.getElementById('phone-notification-popup'); if (oldNotification) { oldNotification.remove(); } const notification = document.createElement('div'); notification.id = 'phone-notification-popup'; notification.style.cssText = ` position: fixed; top: -100px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 400px; background: var(--x-bg-primary); border-radius: 16px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); padding: 12px 16px; display: flex; align-items: center; gap: 12px; z-index: 10000; transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); border: 1px solid var(--x-border-color); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); `; if (leftIcon === 'x' || leftIconHtml) { const iconContainer = document.createElement('div'); iconContainer.style.cssText = ` width: 32px; height: 32px; background-color:#000; border-radius: 8px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; `; if (leftIconHtml) { iconContainer.innerHTML = leftIconHtml; } else { iconContainer.innerHTML = ` <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #fff;"> <g><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></g> </svg> `; } notification.appendChild(iconContainer); } const content = document.createElement('div'); content.style.cssText = ` flex: 1; min-width: 0; `; let contentHtml = ''; if (title) { contentHtml += ` <div style="font-size: 13px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 2px; ">${title}</div> `; } if (message) { contentHtml += ` <div style="font-size: 14px; color:var(--x-text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; ">${message}</div> `; } content.innerHTML = contentHtml; notification.appendChild(content); if (showTime) { const timeLabel = document.createElement('div'); timeLabel.style.cssText = ` font-size: 11px; color:var(--x-text-secondary); position: absolute; top: 12px; right: ${avatar ? '64px' : '16px'}; `; const now = new Date(); const hours = now.getHours(); const minutes = String(now.getMinutes()).padStart(2, '0'); timeLabel.textContent = `${hours}:${minutes}`; notification.appendChild(timeLabel); } if (avatar) { const avatarEl = document.createElement('img'); avatarEl.src = avatar; avatarEl.style.cssText = ` width: 40px; height: 40px; border-radius: 50%; object-fit: cover; flex-shrink: 0; `; notification.appendChild(avatarEl); } const xSocialScreen = document.getElementById('x-social-screen'); const targetContainer = xSocialScreen || document.body; targetContainer.appendChild(notification); requestAnimationFrame(() => { notification.style.top = '16px'; }); setTimeout(() => { notification.style.top = '-100px'; setTimeout(() => { if (notification.parentNode) { notification.remove(); } }, 400); }, duration); notification.onclick = () => { notification.style.top = '-100px'; setTimeout(() => { if (notification.parentNode) { notification.remove(); } }, 400); }; } function showMessageNotification(senderName, senderAvatar, messageCount) { const isEnglish = currentLanguage === 'en'; const messageSuffix = isEnglish ? (messageCount > 1 ? ' messages' : ' message') : '条私信'; showPhoneNotification({ title: senderName, message: isEnglish ? `sent you ${messageCount}${messageSuffix}` : `回复了你 ${messageCount}${messageSuffix}`, avatar: senderAvatar, leftIcon: 'x', }); } function renderDateSeparator(date) { const separatorEl = document.createElement('div'); separatorEl.style.cssText = ` text-align: center; margin: 24px 0 16px; `; separatorEl.innerHTML = ` <span style="font-size: 13px; font-weight: 600; color:var(--x-text-primary); padding: 6px 12px; background-color:var(--x-bg-secondary); border-radius: 12px; ">${date}</span> `; return separatorEl; } function getTransferStatusText(status, isUserSending) { if (!status || status === 'pending') { return 'PENDING'; } else if (status === 'accepted') { return isUserSending ? 'SENT' : 'RECEIVED'; } else if (status === 'rejected') { return 'REJECTED'; } return 'PENDING'; } function getTransferAmountText(status, isUserSending, amount) { if (!status || status === 'pending') { return `$${amount}`; } else if (status === 'accepted') { return `${isUserSending ? '-' : '+'}$${amount}`; } else if (status === 'rejected') { return `$${amount}`; } return `$${amount}`; } function getTransferStatusIcon(status, isLightMode) { const iconColor = isLightMode ? '#666666' : '#cccccc'; if (!status || status === 'pending') { return ` <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: ${iconColor};"> <g><path d="M12,2C6.486,2,2,6.486,2,12s4.486,10,10,10s10-4.486,10-10S17.514,2,12,2z M12,20c-4.411,0-8-3.589-8-8 s3.589-8,8-8s8,3.589,8,8S16.411,20,12,20z"></path><path d="M13,7h-2v5.414l3.293,3.293l1.414-1.414L13,11.586V7z"></path></g> </svg> `; } else if (status === 'accepted') { return ` <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: ${iconColor};"> <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path></g> </svg> `; } else if (status === 'rejected') { return ` <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: ${iconColor};"> <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z"></path></g> </svg> `; } return ` <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: ${iconColor};"> <g><path d="M12,2C6.486,2,2,6.486,2,12s4.486,10,10,10s10-4.486,10-10S17.514,2,12,2z M12,20c-4.411,0-8-3.589-8-8 s3.589-8,8-8s8,3.589,8,8S16.411,20,12,20z"></path><path d="M13,7h-2v5.414l3.293,3.293l1.414-1.414L13,11.586V7z"></path></g> </svg> `; } async function saveBusinessTransfer(businessTransferData) { try { const xDb = getXDB(); const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`; let savedData = await xDb.xAccountProfiles.get(businessTransfersId); if (!savedData) { savedData = { handle: businessTransfersId, name: 'businessTransfers', accountId: currentAccountId || 'main', data: [], updatedAt: new Date().toISOString(), }; } savedData.data.push({ ...businessTransferData, savedAt: new Date().toISOString(), }); await xDb.xAccountProfiles.put(savedData); console.log('✅ 商业转账已保存:', businessTransferData.transferId); } catch (error) { console.error('❌ 保存商业转账失败:', error); } } async function handleBusinessTransferTask(transferMessage, conversationData) { try { console.log('💼 [商业转账] 开始处理任务:', transferMessage.taskDescription); const postKeywords = [ '发帖', '发推', '发推特', '发推文', '发tweet', '发条推', '发个帖', '发条帖', '发个推', '发一条', '发布推文', '发布帖子', 'post', 'tweet', 'tweeted', 'posting', 'gonna post', 'will post', 'going to post', 'publish', 'share on x', 'share on twitter', '发到X上', '发到推特', '发到平台', '分享到X', '晒到X', '宣传', '推广', '广告', ]; const taskDesc = transferMessage.taskDescription.toLowerCase(); const hasPostTask = postKeywords.some(keyword => taskDesc.includes(keyword.toLowerCase())); if (!hasPostTask) { console.log('⏭️ [商业转账] 任务不包含发推关键词，跳过'); return; } console.log('✅ [商业转账] 检测到发推任务'); const willComplete = Math.random() < 0.8; if (!willComplete) { console.log('❌ [商业转账] AI决定不完成任务（20%概率）'); return; } console.log('✅ [商业转账] AI决定完成任务，正在生成推文...'); const xDb = getXDB(); let willBetray = false; let betrayalReason = ''; try { const senderProfile = await StringBuilders.getUnifiedProfile(conversationData.user.handle, { userProfileInfo: StringBuilders.buildUserXProfileInfo(window.userProfileData), }); if (senderProfile) { let betrayalChance = 0.1; if (senderProfile.type === 'character') { const cd = senderProfile.characterData; const aiPersona = (cd.aiPersona || '').toLowerCase(); const rebelliousKeywords = [ '叛逆', '狡猾', '冷漠', '自私', '腹黑', '毒舌', '刻薄', '傲慢', '高傲', '不羁', '反叛', 'rebellious', 'cunning', 'selfish', 'cold', 'arrogant', 'sarcastic', ]; const hasRebelliousTraits = rebelliousKeywords.some(keyword => aiPersona.includes(keyword)); if (hasRebelliousTraits) { betrayalChance += 0.15; betrayalReason = '角色性格叛逆/不友好'; console.log('🎭 [反水检测] 角色性格因素 +15%'); } if (!senderProfile.knowsUserIdentity) { betrayalChance += 0.1; betrayalReason += (betrayalReason ? '，' : '') + '不认识用户'; console.log('🎭 [反水检测] 陌生关系 +10%'); } else if (cd.userPersona) { const userPersonaLower = cd.userPersona.toLowerCase(); const negativeRelationships = [ '敌人', '对手', '仇人', '讨厌', '不喜欢', '矛盾', '竞争', 'enemy', 'rival', 'dislike', 'hate', ]; const hasBadRelationship = negativeRelationships.some(keyword => userPersonaLower.includes(keyword)); if (hasBadRelationship) { betrayalChance += 0.2; betrayalReason += (betrayalReason ? '，' : '') + '与用户关系不好'; console.log('🎭 [反水检测] 负面关系 +20%'); } } } else if (senderProfile.type === 'stranger' || senderProfile.type === 'account') { betrayalChance += 0.05; betrayalReason = '非绑定角色类型'; console.log('🎭 [反水检测] 路人/账号类型 +5%'); } console.log(`🎭 [反水检测] 最终反水概率: ${(betrayalChance * 100).toFixed(0)}%`); willBetray = Math.random() < betrayalChance; if (willBetray) { console.log(`🔥 [商业转账] AI决定反水！原因: ${betrayalReason}`); } } } catch (error) { console.error('🎭 [反水检测] 获取资料失败，使用默认概率:', error); willBetray = Math.random() < 0.1; } const contextMessages = [ { type: 'text', content: willBetray ? `用户花钱让我发推广，但我准备反水揭露这件事或者发负面内容。任务要求：${transferMessage.taskDescription}` : `我需要完成一个商业任务：${transferMessage.taskDescription}`, isOwn: false, time: '最近', _isBetrayal: willBetray, _betrayalReason: betrayalReason, }, ]; const messageData = { id: conversationData.id, user: conversationData.user, _isBusinessBetrayal: willBetray, }; const tweetData = await generateTweetFromConversation(messageData, contextMessages); if (!tweetData) { console.log('⚠️ [商业转账] 推文生成失败'); return; } const timestamp = Date.now(); const newTweetNotification = { id: `mention_business_${timestamp}`, type: 'newTweet', user: conversationData.user, content: willBetray ? `⚠️ ${conversationData.user.name} 反水了！` : `New Tweet from ${conversationData.user.name}`, time: '刚刚', timestamp: timestamp, tweet: tweetData, fromBusinessTransfer: true, businessTransferId: transferMessage.timestamp, isBetrayal: willBetray, betrayalReason: betrayalReason, }; const mentionsDataId = `mentions_${currentAccountId || 'main'}`; let savedMentions = await xDb.xAccountProfiles.get(mentionsDataId); if (!savedMentions) { savedMentions = { handle: mentionsDataId, id: mentionsDataId, data: [], }; } savedMentions.data.unshift(newTweetNotification); await xDb.xAccountProfiles.put(savedMentions); await addTweetToAccountProfile(conversationData.user.handle, tweetData); console.log(`✅ [商业转账] 推文已生成并发布${willBetray ? '（反水）' : ''}`); const isEnglish = currentLanguage === 'en'; showPhoneNotification({ title: willBetray ? '⚠️ 商业推广反水' : 'X', message: willBetray ? isEnglish ? `${conversationData.user.name} betrayed and posted a negative tweet!` : `${conversationData.user.name} 反水了！发布了负面/揭露内容` : isEnglish ? `${conversationData.user.name} completed the business task and posted a tweet!` : `${conversationData.user.name} 完成了商业任务并发布了推文！`, avatar: conversationData.user.avatar, leftIcon: willBetray ? 'custom' : 'x', leftIconHtml: willBetray ? ` <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #ef4444;"> <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path></g> </svg> ` : undefined, }); const mentionsPage = document.getElementById('x-notifications-page'); if (mentionsPage && mentionsPage.style.display === 'flex') { await loadNotifications(); } else { showNavNotificationDot('notifications'); } } catch (error) { console.error('❌ [商业转账] 任务处理失败:', error); } } window.openTransferDialog = function () { const dialog = document.getElementById('transfer-dialog'); if (dialog) { dialog.style.display = 'flex'; const amountInput = document.getElementById('transfer-amount-input'); const noteInput = document.getElementById('transfer-note-input'); const counter = document.getElementById('transfer-note-counter'); if (amountInput) amountInput.value = ''; if (noteInput) noteInput.value = ''; if (counter) counter.textContent = '0 / 100'; setTimeout(() => { if (amountInput) amountInput.focus(); }, 100); } }; window.closeTransferDialog = function () { const dialog = document.getElementById('transfer-dialog'); if (dialog) { dialog.style.display = 'none'; setTimeout(() => { switchTransferType('normal'); const amountInput = document.getElementById('transfer-amount-input'); const noteInput = document.getElementById('transfer-note-input'); const taskDescInput = document.getElementById('transfer-task-description'); const taskDeadlineInput = document.getElementById('transfer-task-deadline'); const depositRatioInput = document.getElementById('transfer-deposit-ratio'); if (amountInput) amountInput.value = ''; if (noteInput) noteInput.value = ''; if (taskDescInput) taskDescInput.value = ''; if (taskDeadlineInput) taskDeadlineInput.value = '24'; if (depositRatioInput) depositRatioInput.value = '20'; const noteCounter = document.getElementById('transfer-note-counter'); const taskCounter = document.getElementById('transfer-task-counter'); if (noteCounter) noteCounter.textContent = '0 / 100'; if (taskCounter) taskCounter.textContent = '0 / 500'; }, 200); } }; window.updateTransferNoteCounter = function () { const noteInput = document.getElementById('transfer-note-input'); const noteCounter = document.getElementById('transfer-note-counter'); if (noteInput && noteCounter) { noteCounter.textContent = `${noteInput.value.length} / 100`; } }; window.updateTaskDescriptionCounter = function () { const taskInput = document.getElementById('transfer-task-description'); const taskCounter = document.getElementById('transfer-task-counter'); if (taskInput && taskCounter) { taskCounter.textContent = `${taskInput.value.length} / 500`; } }; window.switchTransferType = function (type) { const normalBtn = document.getElementById('transfer-type-normal-btn'); const businessBtn = document.getElementById('transfer-type-business-btn'); const businessSection = document.getElementById('business-transfer-section'); if (!normalBtn || !businessBtn || !businessSection) return; if (type === 'business') { normalBtn.style.backgroundColor = 'transparent'; normalBtn.style.color = 'var(--x-text-primary)'; businessBtn.style.backgroundColor = 'var(--x-accent)'; businessBtn.style.color = '#fff'; businessSection.style.display = 'block'; } else { normalBtn.style.backgroundColor = 'var(--x-accent)'; normalBtn.style.color = '#fff'; businessBtn.style.backgroundColor = 'transparent'; businessBtn.style.color = 'var(--x-text-primary)'; businessSection.style.display = 'none'; } }; window.sendTransfer = async function () { const amountInput = document.getElementById('transfer-amount-input'); const noteInput = document.getElementById('transfer-note-input'); if (!amountInput || !noteInput) return; const amount = parseFloat(amountInput.value); const note = noteInput.value.trim(); if (amount <= 0 || amount > 9999999) { showXToast('请输入有效金额（0.01 - 9,999,999）', 'error'); return; } const businessSection = document.getElementById('business-transfer-section'); const isBusiness = businessSection && businessSection.style.display !== 'none'; let businessData = null; if (isBusiness) { const taskDescription = document.getElementById('transfer-task-description')?.value.trim(); const taskDeadline = document.getElementById('transfer-task-deadline')?.value; const depositRatio = parseFloat(document.getElementById('transfer-deposit-ratio')?.value || 20); if (!taskDescription) { showXToast('请填写任务描述', 'error'); return; } if (!taskDeadline || taskDeadline < 1) { showXToast('请设置有效的任务期限', 'error'); return; } const depositAmount = (amount * depositRatio) / 100; const remainingAmount = amount - depositAmount; const deadlineDate = new Date(Date.now() + taskDeadline * 60 * 60 * 1000); businessData = { isBusiness: true, taskDescription: taskDescription, taskDeadline: deadlineDate.toISOString(), taskDeadlineHours: parseInt(taskDeadline), depositRatio: depositRatio, depositAmount: depositAmount.toFixed(2), remainingAmount: remainingAmount.toFixed(2), taskStatus: 'pending', taskProgress: 0, }; } await loadWalletData(); if (!walletData.isActivated) { showXToast('请先激活钱包', 'error'); return; } const actualDeduction = isBusiness ? parseFloat(businessData.depositAmount) : amount; if (walletData.balance < actualDeduction) { showXToast('钱包余额不足', 'error'); return; } try { walletData.balance -= actualDeduction; const recipientName = currentMessageConversation?.user?.name || '对方'; const transactionDesc = isBusiness ? `商业转账给 ${recipientName}（定金 ${businessData.depositRatio}%）${note ? ` - ${note}` : ''}` : `转账给 ${recipientName}${note ? ` - ${note}` : ''}`; const transaction = { id: 'transfer_out_' + Date.now(), description: transactionDesc, amount: -actualDeduction, timestamp: new Date().toISOString(), type: isBusiness ? 'business_transfer_deposit' : 'transfer_out', }; walletData.transactions.unshift(transaction); await saveWalletData(); console.log('💰 钱包余额已扣除:', actualDeduction, '剩余余额:', walletData.balance); const transferMessage = { type: 'transfer', amount: amount.toFixed(2), note: note || null, status: 'pending', timestamp: new Date().toISOString(), isOwn: true, ...businessData, }; userMessageQueue.push(transferMessage); const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { const messageEl = renderMessageItem(transferMessage, true, undefined, true, true); contentContainer.appendChild(messageEl); requestAnimationFrame(() => { messageEl.style.opacity = '1'; messageEl.style.transform = 'translateY(0)'; }); setTimeout(() => { const scrollable = document.getElementById('message-detail-scrollable'); if (scrollable) { scrollable.scrollTop = scrollable.scrollHeight; } }, 100); } saveUserMessageToDB(transferMessage); if (isBusiness && currentMessageConversation) { const receiverName = currentMessageConversation.user?.name || currentMessageConversation.userName || recipientName; const receiverHandle = currentMessageConversation.user?.handle || currentMessageConversation.userHandle || 'unknown'; const receiverAvatar = currentMessageConversation.user?.avatar || currentMessageConversation.userAvatar || 'https: await saveBusinessTransfer({ ...transferMessage, transferId: transferMessage.timestamp, conversationId: currentMessageConversation.id, senderName: receiverName, senderHandle: receiverHandle, senderAvatar: receiverAvatar, direction: 'sent', createdAt: transferMessage.timestamp, }); console.log('💼 商业转账已记录到数据库（发出方）:', receiverName); } closeTransferDialog(); console.log('✅ 转账消息已发送:', transferMessage); const toastMsg = isBusiness ? `商业转账已发送 (-$${actualDeduction.toFixed(2)} 定金)` : `转账已发送 (-$${amount.toFixed(2)})`; showXToast(toastMsg, 'success'); } catch (error) { console.error('转账处理失败:', error); showXToast('转账失败: ' + error.message, 'error'); } }; window.openTransferDetails = function (transferData, isOwn) { const modal = document.getElementById('transfer-details-modal'); const content = document.getElementById('transfer-details-content'); if (!modal || !content) return; const xSocialScreen = document.getElementById('x-social-screen'); const isLightMode = xSocialScreen && xSocialScreen.classList.contains('x-theme-light'); if (transferData.isBusiness && (!transferData.depositAmount || !transferData.remainingAmount)) { const totalAmount = parseFloat(transferData.amount || 0); const depositRatio = parseFloat(transferData.depositRatio || 0); transferData.depositAmount = ((totalAmount * depositRatio) / 100).toFixed(2); transferData.remainingAmount = (totalAmount - parseFloat(transferData.depositAmount)).toFixed(2); if (!transferData.taskDeadline && transferData.taskDeadlineHours) { const createdAt = new Date(transferData.timestamp || Date.now()); const deadlineMs = createdAt.getTime() + parseFloat(transferData.taskDeadlineHours) * 60 * 60 * 1000; transferData.taskDeadline = new Date(deadlineMs).toISOString(); } } const amount = parseFloat(transferData.amount || 0).toFixed(2); const status = transferData.status || 'pending'; const note = transferData.note || ''; const time = transferData.time || formatMessageTime(transferData.timestamp); content.innerHTML = renderTransferTicket(transferData, isOwn, isLightMode); const acceptBtn = document.getElementById('accept-transfer-btn'); const rejectBtn = document.getElementById('reject-transfer-btn'); const completeTaskBtn = document.getElementById('complete-task-btn'); if (acceptBtn) { acceptBtn.onclick = () => acceptTransfer(transferData.timestamp); } if (rejectBtn) { rejectBtn.onclick = () => rejectTransfer(transferData.timestamp); } if (completeTaskBtn) { completeTaskBtn.onclick = () => completeBusinessTask(transferData.timestamp); } modal.style.display = 'flex'; }; window.closeTransferDetails = function () { const modal = document.getElementById('transfer-details-modal'); if (modal) { modal.style.display = 'none'; } }; function renderTransferTicket(transferData, isOwn, isLightMode) { const amount = parseFloat(transferData.amount || 0).toFixed(2); const status = transferData.status || 'pending'; const note = transferData.note || ''; const time = transferData.time || formatMessageTime(transferData.timestamp); const isBusiness = transferData.isBusiness === true; const businessData = isBusiness ? transferData : null; const isPending = status === 'pending'; const canUserAction = !isOwn && isPending; let deadlineText = ''; let isExpired = false; if (isBusiness && businessData.taskDeadline) { const deadline = new Date(businessData.taskDeadline); const now = new Date(); const remainingMs = deadline.getTime() - now.getTime(); if (remainingMs > 0) { const hours = Math.floor(remainingMs / (1000 * 60 * 60)); const minutes = Math.floor((remainingMs % (1000 * 60 * 60)) / (1000 * 60)); deadlineText = hours > 0 ? `${hours}小时${minutes}分钟` : `${minutes}分钟`; } else { deadlineText = '已过期'; isExpired = true; } } const displayAmount = isBusiness ? parseFloat(businessData.depositAmount || 0).toFixed(2) : amount; return ` <div style="background-color: ${ isLightMode ? '#ffffff' : '#1f1f1f' }; position: relative; overflow: hidden; max-height: 80vh; display: flex; flex-direction: column; "> <div style="flex: 1; overflow-y: auto; overflow-x: hidden; "> <div style="padding: 24px 20px 16px; background-color: ${isLightMode ? '#ffffff' : '#1f1f1f'}; position: relative; "> <div onclick="closeTransferDetails()" style="position: absolute; top: 16px; right: 16px; cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s; z-index: 10; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </div> <div style="text-align: center; font-size: 18px; font-weight: 700; color: ${ isLightMode ? '#1a1a1a' : '#e5e5e5' }; margin-bottom: 8px; ">${isBusiness ? '商业转账详情' : '转账详情'}</div> ${ isBusiness ? ` <div style="text-align: center; margin-bottom: 12px; "> <span style="display: inline-block; padding: 4px 12px; background: linear-gradient(135deg, ${ isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.15)' } 0%, ${isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.08)'} 100%); color: ${ isLightMode ? '#1a1a1a' : '#e5e5e5' }; font-size: 11px; font-weight: 600; border-radius: 12px; letter-spacing: 0.5px; border: 1px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.2)' }; ">BUSINESS</span> </div> ` : '' } <div style="text-align: center; font-size: 12px; color: ${ isLightMode ? '#888888' : '#aaaaaa' }; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 20px; ">${getTransferStatusText(status, isOwn)}</div> <div style="text-align: center; font-size: 32px; font-weight: 700; color: ${ isLightMode ? '#1a1a1a' : '#e5e5e5' }; margin-bottom: ${isBusiness ? '8px' : '16px'}; "> ${getTransferAmountText(status, isOwn, displayAmount)} </div> ${ isBusiness ? ` <div style="text-align: center; font-size: 12px; color: ${ isLightMode ? '#888888' : '#aaaaaa' }; margin-bottom: 16px; ">定金 ${businessData.depositRatio}%</div> ` : '' } ${ note ? ` <div style="text-align: center; font-size: 14px; color: ${ isLightMode ? '#666666' : '#999999' }; margin-bottom: 16px; padding: 8px 16px; background-color: ${ isLightMode ? '#f5f5f5' : '#2d2d2d' }; border-radius: 8px; ">"${note}"</div> ` : '' } <div style="position: absolute; top: 50%; right: -40px; transform: translateY(-50%) rotate(15deg); font-size: 48px; color: ${ isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)' }; font-weight: 700; pointer-events: none; white-space: nowrap; ">${isBusiness ? 'BUSINESS' : 'TRANSFER'}</div> </div> <div style="height: 20px; background: linear-gradient(90deg, ${isLightMode ? '#ffffff' : '#1f1f1f'} 10px, transparent 10px, transparent 20px, ${isLightMode ? '#ffffff' : '#1f1f1f'} 20px ); background-size: 20px 100%; position: relative; "> <div style="position: absolute; left: -10px; top: 50%; transform: translateY(-50%); width: 20px; height: 20px; border-radius: 50%; background-color: rgba(0, 0, 0, 0.5); "></div> <div style="position: absolute; right: -10px; top: 50%; transform: translateY(-50%); width: 20px; height: 20px; border-radius: 50%; background-color: rgba(0, 0, 0, 0.5); "></div> </div> <div style="padding: 16px 20px 20px; background-color: ${isLightMode ? '#ffffff' : '#1f1f1f'}; "> ${ isBusiness ? ` <div style="margin-bottom: 16px; padding: 12px; background-color: ${ isLightMode ? '#f8f9fa' : '#2a2a2a' }; border: 1px solid ${isLightMode ? '#e1e8ed' : '#38444d'}; border-radius: 8px; "> <div style="font-size: 12px; font-weight: 600; color: ${ isLightMode ? '#666666' : '#999999' }; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; display: flex; align-items: center; gap: 6px; "> <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: currentColor;"> <g><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm2 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"></path></g> </svg> 任务要求 </div> <div style="font-size: 14px; color: ${ isLightMode ? '#1a1a1a' : '#e5e5e5' }; line-height: 1.5; margin-bottom: 12px; white-space: pre-wrap; word-wrap: break-word; ">${ businessData.taskDescription }</div> <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 8px; border-top: 1px solid ${ isLightMode ? '#e1e8ed' : '#38444d' }; "> <span style="font-size: 12px; color: ${ isLightMode ? '#666666' : '#999999' }; display: flex; align-items: center; gap: 4px; "> <svg viewBox="0 0 24 24" style="width: 12px; height: 12px; fill: currentColor;"> <g><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path></g> </svg> 任务期限 </span> <span style="font-size: 13px; font-weight: 600; color: ${ isExpired ? '#dc2626' : isLightMode ? '#1a1a1a' : '#e5e5e5' }; ">${deadlineText}</span> </div> </div> <div style="margin-bottom: 16px; padding: 12px; background-color: ${ isLightMode ? '#f8f9fa' : '#2a2a2a' }; border: 1px solid ${isLightMode ? '#e1e8ed' : '#38444d'}; border-radius: 8px; "> <div style="font-size: 12px; font-weight: 600; color: ${ isLightMode ? '#666666' : '#999999' }; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; display: flex; align-items: center; gap: 6px; "> <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: currentColor;"> <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.31-8.86c-1.77-.45-2.34-.94-2.34-1.67 0-.84.79-1.43 2.1-1.43 1.38 0 1.9.66 1.94 1.64h1.71c-.05-1.34-.87-2.57-2.49-2.97V5H10.9v1.69c-1.51.32-2.72 1.3-2.72 2.81 0 1.79 1.49 2.69 3.66 3.21 1.95.46 2.34 1.15 2.34 1.87 0 .53-.39 1.39-2.1 1.39-1.6 0-2.23-.72-2.32-1.64H8.04c.1 1.7 1.36 2.66 2.86 2.97V19h2.34v-1.67c1.52-.29 2.72-1.16 2.73-2.77-.01-2.2-1.9-2.96-3.66-3.42z"></path></g> </svg> 金额明细 </div> <div style="display: flex; justify-content: space-between; margin-bottom: 6px; "> <span style="font-size: 13px; color: ${isLightMode ? '#666666' : '#999999'};">总金额</span> <span style="font-size: 13px; color: ${isLightMode ? '#1a1a1a' : '#e5e5e5'}; font-weight: 600;">$${amount}</span> </div> <div style="display: flex; justify-content: space-between; margin-bottom: 6px; "> <span style="font-size: 13px; color: ${isLightMode ? '#666666' : '#999999'};">定金 (${ businessData.depositRatio || 0 }%)</span> <span style="font-size: 13px; color: var(--x-accent); font-weight: 600;">$${parseFloat( businessData.depositAmount || 0, ).toFixed(2)}</span> </div> <div style="display: flex; justify-content: space-between; padding-top: 6px; border-top: 1px solid ${ isLightMode ? '#e1e8ed' : '#38444d' }; "> <span style="font-size: 13px; color: ${isLightMode ? '#666666' : '#999999'};">尾款</span> <span style="font-size: 13px; color: ${isLightMode ? '#1a1a1a' : '#e5e5e5'}; font-weight: 600;">$${parseFloat( businessData.remainingAmount || 0, ).toFixed(2)}</span> </div> </div> ` : '' } <div style="display: flex; justify-content: space-between; margin-bottom: 12px; "> <span style="color: ${isLightMode ? '#666666' : '#999999'}; font-size: 13px;">转账时间</span> <span style="color: ${isLightMode ? '#1a1a1a' : '#e5e5e5'}; font-size: 13px;">${time}</span> </div> <div style="display: flex; justify-content: space-between; margin-bottom: 12px; "> <span style="color: ${isLightMode ? '#666666' : '#999999'}; font-size: 13px;">${ isBusiness ? '任务状态' : '转账状态' }</span> <span style="color: ${isLightMode ? '#1a1a1a' : '#e5e5e5'}; font-size: 13px;"> ${status === 'pending' ? '待处理' : status === 'accepted' ? '已完成' : '已拒绝'} </span> </div> <div style="text-align: center; margin: 16px 0; padding: 8px 0; border-top: 1px solid ${ isLightMode ? '#eeeeee' : '#333333' }; "> <div style="font-family: monospace; font-size: 24px; color: ${ isLightMode ? '#1a1a1a' : '#e5e5e5' }; letter-spacing: 2px; margin-bottom: 4px; ">||||||||||||| ${Math.random().toString().slice(2, 13)}</div> <div style="font-size: 11px; color: ${isLightMode ? '#888888' : '#aaaaaa'}; ">${ isBusiness ? 'BUSINESS' : 'TRANSFER' } ID: ${transferData.timestamp ? new Date(transferData.timestamp).getTime() : Date.now()}</div> </div> </div> </div> ${ canUserAction ? ` <div style="padding: 16px 20px; background-color: ${isLightMode ? '#ffffff' : '#1f1f1f'}; border-top: 1px solid ${ isLightMode ? '#eeeeee' : '#333333' }; "> ${ isBusiness ? ` <div style="font-size: 12px; color: ${ isLightMode ? '#888888' : '#aaaaaa' }; text-align: center; margin-bottom: 12px; line-height: 1.4; ">接收此商业转账即表示同意完成任务要求</div> ` : '' } <div style="display: flex; gap: 12px; "> <button id="reject-transfer-btn" style="flex: 1; padding: 12px; border: 1px solid ${ isLightMode ? '#dc2626' : '#ef4444' }; color: ${ isLightMode ? '#dc2626' : '#ef4444' }; background: transparent; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='${ isLightMode ? '#fef2f2' : '#1f1416' }'" onmouseout="this.style.backgroundColor='transparent'"> 拒绝 </button> <button id="accept-transfer-btn" style="flex: 1; padding: 12px; border: none; color: #ffffff; background: var(--x-accent); border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'"> ${isBusiness ? '接受任务' : '接收'} </button> </div> </div> ` : '' } ${ isOwn && isBusiness && status === 'accepted' && businessData.taskStatus === 'in_progress' ? ` <div style="padding: 16px 20px; background-color: ${isLightMode ? '#ffffff' : '#1f1f1f'}; border-top: 1px solid ${ isLightMode ? '#eeeeee' : '#333333' }; "> <div style="font-size: 12px; color: ${ isLightMode ? '#888888' : '#aaaaaa' }; text-align: center; margin-bottom: 12px; line-height: 1.4; ">验收任务完成情况，确认后将支付剩余尾款</div> <button id="complete-task-btn" style="width: 100%; padding: 12px; border: 1px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.2)' }; color: ${isLightMode ? '#0f1419' : '#ffffff'}; background: linear-gradient(135deg, ${ isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.12)' } 0%, ${ isLightMode ? 'rgba(0, 0, 0, 0.04)' : 'rgba(255, 255, 255, 0.06)' } 100%); border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px; " onmouseover="this.style.backgroundColor='${ isLightMode ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.15)' }'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;"> <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"></path></g> </svg> 确认完成任务并支付尾款 ($${businessData.remainingAmount}) </button> </div> ` : '' } </div> `; } window.acceptTransfer = async function (transferId) { try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data && savedConversation.data.messages) { const transferMessage = savedConversation.data.messages.find( msg => msg.type === 'transfer' && msg.timestamp === transferId, ); if (transferMessage) { const totalAmount = parseFloat(transferMessage.amount); const isBusiness = transferMessage.isBusiness === true; let receivedAmount = totalAmount; if (isBusiness) { if (transferMessage.depositAmount !== undefined) { receivedAmount = parseFloat(transferMessage.depositAmount); } else { const depositRatio = parseFloat(transferMessage.depositRatio) || 20; receivedAmount = (totalAmount * depositRatio) / 100; transferMessage.depositAmount = receivedAmount.toFixed(2); transferMessage.remainingAmount = (totalAmount - receivedAmount).toFixed(2); } } transferMessage.status = 'accepted'; if (isBusiness) { transferMessage.taskStatus = 'in_progress'; const acceptedTime = new Date(); transferMessage.acceptedAt = acceptedTime.toISOString(); const deadlineHours = parseFloat(transferMessage.taskDeadlineHours) || 24; const deadlineTime = new Date(acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000); transferMessage.taskDeadline = deadlineTime.toISOString(); console.log('⏰ [接收商业转账] 设置任务截止时间:', { acceptedAt: transferMessage.acceptedAt, deadlineHours: deadlineHours, taskDeadline: transferMessage.taskDeadline, }); } const systemNotification = { type: 'system', systemType: 'transferAccepted', content: isBusiness ? `你接收了商业转账（定金 $${receivedAmount.toFixed(2)}），请在 ${ transferMessage.taskDeadlineHours } 小时内完成任务` : `你接收了 $${totalAmount.toFixed(2)} 的转账`, timestamp: new Date().toISOString(), time: '刚刚', }; savedConversation.data.messages.push(systemNotification); await xDb.xAccountProfiles.put(savedConversation); await loadWalletData(); const currentBalance = parseFloat(walletData.balance) || 0; walletData.balance = currentBalance + receivedAmount; const senderName = currentMessageConversation?.user?.name || '对方'; const transaction = { id: 'transfer_in_' + Date.now(), description: isBusiness ? `商业转账收款（定金）- ${senderName}${transferMessage.note ? ` - ${transferMessage.note}` : ''}` : `收款自 ${senderName}${transferMessage.note ? ` - ${transferMessage.note}` : ''}`, amount: receivedAmount, timestamp: new Date().toISOString(), type: isBusiness ? 'business_transfer_deposit_in' : 'transfer_in', }; walletData.transactions.unshift(transaction); await saveWalletData(); if (isBusiness && currentMessageConversation) { const businessTransferRecord = { ...transferMessage, transferId: transferId, conversationId: currentMessageConversation.id, senderName: senderName, senderHandle: currentMessageConversation.user?.handle || 'unknown', senderAvatar: currentMessageConversation.user?.avatar || 'https: direction: 'received', createdAt: transferMessage.timestamp, acceptedAt: new Date().toISOString(), }; console.log('💼 [保存商业转账] 准备保存:', businessTransferRecord); console.log('💼 [保存商业转账] taskDeadline:', businessTransferRecord.taskDeadline); console.log('💼 [保存商业转账] taskStatus:', businessTransferRecord.taskStatus); await saveBusinessTransfer(businessTransferRecord); console.log('💼 商业转账已记录到数据库'); } showPhoneNotification({ title: 'X Wallet', message: isBusiness ? `已收定金 $${receivedAmount.toFixed(2)}，请完成任务以获得尾款` : `已收款 $${totalAmount.toFixed(2)}, 当前余额 $${walletData.balance.toFixed(2)}`, avatar: window.userProfileData?.avatar, leftIcon: 'x', }); closeTransferDetails(); if (currentMessageConversation && currentMessageConversation.user) { const profileData = { name: currentMessageConversation.user.name, handle: currentMessageConversation.user.handle, avatar: currentMessageConversation.user.avatar, }; await loadCharacterMessageDetail(currentMessageConversation, profileData); } console.log('✅ 转账已接收:', receivedAmount, '新余额:', walletData.balance); if (isBusiness) { setTimeout(() => { handleBusinessTransferTask(transferMessage, currentMessageConversation); }, 1000); } if (!isBusiness && !transferMessage.isOwn) { const ongoingBusinessTransfer = savedConversation.data.messages .filter( msg => msg.type === 'transfer' && msg.isBusiness && msg.taskStatus === 'in_progress' && !msg.isOwn, ) .pop(); if (ongoingBusinessTransfer) { console.log('💼 [商业任务尾款] 检测到进行中的商业任务，将此转账视为尾款'); ongoingBusinessTransfer.taskStatus = 'completed'; ongoingBusinessTransfer.completedAt = new Date().toISOString(); await xDb.xAccountProfiles.put(savedConversation); await updateBusinessTransferStatus(ongoingBusinessTransfer.timestamp, 'completed'); console.log('✅ [商业任务尾款] 商业任务已完成，状态已更新'); showPhoneNotification({ title: 'X Wallet', message: `任务已完成，已收尾款 $${receivedAmount.toFixed(2)}, 当前余额 $${walletData.balance.toFixed( 2, )}`, avatar: window.userProfileData?.avatar, leftIcon: 'x', }); } } } } } catch (error) { console.error('接收转账失败:', error); showXToast('接收转账失败', 'error'); } }; window.rejectTransfer = async function (transferId) { try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data && savedConversation.data.messages) { const transferMessage = savedConversation.data.messages.find( msg => msg.type === 'transfer' && msg.timestamp === transferId, ); if (transferMessage) { const amount = parseFloat(transferMessage.amount); transferMessage.status = 'rejected'; const systemNotification = { type: 'system', systemType: 'transferRejected', content: `你拒绝了 $${amount.toFixed(2)} 的转账`, timestamp: new Date().toISOString(), time: '刚刚', }; savedConversation.data.messages.push(systemNotification); await xDb.xAccountProfiles.put(savedConversation); closeTransferDetails(); if (currentMessageConversation && currentMessageConversation.user) { const profileData = { name: currentMessageConversation.user.name, handle: currentMessageConversation.user.handle, avatar: currentMessageConversation.user.avatar, }; await loadCharacterMessageDetail(currentMessageConversation, profileData); } console.log('❌ 转账已拒绝:', amount); } } } catch (error) { console.error('拒绝转账失败:', error); showXToast('拒绝转账失败', 'error'); } }; window.completeBusinessTask = async function (transferId) { try { if (!currentMessageConversation) { showXToast('无法找到当前对话', 'error'); return; } const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data && savedConversation.data.messages) { const transferMessage = savedConversation.data.messages.find( msg => msg.type === 'transfer' && msg.timestamp === transferId, ); if (transferMessage && transferMessage.isBusiness) { const remainingAmount = parseFloat(transferMessage.remainingAmount); await loadWalletData(); if (walletData.balance < remainingAmount) { showXToast('钱包余额不足，无法支付尾款', 'error'); return; } transferMessage.taskStatus = 'completed'; transferMessage.completedAt = new Date().toISOString(); walletData.balance -= remainingAmount; const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`; let recipientName = '对方'; const businessData = await xDb.xAccountProfiles.get(businessTransfersId); if (businessData && businessData.data) { const businessTransfer = businessData.data.find(t => t.transferId === transferId); if (businessTransfer && businessTransfer.senderName) { recipientName = businessTransfer.senderName; } } if (recipientName === '对方' && currentMessageConversation?.user?.name) { recipientName = currentMessageConversation.user.name; } const transaction = { id: 'business_remaining_' + Date.now(), description: `商业转账尾款 - ${recipientName}${transferMessage.note ? ` - ${transferMessage.note}` : ''}`, amount: -remainingAmount, timestamp: new Date().toISOString(), type: 'business_transfer_remaining', }; walletData.transactions.unshift(transaction); await saveWalletData(); const systemNotification = { type: 'system', systemType: 'businessTaskCompleted', content: `你已确认任务完成并支付尾款 $${remainingAmount.toFixed(2)}`, timestamp: new Date().toISOString(), time: '刚刚', }; savedConversation.data.messages.push(systemNotification); await xDb.xAccountProfiles.put(savedConversation); await updateBusinessTransferStatus(transferId, 'completed'); showPhoneNotification({ title: 'X Wallet', message: `任务已完成，已支付尾款 $${remainingAmount.toFixed(2)}`, avatar: window.userProfileData?.avatar, leftIcon: 'x', }); closeTransferDetails(); if (currentMessageConversation && currentMessageConversation.user) { const profileData = { name: currentMessageConversation.user.name, handle: currentMessageConversation.user.handle, avatar: currentMessageConversation.user.avatar, }; await loadCharacterMessageDetail(currentMessageConversation, profileData); } console.log('✅ 商业任务已完成，尾款已支付:', remainingAmount); } } } catch (error) { console.error('完成任务失败:', error); showXToast('完成任务失败', 'error'); } }; async function updateBusinessTransferStatus(transferId, newStatus) { try { const xDb = getXDB(); const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`; let savedData = await xDb.xAccountProfiles.get(businessTransfersId); if (savedData && savedData.data) { const transfer = savedData.data.find(t => t.transferId === transferId); if (transfer) { transfer.taskStatus = newStatus; if (newStatus === 'in_progress' && !transfer.acceptedAt) { transfer.acceptedAt = new Date().toISOString(); } else if (newStatus === 'completed') { transfer.completedAt = new Date().toISOString(); } await xDb.xAccountProfiles.put(savedData); console.log('✅ 商业转账状态已更新:', newStatus); } } } catch (error) { console.error('❌ 更新商业转账状态失败:', error); } } window.openBusinessTransferManager = async function () { const xSocialScreen = document.getElementById('x-social-screen'); const isLightMode = xSocialScreen && xSocialScreen.classList.contains('x-theme-light'); const xDb = getXDB(); const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`; let savedData = await xDb.xAccountProfiles.get(businessTransfersId); const businessTransfers = savedData?.data || []; const sentTransfers = businessTransfers.filter(t => t.direction === 'sent'); const receivedTransfers = businessTransfers.filter(t => t.direction === 'received'); const modal = document.createElement('div'); modal.id = 'business-transfer-manager-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: ${ isLightMode ? 'rgba(255, 255, 255, 0.85)' : 'rgba(0, 0, 0, 0.85)' }; display: flex; align-items: center; justify-content: center; z-index: 26; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); `; modal.innerHTML = ` <div style="background-color: ${ isLightMode ? 'rgba(255, 255, 255, 0.95)' : 'rgba(0, 0, 0, 0.95)' }; backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 24px; width: 90%; max-width: 500px; max-height: 80vh; position: relative; overflow: hidden; box-shadow: ${ isLightMode ? '0 20px 60px rgba(0, 0, 0, 0.15), 0 8px 32px rgba(0, 0, 0, 0.1)' : '0 20px 60px rgba(0, 0, 0, 0.8), 0 8px 32px rgba(255, 255, 255, 0.05)' }; border: 2px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)' }; " onclick="event.stopPropagation()"> <div style="background: linear-gradient(135deg, ${ isLightMode ? 'rgba(248, 250, 252, 0.8)' : 'rgba(22, 24, 28, 0.8)' } 0%, ${ isLightMode ? 'rgba(255, 255, 255, 0.6)' : 'rgba(0, 0, 0, 0.6)' } 100%); padding: 24px; text-align: center; border-bottom: 2px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)' }; position: relative; "> <button onclick="closeBusinessTransferManager()" style="position: absolute; top: 16px; right: 16px; background: transparent; border: none; color: ${ isLightMode ? '#536471' : '#71767b' }; cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.2s; " onmouseover="this.style.backgroundColor='${ isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)' }';" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </button> <div style="color: ${ isLightMode ? '#0f1419' : '#ffffff' }; font-size: 20px; font-weight: 700; margin-bottom: 8px; display: flex; align-items: center; justify-content: center; gap: 8px; "> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path></g> </svg> 商业转账管理 </div> <div style="color: ${isLightMode ? '#536471' : '#71767b'}; font-size: 14px; ">管理所有商业合作订单</div> </div> <div style="max-height: 60vh; overflow-y: auto; padding: 16px 20px; "> <div style="margin-bottom: 24px;"> <div style="color: ${ isLightMode ? '#0f1419' : '#ffffff' }; font-size: 16px; font-weight: 700; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid ${ isLightMode ? '#e1e8ed' : '#38444d' }; display: flex; align-items: center; gap: 6px; "> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;"> <g><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></g> </svg> 已发出 (${sentTransfers.length}) </div> ${ sentTransfers.length > 0 ? renderBusinessTransferList(sentTransfers, 'sent', isLightMode) : renderNoBusinessTransfers('sent', isLightMode) } </div> <div> <div style="color: ${ isLightMode ? '#0f1419' : '#ffffff' }; font-size: 16px; font-weight: 700; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid ${ isLightMode ? '#e1e8ed' : '#38444d' }; display: flex; align-items: center; gap: 6px; "> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;"> <g><path d="M20 8l-8 5-8-5V6l8 5 8-5m0-2H4c-1.11 0-2 .89-2 2v12a2 2 0 002 2h16a2 2 0 002-2V6a2 2 0 00-2-2z"></path></g> </svg> 已接收 (${receivedTransfers.length}) </div> ${ receivedTransfers.length > 0 ? renderBusinessTransferList(receivedTransfers, 'received', isLightMode) : renderNoBusinessTransfers('received', isLightMode) } </div> </div> </div> `; document.body.appendChild(modal); document.body.style.overflow = 'hidden'; modal.addEventListener('click', e => { if (e.target === modal) { closeBusinessTransferManager(); } }); const managerCard = modal.querySelector('div'); managerCard.style.transform = 'scale(0.8) translateY(20px)'; managerCard.style.opacity = '0'; requestAnimationFrame(() => { managerCard.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)'; managerCard.style.transform = 'scale(1) translateY(0)'; managerCard.style.opacity = '1'; }); }; function renderBusinessTransferList(transfers, type, isLightMode) { return transfers .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)) .map(transfer => { const now = new Date(); let deadline; if (transfer.taskDeadline) { deadline = new Date(transfer.taskDeadline); } else if (transfer.acceptedAt && transfer.taskDeadlineHours) { const acceptedTime = new Date(transfer.acceptedAt); const deadlineHours = parseFloat(transfer.taskDeadlineHours) || 24; deadline = new Date(acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000); } else if (transfer.createdAt && transfer.taskDeadlineHours) { const createdTime = new Date(transfer.createdAt); const deadlineHours = parseFloat(transfer.taskDeadlineHours) || 24; deadline = new Date(createdTime.getTime() + deadlineHours * 60 * 60 * 1000); } else { deadline = new Date(now.getTime() + 24 * 60 * 60 * 1000); } const remainingMs = deadline.getTime() - now.getTime(); const isExpired = remainingMs <= 0; let deadlineText = ''; if (remainingMs > 0) { const hours = Math.floor(remainingMs / (1000 * 60 * 60)); const minutes = Math.floor((remainingMs % (1000 * 60 * 60)) / (1000 * 60)); deadlineText = hours > 0 ? `${hours}小时${minutes}分钟` : `${minutes}分钟`; } else { deadlineText = '已过期'; } const statusMap = { pending: '待接收', in_progress: '进行中', completed: '已完成', failed: '已失败', }; const statusColorMap = { pending: '#f59e0b', in_progress: 'var(--x-accent)', completed: '#22c55e', failed: '#ef4444', }; return ` <div style="margin-bottom: 12px; background: linear-gradient(135deg, ${ isLightMode ? 'rgba(0, 0, 0, 0.02)' : 'rgba(255, 255, 255, 0.03)' } 0%, ${isLightMode ? 'rgba(0, 0, 0, 0.01)' : 'rgba(255, 255, 255, 0.01)'} 100%); border: 1px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)' }; border-radius: 12px; transition: all 0.2s; position: relative; overflow: hidden; "> <div style="position: absolute; top: 50%; right: -20px; transform: translateY(-50%) rotate(15deg); font-size: 32px; color: ${ isLightMode ? 'rgba(0, 0, 0, 0.02)' : 'rgba(255, 255, 255, 0.02)' }; font-weight: 700; pointer-events: none; ">TICKET</div> <div style="padding: 16px;"> <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;"> <div style="flex: 1;"> <div style="color: ${isLightMode ? '#0f1419' : '#ffffff'}; font-size: 15px; font-weight: 600; margin-bottom: 4px; ">${ type === 'sent' ? `发给 ${transfer.senderName}` : `来自 ${transfer.senderName}` }</div> <div style="color: ${ isLightMode ? '#536471' : '#71767b' }; font-size: 11px; font-family: monospace; letter-spacing: 0.5px; ">${new Date(transfer.createdAt).toLocaleString( 'zh-CN', )}</div> </div> <div style="display: inline-block; padding: 4px 10px; background: linear-gradient(135deg, ${ isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.12)' } 0%, ${isLightMode ? 'rgba(0, 0, 0, 0.04)' : 'rgba(255, 255, 255, 0.06)'} 100%); color: ${ isLightMode ? '#0f1419' : '#ffffff' }; font-size: 10px; font-weight: 600; border-radius: 10px; margin-left: 12px; border: 1px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.2)' }; letter-spacing: 0.5px; ">${statusMap[transfer.taskStatus || 'pending']}</div> </div> <div style="color: ${ isLightMode ? '#0f1419' : '#e5e5e5' }; font-size: 13px; line-height: 1.4; margin-bottom: 12px; padding: 10px; background: ${ isLightMode ? 'rgba(0, 0, 0, 0.02)' : 'rgba(255, 255, 255, 0.02)' }; border-left: 2px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.15)' }; border-radius: 4px; ">${transfer.taskDescription}</div> <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 12px; border-top: 1px dashed ${ isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)' }; "> <div style="color: ${ isExpired ? '#dc2626' : isLightMode ? '#536471' : '#71767b' }; font-size: 11px; display: flex; align-items: center; gap: 4px; "> <svg viewBox="0 0 24 24" style="width: 11px; height: 11px; fill: currentColor;"> <g><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path></g> </svg> ${deadlineText} </div> <div style="color: ${ isLightMode ? '#0f1419' : '#ffffff' }; font-size: 13px; font-weight: 700; font-family: monospace; ">$${ transfer.amount } <span style="opacity: 0.6; font-size: 11px;">(定金 $${transfer.depositAmount})</span></div> </div> <div style="margin-top: 12px; text-align: right;"> <button onclick="deleteBusinessTransfer('${transfer.transferId}', event)" style="background: linear-gradient(135deg, ${ isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.12)' } 0%, ${isLightMode ? 'rgba(0, 0, 0, 0.04)' : 'rgba(255, 255, 255, 0.06)'} 100%); color: ${ isLightMode ? '#0f1419' : '#ffffff' }; border: 1px dashed ${ isLightMode ? 'rgba(0, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.2)' }; border-radius: 8px; padding: 6px 12px; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 4px; position: relative; overflow: hidden; " onmouseover="this.style.background='linear-gradient(135deg, ${ isLightMode ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.15)' } 0%, ${ isLightMode ? 'rgba(0, 0, 0, 0.06)' : 'rgba(255, 255, 255, 0.08)' } 100%)'; this.style.transform='scale(1.02)'" onmouseout="this.style.background='linear-gradient(135deg, ${ isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.12)' } 0%, ${isLightMode ? 'rgba(0, 0, 0, 0.04)' : 'rgba(255, 255, 255, 0.06)'} 100%)'; this.style.transform='scale(1)'"> <svg viewBox="0 0 24 24" style="width: 12px; height: 12px; fill: currentColor; opacity: 0.7;"> <g><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></g> </svg> 删除任务 </button> </div> </div> </div> `; }) .join(''); } function renderNoBusinessTransfers(type, isLightMode) { return ` <div style="text-align: center; padding: 32px 20px; color: ${isLightMode ? '#6b7280' : '#9ca3af'}; font-size: 14px; "> <svg viewBox="0 0 24 24" style="width: 48px; height: 48px; fill: currentColor; opacity: 0.3; margin: 0 auto 12px;"> <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path></g> </svg> <div>暂无${type === 'sent' ? '发出的' : '接收的'}商业转账</div> </div> `; } window.closeBusinessTransferManager = function () { const modal = document.getElementById('business-transfer-manager-modal'); if (modal) { const managerCard = modal.querySelector('div'); managerCard.style.transform = 'scale(0.9) translateY(20px)'; managerCard.style.opacity = '0'; setTimeout(() => { modal.remove(); document.body.style.overflow = 'auto'; }, 200); } }; window.deleteBusinessTransfer = async function (transferId, event) { event.stopPropagation(); try { const xDb = getXDB(); const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(businessTransfersId); if (!savedData || !savedData.data) { showXToast('无法找到商业转账数据', 'error'); return; } const transfer = savedData.data.find(t => t.transferId === transferId); if (!transfer) { showXToast('无法找到该任务', 'error'); return; } const depositAmount = parseFloat(transfer.depositAmount) || 0; const totalAmount = parseFloat(transfer.amount) || 0; const penaltyAmount = depositAmount + totalAmount; const confirmMessage = `删除此任务将扣除违约费 $${penaltyAmount.toFixed(2)}\n（定金 $${depositAmount.toFixed( 2, )} + 全款 $${totalAmount.toFixed(2)}）\n并降低信用值\n\n是否确认删除？`; if (!confirm(confirmMessage)) { return; } const cardElement = event.target.closest('div[style*="margin-bottom: 12px"]'); if (cardElement) { cardElement.style.animation = 'crumple-tear 0.6s cubic-bezier(0.4, 0, 1, 1) forwards'; cardElement.style.transformOrigin = 'center center'; if (!document.getElementById('business-transfer-animations')) { const style = document.createElement('style'); style.id = 'business-transfer-animations'; style.textContent = ` @keyframes crumple-tear { 0% { transform: scale(1) rotate(0deg); opacity: 1; } 20% { transform: scale(0.95) rotate(-2deg); } 40% { transform: scale(0.9) rotate(2deg) translateY(-5px); filter: blur(0px); } 60% { transform: scale(0.7) rotate(-5deg) translateY(-10px); filter: blur(1px); opacity: 0.8; } 80% { transform: scale(0.4) rotate(8deg) translateY(-15px); filter: blur(3px); opacity: 0.4; } 100% { transform: scale(0.1) rotate(15deg) translateY(-20px); filter: blur(5px); opacity: 0; } } `; document.head.appendChild(style); } await new Promise(resolve => setTimeout(resolve, 600)); } await loadWalletData(); walletData.balance -= penaltyAmount; const creditPenalty = Math.min(20, Math.floor(totalAmount / 10)); walletData.creditScore = Math.max(0, walletData.creditScore - creditPenalty); const penaltyTransaction = { id: 'penalty_' + Date.now(), description: `删除商业任务违约费 - ${transfer.taskDescription.substring(0, 30)}...`, amount: -penaltyAmount, timestamp: new Date().toISOString(), type: 'penalty', }; walletData.transactions.unshift(penaltyTransaction); await saveWalletData(); savedData.data = savedData.data.filter(t => t.transferId !== transferId); await xDb.xAccountProfiles.put(savedData); showPhoneNotification({ title: 'X Wallet', message: `任务已删除，扣除违约费 $${penaltyAmount.toFixed(2)}，信用值 -${creditPenalty}`, avatar: window.userProfileData?.avatar, leftIcon: 'custom', leftIconHtml: ` <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #71767b;"> <g><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></g> </svg> `, duration: 5000, }); console.log(`🗑️ 商业任务已删除，扣除违约费 $${penaltyAmount.toFixed(2)}，信用值 -${creditPenalty}`); closeBusinessTransferManager(); setTimeout(() => { openBusinessTransferManager(); }, 300); } catch (error) { console.error('删除商业转账失败:', error); showXToast('删除失败', 'error'); } }; let businessTransferCheckInterval = null; function startBusinessTransferCheck() { if (businessTransferCheckInterval) { clearInterval(businessTransferCheckInterval); } checkBusinessTransfersStatus(); businessTransferCheckInterval = setInterval(() => { checkBusinessTransfersStatus(); }, 60000); console.log('✅ 商业转账状态检查已启动'); } async function checkBusinessTransfersStatus() { try { const xDb = getXDB(); const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(businessTransfersId); if (!savedData || !savedData.data || savedData.data.length === 0) return; const businessTransfers = savedData.data; const now = new Date(); let needsUpdate = false; const transfersToKeep = []; for (const transfer of businessTransfers) { let deadline; if (transfer.taskDeadline) { deadline = new Date(transfer.taskDeadline); } else if (transfer.acceptedAt && transfer.taskDeadlineHours) { const acceptedTime = new Date(transfer.acceptedAt); const deadlineHours = parseFloat(transfer.taskDeadlineHours) || 24; deadline = new Date(acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000); } else if (transfer.createdAt && transfer.taskDeadlineHours) { const createdTime = new Date(transfer.createdAt); const deadlineHours = parseFloat(transfer.taskDeadlineHours) || 24; deadline = new Date(createdTime.getTime() + deadlineHours * 60 * 60 * 1000); } else { console.warn('⚠️ 商业转账缺少截止时间信息，跳过:', transfer.transferId); transfersToKeep.push(transfer); continue; } const completedAt = transfer.completedAt ? new Date(transfer.completedAt) : null; const timeToDeadline = deadline.getTime() - now.getTime(); if ( transfer.taskStatus === 'in_progress' && timeToDeadline > 0 && timeToDeadline <= 3600000 && !transfer.reminderSent ) { const hours = Math.floor(timeToDeadline / (1000 * 60 * 60)); const minutes = Math.floor((timeToDeadline % (1000 * 60 * 60)) / (1000 * 60)); const timeText = hours > 0 ? `${hours}小时${minutes}分钟` : `${minutes}分钟`; showPhoneNotification({ title: '商业转账提醒', message: `任务"${transfer.taskDescription.substring(0, 20)}..."还剩${timeText}截止，请及时完成！`, avatar: window.userProfileData?.avatar, leftIcon: 'custom', leftIconHtml: ` <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #f59e0b;"> <g><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path></g> </svg> `, duration: 5000, }); transfer.reminderSent = true; needsUpdate = true; console.log(`⏰ 已发送任务即将到期提醒: ${transfer.taskDescription.substring(0, 30)}`); } let shouldDelete = false; let isExpiredPenalty = false; if (timeToDeadline < 0 && Math.abs(timeToDeadline) > 3600000) { shouldDelete = true; if (transfer.taskStatus === 'in_progress') { isExpiredPenalty = true; } console.log(`🗑️ 删除过期任务: ${transfer.taskDescription.substring(0, 30)}`); } if (transfer.taskStatus === 'completed' && completedAt) { const timeSinceCompletion = now.getTime() - completedAt.getTime(); if (timeSinceCompletion > 10800000) { shouldDelete = true; console.log(`🗑️ 删除已完成任务: ${transfer.taskDescription.substring(0, 30)}`); } } if (!shouldDelete) { transfersToKeep.push(transfer); } else { if (isExpiredPenalty) { const totalAmount = parseFloat(transfer.amount) || 0; const penaltyAmount = totalAmount; await loadWalletData(); walletData.balance -= penaltyAmount; const creditPenalty = Math.min(15, Math.floor(totalAmount / 15)); walletData.creditScore = Math.max(0, walletData.creditScore - creditPenalty); const penaltyTransaction = { id: 'penalty_expired_' + Date.now(), description: `任务过期违约费 - ${transfer.taskDescription.substring(0, 30)}...`, amount: -penaltyAmount, timestamp: new Date().toISOString(), type: 'penalty', }; walletData.transactions.unshift(penaltyTransaction); await saveWalletData(); showPhoneNotification({ title: 'X Wallet', message: `任务已过期，扣除违约费 $${penaltyAmount.toFixed(2)}，信用值 -${creditPenalty}`, avatar: window.userProfileData?.avatar, leftIcon: 'custom', leftIconHtml: ` <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #71767b;"> <g><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path></g> </svg> `, duration: 5000, }); console.log(`💸 任务过期违约费 $${penaltyAmount.toFixed(2)}，信用值 -${creditPenalty}`); } needsUpdate = true; } } if (needsUpdate) { await xDb.xAccountProfiles.put({ handle: businessTransfersId, name: 'businessTransfers', accountId: currentAccountId || 'main', data: transfersToKeep, updatedAt: new Date().toISOString(), }); console.log(`✅ 商业转账数据已更新，保留 ${transfersToKeep.length}/${businessTransfers.length} 条记录`); const managerModal = document.getElementById('business-transfer-manager-modal'); if (managerModal) { closeBusinessTransferManager(); setTimeout(() => { openBusinessTransferManager(); }, 300); } } } catch (error) { console.error('检查商业转账状态失败:', error); } } async function handleAITransferResponse(aiMessages, conversationRef) { try { const aiTransfer = aiMessages.find(msg => msg.type === 'transfer' && msg.status && msg.status !== 'pending'); if (!aiTransfer) return; const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversationRef.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (!savedConversation || !savedConversation.data || !savedConversation.data.messages) return; const userTransfer = savedConversation.data.messages.find( msg => msg.type === 'transfer' && msg.isOwn && msg.status === 'pending', ); if (!userTransfer) return; const amount = parseFloat(userTransfer.amount); const isBusiness = userTransfer.isBusiness === true; if (aiTransfer.status === 'accepted') { userTransfer.status = 'accepted'; if (isBusiness) { userTransfer.taskStatus = 'in_progress'; userTransfer.acceptedAt = new Date().toISOString(); } const systemNotification = { type: 'system', systemType: 'transferAccepted', content: isBusiness ? `对方接收了商业转账（定金 $${parseFloat(userTransfer.depositAmount).toFixed(2)}），已开始执行任务` : `对方接收了你的 $${amount.toFixed(2)} 转账`, timestamp: new Date().toISOString(), time: '刚刚', }; savedConversation.data.messages.push(systemNotification); await loadWalletData(); const recipientName = conversationRef?.user?.name || '对方'; const transactionType = isBusiness ? 'business_transfer_deposit' : 'transfer_out'; const actualAmount = isBusiness ? parseFloat(userTransfer.depositAmount) : amount; const transaction = walletData.transactions.find( t => t.type === transactionType && Math.abs(t.amount + actualAmount) < 0.01, ); if (transaction) { transaction.description = isBusiness ? `商业转账给 ${recipientName}（定金已接收）${userTransfer.note ? ` - ${userTransfer.note}` : ''}` : `转账给 ${recipientName}（已接收）${userTransfer.note ? ` - ${userTransfer.note}` : ''}`; } await saveWalletData(); await xDb.xAccountProfiles.put(savedConversation); if (isBusiness && conversationRef) { await updateBusinessTransferStatus(userTransfer.timestamp, 'in_progress'); console.log('💼 AI接收的商业转账状态已更新为进行中'); setTimeout(() => { handleBusinessTransferTask(userTransfer, conversationRef); }, 1000); } setTimeout(() => { showPhoneNotification({ title: 'X Wallet', message: isBusiness ? `对方已接受任务，定金 $${actualAmount.toFixed(2)} 已支付` : `已付款 $${amount.toFixed(2)}, 当前余额 $${walletData.balance.toFixed(2)}`, avatar: window.userProfileData?.avatar, leftIcon: 'x', }); }, 3000); console.log('✅ AI 接收了转账:', isBusiness ? `商业转账，定金 ${actualAmount}` : amount); } else if (aiTransfer.status === 'rejected') { userTransfer.status = 'rejected'; if (isBusiness) { userTransfer.taskStatus = 'rejected'; } const systemNotification = { type: 'system', systemType: 'transferRejected', content: isBusiness ? `对方拒绝了商业转账，定金 $${parseFloat(userTransfer.depositAmount).toFixed(2)} 已退回` : `对方拒绝了你的 $${amount.toFixed(2)} 转账`, timestamp: new Date().toISOString(), time: '刚刚', }; savedConversation.data.messages.push(systemNotification); await loadWalletData(); const actualAmount = isBusiness ? parseFloat(userTransfer.depositAmount) : amount; walletData.balance += actualAmount; const recipientName = conversationRef?.user?.name || '对方'; const transactionType = isBusiness ? 'business_transfer_deposit' : 'transfer_out'; const transaction = walletData.transactions.find( t => t.type === transactionType && Math.abs(t.amount + actualAmount) < 0.01, ); if (transaction) { transaction.description = isBusiness ? `商业转账给 ${recipientName}（已拒绝，定金已退回）${userTransfer.note ? ` - ${userTransfer.note}` : ''}` : `转账给 ${recipientName}（已拒绝，已退回）${userTransfer.note ? ` - ${userTransfer.note}` : ''}`; transaction.amount = 0; } const refundTransaction = { id: 'refund_' + Date.now(), description: isBusiness ? `${recipientName} 拒绝商业转账，定金已退回${userTransfer.note ? ` - ${userTransfer.note}` : ''}` : `${recipientName} 拒绝转账，已退回${userTransfer.note ? ` - ${userTransfer.note}` : ''}`, amount: actualAmount, timestamp: new Date().toISOString(), type: 'refund', }; walletData.transactions.unshift(refundTransaction); await saveWalletData(); await xDb.xAccountProfiles.put(savedConversation); setTimeout(() => { showPhoneNotification({ title: 'X Wallet', message: isBusiness ? `商业转账被拒绝，定金 $${actualAmount.toFixed(2)} 已退回，当前余额 $${walletData.balance.toFixed(2)}` : `转账被拒绝，已退回 $${actualAmount.toFixed(2)}, 当前余额 $${walletData.balance.toFixed(2)}`, avatar: window.userProfileData?.avatar, leftIcon: 'x', }); }, 4000); console.log('❌ AI 拒绝了转账，已退回:', isBusiness ? `商业转账定金 ${actualAmount}` : amount); } if (currentMessageConversation && currentMessageConversation.id === conversationRef.id) { const profileData = { name: conversationRef.user.name, handle: conversationRef.user.handle, avatar: conversationRef.user.avatar, }; await loadCharacterMessageDetail(currentMessageConversation, profileData); } } catch (error) { console.error('处理 AI 转账响应失败:', error); } } async function loadCharacterMessageDetail(messageData, profileData) { const contentContainer = document.getElementById('message-detail-content'); if (!contentContainer) return; contentContainer.innerHTML = ''; const topAvatar = document.getElementById('message-detail-top-avatar'); const topName = document.getElementById('message-detail-top-name'); if (topAvatar) { if (topAvatar._fangroupClickHandler) { topAvatar.removeEventListener('click', topAvatar._fangroupClickHandler); delete topAvatar._fangroupClickHandler; } if (topAvatar._fangroupTouchHandler) { topAvatar.removeEventListener('touchend', topAvatar._fangroupTouchHandler); delete topAvatar._fangroupTouchHandler; } } if (topAvatar) topAvatar.src = profileData.avatar; if (topName) topName.textContent = profileData.name; if (topAvatar) { const isCharacter = messageData.id.startsWith('msg_') && messageData.id !== 'msg_001' && !messageData.id.startsWith('msg_account_'); if (!isCharacter) { topAvatar.onclick = () => { openMessageContactSettings(messageData, profileData); }; topAvatar.style.cursor = 'pointer'; } else { topAvatar.onclick = null; topAvatar.style.cursor = 'default'; } } const detailAvatar = document.getElementById('message-detail-avatar'); const detailName = document.getElementById('message-detail-name'); const detailHandle = document.getElementById('message-detail-handle'); if (detailAvatar) { detailAvatar.src = profileData.avatar; detailAvatar.style.cursor = 'pointer'; detailAvatar.onclick = () => { openAccountProfile(profileData.name, profileData.handle, profileData.avatar); }; } if (detailName) detailName.textContent = profileData.name; if (detailHandle) detailHandle.textContent = profileData.handle; const bioEl = document.getElementById('message-detail-bio'); if (profileData.bio && bioEl) { bioEl.textContent = profileData.bio; bioEl.style.display = 'block'; } else if (bioEl) { bioEl.style.display = 'none'; } const followersCount = profileData.followersCount || '0'; const config = languageConfig[currentLanguage] || languageConfig.zh; const followersEl = document.getElementById('message-detail-followers'); if (followersEl) { if (currentLanguage === 'en') { followersEl.textContent = `${followersCount} ${config.messageFollowers}`; } else { followersEl.textContent = `${followersCount} ${config.messageFollowers}`; } } try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if ( savedConversation && savedConversation.data && savedConversation.data.messages && savedConversation.data.messages.length > 0 ) { console.log('✅ 加载已有对话记录'); const today = new Date(); const dateStr = currentLanguage === 'en' ? today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) : `${today.getFullYear()}年${today.getMonth() + 1}月${String(today.getDate()).padStart(2, '0')}日`; contentContainer.appendChild(renderDateSeparator(dateStr)); const groups = groupMessagesBySender(savedConversation.data.messages); const allMessageElements = []; groups.forEach(group => { const isOwn = group[0].message.isOwn === true; group.forEach((item, indexInGroup) => { const isLastInGroup = indexInGroup === group.length - 1; const messageEl = renderMessageItem(item.message, isOwn, item.index, isLastInGroup); contentContainer.appendChild(messageEl); allMessageElements.push(messageEl); }); }); allMessageElements.forEach(el => { el.style.opacity = '1'; el.style.transform = 'translateY(0)'; }); try { const waitingMessages = savedConversation.data.messages.filter( msg => msg.isOwn && msg.waitingForAIResponse === true, ); if (waitingMessages.length > 0) { userMessageQueue = waitingMessages; console.log(`✅ 恢复了 ${userMessageQueue.length} 条等待AI回复的消息到队列`); } else { console.log('📝 所有消息都已得到AI回复'); } } catch (error) { console.error('恢复消息队列失败:', error); } setTimeout(() => { const scrollable = document.getElementById('message-detail-scrollable'); if (scrollable) { scrollable.scrollTop = scrollable.scrollHeight; } }, 100); return; } } catch (error) { console.warn('检查对话记录失败:', error); } contentContainer.innerHTML = ` <div style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 32px;"> <div style="text-align: center; max-width: 300px;"> <img src="${profileData.avatar}" style="width: 64px; height: 64px; border-radius: 50%; margin-bottom: 16px; object-fit: cover; "> <div style="font-size: 28px; font-weight: 700; color:var(--x-text-primary); margin-bottom: 8px; ">开始对话</div> <div style="font-size: 14px; color:var(--x-text-secondary); line-height: 1.4; ">向 ${profileData.name} 发送消息开始聊天</div> </div> </div> `; console.log('✅ 角色私信详情页已加载（首次对话）'); } async function loadFanGroupMessageDetail(messageData) { const contentContainer = document.getElementById('message-detail-content'); if (!contentContainer) return; contentContainer.innerHTML = ''; const topAvatar = document.getElementById('message-detail-top-avatar'); const topName = document.getElementById('message-detail-top-name'); if (topAvatar) { topAvatar.src = messageData.userAvatar || messageData.groupAvatar; topAvatar.style.cursor = 'pointer'; if (topAvatar._fangroupClickHandler) { topAvatar.removeEventListener('click', topAvatar._fangroupClickHandler); topAvatar.removeEventListener('touchend', topAvatar._fangroupTouchHandler); } topAvatar._fangroupClickHandler = e => { e.preventDefault(); e.stopPropagation(); console.log('🖱️ [头像点击] 粉丝群头像被点击'); openFanGroupSettings(messageData); }; topAvatar._fangroupTouchHandler = e => { e.preventDefault(); e.stopPropagation(); console.log('📱 [头像点击] 移动端触摸事件'); openFanGroupSettings(messageData); }; topAvatar.addEventListener('click', topAvatar._fangroupClickHandler); topAvatar.addEventListener('touchend', topAvatar._fangroupTouchHandler); } if (topName) topName.textContent = messageData.userName || messageData.groupName; const scrollableContainer = document.getElementById('message-detail-scrollable'); if (scrollableContainer) { const userInfoSection = scrollableContainer.querySelector('[style*="padding: 24px"]'); if (userInfoSection) { userInfoSection.style.display = 'none'; } } try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if ( savedConversation && savedConversation.data && savedConversation.data.messages && savedConversation.data.messages.length > 0 ) { console.log('✅ 加载已有粉丝群对话记录'); const today = new Date(); const dateStr = currentLanguage === 'en' ? today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) : `${today.getFullYear()}年${today.getMonth() + 1}月${String(today.getDate()).padStart(2, '0')}日`; contentContainer.appendChild(renderDateSeparator(dateStr)); const groups = groupMessagesBySender(savedConversation.data.messages); const allMessageElements = []; groups.forEach(group => { const isOwn = group[0].message.isOwn === true; group.forEach((item, indexInGroup) => { const isLastInGroup = indexInGroup === group.length - 1; const messageEl = renderMessageItem(item.message, isOwn, item.index, isLastInGroup); contentContainer.appendChild(messageEl); allMessageElements.push(messageEl); }); }); allMessageElements.forEach(el => { el.style.opacity = '1'; el.style.transform = 'translateY(0)'; }); try { const waitingMessages = savedConversation.data.messages.filter( msg => msg.isOwn && msg.waitingForAIResponse === true, ); if (waitingMessages.length > 0) { userMessageQueue = waitingMessages; console.log(`✅ 恢复了 ${userMessageQueue.length} 条等待AI回复的消息到队列`); } } catch (error) { console.error('恢复消息队列失败:', error); } setTimeout(() => { const scrollable = document.getElementById('message-detail-scrollable'); if (scrollable) { scrollable.scrollTop = scrollable.scrollHeight; } }, 100); return; } } catch (error) { console.warn('检查粉丝群对话记录失败:', error); } contentContainer.innerHTML = ` <div style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 32px;"> <div style="text-align: center; max-width: 300px;"> <img src="${messageData.userAvatar || messageData.groupAvatar}" style="width: 64px; height: 64px; border-radius: 50%; margin-bottom: 16px; object-fit: cover; "> <div style="font-size: 28px; font-weight: 700; color:var(--x-text-primary); margin-bottom: 8px; ">粉丝群聊天</div> <div style="font-size: 14px; color:var(--x-text-secondary); line-height: 1.4; ">向粉丝群发送消息开始互动</div> </div> </div> `; console.log('✅ 粉丝群私信详情页已加载（首次对话）'); } function loadMessageConversation(messageData, conversationData) { const contentContainer = document.getElementById('message-detail-content'); if (!contentContainer) return; contentContainer.innerHTML = ''; if (!messageData._accountType && messageData.id) { if (messageData.id.startsWith('msg_account_')) { messageData._accountType = 'account'; } else if (messageData.id.startsWith('msg_npc_')) { messageData._accountType = 'npc'; } else if (messageData.id.startsWith('msg_relationship_')) { messageData._accountType = 'relationshipNpc'; } else if (!messageData.id.startsWith('msg_')) { messageData._accountType = 'stranger'; } console.log('🔍 [类型检测] 设置消息类型为:', messageData._accountType); } const topAvatar = document.getElementById('message-detail-top-avatar'); const topName = document.getElementById('message-detail-top-name'); if (topAvatar) { if (topAvatar._fangroupClickHandler) { topAvatar.removeEventListener('click', topAvatar._fangroupClickHandler); delete topAvatar._fangroupClickHandler; } if (topAvatar._fangroupTouchHandler) { topAvatar.removeEventListener('touchend', topAvatar._fangroupTouchHandler); delete topAvatar._fangroupTouchHandler; } } if (topAvatar) topAvatar.src = messageData.user.avatar; if (topName) topName.textContent = messageData.user.name; const isCharacterMessage = messageData.id && messageData.id.startsWith('msg_') && messageData.id !== 'msg_001' && !messageData.id.startsWith('msg_account_'); if (topAvatar && !isCharacterMessage) { topAvatar.style.cursor = 'pointer'; topAvatar.onclick = e => { e.stopPropagation(); console.log('📱 [小头像点击] 打开联系人设置，类型:', messageData._accountType); openMessageContactSettings(messageData, conversationData); }; } else if (topAvatar) { topAvatar.style.cursor = 'default'; topAvatar.onclick = null; } const detailAvatar = document.getElementById('message-detail-avatar'); const detailName = document.getElementById('message-detail-name'); const detailHandle = document.getElementById('message-detail-handle'); if (detailAvatar) { detailAvatar.src = messageData.user.avatar; detailAvatar.style.cursor = 'pointer'; detailAvatar.onclick = () => { openAccountProfileFromDM(messageData, conversationData); }; } if (detailName) detailName.textContent = messageData.user.name; if (detailHandle) detailHandle.textContent = messageData.user.handle; const bioEl = document.getElementById('message-detail-bio'); if (conversationData?.senderProfile?.bio && bioEl) { bioEl.textContent = conversationData.senderProfile.bio; bioEl.style.display = 'block'; } else if (bioEl) { bioEl.style.display = 'none'; } const followersCount = conversationData?.senderProfile?.followers || Math.floor(Math.random() * 1000) + 100; const config = languageConfig[currentLanguage] || languageConfig.zh; if (currentLanguage === 'en') { document.getElementById('message-detail-followers').textContent = `${followersCount} ${config.messageFollowers}`; } else { document.getElementById('message-detail-followers').textContent = `${followersCount} ${config.messageFollowers}`; } const today = new Date(); const dateStr = currentLanguage === 'en' ? today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) : `${today.getFullYear()}年${today.getMonth() + 1}月${String(today.getDate()).padStart(2, '0')}日`; contentContainer.appendChild(renderDateSeparator(dateStr)); if (conversationData && conversationData.messages && conversationData.messages.length > 0) { const groups = groupMessagesBySender(conversationData.messages); const allMessageElements = []; groups.forEach(group => { const isOwn = group[0].message.isOwn === true; group.forEach((item, indexInGroup) => { const isLastInGroup = indexInGroup === group.length - 1; const messageEl = renderMessageItem(item.message, isOwn, item.index, isLastInGroup); contentContainer.appendChild(messageEl); allMessageElements.push(messageEl); }); }); allMessageElements.forEach(el => { el.style.opacity = '1'; el.style.transform = 'translateY(0)'; }); } else { const messageEl = renderMessageItem( { type: 'text', content: messageData.preview, time: '刚刚', }, false, 0, true, ); contentContainer.appendChild(messageEl); messageEl.style.opacity = '1'; messageEl.style.transform = 'translateY(0)'; } setTimeout(() => { const scrollable = document.getElementById('message-detail-scrollable'); if (scrollable) { scrollable.scrollTop = scrollable.scrollHeight; } }, 100); } window.openMessageDetail = async function (messageData) { if (!messageData._accountType && messageData.id) { if (messageData.id.startsWith('msg_account_')) { messageData._accountType = 'account'; } else if (messageData.id.startsWith('msg_npc_')) { messageData._accountType = 'npc'; } else if (messageData.id.startsWith('msg_relationship_')) { messageData._accountType = 'relationshipNpc'; } else if (!messageData.id.startsWith('msg_') || messageData.id === 'msg_001') { messageData._accountType = 'stranger'; } console.log('🔍 [打开私信] 检测到类型:', messageData._accountType, '| ID:', messageData.id); } if (messageData.type !== 'fangroup') { delete messageData.type; } currentMessageConversation = messageData; userMessageQueue = []; const messagesPage = document.getElementById('x-messages-page'); const notificationsPage = document.getElementById('x-notifications-page'); const isFromNotifications = notificationsPage && notificationsPage.style.display === 'flex'; messagesPage.style.display = 'none'; const composeBtn = document.getElementById('compose-message-btn'); if (composeBtn) composeBtn.style.display = 'none'; if (isFromNotifications) { notificationsPage.style.display = 'none'; } const refreshMessagesBtn = document.getElementById('refresh-messages-btn'); if (refreshMessagesBtn) refreshMessagesBtn.style.display = 'none'; const detailPage = document.getElementById('x-message-detail-page'); detailPage.style.display = 'flex'; detailPage.dataset.conversationId = messageData.id; detailPage.dataset.fromNotifications = isFromNotifications ? 'true' : 'false'; setTimeout(() => { const messageInput = document.getElementById('message-input'); const sendBtn = document.getElementById('message-send-btn'); if (messageInput) { messageInput.disabled = false; messageInput.placeholder = '发送私信'; } if (sendBtn) { sendBtn.disabled = false; } }, 50); const xDb = getXDB(); try { const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); if (savedData && savedData.data) { const messagesList = savedData.data; const messageIndex = messagesList.findIndex(msg => msg.id === messageData.id); if (messageIndex !== -1 && messagesList[messageIndex].unread) { messagesList[messageIndex].unread = false; messagesList[messageIndex].unreadCount = 0; await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); sampleMessagesData = messagesList; console.log('✅ 已清除未读标记'); } } } catch (error) { console.error('清除未读标记失败:', error); } const isFanGroup = messageData.type === 'fangroup' || (messageData.id && messageData.id.startsWith('fangroup_')); if (isFanGroup) { console.log('👥 检测到粉丝群，加载粉丝群详情页'); loadFanGroupMessageDetail(messageData); return; } const isCharacterMessage = messageData.id && messageData.id.startsWith('msg_') && messageData.id !== 'msg_001'; if (isCharacterMessage) { console.log('📨 检测到已绑定角色私信，从账户主页数据读取资料'); const characterId = messageData.id.replace('msg_', ''); try { const xProfile = await xDb.xCharacterProfiles.get(characterId); if (xProfile) { const cleanHandle = xProfile.xHandle.replace('@', ''); const accountProfile = await xDb.xAccountProfiles.get(cleanHandle); if (accountProfile && accountProfile.accountInfo) { console.log('✅ 找到角色的账户主页数据'); const updatedAccountInfo = { ...accountProfile.accountInfo, avatar: xProfile.xAvatar, name: xProfile.xName, handle: xProfile.xHandle, }; loadCharacterMessageDetail(messageData, updatedAccountInfo); return; } } console.log('⚠️ 未找到角色的账户主页数据，使用基本资料'); if (xProfile) { const basicProfile = { name: xProfile.xName, handle: xProfile.xHandle, avatar: xProfile.xAvatar, bio: xProfile.xBio || '', followersCount: xProfile.followersCount || '0', verified: xProfile.xVerified || false, }; loadCharacterMessageDetail(messageData, basicProfile); return; } } catch (error) { console.error('读取角色资料失败:', error); } } if (!messageData.user && messageData.userName) { messageData.user = { name: messageData.userName, handle: messageData.userHandle, avatar: messageData.userAvatar, verified: messageData.verified || false, }; } const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`; let conversationData = null; try { const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data) { conversationData = savedConversation.data; console.log('✅ 从数据库加载私信对话数据'); if (savedConversation.isBlocked) { console.log('⚠️ [拉黑] 该用户已被拉黑'); loadMessageConversation(messageData, conversationData); setTimeout(() => { const messageInput = document.getElementById('message-input'); const sendBtn = document.getElementById('message-send-btn'); if (messageInput) { messageInput.disabled = true; messageInput.placeholder = '对方已将你拉黑'; } if (sendBtn) { sendBtn.disabled = true; } }, 100); return; } loadMessageConversation(messageData, conversationData); } } catch (error) { console.error('加载私信对话数据失败:', error); } if (!conversationData) { const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { contentContainer.innerHTML = ` <div style="flex: 1; display: flex; align-items: center; justify-content: center;"> <div style="text-align: center;"> <div style="margin-bottom: 12px;"> <svg viewBox="0 0 24 24" style="width: 48px; height: 48px; fill: var(--x-accent); animation: spin 1s linear infinite;"> <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"></path></g> </svg> </div> <div style="color:var(--x-text-primary); font-size: 16px; font-weight: 600;">正在生成对话详情...</div> </div> </div> `; } conversationData = await generateMessageConversation(messageData); if (conversationData) { loadMessageConversation(messageData, conversationData); } else { loadMessageConversation(messageData, null); } } }; window.closeMessageDetail = async function () { const input = document.getElementById('message-input'); if (input) { input.value = ''; autoResizeMessageInput(input); } const detailPage = document.getElementById('x-message-detail-page'); const isFromNotifications = detailPage.dataset.fromNotifications === 'true'; detailPage.style.display = 'none'; const isFromAccountProfile = currentMessageConversation && currentMessageConversation._fromAccountProfile === true; if (isFromAccountProfile) { console.log('📖 [返回] 从私信详情页返回账户主页'); const accountProfilePage = document.getElementById('account-profile-page'); if (accountProfilePage) { accountProfilePage.style.display = 'flex'; } } else if (isFromNotifications) { console.log('📖 [返回] 从私信详情页返回通知页面'); document.getElementById('x-notifications-page').style.display = 'flex'; const refreshMessagesBtn = document.getElementById('refresh-messages-btn'); const isAllTab = document.querySelector('.notification-tab.active')?.textContent.includes('全部') || document.querySelector('.notification-tab.active')?.textContent.includes('All'); if (refreshMessagesBtn && isAllTab) { refreshMessagesBtn.style.display = 'flex'; } if (typeof loadNotifications === 'function') { await loadNotifications(); } } else { console.log('📖 [返回] 从私信详情页返回私信列表'); document.getElementById('x-messages-page').style.display = 'flex'; const composeBtn = document.getElementById('compose-message-btn'); if (composeBtn) composeBtn.style.display = 'flex'; if (typeof renderMessagesList === 'function') { renderMessagesList(sampleMessagesData); } } currentMessageConversation = null; userMessageQueue = []; }; window.autoResizeMessageInput = function (textarea) { textarea.style.height = '36px'; const scrollHeight = textarea.scrollHeight; if (scrollHeight > 36) { textarea.style.height = Math.min(scrollHeight, 100) + 'px'; } }; window.handleMessageInputKeydown = function (event) { if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendMessageContent(); } }; window.toggleMessageFunctionMenu = function () { const menu = document.getElementById('message-function-menu'); const addBtn = document.getElementById('message-add-btn'); if (!menu || !addBtn) return; const isVisible = menu.style.display === 'flex'; if (isVisible) { menu.style.display = 'none'; const svg = addBtn.querySelector('svg'); if (svg) svg.style.transform = 'rotate(0deg)'; } else { menu.style.display = 'flex'; const svg = addBtn.querySelector('svg'); if (svg) svg.style.transform = 'rotate(45deg)'; } }; document.addEventListener('click', function (e) { const menu = document.getElementById('message-function-menu'); const addBtn = document.getElementById('message-add-btn'); if (!menu || !addBtn) return; if (!menu.contains(e.target) && !addBtn.contains(e.target)) { menu.style.display = 'none'; const svg = addBtn.querySelector('svg'); if (svg) svg.style.transform = 'rotate(0deg)'; } }); window.openImageTypeSelector = function () { const dialog = document.getElementById('image-type-selector-dialog'); if (dialog) { dialog.style.display = 'flex'; } }; window.closeImageTypeSelector = function () { const dialog = document.getElementById('image-type-selector-dialog'); if (dialog) { dialog.style.display = 'none'; } }; window.selectImageType = function (type) { closeImageTypeSelector(); if (type === 'real') { triggerMessageImageUpload(); } else if (type === 'text') { openTextImageDialog(); } }; function openTextImageDialog() { const dialog = document.getElementById('text-image-dialog'); const input = document.getElementById('text-image-description-input'); const counter = document.getElementById('text-image-counter'); if (dialog) { dialog.style.display = 'flex'; } if (input) { input.value = ''; } if (counter) { counter.textContent = '0 / 500'; } setTimeout(() => { if (input) input.focus(); }, 100); } window.closeTextImageDialog = function () { const dialog = document.getElementById('text-image-dialog'); if (dialog) { dialog.style.display = 'none'; } }; window.updateTextImageCounter = function () { const input = document.getElementById('text-image-description-input'); const counter = document.getElementById('text-image-counter'); if (input && counter) { counter.textContent = `${input.value.length} / 500`; } }; window.sendTextImage = async function () { const input = document.getElementById('text-image-description-input'); if (!input) return; const description = input.value.trim(); if (!description) { showXToast('请输入图片描述', 'error'); return; } closeTextImageDialog(); const now = new Date(); const hours = now.getHours(); const minutes = String(now.getMinutes()).padStart(2, '0'); const timeStr = `${hours}:${minutes}`; const textImageMessage = { type: 'image', imageDescription: description, sensitive: false, time: timeStr, timestamp: now.toISOString(), isOwn: true, }; userMessageQueue.push(textImageMessage); const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { const currentMessageCount = contentContainer.querySelectorAll('.message-item').length; const newMessage = renderMessageItem(textImageMessage, true, currentMessageCount); contentContainer.appendChild(newMessage); setTimeout(() => { newMessage.style.transition = 'all 0.3s ease'; newMessage.style.opacity = '1'; newMessage.style.transform = 'translateY(0)'; }, 10); setTimeout(() => { const scrollable = document.getElementById('message-detail-scrollable'); if (scrollable) { scrollable.scrollTo({ top: scrollable.scrollHeight, behavior: 'smooth', }); } }, 100); } await saveUserMessageToDB(textImageMessage); console.log('✅ 文字图片消息已添加到队列，等待发送'); }; window.triggerMessageImageUpload = function () { const input = document.getElementById('message-image-input'); if (input) input.click(); }; let pendingMessageImages = []; window.handleMessageImageUpload = async function (event) { const files = event.target.files; if (!files || files.length === 0) return; if (pendingMessageImages.length + files.length > 4) { showXToast('最多只能上传4张图片', 'error'); return; } for (let i = 0; i < files.length; i++) { const file = files[i]; if (!file.type.startsWith('image/')) { showXToast('请选择图片文件', 'error'); continue; } if (file.size > 5 * 1024 * 1024) { showXToast('图片文件不能超过5MB', 'error'); continue; } const reader = new FileReader(); reader.onload = function (e) { const base64Data = e.target.result; pendingMessageImages.push({ content: base64Data, fileName: file.name, }); sendImageMessage(base64Data, file.name); console.log(`✅ 图片 ${file.name} 已添加并发送`); }; reader.readAsDataURL(file); } event.target.value = ''; }; async function sendImageMessage(base64Data, fileName) { const now = new Date(); const hours = now.getHours(); const minutes = String(now.getMinutes()).padStart(2, '0'); const period = hours >= 12 ? '下午' : '上午'; const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutes} ${period}`; const imageMessage = { type: 'image', imageData: base64Data, fileName: fileName, time: timeStr, timestamp: now.toISOString(), isOwn: true, }; userMessageQueue.push(imageMessage); const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { const currentMessageCount = contentContainer.querySelectorAll('.message-item:not(#typing-indicator)').length; const newMessage = renderMessageItem(imageMessage, true, currentMessageCount, true); contentContainer.appendChild(newMessage); setTimeout(() => { newMessage.style.transition = 'all 0.3s ease'; newMessage.style.opacity = '1'; newMessage.style.transform = 'translateY(0)'; }, 10); setTimeout(() => { const scrollable = document.getElementById('message-detail-scrollable'); if (scrollable) { scrollable.scrollTo({ top: scrollable.scrollHeight, behavior: 'smooth', }); } }, 100); } await saveUserMessageToDB(imageMessage); console.log('✅ 图片消息已添加到队列，等待发送'); } let userMessageQueue = []; let userStickers = []; let currentStickerTab = 'frequent'; async function loadUserStickers() { try { const xDb = getXDB(); const accountId = currentAccountId || 'main'; const stickerDataId = `userStickers_${accountId}`; const stickerData = await xDb.xUserTweets.get(stickerDataId); if (stickerData && stickerData.stickers) { userStickers = stickerData.stickers; userStickers = userStickers.map(sticker => ({ ...sticker, useCount: sticker.useCount || 0, lastUsedAt: sticker.lastUsedAt || null, })); } else { userStickers = []; } } catch (error) { console.error('加载表情包失败:', error); userStickers = []; } } async function saveUserStickers() { try { const xDb = getXDB(); const accountId = currentAccountId || 'main'; const stickerDataId = `userStickers_${accountId}`; await xDb.xUserTweets.put({ id: stickerDataId, stickers: userStickers, updatedAt: new Date().toISOString(), }); console.log('✅ 表情包已保存'); } catch (error) { console.error('保存表情包失败:', error); } } window.openStickerPicker = async function () { await loadUserStickers(); currentStickerTab = 'frequent'; updateStickerTabUI(); renderStickerList(); const modal = document.getElementById('sticker-picker-modal'); if (modal) { modal.style.display = 'flex'; } }; window.switchStickerTab = function (tab) { currentStickerTab = tab; updateStickerTabUI(); renderStickerList(); }; function updateStickerTabUI() { const frequentTab = document.getElementById('sticker-tab-frequent'); const allTab = document.getElementById('sticker-tab-all'); if (currentStickerTab === 'frequent') { frequentTab.style.borderBottomColor = 'var(--x-accent)'; frequentTab.style.color = 'var(--x-text-primary)'; allTab.style.borderBottomColor = 'transparent'; allTab.style.color = 'var(--x-text-secondary)'; } else { frequentTab.style.borderBottomColor = 'transparent'; frequentTab.style.color = 'var(--x-text-secondary)'; allTab.style.borderBottomColor = 'var(--x-accent)'; allTab.style.color = 'var(--x-text-primary)'; } } window.closeStickerPicker = function () { const modal = document.getElementById('sticker-picker-modal'); if (modal) { modal.style.display = 'none'; } if (window.setCommentStickerMode) { window.setCommentStickerMode(false); } }; function renderStickerList() { const listContainer = document.getElementById('sticker-list'); if (!listContainer) return; const screenWidth = window.innerWidth; let minColumnWidth = '80px'; if (screenWidth < 400) { minColumnWidth = '70px'; } else if (screenWidth < 500) { minColumnWidth = '75px'; } listContainer.style.gridTemplateColumns = `repeat(auto-fill, minmax(${minColumnWidth}, 1fr))`; listContainer.innerHTML = ''; let displayStickers = []; if (currentStickerTab === 'frequent') { const frequentStickers = userStickers .filter(s => s.useCount > 0) .sort((a, b) => { if (b.useCount !== a.useCount) { return b.useCount - a.useCount; } if (a.lastUsedAt && b.lastUsedAt) { return new Date(b.lastUsedAt) - new Date(a.lastUsedAt); } return 0; }) .slice(0, 20); displayStickers = frequentStickers; if (frequentStickers.length === 0) { listContainer.style.display = 'flex'; listContainer.innerHTML = ` <div style="width: 100%; text-align: center; padding: 60px 20px; color:var(--x-text-secondary); "> <div style="font-size: 48px; margin-bottom: 12px;">😊</div> <div style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">暂无常用表情包</div> <div style="font-size: 13px;">使用过的表情包会出现在这里</div> </div> `; return; } else { listContainer.style.display = 'grid'; } } else { displayStickers = [...userStickers].reverse(); if (userStickers.length === 0) { listContainer.style.display = 'flex'; listContainer.innerHTML = ` <div style="width: 100%; text-align: center; padding: 60px 20px; color:var(--x-text-secondary); "> <div style="font-size: 48px; margin-bottom: 12px;">📦</div> <div style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">暂无表情包</div> <div style="font-size: 13px;">点击下方"导入表情包"添加</div> </div> `; return; } else { listContainer.style.display = 'grid'; } } displayStickers.forEach((sticker, displayIndex) => { const originalIndex = userStickers.findIndex(s => s.url === sticker.url && s.description === sticker.description); const stickerEl = document.createElement('div'); stickerEl.style.cssText = ` position: relative; cursor: pointer; border-radius: 8px; overflow: hidden; transition: transform 0.2s; width: 100%; padding-bottom: 100%; background-color:var(--x-bg-secondary); `; stickerEl.onmouseover = () => { stickerEl.style.transform = 'scale(1.05)'; }; stickerEl.onmouseout = () => { stickerEl.style.transform = 'scale(1)'; }; stickerEl.onclick = () => { if (window.getCommentStickerMode && window.getCommentStickerMode()) { if (window.selectCommentSticker) { window.selectCommentSticker(sticker); } } else { sendStickerMessage(sticker); closeStickerPicker(); } }; stickerEl.innerHTML = ` <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;"> <img src="${sticker.url}" alt="${sticker.description}" style="width: 100%; height: 100%; object-fit: cover; display: block;" onerror="this.parentElement.innerHTML='<div style=\\'display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%; background-color:var(--x-bg-secondary); color:var(--x-text-secondary); font-size: 11px; padding: 4px; text-align: center;\\'>❌<br>加载失败<br><button onclick=\\'deleteSticker(${originalIndex})\\' style=\\'margin-top: 4px; padding: 2px 6px; font-size: 10px; background: var(--x-accent); color: white; border: none; border-radius: 4px; cursor: pointer;\\'>删除</button></div>';"> </div> <button onclick="deleteSticker(${originalIndex}); event.stopPropagation();" ontouchstart="this.style.opacity='1'" style="position: absolute; top: 4px; right: 4px; background: rgba(0,0,0,0.7); border: none; border-radius: 50%; width: 24px; height: 24px; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; opacity: 0; transition: opacity 0.2s; z-index: 2; " onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0'"> <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #fff;"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </button> `; listContainer.appendChild(stickerEl); }); } window.deleteSticker = async function (index) { if (confirm('确定要删除这个表情包吗？')) { userStickers.splice(index, 1); await saveUserStickers(); const managerDialog = document.getElementById('sticker-manager-dialog'); if (managerDialog && managerDialog.style.display === 'flex') { renderStickerManager(); } const pickerModal = document.getElementById('sticker-picker-modal'); if (pickerModal && pickerModal.style.display === 'flex') { renderStickerList(); } showXToast('已删除', 'success'); } }; window.openAddStickerDialog = function () { const dialog = document.getElementById('add-sticker-dialog'); if (dialog) { dialog.style.display = 'flex'; const batchInput = document.getElementById('sticker-batch-input'); if (batchInput) { batchInput.value = ''; } } }; window.closeAddStickerDialog = function () { const dialog = document.getElementById('add-sticker-dialog'); if (dialog) { dialog.style.display = 'none'; } }; window.openVoiceMessageDialog = function () { const dialog = document.getElementById('voice-message-dialog'); if (dialog) { dialog.style.display = 'flex'; const textInput = document.getElementById('voice-message-text-input'); if (textInput) { textInput.value = ''; textInput.focus(); } } }; window.closeVoiceMessageDialog = function () { const dialog = document.getElementById('voice-message-dialog'); if (dialog) { dialog.style.display = 'none'; } }; window.sendVoiceMessage = function () { const textInput = document.getElementById('voice-message-text-input'); if (!textInput) return; const voiceText = textInput.value.trim(); if (!voiceText) { showXToast('请输入语音内容', 'error'); return; } const estimatedDuration = Math.max(5, Math.ceil(voiceText.length / 10)); const minutes = Math.floor(estimatedDuration / 60); const seconds = estimatedDuration % 60; const durationStr = minutes > 0 ? `${minutes}:${String(seconds).padStart(2, '0')}` : `0:${String(seconds).padStart(2, '0')}`; const now = new Date(); const hours = now.getHours(); const minutesNow = String(now.getMinutes()).padStart(2, '0'); const period = hours >= 12 ? '下午' : '上午'; const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutesNow} ${period}`; const voiceMessage = { type: 'voice', voiceText: voiceText, duration: durationStr, time: timeStr, timestamp: now.toISOString(), isOwn: true, }; userMessageQueue.push(voiceMessage); const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { const messageEl = renderMessageItem(voiceMessage, true, undefined, true, true); contentContainer.appendChild(messageEl); requestAnimationFrame(() => { messageEl.style.opacity = '1'; messageEl.style.transform = 'translateY(0)'; }); setTimeout(() => { const scrollable = document.getElementById('message-detail-scrollable'); if (scrollable) { scrollable.scrollTop = scrollable.scrollHeight; } }, 100); } saveUserMessageToDB(voiceMessage); closeVoiceMessageDialog(); console.log('✅ [语音消息] 已添加到队列:', voiceMessage); }; window.openStickerManager = async function () { await loadUserStickers(); renderStickerManager(); const dialog = document.getElementById('sticker-manager-dialog'); if (dialog) { dialog.style.display = 'flex'; } }; window.closeStickerManager = function () { const dialog = document.getElementById('sticker-manager-dialog'); if (dialog) { dialog.style.display = 'none'; } }; function renderStickerManager() { const listContainer = document.getElementById('sticker-manager-list'); if (!listContainer) return; listContainer.innerHTML = ''; if (userStickers.length === 0) { listContainer.innerHTML = ` <div style="text-align: center; padding: 40px 20px; color:var(--x-text-secondary);"> <div style="font-size: 14px;">暂无表情包</div> </div> `; return; } userStickers.forEach((sticker, index) => { const itemEl = document.createElement('div'); itemEl.style.cssText = ` padding: 12px; margin-bottom: 8px; background-color:var(--x-bg-secondary); border-radius: 8px; display: flex; gap: 12px; align-items: flex-start; `; itemEl.innerHTML = ` <img src="${sticker.url}" style="width: 60px; height: 60px; object-fit: cover; border-radius: 6px; flex-shrink: 0;" onerror="this.src=''; this.style.background='var(--x-bg-hover)'; this.style.display='flex'; this.style.alignItems='center'; this.style.justifyContent='center';"> <div style="flex: 1; min-width: 0;"> <div style="font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px;"> ${sticker.description} </div> <div style="font-size: 12px; color:var(--x-text-secondary); word-break: break-all; margin-bottom: 4px;"> ${sticker.url} </div> <div style="font-size: 11px; color:var(--x-text-secondary);"> 使用次数: ${sticker.useCount || 0} ${sticker.lastUsedAt ? `· 最后使用: ${new Date(sticker.lastUsedAt).toLocaleString('zh-CN')}` : ''} </div> </div> <button onclick="editSticker(${index}); event.stopPropagation();" style="background-color: var(--x-bg-hover); color:var(--x-text-primary); border: none; border-radius: 6px; padding: 6px 12px; font-size: 12px; cursor: pointer; flex-shrink: 0; ">编辑</button> <button onclick="deleteSticker(${index}); event.stopPropagation();" style="background-color: rgba(239, 68, 68, 0.1); color: rgb(239, 68, 68); border: none; border-radius: 6px; padding: 6px 12px; font-size: 12px; cursor: pointer; flex-shrink: 0; ">删除</button> `; listContainer.appendChild(itemEl); }); } window.editSticker = function (index) { const sticker = userStickers[index]; if (!sticker) return; const newDescription = prompt('修改描述:', sticker.description); if (newDescription === null) return; const newUrl = prompt('修改链接:', sticker.url); if (newUrl === null) return; try { const urlObj = new URL(newUrl.trim()); userStickers[index].description = newDescription.trim(); userStickers[index].url = urlObj.href; saveUserStickers().then(() => { renderStickerManager(); showXToast('修改成功', 'success'); }); } catch (e) { showXToast('链接格式无效', 'error'); } }; window.clearAllStickers = async function () { if (!confirm(`确定要清空所有 ${userStickers.length} 个表情包吗？此操作不可恢复！`)) { return; } userStickers = []; await saveUserStickers(); renderStickerManager(); renderStickerList(); showXToast('已清空所有表情包', 'success'); }; window.batchAddStickers = async function () { const batchInput = document.getElementById('sticker-batch-input'); const text = batchInput ? batchInput.value.trim() : ''; if (!text) { showXToast('请输入表情包信息', 'error'); return; } const lines = text.split('\n').filter(line => line.trim()); const newStickers = []; const errors = []; for (let i = 0; i < lines.length; i++) { const line = lines[i].trim(); const urlMatch = line.match(/(https?:\/\/[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}(?:\/[^\s]*)?)/); if (!urlMatch) { errors.push(`第${i + 1}行：未找到有效链接`); continue; } let url = urlMatch[0].trim(); const description = line.substring(0, urlMatch.index).trim(); if (!description) { errors.push(`第${i + 1}行：缺少描述`); continue; } try { const urlObj = new URL(url); if (!urlObj.protocol || !urlObj.host) { errors.push(`第${i + 1}行：链接格式无效`); continue; } url = urlObj.href; } catch (e) { errors.push(`第${i + 1}行：链接格式无效 - ${e.message}`); continue; } const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg']; const hasImageExtension = imageExtensions.some(ext => url.toLowerCase().includes(ext)); if (!hasImageExtension) { console.warn(`第${i + 1}行：链接可能不是图片格式，但仍会导入`); } const isDuplicate = userStickers.some(s => s.url === url); if (isDuplicate) { errors.push(`第${i + 1}行：该表情包已存在`); continue; } newStickers.push({ description, url, useCount: 0, lastUsedAt: null, createdAt: new Date().toISOString(), }); } if (newStickers.length === 0) { if (errors.length > 0) { showXToast(errors.join('\n'), 'error'); } else { showXToast('没有可导入的表情包', 'error'); } return; } userStickers.push(...newStickers); await saveUserStickers(); renderStickerList(); closeAddStickerDialog(); let message = `成功导入${newStickers.length}个表情包`; if (errors.length > 0) { message += `，${errors.length}个失败`; } showXToast(message, 'success'); }; async function sendStickerMessage(sticker) { const blockCheck = await checkIfBlocked(); if (blockCheck.isBlocked) { showXToast('对方已将你拉黑，无法发送消息', 'error'); return; } if (blockCheck.error) { showXToast(blockCheck.error, 'error'); return; } const stickerIndex = userStickers.findIndex(s => s.url === sticker.url && s.description === sticker.description); if (stickerIndex !== -1) { userStickers[stickerIndex].useCount = (userStickers[stickerIndex].useCount || 0) + 1; userStickers[stickerIndex].lastUsedAt = new Date().toISOString(); await saveUserStickers(); } const now = new Date(); const hours = now.getHours(); const minutes = String(now.getMinutes()).padStart(2, '0'); const period = hours >= 12 ? '下午' : '上午'; const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutes} ${period}`; const stickerMessage = { type: 'sticker', stickerDescription: sticker.description, stickerUrl: sticker.url, time: timeStr, timestamp: now.toISOString(), isOwn: true, }; userMessageQueue.push(stickerMessage); const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { const currentMessageCount = contentContainer.querySelectorAll('.message-item:not(#typing-indicator)').length; const newMessage = renderMessageItem(stickerMessage, true, currentMessageCount, true); contentContainer.appendChild(newMessage); setTimeout(() => { newMessage.style.transition = 'all 0.3s ease'; newMessage.style.opacity = '1'; newMessage.style.transform = 'translateY(0)'; }, 10); setTimeout(() => { const scrollable = document.getElementById('message-detail-scrollable'); if (scrollable) { scrollable.scrollTo({ top: scrollable.scrollHeight, behavior: 'smooth', }); } }, 100); } await saveUserMessageToDB(stickerMessage); console.log('✅ 表情包消息已添加到队列，等待发送'); } async function checkIfBlocked() { if (!currentMessageConversation) { return { isBlocked: false, error: '会话数据丢失' }; } try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.isBlocked) { console.log('⚠️ [拉黑] 对方已拉黑用户，禁止发送消息'); const input = document.getElementById('message-input'); const sendBtn = document.getElementById('message-send-btn'); if (input) { input.disabled = true; input.placeholder = '对方已将你拉黑'; } if (sendBtn) { sendBtn.disabled = true; } return { isBlocked: true }; } return { isBlocked: false }; } catch (error) { console.error('检查拉黑状态失败:', error); return { isBlocked: false, error: error.message }; } } window.sendMessageContent = async function () { const input = document.getElementById('message-input'); if (!input) return; const content = input.value.trim(); if (!content) return; const blockCheck = await checkIfBlocked(); if (blockCheck.isBlocked) { showXToast('对方已将你拉黑，无法发送消息', 'error'); return; } if (blockCheck.error) { showXToast(blockCheck.error, 'error'); return; } const now = new Date(); const hours = now.getHours(); const minutes = String(now.getMinutes()).padStart(2, '0'); const period = hours >= 12 ? '下午' : '上午'; const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutes} ${period}`; const userMessage = { type: 'text', content: content, time: timeStr, timestamp: now.toISOString(), isOwn: true, }; userMessageQueue.push(userMessage); const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { const currentMessageCount = contentContainer.querySelectorAll('.message-item:not(#typing-indicator)').length; const allMessages = Array.from(contentContainer.querySelectorAll('.message-item:not(#typing-indicator)')); const lastMessage = allMessages[allMessages.length - 1]; const isLastMessageOwn = lastMessage?.querySelector('[data-message-index]')?.closest('.message-item')?.style.alignItems === 'flex-end'; const newMessage = renderMessageItem(userMessage, true, currentMessageCount, true); contentContainer.appendChild(newMessage); setTimeout(() => { newMessage.style.transition = 'all 0.3s ease'; newMessage.style.opacity = '1'; newMessage.style.transform = 'translateY(0)'; }, 10); setTimeout(() => { const scrollable = document.getElementById('message-detail-scrollable'); if (scrollable) { scrollable.scrollTo({ top: scrollable.scrollHeight, behavior: 'smooth', }); } }, 100); } input.value = ''; autoResizeMessageInput(input); await saveUserMessageToDB(userMessage); console.log('✅ 用户消息已发送并保存:', content); }; async function saveUserMessageToDB(userMessage) { if (!currentMessageConversation) return; try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`; let savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data) { if (!savedConversation.data.messages) { savedConversation.data.messages = []; } userMessage.waitingForAIResponse = true; savedConversation.data.messages.push(userMessage); savedConversation.updatedAt = new Date().toISOString(); await xDb.xAccountProfiles.put(savedConversation); console.log('✅ 用户消息已保存到数据库（更新）'); const messageId = currentMessageConversation.id; if (messageId && messageId.startsWith('msg_') && !messageId.startsWith('msg_account_')) { const characterId = messageId.replace('msg_', ''); if (typeof window.resetAutoMessageTrigger === 'function') { window.resetAutoMessageTrigger(characterId); } } try { const dataId = `messagesList_${currentAccountId || 'main'}`; const messagesListData = await xDb.xAccountProfiles.get(dataId); if (messagesListData && messagesListData.data) { const messagesList = messagesListData.data; const msgIndex = messagesList.findIndex(msg => msg.id === messageId); if (msgIndex !== -1 && messagesList[msgIndex].unread) { messagesList[msgIndex].unread = false; messagesList[msgIndex].unreadCount = 0; await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); sampleMessagesData = messagesList; console.log('✅ 已清除未读标记（用户回复）'); } } } catch (error) { console.error('清除未读标记失败:', error); } } else { console.log('📨 创建新的对话记录'); const newConversation = { handle: conversationId, name: 'messageConversation', data: { messages: [userMessage], }, messageId: currentMessageConversation.id, updatedAt: new Date().toISOString(), }; await xDb.xAccountProfiles.put(newConversation); console.log('✅ 用户消息已保存到数据库（新建）'); const messageId = currentMessageConversation.id; if (messageId && messageId.startsWith('msg_') && !messageId.startsWith('msg_account_')) { const characterId = messageId.replace('msg_', ''); if (typeof window.resetAutoMessageTrigger === 'function') { window.resetAutoMessageTrigger(characterId); } } } } catch (error) { console.error('保存用户消息失败:', error); } } window.regenerateAIResponse = async function () { if (!currentMessageConversation) { showXToast('会话数据丢失', 'error'); return; } try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (!savedConversation || !savedConversation.data || !savedConversation.data.messages) { showXToast('没有对话记录', 'error'); return; } const messages = savedConversation.data.messages; let lastUserMessageIndex = -1; for (let i = messages.length - 1; i >= 0; i--) { if (messages[i].isOwn === true) { lastUserMessageIndex = i; break; } } if (lastUserMessageIndex === -1) { showXToast('没有找到用户消息', 'error'); return; } const userMessages = []; for (let i = lastUserMessageIndex; i < messages.length && messages[i].isOwn === true; i++) { userMessages.push(messages[i]); } const newMessages = messages.slice(0, lastUserMessageIndex + userMessages.length); savedConversation.data.messages = newMessages; await xDb.xAccountProfiles.put(savedConversation); const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { contentContainer.innerHTML = ''; const today = new Date(); const dateStr = currentLanguage === 'en' ? today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) : `${today.getFullYear()}年${today.getMonth() + 1}月${String(today.getDate()).padStart(2, '0')}日`; contentContainer.appendChild(renderDateSeparator(dateStr)); const groups = groupMessagesBySender(newMessages); const allMessageElements = []; groups.forEach(group => { const isOwn = group[0].message.isOwn === true; group.forEach((item, indexInGroup) => { const isLastInGroup = indexInGroup === group.length - 1; const messageEl = renderMessageItem(item.message, isOwn, item.index, isLastInGroup); contentContainer.appendChild(messageEl); allMessageElements.push(messageEl); }); }); allMessageElements.forEach(el => { el.style.opacity = '1'; el.style.transform = 'translateY(0)'; }); setTimeout(() => { const scrollable = document.getElementById('message-detail-scrollable'); if (scrollable) { scrollable.scrollTop = scrollable.scrollHeight; } }, 100); } userMessageQueue = userMessages; setTimeout(() => { getAIResponse(); }, 500); } catch (error) { console.error('重新生成失败:', error); showXToast('重新生成失败', 'error'); } }; async function handleFanGroupJoinAfterAIResponse(conversationRef) { try { console.log('🔍 [粉丝群加入] ========== 开始检测 =========='); console.log('🔍 [粉丝群加入] 当前对话:', conversationRef.id, conversationRef.name || conversationRef.userName); const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversationRef.id}`; console.log('🔍 [粉丝群加入] 读取对话ID:', conversationId); const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (!savedConversation || !savedConversation.data || !savedConversation.data.messages) { console.log('⚠️ [粉丝群加入] 未找到对话记录'); return; } const messages = savedConversation.data.messages; console.log(`🔍 [粉丝群加入] 对话总消息数: ${messages.length}`); const fanGroupMessages = []; const startIndex = Math.max(0, messages.length - 20); console.log(`🔍 [粉丝群加入] 检查消息范围: ${startIndex} - ${messages.length - 1}`); for (let i = startIndex; i < messages.length; i++) { const msg = messages[i]; console.log(`🔍 [粉丝群加入] 消息${i}: type=${msg.type}, isOwn=${msg.isOwn}`); if (msg.type === 'quoteFanGroup') { console.log(`✅ [粉丝群加入] 找到quoteFanGroup消息! isOwn=${msg.isOwn}`, msg.fanGroup); if (msg.isOwn === true) { fanGroupMessages.push(msg); } } } if (fanGroupMessages.length === 0) { console.log('⏭️ [粉丝群加入] 未检测到用户发送的粉丝群转发消息'); return; } console.log(`✅ [粉丝群加入] 检测到 ${fanGroupMessages.length} 个粉丝群转发`); for (const fanGroupMsg of fanGroupMessages) { const fanGroupData = fanGroupMsg.fanGroup; const joinProbability = 0.4 + Math.random() * 0.3; const shouldJoin = Math.random() < joinProbability; if (!shouldJoin) { console.log( `🎯 [粉丝群加入] ${conversationRef.userName || conversationRef.user?.name} 决定不加入粉丝群 ${ fanGroupData.name }`, ); continue; } console.log( `✅ [粉丝群加入] ${conversationRef.userName || conversationRef.user?.name} 决定加入粉丝群 ${ fanGroupData.name }`, ); const contactHandle = conversationRef.userHandle || conversationRef.user?.handle; if (!contactHandle) { console.warn('⚠️ [粉丝群加入] 无法获取联系人句柄'); continue; } const contactProfile = await StringBuilders.getUnifiedProfile(contactHandle, { userProfileInfo: window.userProfileData, messageId: conversationRef.id, }); if (!contactProfile) { console.warn('⚠️ [粉丝群加入] 无法获取联系人资料'); continue; } const newMember = { id: conversationRef.id, name: contactProfile.name, handle: contactProfile.handle, avatar: contactProfile.avatar, type: contactProfile.type, joinedAt: new Date().toISOString(), }; const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); let messagesList = savedData?.data || []; const fanGroupIndex = messagesList.findIndex(msg => msg.id === fanGroupData.id); if (fanGroupIndex !== -1) { const fanGroup = messagesList[fanGroupIndex]; if (!fanGroup.members) { fanGroup.members = []; } const isMember = fanGroup.members.some(m => m.id === newMember.id); if (isMember) { console.log(`⚠️ [粉丝群加入] ${newMember.name} 已经是粉丝群成员`); continue; } fanGroup.members.push(newMember); fanGroup.memberCount = fanGroup.members.length; await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); console.log( `✅ [粉丝群加入] ${newMember.name} 已加入粉丝群 ${fanGroupData.name}，当前成员数: ${fanGroup.memberCount}`, ); const fanGroupConversationId = `messageConversation_${currentAccountId || 'main'}_${fanGroupData.id}`; const fanGroupConversation = await xDb.xAccountProfiles.get(fanGroupConversationId); if (fanGroupConversation && fanGroupConversation.data) { if (!fanGroupConversation.data.messages) { fanGroupConversation.data.messages = []; } const systemMessage = { type: 'system', systemType: 'memberJoined', content: `${newMember.name} 加入了粉丝群`, timestamp: new Date().toISOString(), time: '刚刚', }; fanGroupConversation.data.messages.push(systemMessage); await xDb.xAccountProfiles.put(fanGroupConversation); console.log(`✅ [粉丝群加入] 已在粉丝群对话中添加系统通知`); } setTimeout(() => { const isEnglish = currentLanguage === 'en'; showPhoneNotification({ title: fanGroupData.name, message: isEnglish ? `${newMember.name} joined the fan group` : `${newMember.name} 加入了粉丝群`, avatar: fanGroupData.avatar, leftIcon: 'x', duration: 3000, }); }, 3000); if (document.getElementById('x-messages-page')?.style.display === 'block') { await loadMessagesList(); } await checkAndTriggerFanGroupAutoChat(fanGroupData.id, fanGroup.memberCount); } } } catch (error) { console.error('❌ [粉丝群加入] 处理粉丝群加入失败:', error); } } window.getAIResponse = async function () { if (!currentMessageConversation) { showXToast('会话数据丢失', 'error'); return; } if (userMessageQueue.length === 0) { console.log('📖 [AI回复] userMessageQueue为空，尝试从数据库读取未回复消息'); try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data && savedConversation.data.messages) { const messages = savedConversation.data.messages; let lastAIMessageIndex = -1; for (let i = messages.length - 1; i >= 0; i--) { if (messages[i].isOwn === false && messages[i].type !== 'system') { lastAIMessageIndex = i; break; } } const unrespondedMessages = []; for (let i = lastAIMessageIndex + 1; i < messages.length; i++) { if (messages[i].isOwn === true) { unrespondedMessages.push(messages[i]); } } if (unrespondedMessages.length > 0) { userMessageQueue = [...unrespondedMessages]; console.log(`✅ [AI回复] 从数据库读取到 ${userMessageQueue.length} 条未回复消息`); console.log('📋 [AI回复] 消息类型:', userMessageQueue.map(m => m.type).join(', ')); } else { showXToast('请先发送消息', 'info'); return; } } else { showXToast('请先发送消息', 'info'); return; } } catch (error) { console.error('❌ [AI回复] 读取未回复消息失败:', error); showXToast('请先发送消息', 'info'); return; } } const conversationRef = currentMessageConversation; const sendBtn = document.getElementById('message-send-btn'); if (sendBtn) { sendBtn.disabled = true; sendBtn.style.opacity = '0.5'; } try { console.log('📤 [AI回复] 准备显示正在输入气泡'); showTypingIndicator(); const isFanGroup = conversationRef.type === 'fangroup' || (conversationRef.id && conversationRef.id.startsWith('fangroup_')); let aiMessages; if (isFanGroup) { console.log('📤 [AI回复] 检测到粉丝群，调用第11个情景生成器'); aiMessages = await generateFanGroupConversation(conversationRef, true, { userMessages: userMessageQueue, }); } else { console.log('📤 [AI回复] 开始请求AI生成回复（普通私信）'); aiMessages = await generateMessageConversation(conversationRef, true, { userMessages: userMessageQueue, }); } console.log('📥 [AI回复] AI回复已返回'); hideTypingIndicator(); const hasBlockedMessage = aiMessages && aiMessages.some(msg => msg.type === 'system' && msg.systemType === 'blocked'); const hasUnblockedMessage = aiMessages && aiMessages.some(msg => msg.type === 'system' && msg.systemType === 'unblocked'); const hasAwayMessage = aiMessages && aiMessages.some(msg => msg.type === 'system' && msg.systemType === 'away'); if (hasUnblockedMessage) { console.log('🎉 [拉黑解除] 对方已解除拉黑'); try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversationRef.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation) { savedConversation.isBlocked = false; delete savedConversation.blockedAt; await xDb.xAccountProfiles.put(savedConversation); console.log('✅ [拉黑解除] 拉黑状态已解除'); } } catch (error) { console.error('❌ [拉黑解除] 解除拉黑状态失败:', error); } const messageInput = document.getElementById('message-input'); const sendBtn = document.getElementById('message-send-btn'); if (messageInput) { messageInput.disabled = false; messageInput.placeholder = '发送私信'; } if (sendBtn) { sendBtn.disabled = false; } const unblockedMessage = aiMessages.find(msg => msg.type === 'system' && msg.systemType === 'unblocked'); if (unblockedMessage) { const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { const currentMessageCount = contentContainer.querySelectorAll( '.message-item:not(#typing-indicator)', ).length; const messageEl = renderMessageItem(unblockedMessage, false, currentMessageCount, true); contentContainer.appendChild(messageEl); requestAnimationFrame(() => { messageEl.style.opacity = '1'; messageEl.style.transform = 'translateY(0)'; }); } } const otherMessages = aiMessages.filter(msg => msg.type !== 'system' || msg.systemType !== 'unblocked'); if (otherMessages.length > 0) { const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { let currentMessageCount = contentContainer.querySelectorAll('.message-item:not(#typing-indicator)').length; otherMessages.forEach((msg, index) => { const messageEl = renderMessageItem( msg, false, currentMessageCount + index, index === otherMessages.length - 1, ); contentContainer.appendChild(messageEl); requestAnimationFrame(() => { messageEl.style.opacity = '1'; messageEl.style.transform = 'translateY(0)'; }); }); } await saveAIMessagesToDB(aiMessages, conversationRef); } else { await saveAIMessagesToDB(aiMessages, conversationRef); } const isEnglish = currentLanguage === 'en'; showPhoneNotification({ title: conversationRef.userName || conversationRef.user?.name || '未知用户', message: isEnglish ? 'Has unblocked you' : '已解除拉黑', avatar: conversationRef.userAvatar || conversationRef.user?.avatar || 'https: leftIcon: 'x', duration: 3000, }); userMessageQueue = []; const scrollable = document.getElementById('message-detail-scrollable'); if (scrollable) { setTimeout(() => { scrollable.scrollTop = scrollable.scrollHeight; }, 100); } return; } if (hasBlockedMessage) { console.log('⚠️ [拉黑] 对方已将用户拉黑'); try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversationRef.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation) { savedConversation.isBlocked = true; savedConversation.blockedAt = new Date().toISOString(); await xDb.xAccountProfiles.put(savedConversation); console.log('✅ [拉黑] 拉黑状态已保存'); } } catch (error) { console.error('❌ [拉黑] 保存拉黑状态失败:', error); } const messageInput = document.getElementById('message-input'); const sendBtn = document.getElementById('message-send-btn'); if (messageInput) { messageInput.disabled = true; messageInput.placeholder = '对方已将你拉黑'; } if (sendBtn) { sendBtn.disabled = true; } if (aiMessages && aiMessages.length > 0) { const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { const currentMessageCount = contentContainer.querySelectorAll( '.message-item:not(#typing-indicator)', ).length; const messageEl = renderMessageItem(aiMessages[0], false, currentMessageCount, true); contentContainer.appendChild(messageEl); requestAnimationFrame(() => { messageEl.style.opacity = '1'; messageEl.style.transform = 'translateY(0)'; }); } await saveAIMessagesToDB(aiMessages, conversationRef); } const isEnglish = currentLanguage === 'en'; showPhoneNotification({ title: 'X', message: isEnglish ? 'You have been blocked by this user' : '对方已将你拉黑', leftIcon: 'x', duration: 3000, }); userMessageQueue = []; if (sendBtn) { sendBtn.disabled = false; sendBtn.style.opacity = '1'; } return; } if (hasAwayMessage) { console.log('⏰ [离开] 对方暂时离开'); const awayMessage = aiMessages.find(msg => msg.type === 'system' && msg.systemType === 'away'); const awayDuration = awayMessage.awayDuration || 60; try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversationRef.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation) { savedConversation.isAway = true; savedConversation.awayUntil = new Date(Date.now() + awayDuration * 60 * 1000).toISOString(); savedConversation.awayDuration = awayDuration; await xDb.xAccountProfiles.put(savedConversation); console.log(`✅ [离开] 离开状态已保存，将在${awayDuration}分钟后恢复`); } } catch (error) { console.error('❌ [离开] 保存离开状态失败:', error); } if (aiMessages && aiMessages.length > 0) { const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { const currentMessageCount = contentContainer.querySelectorAll( '.message-item:not(#typing-indicator)', ).length; const messageEl = renderMessageItem(aiMessages[0], false, currentMessageCount, true); contentContainer.appendChild(messageEl); requestAnimationFrame(() => { messageEl.style.opacity = '1'; messageEl.style.transform = 'translateY(0)'; }); } await saveAIMessagesToDB(aiMessages, conversationRef); } setTimeout(() => { console.log(`⏰ [离开] 离开时间结束，准备触发自动消息`); if (typeof triggerAutoMessageAfterAway === 'function') { triggerAutoMessageAfterAway(conversationRef.id); } }, awayDuration * 60 * 1000); const isEnglish = currentLanguage === 'en'; showPhoneNotification({ title: 'X', message: awayMessage.content, leftIcon: 'x', duration: 3000, }); userMessageQueue = []; const sendBtn = document.getElementById('message-send-btn'); if (sendBtn) { sendBtn.disabled = false; sendBtn.style.opacity = '1'; } return; } if (aiMessages && aiMessages.length > 0) { const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { let currentMessageCount = contentContainer.querySelectorAll('.message-item:not(#typing-indicator)').length; const messageElements = []; const aiMessagesCount = aiMessages.length; aiMessages.forEach((message, index) => { const isLastMessage = index === aiMessagesCount - 1; const messageEl = renderMessageItem(message, false, currentMessageCount, isLastMessage); contentContainer.appendChild(messageEl); messageElements.push(messageEl); currentMessageCount++; }); await animateMessagesOneByOne(messageElements, 400); } await saveAIMessagesToDB(aiMessages, conversationRef); await handleFanGroupJoinAfterAIResponse(conversationRef); await handleAITransferResponse(aiMessages, conversationRef); userMessageQueue = []; if (document.getElementById('x-message-detail-page')?.style.display !== 'none') { const displayName = conversationRef.user?.name || conversationRef.userName || conversationRef.groupName; const displayAvatar = conversationRef.user?.avatar || conversationRef.userAvatar || conversationRef.groupAvatar; showMessageNotification(displayName, displayAvatar, aiMessages.length); } else { console.log('✅ AI回复已保存（用户已离开详情页）'); try { const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); if (savedData && savedData.data) { const messagesList = savedData.data; const messageIndex = messagesList.findIndex(msg => msg.id === conversationRef.id); if (messageIndex !== -1) { messagesList[messageIndex].unread = true; messagesList[messageIndex].unreadCount = (messagesList[messageIndex].unreadCount || 0) + aiMessages.length; await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); sampleMessagesData = messagesList; const displayName = conversationRef.user?.name || conversationRef.userName || conversationRef.groupName; const displayAvatar = conversationRef.user?.avatar || conversationRef.userAvatar || conversationRef.groupAvatar; showMessageNotification(displayName, displayAvatar, aiMessages.length); showNavNotificationDot('messages'); console.log('✅ 已标记为未读并显示提醒'); } } } catch (error) { console.error('标记未读失败:', error); } } (async () => { try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversationRef.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data && savedConversation.data.messages) { await detectAndGenerateNewTweetNotification(conversationRef, savedConversation.data.messages); } } catch (error) { console.error('New Tweet 检测失败:', error); } })(); } else { console.log('📭 [不回复] AI决定不回复用户消息'); const isEnglish = currentLanguage === 'en'; showPhoneNotification({ title: 'X', message: isEnglish ? 'Message delivered' : '消息已送达', leftIcon: 'x', duration: 2000, }); userMessageQueue = []; } } catch (error) { console.error('获取AI回复失败:', error); hideTypingIndicator(); if (document.getElementById('x-message-detail-page')?.style.display !== 'none') { showXToast(`获取回复失败: ${error.message}`, 'error'); } } finally { if (sendBtn) { sendBtn.disabled = false; sendBtn.style.opacity = '1'; } } }; async function saveAIMessagesToDB(aiMessages, conversationRef = null) { const conversation = conversationRef || currentMessageConversation; if (!conversation || !aiMessages || aiMessages.length === 0) return; try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversation.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data) { if (!savedConversation.data.messages) { savedConversation.data.messages = []; } savedConversation.data.messages.forEach(msg => { if (msg.isOwn && msg.waitingForAIResponse) { msg.waitingForAIResponse = false; } }); aiMessages.forEach(msg => { if (!msg.timestamp) { msg.timestamp = new Date().toISOString(); } }); savedConversation.data.messages.push(...aiMessages); savedConversation.updatedAt = new Date().toISOString(); await xDb.xAccountProfiles.put(savedConversation); console.log('✅ AI回复已保存到数据库'); } } catch (error) { console.error('保存AI回复失败:', error); } } window.openAccountProfileFromDM = async function (messageData, conversationData) { try { console.log('🔍 从私信详情页打开账户主页:', messageData.user.name); const existingInfo = { name: messageData.user.name, handle: messageData.user.handle, avatar: messageData.user.avatar, verified: messageData.user.verified || false, }; if (conversationData && conversationData.senderProfile) { if (conversationData.senderProfile.bio) { existingInfo.bio = conversationData.senderProfile.bio; } if (conversationData.senderProfile.followers) { existingInfo.followersCount = conversationData.senderProfile.followers.toString(); } if (conversationData.senderProfile.verified !== undefined) { existingInfo.verified = conversationData.senderProfile.verified; } } console.log('📋 现有资料:', existingInfo); await openAccountProfile(existingInfo.name, existingInfo.handle, existingInfo.avatar, { source: 'dm', existingInfo: existingInfo, messagePreview: messageData.preview, }); } catch (error) { console.error('从私信详情页打开账户主页失败:', error); showXToast(`打开主页失败: ${error.message}`, 'error'); } }; window.openAccountProfileFromQuoteProfile = async function (profileData) { try { console.log('🔍 从账户名片打开主页:', profileData.name); const existingInfo = { name: profileData.name, handle: profileData.handle, avatar: profileData.avatar, verified: profileData.verified || false, }; if (profileData.bio) { existingInfo.bio = profileData.bio; } if (profileData.followers) { existingInfo.followersCount = profileData.followers.toString(); } console.log('📋 现有资料:', existingInfo); let conversationContext = null; if (currentMessageConversation) { console.log('📝 [名片点击] 检测到当前对话:', currentMessageConversation.userName); conversationContext = { currentConversationHandle: currentMessageConversation.userHandle || currentMessageConversation.handle, currentConversationName: currentMessageConversation.userName || currentMessageConversation.name, messageId: currentMessageConversation.id, }; } await openAccountProfile(existingInfo.name, existingInfo.handle, existingInfo.avatar, { source: 'dm_quote_profile', existingInfo: existingInfo, conversationContext: conversationContext, }); } catch (error) { console.error('从账户名片打开主页失败:', error); showXToast(`打开主页失败: ${error.message}`, 'error'); } }; let sampleMessagesData = []; async function loadMessagesList() { console.log('📨 加载私信列表'); try { const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); if (savedData && savedData.data) { sampleMessagesData = savedData.data; console.log('✅ 从数据库加载私信列表，共', sampleMessagesData.length, '条'); } else { console.log('📨 数据库中没有私信列表数据，使用空列表'); sampleMessagesData = []; } renderMessagesList(sampleMessagesData); } catch (error) { console.error('加载私信列表失败:', error); showXToast('加载私信失败', 'error'); } } async function renderMessagesList(messages) { const container = document.getElementById('messages-list-container'); if (!container) { console.error('私信列表容器不存在'); return; } container.innerHTML = ''; if (!messages || messages.length === 0) { container.innerHTML = ` <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 32px; text-align: center; "> <svg viewBox="0 0 24 24" style="width: 56px; height: 56px; fill: var(--x-text-secondary); margin-bottom: 16px;"> <g><path d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v2.764l8 3.638 8-3.636V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.463l-8 3.636-8-3.638V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.037z"></path></g> </svg> <div style="font-size: 28px; font-weight: 700; color:var(--x-text-primary); margin-bottom: 8px; " data-i18n="messagesEmpty">暂无私信</div> <div style="font-size: 14px; color:var(--x-text-secondary); max-width: 320px; " data-i18n="messagesEmptyDesc">发送私信与朋友保持联系</div> </div> `; return; } for (const message of messages) { const messageItem = await createMessageItem(message); container.appendChild(messageItem); } } async function createMessageItem(message) { const messageDiv = document.createElement('div'); messageDiv.className = 'message-item'; messageDiv.style.cssText = ` display: flex; align-items: center; padding: 16px; border-bottom: 1px solid var(--x-border-color); cursor: pointer; transition: background-color 0.2s; `; let currentAvatar = message.userAvatar; const isCharacterMessage = message.id && message.id.startsWith('msg_') && message.id !== 'msg_001'; if (isCharacterMessage) { try { const xDb = getXDB(); const characterId = message.id.replace('msg_', ''); const xProfile = await xDb.xCharacterProfiles.get(characterId); if (xProfile && xProfile.xAvatar) { currentAvatar = xProfile.xAvatar; } } catch (error) { console.warn('读取角色头像失败:', error); } } let lastMessageText = message.lastMessage || ''; let lastMessageTime = message.timestamp; try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${message.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data && savedConversation.data.messages) { const messages = savedConversation.data.messages; if (messages.length > 0) { const latestMsg = messages[messages.length - 1]; if (latestMsg.type === 'text') { lastMessageText = latestMsg.content; } else if (latestMsg.type === 'image') { lastMessageText = '[图片]'; } else if (latestMsg.type === 'voice') { lastMessageText = '[语音]'; } else if (latestMsg.type === 'link') { lastMessageText = '[链接]'; } else if (latestMsg.type === 'quoteTweet') { lastMessageText = '[转发推文]'; } else if (latestMsg.type === 'quoteProfile') { lastMessageText = '[转发主页]'; } if (latestMsg.timestamp) { lastMessageTime = latestMsg.timestamp; } } } } catch (error) { console.warn('获取最新消息失败:', error); } const timeStr = formatMessageTime(lastMessageTime); messageDiv.innerHTML = ` <div style="position: relative; flex-shrink: 0; margin-right: 12px;"> <img src="${currentAvatar}" alt="${message.userName}" style="width: 48px; height: 48px; border-radius: 50%; object-fit: cover; "> ${ message.unread ? ` <div style="position: absolute; top: -2px; right: -2px; width: 12px; height: 12px; background-color: var(--x-accent); border: 2px solid var(--x-bg-primary); border-radius: 50%; "></div> ` : '' } </div> <div style="flex: 1; min-width: 0;"> <div style="display: flex; align-items: center; margin-bottom: 4px;"> <span style="font-size: 15px; font-weight: ${ message.unread ? '700' : '700' }; color:var(--x-text-primary); margin-right: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">${ message.userName }</span> <span style="font-size: 15px; color:var(--x-text-secondary); margin-right: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">@${ message.userHandle }</span> <span style="font-size: 15px; color:var(--x-text-secondary); margin-left: auto; flex-shrink: 0; ">· ${timeStr}</span> </div> <div style="font-size: 15px; color: ${ message.unread ? 'var(--x-text-primary)' : 'var(--x-text-secondary)' }; font-weight: ${ message.unread ? '600' : 'normal' }; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">${lastMessageText || '开始对话'}</div> </div> `; messageDiv.addEventListener('mouseenter', () => { messageDiv.style.backgroundColor = 'var(--x-bg-hover)'; }); messageDiv.addEventListener('mouseleave', () => { messageDiv.style.backgroundColor = 'transparent'; }); messageDiv.addEventListener('click', () => { window.openMessageDetail(message); }); return messageDiv; } function formatMessageTime(timestamp) { const now = new Date(); const time = new Date(timestamp); const diff = now - time; const seconds = Math.floor(diff / 1000); const minutes = Math.floor(seconds / 60); const hours = Math.floor(minutes / 60); const days = Math.floor(hours / 24); const isEnglish = currentLanguage === 'en'; if (seconds < 60) { return isEnglish ? 'now' : '刚刚'; } else if (minutes < 60) { return isEnglish ? `${minutes}m` : `${minutes}分钟`; } else if (hours < 24) { return isEnglish ? `${hours}h` : `${hours}小时`; } else if (days < 7) { return isEnglish ? `${days}d` : `${days}天`; } else { if (isEnglish) { const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; return `${months[time.getMonth()]} ${time.getDate()}`; } else { const month = time.getMonth() + 1; const day = time.getDate(); return `${month}月${day}日`; } } } async function openNewMessageModal() { console.log('📨 打开新建私信弹窗'); try { const db = getDB(); const xDb = getXDB(); const settingsId = `xSettings_${currentAccountId || 'main'}`; const xSettings = await xDb.xSettings.get(settingsId); const boundCharacters = xSettings?.boundCharacters || []; console.log(`📨 绑定角色数: ${boundCharacters.length}`); const allChats = await db.chats.toArray(); const characters = allChats.filter(chat => !chat.isGroup && boundCharacters.includes(chat.id)); const charactersWithXProfile = []; for (const character of characters) { const xProfile = await xDb.xCharacterProfiles.get(character.id); if (xProfile) { charactersWithXProfile.push({ id: character.id, name: character.name, xProfile: xProfile, }); } } console.log(`📨 可选择角色数: ${charactersWithXProfile.length}`); showNewMessageModal(charactersWithXProfile); } catch (error) { console.error('打开新建私信弹窗失败:', error); showXToast('打开弹窗失败', 'error'); } } function showNewMessageModal(characters) { const modal = document.createElement('div'); modal.id = 'new-message-modal'; modal.style.cssText = ` display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--x-modal-overlay); z-index: 1000; align-items: center; justify-content: center; backdrop-filter: blur(4px); `; modal.innerHTML = ` <div class="modal-content" onclick="event.stopPropagation()" style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 500px; max-height: 70vh; overflow: hidden; border: 1px solid var(--x-border-color); "> <div class="modal-header" style="display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--x-border-color); background-color:var(--x-bg-primary); "> <div style="display: flex; align-items: center; gap: 20px;"> <div class="modal-close-btn" onclick="closeNewMessageModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </div> <h2 style="color:var(--x-text-primary); font-size: 20px; font-weight: 700; margin: 0; ">新建私信</h2> </div> </div> <div class="modal-body" style="padding: 16px 20px; overflow-y: auto; max-height: calc(70vh - 80px); "> <div style="color:var(--x-text-secondary); font-size: 14px; margin-bottom: ${ characters.length > 0 ? '16px' : '8px' }; line-height: 1.4; "> ${characters.length > 0 ? '选择要发送私信的角色' : '暂无可用角色，可以创建粉丝群'} </div> <div id="new-message-characters-list" style="display: flex; flex-direction: column; gap: 0; "> ${characters .map( character => ` <div class="character-select-item" data-character-id="${character.id}" onclick="selectCharacterForMessage('${ character.id }')" style="display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <img src="${character.xProfile.xAvatar}" alt="${character.xProfile.xName}" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0; object-fit: cover; "> <div style="flex: 1; min-width: 0;"> <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; "> <span style="font-size: 15px; font-weight: 700; color:var(--x-text-primary); ">${character.xProfile.xName}</span> ${ character.xProfile.xVerified ? ` <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"> <path d="M22.5 12.5c0-1.58-.875-2.95-2.148-3.6.154-.435.238-.905.238-1.4 0-2.21-1.71-3.998-3.818-3.998-.47 0-.92.084-1.336.25C14.818 2.415 13.51 1.5 12 1.5s-2.816.917-3.437 2.25c-.415-.165-.866-.25-1.336-.25-2.11 0-3.818 1.79-3.818 4 0 .494.083.964.237 1.4-1.272.65-2.147 2.018-2.147 3.6 0 1.495.782 2.798 1.942 3.486-.02.17-.032.34-.032.514 0 2.21 1.708 4 3.818 4 .47 0 .92-.086 1.335-.25.62 1.334 1.926 2.25 3.437 2.25 1.512 0 2.818-.916 3.437-2.25.415.163.865.248 1.336.248 2.11 0 3.818-1.79 3.818-4 0-.174-.012-.344-.033-.513 1.158-.687 1.943-1.99 1.943-3.484zm-6.616-3.334l-4.334 6.5c-.145.217-.382.334-.625.334-.143 0-.288-.04-.416-.126l-2.5-1.668c-.326-.217-.413-.656-.196-.982.217-.326.656-.414.982-.196l1.875 1.25 3.75-5.625c.22-.33.66-.418.99-.196.33.22.418.66.196.99z"/> </svg> ` : '' } </div> <div style="font-size: 15px; color:var(--x-text-secondary); ">@${character.xProfile.xHandle}</div> </div> </div> `, ) .join('')} </div> ${ characters.length > 0 ? ` <div style="height: 1px; background-color: var(--x-border-color); margin: 16px 0; "></div> ` : '' } <div onclick="createFanGroup()" style="display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; border: 2px dashed var(--x-border-color); " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'; this.style.borderColor='var(--x-accent)'" onmouseout="this.style.backgroundColor='transparent'; this.style.borderColor='var(--x-border-color)'"> <div style="width: 40px; height: 40px; border-radius: 50%; background-color:var(--x-bg-secondary); display: flex; align-items: center; justify-content: center; flex-shrink: 0; "> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);"> <g><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"></path></g> </svg> </div> <div style="flex: 1; min-width: 0;"> <div style="font-size: 15px; font-weight: 700; color:var(--x-text-primary); margin-bottom: 2px; ">创建粉丝群</div> <div style="font-size: 13px; color:var(--x-text-secondary); ">与你的粉丝群组互动</div> </div> </div> </div> </div> `; const xSocialScreen = document.getElementById('x-social-screen'); if (xSocialScreen) { xSocialScreen.appendChild(modal); } else { document.body.appendChild(modal); } modal.addEventListener('click', e => { if (e.target === modal) { closeNewMessageModal(); } }); } function closeNewMessageModal() { const modal = document.getElementById('new-message-modal'); if (modal) { modal.remove(); } } async function selectCharacterForMessage(characterId) { console.log('📨 选择角色创建私信:', characterId); try { const db = getDB(); const xDb = getXDB(); const character = await db.chats.get(characterId); const xProfile = await xDb.xCharacterProfiles.get(characterId); if (!character || !xProfile) { showXToast('无法获取角色信息', 'error'); return; } const existingIndex = sampleMessagesData.findIndex(msg => msg.id === `msg_${characterId}`); if (existingIndex === -1) { const newMessage = { id: `msg_${characterId}`, userName: xProfile.xName, userHandle: xProfile.xHandle, userAvatar: xProfile.xAvatar, lastMessage: '', timestamp: new Date().toISOString(), unread: false, }; sampleMessagesData.unshift(newMessage); console.log('✅ 已添加新私信:', newMessage); try { const dataId = `messagesList_${currentAccountId || 'main'}`; await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: sampleMessagesData, updatedAt: new Date().toISOString(), }); console.log('✅ 私信列表已保存到数据库'); } catch (saveError) { console.error('保存私信列表失败:', saveError); } } else { console.log('⚠️ 该角色的私信已存在'); } closeNewMessageModal(); renderMessagesList(sampleMessagesData); showXToast(`已添加与 ${xProfile.xName} 的私信`, 'success'); } catch (error) { console.error('选择角色失败:', error); showXToast('操作失败', 'error'); } } async function openMessageContactSettings(messageData, profileData) { const isInContactList = sampleMessagesData.some(msg => msg.id === messageData.id); let autoMessageEnabled = false; let autoMessageInterval = 60; let customAvatar = messageData.user.avatar; try { const xDb = getXDB(); const settingsId = `strangerSettings_${currentAccountId || 'main'}_${messageData.id}`; const settings = await xDb.xAccountProfiles.get(settingsId); if (settings) { autoMessageEnabled = settings.autoMessageEnabled || false; autoMessageInterval = settings.autoMessageInterval || 60; customAvatar = settings.customAvatar || messageData.user.avatar; } } catch (error) { console.error('读取设置失败:', error); } const modal = document.createElement('div'); modal.id = 'stranger-message-settings-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 25; backdrop-filter: blur(4px); `; modal.innerHTML = ` <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 500px; max-height: 80vh; overflow: hidden; border: 1px solid var(--x-border-color); display: flex; flex-direction: column; " onclick="event.stopPropagation()"> <div style="padding: 16px 20px; border-bottom: 1px solid var(--x-border-color); display: flex; align-items: center; justify-content: space-between; "> <div style="display: flex; align-items: center; gap: 12px;"> <img src="${messageData.user.avatar}" style="width: 40px; height: 40px; border-radius: 50%;"> <div> <div style="font-size: 18px; font-weight: 700; color:var(--x-text-primary);">${messageData.user.name}</div> <div style="font-size: 14px; color:var(--x-text-secondary);">${messageData.user.handle}</div> </div> </div> <div onclick="closeStrangerMessageSettings()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </div> </div> <div style="flex: 1; overflow-y: auto; padding: 20px; "> <div style="margin-bottom: 24px;"> <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; "> <div> <div style="font-size: 16px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px;"> 添加到联系人 </div> <div style="font-size: 13px; color:var(--x-text-secondary);"> 添加后可在私信列表中快速找到 </div> </div> <div class="x-toggle" id="contact-toggle" onclick="toggleStrangerContact('${ messageData.id }')" style="cursor: pointer;"> <div class="toggle-switch" style="width: 50px; height: 30px; background-color: ${ isInContactList ? 'var(--x-accent)' : '#333' }; border-radius: 15px; position: relative; transition: all 0.3s ease; "> <div class="toggle-circle" style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: ${ isInContactList ? '22px' : '2px' }; transition: all 0.3s ease; "></div> </div> </div> </div> </div> <div style="margin-bottom: 24px;"> <div style="font-size: 16px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 12px;"> 更换头像 </div> <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;"> <img id="stranger-avatar-preview" src="${customAvatar}" style="width: 64px; height: 64px; border-radius: 50%; object-fit: cover; "> </div> <div style="display: flex; gap: 8px;"> <input type="text" id="stranger-avatar-url-input" placeholder="输入图片链接地址" value="${customAvatar}" style="flex: 1; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 20px; padding: 10px 16px; font-size: 14px; color:var(--x-text-primary); outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'" > <button onclick="updateStrangerAvatar('${ messageData.id }')" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; white-space: nowrap; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'"> 更新 </button> </div> </div> <div style="margin-bottom: 24px;"> <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; "> <div> <div style="font-size: 16px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px;"> 自动发信息 </div> <div style="font-size: 13px; color:var(--x-text-secondary);"> ${isInContactList ? '启用后该账户会自动发送私信和推文' : '需先添加到联系人后才能启用'} </div> </div> <div class="x-toggle" id="auto-message-toggle" onclick="${ isInContactList ? `toggleStrangerAutoMessage('${messageData.id}')` : "showXToast('请先添加到联系人', 'warning')" }" style="cursor: ${isInContactList ? 'pointer' : 'not-allowed'}; opacity: ${isInContactList ? '1' : '0.5'};"> <div class="toggle-switch" style="width: 50px; height: 30px; background-color: ${ autoMessageEnabled ? 'var(--x-accent)' : '#333' }; border-radius: 15px; position: relative; transition: all 0.3s ease; "> <div class="toggle-circle" style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: ${ autoMessageEnabled ? '22px' : '2px' }; transition: all 0.3s ease; "></div> </div> </div> </div> ${ isInContactList ? ` <div style="margin-top: 12px;"> <div style="font-size: 14px; color:var(--x-text-secondary); margin-bottom: 8px;"> 发送间隔（秒） </div> <input type="number" id="stranger-interval-input" min="10" max="3600" value="${autoMessageInterval}" style="width: 100%; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 10px 12px; font-size: 14px; color:var(--x-text-primary); outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'" onchange="updateStrangerInterval('${messageData.id}', this.value)" > <div style="font-size: 12px; color:var(--x-text-secondary); margin-top: 4px;"> 建议：60-300秒之间 </div> </div> ` : '' } </div> </div> </div> `; const xSocialScreen = document.getElementById('x-social-screen'); if (xSocialScreen) { xSocialScreen.appendChild(modal); } else { document.body.appendChild(modal); } modal.onclick = e => { if (e.target === modal) { closeStrangerMessageSettings(); } }; window.currentStrangerSettings = { messageData: messageData, conversationData: profileData, }; } async function openStrangerMessageSettings(messageData, conversationData) { const isInContactList = sampleMessagesData.some(msg => msg.id === messageData.id); let autoMessageEnabled = false; let autoMessageInterval = 60; let customAvatar = messageData.user.avatar; try { const xDb = getXDB(); const settingsId = `strangerSettings_${currentAccountId || 'main'}_${messageData.id}`; const settings = await xDb.xAccountProfiles.get(settingsId); if (settings) { autoMessageEnabled = settings.autoMessageEnabled || false; autoMessageInterval = settings.autoMessageInterval || 60; customAvatar = settings.customAvatar || messageData.user.avatar; } } catch (error) { console.error('读取陌生人设置失败:', error); } const modal = document.createElement('div'); modal.id = 'stranger-message-settings-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 25; backdrop-filter: blur(4px); `; modal.innerHTML = ` <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 500px; max-height: 80vh; overflow: hidden; border: 1px solid var(--x-border-color); display: flex; flex-direction: column; " onclick="event.stopPropagation()"> <div style="padding: 16px 20px; border-bottom: 1px solid var(--x-border-color); display: flex; align-items: center; justify-content: space-between; "> <div style="display: flex; align-items: center; gap: 12px;"> <img src="${messageData.user.avatar}" style="width: 40px; height: 40px; border-radius: 50%;"> <div> <div style="font-size: 18px; font-weight: 700; color:var(--x-text-primary);">${messageData.user.name}</div> <div style="font-size: 14px; color:var(--x-text-secondary);">${messageData.user.handle}</div> </div> </div> <div onclick="closeStrangerMessageSettings()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </div> </div> <div style="flex: 1; overflow-y: auto; padding: 20px; "> <div style="margin-bottom: 24px;"> <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; "> <div> <div style="font-size: 16px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px;"> 添加到联系人 </div> <div style="font-size: 13px; color:var(--x-text-secondary);"> 添加后可在私信列表中快速找到 </div> </div> <div class="x-toggle" id="contact-toggle" onclick="toggleStrangerContact('${ messageData.id }')" style="cursor: pointer;"> <div class="toggle-switch" style="width: 50px; height: 30px; background-color: ${ isInContactList ? 'var(--x-accent)' : '#333' }; border-radius: 15px; position: relative; transition: all 0.3s ease; "> <div class="toggle-circle" style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: ${ isInContactList ? '22px' : '2px' }; transition: all 0.3s ease; "></div> </div> </div> </div> </div> <div style="margin-bottom: 24px;"> <div style="font-size: 16px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 12px;"> 更换头像 </div> <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;"> <img id="stranger-avatar-preview" src="${customAvatar}" style="width: 64px; height: 64px; border-radius: 50%; object-fit: cover; "> </div> <div style="display: flex; gap: 8px;"> <input type="text" id="stranger-avatar-url-input" placeholder="输入图片链接地址" value="${customAvatar}" style="flex: 1; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 20px; padding: 10px 16px; font-size: 14px; color:var(--x-text-primary); outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'" > <button onclick="updateStrangerAvatar('${ messageData.id }')" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; white-space: nowrap; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'"> 更新 </button> </div> </div> <div style="margin-bottom: 24px;"> <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; "> <div> <div style="font-size: 16px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px;"> 自动发信息 </div> <div style="font-size: 13px; color:var(--x-text-secondary);"> ${isInContactList ? '启用后该账户会自动发送私信' : '需先添加到联系人后才能启用'} </div> </div> <div class="x-toggle" id="auto-message-toggle" onclick="${ isInContactList ? `toggleStrangerAutoMessage('${messageData.id}')` : "showXToast('请先添加到联系人', 'warning')" }" style="cursor: ${isInContactList ? 'pointer' : 'not-allowed'}; opacity: ${isInContactList ? '1' : '0.5'};"> <div class="toggle-switch" style="width: 50px; height: 30px; background-color: ${ autoMessageEnabled ? 'var(--x-accent)' : '#333' }; border-radius: 15px; position: relative; transition: all 0.3s ease; "> <div class="toggle-circle" style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: ${ autoMessageEnabled ? '22px' : '2px' }; transition: all 0.3s ease; "></div> </div> </div> </div> ${ isInContactList ? ` <div style="margin-top: 12px;"> <div style="font-size: 14px; color:var(--x-text-secondary); margin-bottom: 8px;"> 发送间隔（秒） </div> <input type="number" id="stranger-interval-input" min="10" max="3600" value="${autoMessageInterval}" style="width: 100%; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 10px 12px; font-size: 14px; color:var(--x-text-primary); outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'" onchange="updateStrangerInterval('${messageData.id}', this.value)" > <div style="font-size: 12px; color:var(--x-text-secondary); margin-top: 4px;"> 建议：60-300秒之间 </div> </div> ` : '' } </div> </div> </div> `; const xSocialScreen = document.getElementById('x-social-screen'); if (xSocialScreen) { xSocialScreen.appendChild(modal); } else { document.body.appendChild(modal); } modal.onclick = e => { if (e.target === modal) { closeStrangerMessageSettings(); } }; window.currentStrangerSettings = { messageData: messageData, conversationData: conversationData, }; } function closeStrangerMessageSettings() { const modal = document.getElementById('stranger-message-settings-modal'); if (modal) { modal.remove(); } window.currentStrangerSettings = null; } async function toggleStrangerContact(messageId) { try { const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); let messagesList = savedData?.data || []; console.log('📝 [联系人] 当前私信列表数量:', messagesList.length); const existingIndex = messagesList.findIndex(msg => msg.id === messageId); const toggle = document.getElementById('contact-toggle'); const toggleSwitch = toggle.querySelector('.toggle-switch'); const toggleCircle = toggle.querySelector('.toggle-circle'); if (existingIndex !== -1) { messagesList.splice(existingIndex, 1); console.log('📝 [联系人] 移除后私信列表数量:', messagesList.length); toggleSwitch.style.backgroundColor = '#333'; toggleCircle.style.left = '2px'; const settingsId = `strangerSettings_${currentAccountId || 'main'}_${messageId}`; await xDb.xAccountProfiles.delete(settingsId); const autoToggle = document.getElementById('auto-message-toggle'); if (autoToggle) { const autoSwitch = autoToggle.querySelector('.toggle-switch'); const autoCircle = autoToggle.querySelector('.toggle-circle'); autoSwitch.style.backgroundColor = '#333'; autoCircle.style.left = '2px'; autoToggle.style.opacity = '0.5'; autoToggle.style.cursor = 'not-allowed'; autoToggle.onclick = () => showXToast('请先添加到联系人', 'warning'); } showXToast('已从联系人移除', 'success'); } else { const messageData = window.currentStrangerSettings.messageData; const newMessage = { id: messageId, userName: messageData.user.name, userHandle: messageData.user.handle.replace('@', ''), userAvatar: messageData.user.avatar, lastMessage: messageData.preview || '', timestamp: new Date().toISOString(), unread: false, }; messagesList.unshift(newMessage); console.log('📝 [联系人] 添加后私信列表数量:', messagesList.length); toggleSwitch.style.backgroundColor = 'var(--x-accent)'; toggleCircle.style.left = '22px'; const autoToggle = document.getElementById('auto-message-toggle'); if (autoToggle) { autoToggle.style.opacity = '1'; autoToggle.style.cursor = 'pointer'; autoToggle.onclick = () => toggleStrangerAutoMessage(messageId); } showXToast('已添加到联系人', 'success'); } await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); console.log('✅ [联系人] 已保存到数据库，列表数量:', messagesList.length); sampleMessagesData = messagesList; const messagesPage = document.getElementById('x-messages-page'); if (messagesPage && messagesPage.style.display === 'flex') { await loadMessagesList(); } } catch (error) { console.error('切换联系人状态失败:', error); showXToast('操作失败', 'error'); } } async function updateStrangerAvatar(messageId) { const input = document.getElementById('stranger-avatar-url-input'); if (!input) return; const newAvatarUrl = input.value.trim(); if (!newAvatarUrl) { showXToast('请输入头像链接', 'warning'); return; } try { const preview = document.getElementById('stranger-avatar-preview'); if (preview) preview.src = newAvatarUrl; const topAvatar = document.getElementById('message-detail-top-avatar'); if (topAvatar) topAvatar.src = newAvatarUrl; const detailAvatar = document.getElementById('message-detail-avatar'); if (detailAvatar) detailAvatar.src = newAvatarUrl; const xDb = getXDB(); const settingsId = `strangerSettings_${currentAccountId || 'main'}_${messageId}`; const settings = (await xDb.xAccountProfiles.get(settingsId)) || { handle: settingsId, id: settingsId, messageId: messageId, }; settings.customAvatar = newAvatarUrl; settings.updatedAt = new Date().toISOString(); await xDb.xAccountProfiles.put(settings); const messageIndex = sampleMessagesData.findIndex(msg => msg.id === messageId); if (messageIndex !== -1) { sampleMessagesData[messageIndex].userAvatar = newAvatarUrl; const dataId = `messagesList_${currentAccountId || 'main'}`; await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: sampleMessagesData, updatedAt: new Date().toISOString(), }); const messagesPage = document.getElementById('x-messages-page'); if (messagesPage && messagesPage.style.display === 'flex') { await loadMessagesList(); } } if (window.currentStrangerSettings && window.currentStrangerSettings.messageData) { window.currentStrangerSettings.messageData.user.avatar = newAvatarUrl; } showXToast('头像已更新', 'success'); } catch (error) { console.error('更新头像失败:', error); showXToast('更新失败', 'error'); } } async function updateStrangerInterval(messageId, interval) { try { const intervalNum = parseInt(interval); if (isNaN(intervalNum) || intervalNum < 10 || intervalNum > 3600) { showXToast('时间间隔必须在10-3600秒之间', 'warning'); return; } const xDb = getXDB(); const settingsId = `strangerSettings_${currentAccountId || 'main'}_${messageId}`; const settings = (await xDb.xAccountProfiles.get(settingsId)) || { handle: settingsId, id: settingsId, messageId: messageId, }; settings.autoMessageInterval = intervalNum; settings.updatedAt = new Date().toISOString(); await xDb.xAccountProfiles.put(settings); showXToast(`已设置间隔为 ${intervalNum} 秒`, 'success'); } catch (error) { console.error('更新时间间隔失败:', error); showXToast('更新失败', 'error'); } } async function toggleStrangerAutoMessage(messageId) { try { const xDb = getXDB(); const settingsId = `strangerSettings_${currentAccountId || 'main'}_${messageId}`; const settings = await xDb.xAccountProfiles.get(settingsId); const currentEnabled = settings && settings.autoMessageEnabled; const toggle = document.getElementById('auto-message-toggle'); const toggleSwitch = toggle.querySelector('.toggle-switch'); const toggleCircle = toggle.querySelector('.toggle-circle'); if (currentEnabled) { settings.autoMessageEnabled = false; await xDb.xAccountProfiles.put(settings); toggleSwitch.style.backgroundColor = '#333'; toggleCircle.style.left = '2px'; showXToast('已关闭自动发信息', 'success'); } else { const newSettings = settings || { handle: settingsId, id: settingsId, messageId: messageId, autoMessageInterval: 60, }; newSettings.autoMessageEnabled = true; newSettings.updatedAt = new Date().toISOString(); await xDb.xAccountProfiles.put(newSettings); toggleSwitch.style.backgroundColor = 'var(--x-accent)'; toggleCircle.style.left = '22px'; showXToast('已开启自动发信息', 'success'); } } catch (error) { console.error('切换自动发信息失败:', error); showXToast('操作失败', 'error'); } } window.closeStrangerMessageSettings = closeStrangerMessageSettings; window.toggleStrangerContact = toggleStrangerContact; window.updateStrangerAvatar = updateStrangerAvatar; window.updateStrangerInterval = updateStrangerInterval; window.toggleStrangerAutoMessage = toggleStrangerAutoMessage; async function createFanGroup() { try { const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); let messagesList = savedData?.data || []; const groupId = `fangroup_${Date.now()}`; const newFanGroup = { id: groupId, type: 'fangroup', userName: '我的粉丝群', userHandle: 'fangroup', userAvatar: 'https: lastMessage: '', timestamp: new Date().toISOString(), unread: false, groupName: '我的粉丝群', groupThreshold: '', memberCount: 0, members: [], }; messagesList.unshift(newFanGroup); await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); console.log('✅ [粉丝群] 已创建新粉丝群:', groupId); closeNewMessageModal(); sampleMessagesData = messagesList; await loadMessagesList(); showXToast('已创建粉丝群', 'success'); setTimeout(() => { window.openMessageDetail(newFanGroup); }, 300); } catch (error) { console.error('❌ [粉丝群] 创建失败:', error); showXToast('创建粉丝群失败', 'error'); } } async function openFanGroupSettings(groupData) { console.log('🎯 [粉丝群] 打开设置弹窗', groupData); try { const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); const messagesList = savedData?.data || []; const fanGroup = messagesList.find(msg => msg.id === groupData.id); if (!fanGroup) { showXToast('未找到粉丝群数据', 'error'); return; } let autoMessageEnabled = false; let autoMessageInterval = 120; const fanGroupSettingsId = `fanGroupSettings_${currentAccountId || 'main'}_${groupData.id}`; const fanGroupSettings = await xDb.xAccountProfiles.get(fanGroupSettingsId); if (fanGroupSettings && fanGroupSettings.data) { autoMessageEnabled = fanGroupSettings.data.autoMessageEnabled || false; autoMessageInterval = fanGroupSettings.data.autoMessageInterval || 120; } const modal = document.createElement('div'); modal.id = 'fangroup-settings-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 25; backdrop-filter: blur(4px); `; modal.innerHTML = ` <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 480px; max-height: 85vh; overflow: hidden; border: 1px solid var(--x-border-color); display: flex; flex-direction: column; " onclick="event.stopPropagation()"> <div style="padding: 14px 16px; border-bottom: 1px solid var(--x-border-color); display: flex; align-items: center; justify-content: space-between; "> <div style="font-size: 17px; font-weight: 700; color:var(--x-text-primary);">粉丝群设置</div> <div style="display: flex; align-items: center; gap: 4px;"> <div onclick="openFanGroupShareModal('${ groupData.id }')" style="cursor: pointer; padding: 6px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'" title="转发粉丝群"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"> <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g> </svg> </div> <div onclick="closeFanGroupSettings()" style="cursor: pointer; padding: 6px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-secondary);"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </div> </div> </div> <div style="flex: 1; overflow-y: auto; padding: 16px; "> <div style="margin-bottom: 18px;"> <div style="font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 10px;"> 群头像 </div> <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;"> <img id="fangroup-avatar-preview" src="${ fanGroup.userAvatar || fanGroup.groupAvatar || 'https: }" style="width: 52px; height: 52px; border-radius: 50%; object-fit: cover; "> </div> <div style="display: flex; gap: 6px;"> <input type="text" id="fangroup-avatar-input" placeholder="输入图片链接地址" value="${fanGroup.userAvatar || fanGroup.groupAvatar || ''}" style="flex: 1; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 8px 12px; font-size: 13px; color:var(--x-text-primary); outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'" oninput="updateFanGroupAvatarPreview(this.value)" > <button onclick="saveFanGroupAvatar('${ groupData.id }')" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 8px; padding: 8px 14px; font-size: 13px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; white-space: nowrap; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'"> 更新 </button> </div> </div> <div style="margin-bottom: 18px;"> <div style="font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 10px;"> 群名称 </div> <input type="text" id="fangroup-name-input" placeholder="输入群名称" value="${fanGroup.userName || fanGroup.groupName || '我的粉丝群'}" maxlength="30" style="width: 100%; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 10px 12px; font-size: 13px; color:var(--x-text-primary); outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'" > </div> <div style="margin-bottom: 18px;"> <div style="font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 10px;"> 入群门槛 </div> <textarea id="fangroup-threshold-input" placeholder="例如：关注满30天、互动次数达到10次等..." maxlength="200" style="width: 100%; min-height: 80px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 10px 12px; font-size: 13px; color:var(--x-text-primary); outline: none; resize: vertical; font-family: inherit; line-height: 1.5; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'" >${fanGroup.groupThreshold || ''}</textarea> <div style="text-align: right; margin-top: 4px;"> <span style="font-size: 11px; color:var(--x-text-secondary);">设置粉丝需要满足的条件才能进群</span> </div> </div> <div style="margin-bottom: 24px;"> <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; "> <div> <div style="font-size: 16px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px;"> 后台自动发信息 </div> <div style="font-size: 13px; color:var(--x-text-secondary);"> 启用后群成员会自动交流 </div> </div> <div class="x-toggle" id="fangroup-auto-message-toggle" onclick="toggleFanGroupAutoMessage('${ groupData.id }')" style="cursor: pointer;"> <div class="toggle-switch" style="width: 50px; height: 30px; background-color: ${ autoMessageEnabled ? 'var(--x-accent)' : '#333' }; border-radius: 15px; position: relative; transition: all 0.3s ease; "> <div class="toggle-circle" style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: ${ autoMessageEnabled ? '22px' : '2px' }; transition: all 0.3s ease; "></div> </div> </div> </div> <div style="margin-top: 12px;"> <div style="font-size: 14px; color:var(--x-text-secondary); margin-bottom: 8px;"> 发送间隔（秒） </div> <input type="number" id="fangroup-interval-input" min="60" max="3600" value="${autoMessageInterval}" style="width: 100%; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 10px 12px; font-size: 14px; color:var(--x-text-primary); outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'" onchange="updateFanGroupInterval('${groupData.id}', this.value)" > <div style="font-size: 12px; color:var(--x-text-secondary); margin-top: 4px;"> 建议：120-600秒之间 </div> </div> </div> <div style="margin-bottom: 18px;"> <div style="font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between;"> <span>群成员</span> <span style="font-size: 13px; color: var(--x-accent); font-weight: 700;">${fanGroup.members?.length || 0} 人</span> </div> <div style="max-height: 240px; overflow-y: auto; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 6px; "> ${ fanGroup.members && fanGroup.members.length > 0 ? fanGroup.members .map( member => ` <div style="display: flex; align-items: center; gap: 10px; padding: 6px; border-radius: 6px; transition: background-color 0.2s; margin-bottom: 2px; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <img src="${member.avatar}" style="width: 32px; height: 32px; border-radius: 50%; object-fit: cover; "> <div style="flex: 1; min-width: 0;"> <div style="color:var(--x-text-primary); font-size: 13px; font-weight: 600;"> ${member.name} </div> <div style="color:var(--x-text-secondary); font-size: 11px;"> ${member.handle} </div> </div> <button onclick="kickFanGroupMember('${groupData.id}', '${member.id}', '${member.name}')" style="background-color: transparent; color: #ef4444; border: 1px solid #ef4444; border-radius: 6px; padding: 4px 10px; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s; white-space: nowrap; " onmouseover="this.style.backgroundColor='#ef444410'" onmouseout="this.style.backgroundColor='transparent'"> 踢出 </button> </div> `, ) .join('') : `<div style="text-align: center; padding: 20px; color:var(--x-text-secondary); font-size: 12px; ">暂无成员</div>` } </div> </div> </div> <div style="padding: 12px 16px; border-top: 1px solid var(--x-border-color); display: flex; flex-direction: column; gap: 8px;"> <button onclick="openFanGroupApplicationsModal('${ groupData.id }')" style="background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 8px; padding: 10px 16px; font-size: 13px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'"> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);"> <g><path d="M17.5 4.5c-1.95-1.96-5.11-1.96-7.07 0-1.96 1.96-1.96 5.11 0 7.07 1.95 1.96 5.11 1.96 7.07 0 1.96-1.96 1.96-5.11 0-7.07zM14 9c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z M12 14H6c-1.1 0-2 .9-2 2v5h16v-5c0-1.1-.9-2-2-2h-6z"></path></g> </svg> 查看入群申请 </button> <div style="display: flex; gap: 6px;"> <button onclick="dissolveFanGroup('${ groupData.id }')" style="background-color: transparent; color: #ef4444; border: 1px solid #ef4444; border-radius: 8px; padding: 9px 14px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s; white-space: nowrap; " onmouseover="this.style.backgroundColor='#ef444410'" onmouseout="this.style.backgroundColor='transparent'"> 解散群聊 </button> <button onclick="closeFanGroupSettings()" style="flex: 1; background-color:var(--x-bg-secondary); color:var(--x-text-secondary); border: none; border-radius: 8px; padding: 9px 14px; font-size: 13px; font-weight: 600; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">取消</button> <button onclick="saveFanGroupSettings('${ groupData.id }')" style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 8px; padding: 9px 14px; font-size: 13px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">保存</button> </div> </div> </div> `; const xSocialScreen = document.getElementById('x-social-screen'); if (xSocialScreen) { xSocialScreen.appendChild(modal); } else { document.body.appendChild(modal); } modal.onclick = e => { if (e.target === modal) { closeFanGroupSettings(); } }; } catch (error) { console.error('❌ [粉丝群] 打开设置失败:', error); showXToast('打开设置失败', 'error'); } } function closeFanGroupSettings() { const modal = document.getElementById('fangroup-settings-modal'); if (modal) { modal.remove(); } } function updateFanGroupAvatarPreview(avatarUrl) { const preview = document.getElementById('fangroup-avatar-preview'); if (preview && avatarUrl) { preview.src = avatarUrl; } } async function saveFanGroupAvatar(groupId) { const avatarInput = document.getElementById('fangroup-avatar-input'); if (!avatarInput) return; const newAvatar = avatarInput.value.trim(); if (!newAvatar) { showXToast('请输入头像链接', 'warning'); return; } try { const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); let messagesList = savedData?.data || []; const groupIndex = messagesList.findIndex(msg => msg.id === groupId); if (groupIndex !== -1) { messagesList[groupIndex].userAvatar = newAvatar; messagesList[groupIndex].groupAvatar = newAvatar; await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); sampleMessagesData = messagesList; const topAvatar = document.getElementById('message-detail-top-avatar'); if (topAvatar && currentMessageConversation?.id === groupId) { topAvatar.src = newAvatar; } await loadMessagesList(); showXToast('头像已更新', 'success'); } } catch (error) { console.error('❌ [粉丝群] 保存头像失败:', error); showXToast('保存失败', 'error'); } } async function saveFanGroupSettings(groupId) { try { const nameInput = document.getElementById('fangroup-name-input'); const thresholdInput = document.getElementById('fangroup-threshold-input'); if (!nameInput) return; const newName = nameInput.value.trim(); const newThreshold = thresholdInput ? thresholdInput.value.trim() : ''; if (!newName) { showXToast('请输入群名称', 'warning'); return; } const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); let messagesList = savedData?.data || []; const groupIndex = messagesList.findIndex(msg => msg.id === groupId); if (groupIndex !== -1) { messagesList[groupIndex].userName = newName; messagesList[groupIndex].groupName = newName; messagesList[groupIndex].groupThreshold = newThreshold; await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); sampleMessagesData = messagesList; const topName = document.getElementById('message-detail-top-name'); if (topName && currentMessageConversation?.id === groupId) { topName.textContent = newName; } await loadMessagesList(); showXToast('设置已保存', 'success'); closeFanGroupSettings(); } } catch (error) { console.error('❌ [粉丝群] 保存设置失败:', error); showXToast('保存失败', 'error'); } } async function toggleFanGroupAutoMessage(groupId) { try { const xDb = getXDB(); const settingsId = `fanGroupSettings_${currentAccountId || 'main'}_${groupId}`; const settings = await xDb.xAccountProfiles.get(settingsId); const currentState = settings?.data?.autoMessageEnabled || false; const newState = !currentState; await xDb.xAccountProfiles.put({ handle: settingsId, name: 'fanGroupSettings', data: { autoMessageEnabled: newState, autoMessageInterval: settings?.data?.autoMessageInterval || 120, groupId: groupId, }, updatedAt: new Date().toISOString(), }); console.log(`🤖 [粉丝群] 自动发信息已${newState ? '启用' : '禁用'}`); const toggle = document.getElementById('fangroup-auto-message-toggle'); if (toggle) { const toggleSwitch = toggle.querySelector('.toggle-switch'); const toggleCircle = toggle.querySelector('.toggle-circle'); toggleSwitch.style.backgroundColor = newState ? 'var(--x-accent)' : '#333'; toggleCircle.style.left = newState ? '22px' : '2px'; } showXToast(newState ? '已启用后台自动发信息' : '已禁用后台自动发信息', 'success'); } catch (error) { console.error('❌ [粉丝群] 切换自动发信息失败:', error); showXToast('操作失败', 'error'); } } async function updateFanGroupInterval(groupId, interval) { try { const xDb = getXDB(); const settingsId = `fanGroupSettings_${currentAccountId || 'main'}_${groupId}`; const settings = await xDb.xAccountProfiles.get(settingsId); const newInterval = Math.max(60, Math.min(3600, parseInt(interval) || 120)); await xDb.xAccountProfiles.put({ handle: settingsId, name: 'fanGroupSettings', data: { autoMessageEnabled: settings?.data?.autoMessageEnabled || false, autoMessageInterval: newInterval, groupId: groupId, }, updatedAt: new Date().toISOString(), }); console.log(`🤖 [粉丝群] 自动发信息间隔已更新: ${newInterval}秒`); showXToast(`间隔已更新为 ${newInterval} 秒`, 'success'); } catch (error) { console.error('❌ [粉丝群] 更新间隔失败:', error); showXToast('更新失败', 'error'); } } window.handleMessageDetailAvatarClick = function () { console.log('🖱️ [头像点击] 触发头像点击事件'); if (!currentMessageConversation) { console.warn('⚠️ [头像点击] currentMessageConversation 为空'); return; } console.log('🖱️ [头像点击] 当前对话类型:', currentMessageConversation.type, currentMessageConversation.id); const isFanGroup = currentMessageConversation.type === 'fangroup' || (currentMessageConversation.id && currentMessageConversation.id.startsWith('fangroup_')); if (isFanGroup) { console.log('🖱️ [头像点击] 检测到粉丝群，打开设置'); openFanGroupSettings(currentMessageConversation); return; } const isCharacterMessage = currentMessageConversation.id && currentMessageConversation.id.startsWith('msg_') && currentMessageConversation.id !== 'msg_001'; if (isCharacterMessage) { console.log('🖱️ [头像点击] 角色对话不支持设置'); return; } console.log('🖱️ [头像点击] 打开联系人设置，类型:', currentMessageConversation._accountType || 'stranger'); const messageData = { id: currentMessageConversation.id, user: { name: currentMessageConversation.userName || currentMessageConversation.name, handle: currentMessageConversation.userHandle || currentMessageConversation.handle, avatar: currentMessageConversation.userAvatar || currentMessageConversation.avatar, }, preview: currentMessageConversation.lastMessage || '', _accountType: currentMessageConversation._accountType || 'stranger', }; openMessageContactSettings(messageData, null); }; function adjustFanGroupDetailPage(isFanGroup) { const scrollableContainer = document.getElementById('message-detail-scrollable'); if (!scrollableContainer) return; const userInfoSection = scrollableContainer.children[0]; if (!userInfoSection) return; const autoReactionBtn = document.getElementById('fangroup-auto-reaction-btn'); const announcementBtn = document.getElementById('fangroup-announcement-btn'); const filesBtn = document.getElementById('fangroup-files-btn'); if (isFanGroup) { userInfoSection.style.display = 'none'; if (autoReactionBtn) { autoReactionBtn.style.display = 'flex'; } if (announcementBtn) { announcementBtn.style.display = 'flex'; } if (filesBtn) { filesBtn.style.display = 'flex'; } console.log('🎯 [粉丝群] 已隐藏详细信息区域，显示自反应按钮、群公告按钮和群文件按钮'); } else { userInfoSection.style.display = 'flex'; if (autoReactionBtn) { autoReactionBtn.style.display = 'none'; } if (announcementBtn) { announcementBtn.style.display = 'none'; } if (filesBtn) { filesBtn.style.display = 'none'; } } } async function openFanGroupShareModal(groupId) { console.log('📤 [粉丝群转发] 打开转发选项', groupId); try { const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); const messagesList = savedData?.data || []; const fanGroup = messagesList.find(msg => msg.id === groupId); if (!fanGroup) { showXToast('未找到粉丝群数据', 'error'); return; } const modal = document.createElement('div'); modal.id = 'fangroup-share-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 30; backdrop-filter: blur(4px); `; modal.innerHTML = ` <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 400px; border: 1px solid var(--x-border-color); overflow: hidden; " onclick="event.stopPropagation()"> <div style="padding: 20px; border-bottom: 1px solid var(--x-border-color); "> <div style="font-size: 20px; font-weight: 700; color:var(--x-text-primary); text-align: center;"> 转发粉丝群 </div> </div> <div style="padding: 20px; border-bottom: 1px solid var(--x-border-color);"> <div style="display: flex; align-items: center; gap: 12px;"> <img src="${fanGroup.userAvatar || fanGroup.groupAvatar || 'https: style="width: 48px; height: 48px; border-radius: 50%; object-fit: cover;"> <div style="flex: 1;"> <div style="color:var(--x-text-primary); font-size: 16px; font-weight: 600; margin-bottom: 4px;"> ${fanGroup.userName || fanGroup.groupName || '我的粉丝群'} </div> <div style="color:var(--x-text-secondary); font-size: 13px;"> ${fanGroup.memberCount || 0} 位成员 </div> </div> </div> ${ fanGroup.groupThreshold ? ` <div style="margin-top: 12px; padding: 10px; background-color:var(--x-bg-secondary); border-radius: 8px; color:var(--x-text-secondary); font-size: 13px; line-height: 1.4; "> <div style="color:var(--x-text-primary); font-weight: 600; margin-bottom: 4px;">入群门槛</div> ${fanGroup.groupThreshold} </div> ` : '' } </div> <div style="padding: 12px;"> <div onclick="shareFanGroupToContact('${groupId}')" style="display: flex; align-items: center; gap: 16px; padding: 16px; border-radius: 12px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <div style="width: 40px; height: 40px; border-radius: 50%; background-color:var(--x-bg-secondary); display: flex; align-items: center; justify-content: center; "> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);"> <g><path d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v2.764l8 3.638 8-3.636V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.463l-8 3.636-8-3.638V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.037z"></path></g> </svg> </div> <div style="flex: 1;"> <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 2px;"> 转发到联系人 </div> <div style="color:var(--x-text-secondary); font-size: 13px;"> 分享给你的私信联系人 </div> </div> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-secondary);"> <g><path d="M8.58 7.17l4.24 4.24-4.24 4.24 1.42 1.42 5.66-5.66-5.66-5.66z"></path></g> </svg> </div> <div onclick="shareFanGroupToPost('${groupId}')" style="display: flex; align-items: center; gap: 16px; padding: 16px; border-radius: 12px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <div style="width: 40px; height: 40px; border-radius: 50%; background-color:var(--x-bg-secondary); display: flex; align-items: center; justify-content: center; "> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);"> <g><path d="M8.8 7.2H5.6V3.9c0-.4-.3-.8-.8-.8s-.7.4-.7.8v3.3H.8c-.4 0-.8.3-.8.8s.3.8.8.8h3.3v3.3c0 .4.3.8.8.8s.8-.3.8-.8V8.7H9c.4 0 .8-.3.8-.8s-.5-.7-1-.7zm15-4.9v-.1h-.1c-.1 0-9.2 1.2-14.4 11.7-3.8 7.6-3.6 9.9-3.3 9.9.3.1 3.4-6.5 6.7-9.2 5.2-1.1 6.6-3.6 6.6-3.6s-1.5.2-2.1.2c-.8 0-1.4-.2-1.7-.3 1.3-1.2 2.4-1.5 3.5-1.7.9-.2 1.8-.4 3-1.2 2.2-1.6 1.9-5.5 1.8-5.7z"></path></g> </svg> </div> <div style="flex: 1;"> <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 2px;"> 转发到推文 </div> <div style="color:var(--x-text-secondary); font-size: 13px;"> 发布推文并引用粉丝群 </div> </div> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-secondary);"> <g><path d="M8.58 7.17l4.24 4.24-4.24 4.24 1.42 1.42 5.66-5.66-5.66-5.66z"></path></g> </svg> </div> </div> <div style="padding: 12px 20px 20px 20px;"> <button onclick="closeFanGroupShareModal()" style="width: 100%; background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 20px; padding: 12px 20px; font-size: 15px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'"> 取消 </button> </div> </div> `; const xSocialScreen = document.getElementById('x-social-screen'); if (xSocialScreen) { xSocialScreen.appendChild(modal); } else { document.body.appendChild(modal); } modal.onclick = e => { if (e.target === modal) { closeFanGroupShareModal(); } }; } catch (error) { console.error('❌ [粉丝群转发] 打开转发选项失败:', error); showXToast('打开转发选项失败', 'error'); } } function closeFanGroupShareModal() { const modal = document.getElementById('fangroup-share-modal'); if (modal) { modal.remove(); } } async function shareFanGroupToContact(groupId) { console.log('📤 [粉丝群转发] 转发到联系人', groupId); try { const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); const messagesList = savedData?.data || []; const fanGroup = messagesList.find(msg => msg.id === groupId); if (!fanGroup) { showXToast('未找到粉丝群数据', 'error'); return; } closeFanGroupShareModal(); const contacts = messagesList.filter(msg => msg.id !== groupId); if (contacts.length === 0) { showXToast('暂无其他联系人', 'info'); return; } const modal = document.createElement('div'); modal.id = 'fangroup-contact-select-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 35; backdrop-filter: blur(4px); `; modal.innerHTML = ` <div style=" background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 500px; max-height: 80vh; border: 1px solid var(--x-border-color); display: flex; flex-direction: column; overflow: hidden; " onclick="event.stopPropagation()"> <div style=" padding: 16px 20px; border-bottom: 1px solid var(--x-border-color); display: flex; align-items: center; justify-content: space-between; "> <div style="font-size: 18px; font-weight: 700; color:var(--x-text-primary);"> 选择转发对象 </div> <div onclick="closeFanGroupContactSelectModal()" style=" cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </div> </div> <div style=" padding: 16px 20px; background-color:var(--x-bg-secondary); border-bottom: 1px solid var(--x-border-color); "> <div style="font-size: 13px; color:var(--x-text-secondary); margin-bottom: 8px;"> 将要转发的粉丝群 </div> <div style="display: flex; align-items: center; gap: 12px;"> <img src="${fanGroup.userAvatar || fanGroup.groupAvatar || 'https: style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover;"> <div style="flex: 1;"> <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600;"> ${fanGroup.userName || fanGroup.groupName || '我的粉丝群'} </div> <div style="color:var(--x-text-secondary); font-size: 13px;"> ${fanGroup.memberCount || 0} 位成员 </div> </div> </div> </div> <div id="fangroup-contact-list" style=" flex: 1; overflow-y: auto; padding: 12px; "> ${contacts .map( contact => ` <div class="fangroup-contact-item" data-contact-id="${contact.id}" style=" display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: 12px; cursor: pointer; transition: background-color 0.2s; margin-bottom: 8px; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="if(!this.classList.contains('selected')) this.style.backgroundColor='transparent'" onclick="toggleContactSelection('${contact.id}')"> <div class="contact-checkbox" style=" width: 20px; height: 20px; border-radius: 50%; border: 2px solid var(--x-border-color); background-color: var(--x-bg-primary); flex-shrink: 0; transition: all 0.2s; "></div> <img src="${contact.userAvatar || contact.avatar || 'https: style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover; flex-shrink: 0;"> <div style="flex: 1; min-width: 0;"> <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 2px;"> <span style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"> ${contact.userName || contact.name || '未知用户'} </span> ${ contact.type === 'fangroup' ? ` <span style=" padding: 2px 6px; background-color:var(--x-bg-secondary); color:var(--x-text-secondary); font-size: 10px; border-radius: 4px; font-weight: 600; ">粉丝群</span> ` : '' } </div> <div style="color:var(--x-text-secondary); font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"> ${contact.lastMessage || contact.userHandle || ''} </div> </div> </div> `, ) .join('')} </div> <div style=" padding: 16px 20px; border-top: 1px solid var(--x-border-color); display: flex; gap: 12px; "> <button onclick="closeFanGroupContactSelectModal()" style=" flex: 1; background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 20px; padding: 12px 20px; font-size: 15px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'"> 取消 </button> <button id="fangroup-contact-confirm-btn" onclick="confirmFanGroupContactShare('${groupId}')" style=" flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 12px 20px; font-size: 15px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; opacity: 0.5; " disabled> 转发 (0) </button> </div> </div> `; const xSocialScreen = document.getElementById('x-social-screen'); if (xSocialScreen) { xSocialScreen.appendChild(modal); } else { document.body.appendChild(modal); } modal.onclick = e => { if (e.target === modal) { closeFanGroupContactSelectModal(); } }; } catch (error) { console.error('❌ [粉丝群转发] 打开联系人选择失败:', error); showXToast('打开联系人选择失败', 'error'); } } async function shareFanGroupToPost(groupId) { console.log('📤 [粉丝群转发] 转发到发帖', groupId); try { const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); const messagesList = savedData?.data || []; const fanGroup = messagesList.find(msg => msg.id === groupId); if (!fanGroup) { showXToast('未找到粉丝群数据', 'error'); return; } closeFanGroupShareModal(); closeFanGroupSettings(); openComposeTweetModal(); setTimeout(() => { window.currentQuoteFanGroup = { id: fanGroup.id, name: fanGroup.userName || fanGroup.groupName || '我的粉丝群', avatar: fanGroup.userAvatar || fanGroup.groupAvatar || 'https: memberCount: fanGroup.memberCount || 0, threshold: fanGroup.groupThreshold || '', }; console.log('📤 [粉丝群转发] 粉丝群引用数据已设置:', window.currentQuoteFanGroup); addFanGroupQuoteToCompose(); showXToast('已添加粉丝群引用，请编写推文内容', 'success'); }, 150); } catch (error) { console.error('❌ [粉丝群转发] 转发到发帖失败:', error); showXToast('转发失败: ' + error.message, 'error'); } } function addFanGroupQuoteToCompose() { console.log('🔍 [粉丝群转发] 开始添加引用区域...'); if (!window.currentQuoteFanGroup) { console.warn('⚠️ [粉丝群转发] currentQuoteFanGroup 为空'); return; } const fanGroup = window.currentQuoteFanGroup; console.log('📤 [粉丝群转发] 粉丝群数据:', fanGroup); const modal = document.getElementById('compose-tweet-modal'); if (!modal) { console.error('❌ [粉丝群转发] 找不到发帖弹窗'); return; } let quoteSection = document.getElementById('compose-fangroup-quote-section'); if (quoteSection) { console.log('🗑️ [粉丝群转发] 移除旧的引用区域'); quoteSection.remove(); } quoteSection = document.createElement('div'); quoteSection.id = 'compose-fangroup-quote-section'; quoteSection.style.cssText = ` margin: 16px 0 0 0; padding: 12px; border: 1px solid var(--x-border-color); border-radius: 12px; background-color: var(--x-bg-hover); `; quoteSection.innerHTML = ` <div style="display: flex; align-items: flex-start; gap: 12px;"> <img src="${fanGroup.avatar}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover;"> <div style="flex: 1; min-width: 0;"> <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;"> <span style="color:var(--x-text-primary); font-size: 15px; font-weight: 700;">${fanGroup.name}</span> <span style="padding: 2px 8px; background-color:var(--x-bg-secondary); color:var(--x-text-secondary); font-size: 11px; border-radius: 4px; font-weight: 600; ">粉丝群</span> </div> <div style="color:var(--x-text-secondary); font-size: 13px; margin-bottom: 8px;"> ${fanGroup.memberCount} 位成员 </div> ${ fanGroup.threshold ? ` <div style="padding: 8px; background-color:var(--x-bg-secondary); border-radius: 6px; color:var(--x-text-secondary); font-size: 12px; line-height: 1.4; "> <div style="color:var(--x-text-primary); font-weight: 600; margin-bottom: 2px; font-size: 11px;">入群门槛</div> ${fanGroup.threshold.length > 60 ? fanGroup.threshold.substring(0, 60) + '...' : fanGroup.threshold} </div> ` : '' } </div> <div onclick="removeFanGroupQuote()" style="cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-secondary)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-secondary);"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </div> </div> `; const textInput = modal.querySelector('#compose-text-input'); if (!textInput) { console.error('❌ [粉丝群转发] 找不到文本输入框'); return; } const inputContainer = textInput.parentElement; console.log('📍 [粉丝群转发] 找到输入容器:', inputContainer); const quotePreview = modal.querySelector('#quote-content-preview'); if (quotePreview) { inputContainer.insertBefore(quoteSection, quotePreview); console.log('✅ [粉丝群转发] 引用区域已插入到引用预览区域之前'); } else { inputContainer.insertBefore(quoteSection, textInput.nextSibling); console.log('✅ [粉丝群转发] 引用区域已插入到textarea之后'); } console.log('✅ [粉丝群转发] 引用区域添加完成！'); } window.removeFanGroupQuote = function () { console.log('🗑️ [粉丝群转发] 移除引用'); window.currentQuoteFanGroup = null; const quoteSection = document.getElementById('compose-fangroup-quote-section'); if (quoteSection) { quoteSection.remove(); console.log('✅ [粉丝群转发] 引用区域已移除'); } showXToast('已移除粉丝群引用', 'info'); }; window.kickFanGroupMember = async function (groupId, memberId, memberName) { console.log('🚫 [粉丝群] 踢出成员', groupId, memberId, memberName); try { if (!confirm(`确定要将 ${memberName} 踢出粉丝群吗？`)) { return; } const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); let messagesList = savedData?.data || []; const groupIndex = messagesList.findIndex(msg => msg.id === groupId); if (groupIndex === -1) { showXToast('未找到粉丝群数据', 'error'); return; } const fanGroup = messagesList[groupIndex]; if (!fanGroup.members) { fanGroup.members = []; } const memberIndex = fanGroup.members.findIndex(m => m.id === memberId); if (memberIndex === -1) { showXToast('未找到该成员', 'error'); return; } fanGroup.members.splice(memberIndex, 1); fanGroup.memberCount = fanGroup.members.length; await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); console.log('✅ [粉丝群] 成员已移除，当前成员数:', fanGroup.memberCount); const conversationId = `messageConversation_${currentAccountId || 'main'}_${groupId}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data && savedConversation.data.messages) { const systemMessage = { type: 'system', systemType: 'memberKicked', content: `${memberName} 被移出了粉丝群`, timestamp: new Date().toISOString(), time: '刚刚', }; savedConversation.data.messages.push(systemMessage); await xDb.xAccountProfiles.put(savedConversation); console.log('✅ [粉丝群] 已添加踢出系统通知'); if (currentMessageConversation && currentMessageConversation.id === groupId) { await window.openMessageDetail(fanGroup); } } showXToast('已将成员移出粉丝群', 'success'); closeFanGroupSettings(); setTimeout(() => { openFanGroupSettings(fanGroup); }, 300); } catch (error) { console.error('❌ [粉丝群] 踢出成员失败:', error); showXToast('操作失败: ' + error.message, 'error'); } }; window.dissolveFanGroup = async function (groupId) { console.log('💥 [粉丝群] 解散群聊', groupId); try { if (!confirm('确定要解散此粉丝群吗？\n\n解散后将删除所有成员、申请记录和聊天记录，此操作不可撤销！')) { return; } const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); let messagesList = savedData?.data || []; const groupIndex = messagesList.findIndex(msg => msg.id === groupId); if (groupIndex === -1) { showXToast('未找到粉丝群数据', 'error'); return; } const fanGroupName = messagesList[groupIndex].userName || messagesList[groupIndex].groupName; messagesList.splice(groupIndex, 1); await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); sampleMessagesData = messagesList; console.log('✅ [粉丝群] 已从私信列表中删除'); const applicationsId = `fanGroupApplications_${currentAccountId || 'main'}_${groupId}`; try { await xDb.xAccountProfiles.delete(applicationsId); console.log('✅ [粉丝群] 已删除申请数据'); } catch (error) { console.warn('⚠️ [粉丝群] 删除申请数据时出错（可能不存在）:', error); } const conversationId = `messageConversation_${currentAccountId || 'main'}_${groupId}`; try { await xDb.xAccountProfiles.delete(conversationId); console.log('✅ [粉丝群] 已删除聊天记录'); } catch (error) { console.warn('⚠️ [粉丝群] 删除聊天记录时出错（可能不存在）:', error); } closeFanGroupSettings(); closeFanGroupApplicationsModal(); if (currentMessageConversation && currentMessageConversation.id === groupId) { currentMessageConversation = null; const messageDetailView = document.getElementById('message-detail-view'); if (messageDetailView) { messageDetailView.style.display = 'none'; } } await loadMessagesList(); showXToast(`已解散粉丝群"${fanGroupName}"`, 'success'); } catch (error) { console.error('❌ [粉丝群] 解散失败:', error); showXToast('解散失败: ' + error.message, 'error'); } }; window.closeFanGroupContactSelectModal = function () { const modal = document.getElementById('fangroup-contact-select-modal'); if (modal) { modal.remove(); } window.selectedFanGroupContacts = new Set(); }; window.toggleContactSelection = function (contactId) { if (!window.selectedFanGroupContacts) { window.selectedFanGroupContacts = new Set(); } const contactItem = document.querySelector(`.fangroup-contact-item[data-contact-id="${contactId}"]`); const checkbox = contactItem?.querySelector('.contact-checkbox'); if (!contactItem || !checkbox) return; if (window.selectedFanGroupContacts.has(contactId)) { window.selectedFanGroupContacts.delete(contactId); contactItem.classList.remove('selected'); checkbox.style.backgroundColor = 'var(--x-bg-primary)'; checkbox.style.borderColor = 'var(--x-border-color)'; checkbox.innerHTML = ''; } else { window.selectedFanGroupContacts.add(contactId); contactItem.classList.add('selected'); checkbox.style.backgroundColor = 'var(--x-accent)'; checkbox.style.borderColor = 'var(--x-accent)'; checkbox.innerHTML = ` <svg viewBox="0 0 24 24" style="width: 12px; height: 12px; fill: #fff;"> <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></g> </svg> `; } const confirmBtn = document.getElementById('fangroup-contact-confirm-btn'); if (confirmBtn) { const selectedCount = window.selectedFanGroupContacts.size; confirmBtn.textContent = `转发 (${selectedCount})`; if (selectedCount > 0) { confirmBtn.disabled = false; confirmBtn.style.opacity = '1'; } else { confirmBtn.disabled = true; confirmBtn.style.opacity = '0.5'; } } }; window.confirmFanGroupContactShare = async function (groupId) { if (!window.selectedFanGroupContacts || window.selectedFanGroupContacts.size === 0) { showXToast('请至少选择一个联系人', 'warning'); return; } try { const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); const messagesList = savedData?.data || []; const fanGroup = messagesList.find(msg => msg.id === groupId); if (!fanGroup) { showXToast('未找到粉丝群数据', 'error'); return; } console.log(`📤 [粉丝群转发] 开始转发到 ${window.selectedFanGroupContacts.size} 个联系人`); const fanGroupShareMessage = { type: 'quoteFanGroup', fanGroup: { id: fanGroup.id, name: fanGroup.userName || fanGroup.groupName || '我的粉丝群', avatar: fanGroup.userAvatar || fanGroup.groupAvatar || 'https: memberCount: fanGroup.memberCount || 0, threshold: fanGroup.groupThreshold || '', }, timestamp: new Date().toISOString(), time: '刚刚', isOwn: true, }; let successCount = 0; for (const contactId of window.selectedFanGroupContacts) { try { const conversationId = `messageConversation_${currentAccountId || 'main'}_${contactId}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data) { if (!savedConversation.data.messages) { savedConversation.data.messages = []; } savedConversation.data.messages.push(fanGroupShareMessage); await xDb.xAccountProfiles.put(savedConversation); } else { await xDb.xAccountProfiles.put({ handle: conversationId, name: 'messageConversation', data: { messages: [fanGroupShareMessage], }, messageId: contactId, accountId: currentAccountId || 'main', updatedAt: new Date().toISOString(), }); } const contact = messagesList.find(msg => msg.id === contactId); if (contact) { contact.lastMessage = `[粉丝群] ${fanGroup.userName || fanGroup.groupName || '我的粉丝群'}`; contact.timestamp = new Date().toISOString(); contact.unread = false; } successCount++; console.log(`✅ [粉丝群转发] 已转发到联系人: ${contactId}`); } catch (error) { console.error(`❌ [粉丝群转发] 转发到联系人 ${contactId} 失败:`, error); } } await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); await loadMessagesList(); closeFanGroupContactSelectModal(); closeFanGroupSettings(); showXToast(`已转发到 ${successCount} 个联系人`, 'success'); console.log(`✅ [粉丝群转发] 转发完成，成功 ${successCount}/${window.selectedFanGroupContacts.size}`); } catch (error) { console.error('❌ [粉丝群转发] 确认转发失败:', error); showXToast('转发失败: ' + error.message, 'error'); } }; async function generateFanGroupConversation(fanGroupData, isContinueMode = false, options = {}) { console.log('💬 [第11情景] 粉丝群私信生成器启动', { groupId: fanGroupData.id, groupName: fanGroupData.userName || fanGroupData.groupName, isContinueMode, }); try { const { apiConfig, xSettings, xDb } = await APIUtils.loadConfigAndSettings(); const { userPrompt, worldSetting } = xSettings; const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); const recentUserTweets = userTweetsData?.tweets?.slice(0, 3) || []; console.log('📋 [第11情景] 用户资料:', userXProfileInfo); console.log('📋 [第11情景] 用户推文数:', recentUserTweets.length); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); const messagesList = savedData?.data || []; const fanGroup = messagesList.find(msg => msg.id === fanGroupData.id); if (!fanGroup) { showXToast('未找到粉丝群数据', 'error'); return []; } const members = fanGroup.members || []; const memberProfiles = []; const memberApplications = []; console.log('👥 [第11情景] 群成员数:', members.length); const applicationsId = `fanGroupApplications_${currentAccountId || 'main'}_${fanGroup.id}`; const applicationsData = await xDb.xAccountProfiles.get(applicationsId); const allApplications = applicationsData?.data || []; for (const member of members) { const memberProfile = await StringBuilders.getUnifiedProfile(member.handle, { userProfileInfo: userXProfileInfo, messageId: member.id, }); if (memberProfile) { if (memberProfile.tweets && memberProfile.tweets.length > 0) { memberProfile.tweets = [memberProfile.tweets[0]]; } memberProfiles.push(memberProfile); } const application = allApplications.find(app => app.id === member.id && app.status === 'approved'); if (application) { memberApplications.push({ memberId: member.id, memberName: member.name, memberHandle: member.handle, reason: application.reason, type: application.type, amount: application.amount, }); } } console.log('📊 [第11情景] 已加载成员资料:', memberProfiles.length); console.log('📊 [第11情景] 已加载入群申请:', memberApplications.length); let tokenCount = 0; let systemPrompt = StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting, }); tokenCount = TokenUtils.logTokenUsage('第11情景-粉丝群私信', '基础系统提示词', systemPrompt, tokenCount); const worldBooksContent = await StringBuilders.getApplicableWorldBooks('messages', { boundCharacters: [], }); if (worldBooksContent) { systemPrompt += worldBooksContent; tokenCount = TokenUtils.logTokenUsage('第11情景-粉丝群私信', '世界书内容', worldBooksContent, tokenCount); } systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📋 用户完整资料（粉丝群主） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ - 用户名：${userXProfileInfo.name} - 用户句柄：${userXProfileInfo.handle} - 认证状态：${userXProfileInfo.verified ? '已认证' : '未认证'} ${ userXProfileInfo.verificationType && userXProfileInfo.verificationType !== 'none' ? `- 认证类型：${ userXProfileInfo.verificationType === 'verified' ? '蓝色勾标认证' : userXProfileInfo.verificationType === 'couple' ? '情侣认证' : userXProfileInfo.verificationType === 'married' ? '已婚认证' : userXProfileInfo.verificationType === 'vip' ? 'VIP认证' : '无' }` : '' } ${userXProfileInfo.publicIdentity ? `- 公众身份：${userXProfileInfo.publicIdentity}` : ''} ${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ''} ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; if (recentUserTweets.length > 0) { systemPrompt += ` 【用户近期推文】（${recentUserTweets.length}条，了解群主风格）： `; recentUserTweets.forEach((tweet, index) => { systemPrompt += `${index + 1}. "${tweet.content}" - 时间：${tweet.time || '最近'} - 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发，${tweet.stats?.comments || 0}评论 `; }); } systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 👥 粉丝群信息 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ - 群名：${fanGroup.userName || fanGroup.groupName} - 群主：${userXProfileInfo.name} (${userXProfileInfo.handle}) - 当前成员数：${members.length} 人 ${fanGroup.groupThreshold ? `- 入群门槛：${fanGroup.groupThreshold}` : '- 入群门槛：无'} ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; try { const announcementsId = `fanGroupAnnouncements_${currentAccountId || 'main'}_${fanGroup.id}`; const savedAnnouncements = await xDb.xAccountProfiles.get(announcementsId); const announcements = savedAnnouncements?.data || []; if (announcements.length > 0) { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📢 粉丝群公告（${announcements.length}条） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ⚠️ 重要：请注意以下群公告内容，这些是群主发布的重要信息，成员的对话可能会涉及这些公告内容。 `; const recentAnnouncements = announcements.slice(0, 10); recentAnnouncements.forEach((announcement, index) => { const createdDate = new Date(announcement.createdAt); const formattedDate = `${createdDate.getFullYear()}年${ createdDate.getMonth() + 1 }月${createdDate.getDate()}日 ${String(createdDate.getHours()).padStart(2, '0')}:${String( createdDate.getMinutes(), ).padStart(2, '0')}`; systemPrompt += ` 【公告 ${index + 1}】 发布时间：${formattedDate} 公告内容：${announcement.content} `; }); systemPrompt += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; console.log(`📢 [第11情景] 已加载群公告: ${announcements.length}条`); } } catch (error) { console.warn('⚠️ [第11情景] 加载群公告失败:', error); } try { const foldersId = `fanGroupFolders_${currentAccountId || 'main'}_${fanGroup.id}`; const foldersData = await xDb.xAccountProfiles.get(foldersId); const folders = foldersData?.data || []; const files = await getFanGroupFiles(fanGroup.id); systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📁 粉丝群文件库 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ⚠️ 重要：以下是群内的文件管理系统，成员可以在对话中引用、讨论或上传新文件。 `; if (folders.length > 0) { systemPrompt += ` 【文件夹列表】（${folders.length}个） ⚠️ 上传文件时可以选择放入以下文件夹，也可以不放入任何文件夹（散落显示） `; folders.forEach((folder, index) => { const filesInFolder = files.filter(f => f.folderId === folder.id); systemPrompt += `${index + 1}. 文件夹「${folder.name}」 - 文件夹ID: ${folder.id}（上传文件时使用此ID） - 包含文件数: ${filesInFolder.length}个 `; }); } else { systemPrompt += ` 【文件夹列表】 暂无文件夹，上传的文件将显示为未分类状态 `; } if (files.length > 0) { systemPrompt += ` 【已上传文件】（${files.length}个） `; const recentFiles = files.slice(0, 20); recentFiles.forEach((file, index) => { const uploadDate = new Date(file.uploadedAt); const formattedDate = `${uploadDate.getMonth() + 1}/${uploadDate.getDate()} ${String( uploadDate.getHours(), ).padStart(2, '0')}:${String(uploadDate.getMinutes()).padStart(2, '0')}`; const fileTypeText = file.type === 'text' ? '文本文档' : file.type === 'image' ? '图片文件' : file.type === 'video' ? '视频文件' : file.type === 'link' ? '链接' : '文件'; systemPrompt += ` 【文件 ${index + 1}】 文件名：${file.name} 类型：${fileTypeText} 上传者：${file.uploadedBy} 上传时间：${formattedDate} 所属文件夹：${file.folderName} 内容摘要：${file.content.substring(0, 150)}${file.content.length > 150 ? '...' : ''} `; }); } systemPrompt += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; console.log(`📁 [第11情景] 已加载群文件: ${files.length}个, 文件夹: ${folders.length}个`); } catch (error) { console.warn('⚠️ [第11情景] 加载群文件失败:', error); } if (members.length > 0) { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 👥 群成员资料（${members.length}人） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ⚠️ 重要：每个成员必须使用以下准确的ID、昵称和句柄，不得自创！ `; members.forEach((member, index) => { systemPrompt += ` 【群成员 ${index + 1}】 - 成员ID: ${member.id}（生成消息时必须使用此ID作为senderId） - 昵称: ${member.name}（生成消息时必须使用此昵称作为senderName） - 句柄: ${member.handle}（生成消息时必须使用此句柄作为senderHandle） - 头像: ${member.avatar}（生成消息时必须使用此头像作为senderAvatar） `; const memberProfile = memberProfiles.find(p => p.handle === member.handle); if (memberProfile) { const formattedProfile = StringBuilders.formatProfileForPrompt(memberProfile, { includeType: false, includeTweets: true, includeRelationships: true, }); systemPrompt += formattedProfile; } else { systemPrompt += `⚠️ 未能获取该成员的详细资料\n`; } const application = memberApplications.find(app => app.memberHandle === member.handle); if (application) { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📝 入群申请信息（了解该成员加群动机） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 申请理由：${application.reason} 申请类型：${application.type === 'sincere' ? '真诚粉丝' : application.type === 'normal' ? '普通申请' : '可疑申请'} ${application.amount > 0 ? `入群费用：$${application.amount.toFixed(2)}` : '免费入群'} ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } systemPrompt += `\n`; }); systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ⚠️ 生成消息时的成员身份使用规则 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 必须从上述群成员列表中选择，使用准确的ID和身份信息： - senderId：必须使用【成员ID】（例如：${members[0]?.id}） - senderName：必须使用【昵称】（例如：${members[0]?.name}） - senderHandle：必须使用【句柄】（例如：${members[0]?.handle}） - senderAvatar：必须使用【头像】（例如：${members[0]?.avatar}） 🚨 禁止自创成员身份！所有发言者必须是上述列出的群成员！ ⚠️ 如果某成员已被踢出（在聊天记录中看到"XX 被移出了粉丝群"），则该成员不得再发言！ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } let existingMessages = []; if (isContinueMode) { const conversationId = `messageConversation_${currentAccountId || 'main'}_${fanGroup.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data && savedConversation.data.messages) { existingMessages = savedConversation.data.messages; } } console.log('📖 [第11情景] 现有对话记录:', existingMessages.length, '条（包括系统通知）'); if (isContinueMode && existingMessages.length > 0) { systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 💬 粉丝群聊天记录（当前私信的历史记录，包括系统通知） ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const recentMessages = existingMessages.slice(-30); recentMessages.forEach((msg, index) => { let content = ''; if (msg.type === 'system') { content = `[系统通知] ${msg.content}`; systemPrompt += `${content}\n`; return; } const senderName = msg.isOwn ? userXProfileInfo.name : msg.senderName || '群成员'; if (msg.type === 'text') { content = msg.content || ''; } else if (msg.type === 'image') { if (msg.isOwn && msg.imageData) { content = `[用户发送了图片]`; } else if (msg.imageDescription) { content = `[图片: ${msg.imageDescription}]`; } else { content = `[图片]`; } } else if (msg.type === 'voice') { content = `[语音: ${msg.voiceText || '语音消息'}]`; } else if (msg.type === 'sticker') { if (msg.isOwn && msg.stickerDescription) { content = `[用户发送的表情包: ${msg.stickerDescription}]`; } else if (msg.stickerUrl) { content = `[表情包: ${msg.stickerUrl}]`; } else { content = `[表情包]`; } } else if (msg.type === 'transfer') { const amount = parseFloat(msg.amount || 0).toFixed(2); const note = msg.note ? ` (${msg.note})` : ''; const direction = msg.isOwn ? '转出' : '转入'; content = `[${direction}: $${amount}${note}]`; } else if (msg.type === 'link') { content = `[文章链接]\n标题：${msg.title}\n简介：${msg.description || ''}\n作者：${ msg.author || '' }\n来源：${msg.source || ''}\n正文：${msg.body || msg.description || ''}`; } else if (msg.type === 'quoteTweet') { content = `[转发推文: ${msg.tweet?.content || ''}]`; } else if (msg.type === 'quoteProfile') { content = `[分享主页: ${msg.profile?.name || ''}]`; } else if (msg.type === 'quoteFanGroup') { content = `[分享粉丝群: ${msg.fanGroup?.name || ''}（${msg.fanGroup?.memberCount || 0}人）${ msg.fanGroup?.threshold ? `，入群门槛：${msg.fanGroup.threshold}` : '' }]`; } else if (msg.type === 'groupFile') { const fileTypeText = msg.file?.type === 'text' ? '文本文档' : msg.file?.type === 'image' ? '图片' : msg.file?.type === 'video' ? '视频' : msg.file?.type === 'link' ? '链接' : '文件'; content = `[群文件: ${msg.file?.name || '未命名文件'}]\n类型：${fileTypeText}\n上传者：${ msg.file?.uploadedBy || '未知' }\n内容：${msg.file?.content?.substring(0, 100) || ''}${msg.file?.content?.length > 100 ? '...' : ''}`; } else if (msg.type === 'forward') { if (msg.forwardType === 'tweet') { content = `[转发了推文]\n`; if (msg.fullContext && msg.fullContext.tweet) { const tweet = msg.fullContext.tweet; content += `推文作者：${tweet.user?.name || '未知'}\n推文内容：${tweet.content || ''}\n`; if (msg.fullContext.comments && msg.fullContext.comments.length > 0) { content += `评论区（${msg.fullContext.comments.length}条评论）：\n`; msg.fullContext.comments.slice(0, 3).forEach((c, i) => { content += ` ${i + 1}. ${c.user?.name || '未知'}: ${c.content || ''}\n`; }); if (msg.fullContext.comments.length > 3) { content += ` ...还有${msg.fullContext.comments.length - 3}条评论\n`; } } } else { content += `${msg.forwardContent?.content || ''}`; } } else if (msg.forwardType === 'comment') { content = `[转发了评论]\n`; if (msg.fullContext) { if (msg.fullContext.parentTweet) { content += `原推文作者：${msg.fullContext.parentTweet.user?.name || '未知'}\n原推文内容：${ msg.fullContext.parentTweet.content || '' }\n\n`; } if (msg.fullContext.comment) { content += `评论作者：${msg.fullContext.comment.user?.name || '未知'}\n评论内容：${ msg.fullContext.comment.content || '' }`; } } else { content += `${msg.forwardContent?.content || ''}`; } } } else { content = `[${msg.type}消息]`; } if (content) { const displayContent = content.length > 100 ? `${content.substring(0, 100)}...` : content; systemPrompt += `${senderName}: ${displayContent}\n`; } }); systemPrompt += ` ⚠️ 以上是现有对话记录（包括系统通知），请保持对话的连贯性和一致性 ⚠️ 注意：如果看到"XX 被移出了粉丝群"的系统通知，该成员不得再发言！ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; } const isAutoTrigger = options.isAutoTrigger || false; const newMemberCount = options.newMemberCount || 0; systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务：粉丝群对话生成 🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的粉丝群私信对话生成器。 **群聊场景**： - 📱 这是X社交平台的粉丝群私信功能 - 👥 这是一个群聊，有${members.length}位成员 - 👑 群主是${userXProfileInfo.name} (${userXProfileInfo.handle}) ${ isAutoTrigger ? `- 🎉 群成员数达到${newMemberCount}人，触发自动群聊` : `- 💬 用户${isContinueMode ? '刚刚在群里发言' : '打开了粉丝群聊天'}` } **生成要求**： ${ isAutoTrigger ? ` 1. 生成5-12条群成员的发言，庆祝群成员达到${newMemberCount}人 2. 成员发言应该多样化：祝贺、感谢群主、分享感受、互相交流等 3. 不同成员的发言风格应该根据其资料和入群申请体现差异 4. 可以@群主或其他成员（使用句柄，如 @${userXProfileInfo.handle}） 5. 🎯 **重要：成员之间要互相交流**，不要只是单向对群主说话 ` : options.isAutoReaction ? ` 1. 生成6-15条群成员之间的自发交流消息 2. 🎯 **核心：成员之间的互动交流，而不是对群主的回应** 3. 交流内容可以是： - 成员之间互相打招呼、闲聊 - 讨论共同感兴趣的话题（根据成员资料推断） - 分享最近的生活、工作、学习 - 互相@对方进行对话（使用句柄，如 @成员句柄） - 对其他成员的推文或动态发表看法 - 讨论群主的最近推文（但不是直接@群主） - 组织活动、约饭、游戏等 4. 每个成员的发言要符合其性格特点和入群申请体现的动机 5. 营造真实的粉丝群内部氛围，像真实的粉丝群一样有活力 6. 至少要有2-3组成员之间的对话往来（A说话->B回应->C插话） ` : isContinueMode ? ` 1. 根据用户最新发言，生成3-8条群成员的回复 2. 🎯 **重要：不要所有成员都只回应群主** 3. 可以有以下几种情况： - 部分成员直接回应群主的发言 - 部分成员之间互相交流、讨论群主的话题 - 部分成员@其他成员进行对话 4. 回复应该自然、多样，符合各成员的身份和性格 5. 不是每个成员都必须回复，根据话题相关性和成员特点选择 6. 营造真实的群聊氛围，而不是"群主发言->所有人回应"的模式 ` : ` 1. 生成4-8条群成员的日常发言 2. 发言内容可以是：打招呼、分享日常、讨论共同兴趣、询问群主等 3. 体现真实的粉丝群氛围 4. 成员之间可以互相交流，不要只是单向对群主说话 ` } ${options.isAutoReaction ? '6.' : '5.'} 🚨 只生成群成员的消息，不要生成用户（群主）的消息 ${ options.isAutoReaction ? '7.' : '6.' } 每条消息必须包含senderId（成员ID）、senderName（成员昵称）、senderHandle（成员句柄）、senderAvatar（成员头像） ${options.isAutoReaction ? '8.' : '7.'} 消息类型包括多种，请根据实际需要自然选择 **消息类型使用原则**： - ⭐ **以文本消息为主**：大部分消息（80-90%）应该是纯文本消息（type: "text"） - 📷 **偶尔使用其他类型**：仅在特定情况下使用其他消息类型（10-20%）： * image：当需要分享照片、图片或视觉内容时 * voice：当成员特别激动、情绪强烈时 * sticker：⚠️ **极少使用**（不超过5%）！只在情绪特别强烈且适合用表情包表达时才使用 * transfer：⚠️ **极少使用**！群成员可以发红包给群主或其他成员（5-30美元），需谨慎 * link：当需要分享文章、新闻或故事时 * quoteTweet：当提及或讨论某条推文时 * quoteProfile：当推荐某个账户或介绍某人时 - 🚫 **禁止每种类型都使用**：不要为了展示多样性而强行使用所有消息类型 - ✅ **自然使用**：根据对话内容和情境自然选择消息类型，不刻意 **JSON返回格式**： \`\`\`json { "messages": [ { "senderId": "成员ID（从成员列表中选择）", "senderName": "成员昵称", "senderHandle": "成员句柄（如@username）", "senderAvatar": "成员头像URL", "type": "text", "content": "消息内容", "time": "刚刚" } ] } \`\`\` **消息类型详解**： 1. 文本消息（最常用，首选）： { "type": "text", "content": "消息内容", "time": "刚刚" } 2. 图片消息： { "type": "image", "imageDescription": "图片内容的文字描述", "sensitive": false, "time": "刚刚" } 3. 语音消息： { "type": "voice", "voiceText": "先用括号标注出对声音的形容，再是语音内容的文字", "duration": "时长如0:15", "time": "刚刚" } 4. 表情包消息： { "type": "sticker", "stickerUrl": "表情包图片链接（从世界书中选择）", "time": "刚刚" } 5. 转账消息（普通转账，群成员发红包）： { "type": "transfer", "amount": 20.00, "note": "感谢群主", "status": "pending", "time": "刚刚" } ⚠️ 转账说明： - amount：转账金额（数字类型），建议5-30美元 - note：转账备注，说明转账目的 - status：必须为"pending" - 🚫 **不支持商业转账**：粉丝群中只能发普通转账（红包、礼物等） - 🚫 **谨慎使用**：只有关系亲密或有明确理由时才转账 6. 文章链接消息： { "type": "link", "url": "文章来源网址（可选）", "title": "文章标题", "description": "文章简介/摘要", "author": "文章作者", "source": "文章来源名称", "body": "文章正文内容（完整内容，可使用**文本**加粗，__文本__下划线）", "time": "刚刚" } 7. 转发推文： { "type": "quoteTweet", "tweet": { "userName": "推文作者名", "userHandle": "@handle", "userAvatar": "https: "verified": false, "content": "推文内容", "time": "推文时间" }, "caption": "转发时的说明（可选）", "time": "刚刚" } 8. 转发主页： { "type": "quoteProfile", "profile": { "name": "账户名", "handle": "@handle", "avatar": "https: "bio": "个人简介", "followers": 关注者数量（数字）, "verified": false }, "caption": "转发时的说明（可选）", "time": "刚刚" } 9. 转发粉丝群： { "type": "quoteFanGroup", "fanGroup": { "id": "粉丝群ID", "name": "粉丝群名称", "avatar": "粉丝群头像链接", "memberCount": 成员数量（数字）, "threshold": "入群门槛说明（可选）" }, "caption": "转发时的说明（可选）", "time": "刚刚" } ⚠️ 转发粉丝群说明： - 这是用户转发粉丝群邀请时的消息类型 - 包含粉丝群的基本信息：名称、头像、成员数、入群门槛等 - 群成员可以根据粉丝群信息决定是否感兴趣、讨论这个群等 - AI不应该主动生成此类型消息（除非有合理的场景理由） 10. 群文件上传： { "type": "groupFile", "file": { "name": "文件名称", "type": "文件类型（text/image/video/link）", "content": "文件内容（完整文本内容、链接URL等）", "folderId": "文件夹ID（可选）" }, "time": "刚刚" } ⚠️ 群文件说明： - 成员可以上传文本文档、图片链接、视频链接、文章链接等各种资料到群文件 - file.type：文件类型（text文本、image图片、video视频、link链接） - file.content：文件实际内容，对于文本是完整内容，对于链接是URL - file.name：文件名，应该能够概括文件内容 - file.folderId：📂 **文件夹归类**（可选字段） * 如果要将文件放入特定文件夹，从上方【文件夹列表】中选择对应的文件夹ID * 例如：如果有文件夹「学习资料」ID为folder_123，设置"folderId": "folder_123" * 如果不指定或设为null，文件将显示为"未分类"状态 * 💡 建议：相关主题的文件归入同一文件夹，方便查找和管理 - 📁 成员上传的文件会自动添加到群文件库，群主和其他成员可以在群文件中查看 - 🎯 使用场景：分享学习资料、工作文档、有用的链接、图片素材等 - 🎯 归类建议：根据内容类型选择合适的文件夹，如学习资料放入学习文件夹，图片素材放入素材文件夹 11. 转发推文/评论（forward）： ⚠️ **此类型禁止AI生成！这是用户手动转发操作产生的消息类型。** 如果在聊天记录中看到此类型消息，说明用户转发了推文或评论到群里，可以查看其中的完整内容： - 转发推文时，包含完整推文内容和该推文的所有评论区内容 - 转发评论时，包含评论内容和该评论所属的推文内容 AI应该根据这些完整的上下文信息来理解用户分享的内容并给出回应。 ⚠️ 重要规则： - 群成员ID、昵称、句柄、头像必须从上方群成员资料中选择，不要自创 - 每个成员的发言要符合其资料和入群申请体现的性格特点 - 保持群聊的真实感和多样性，避免千篇一律 - ⚠️ image和sticker是完全不同的类型，不要混淆！ - ⚠️ link类型是文章链接，需要包含完整的文章内容 - 时间使用相对时间（如"刚刚"、"1分钟前"等） - 所有头像统一使用成员列表中提供的头像URL - verified字段必须是布尔值(true/false) - followers等数字字段必须是纯数字 - 可选字段不使用时完全省略，不要设为null ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ `; const userConstraintsStart = systemPrompt.length; systemPrompt += StringBuilders.buildUniversalConstraints(userXProfileInfo); const userConstraints = systemPrompt.substring(userConstraintsStart); tokenCount = TokenUtils.logTokenUsage('第11情景-粉丝群私信', '用户约束', userConstraints, tokenCount); const messages = [{ role: 'user', content: '请生成粉丝群对话' }]; TokenUtils.logFinalPrompt('第11情景-粉丝群私信', systemPrompt, messages[0].content); const aiResponseContent = await APIUtils.sendAIRequest({ apiConfig, systemPrompt, messages, temperature: 0.9, }); console.log('🎯 [第11情景] AI响应长度:', aiResponseContent.length, '字符'); console.log('🎯 [第11情景] AI完整响应:\n', aiResponseContent); let conversationData = APIUtils.parseJSONResponse(aiResponseContent); if (!conversationData.messages || !Array.isArray(conversationData.messages)) { throw new Error('AI返回的数据格式不正确'); } console.log(`✅ [第11情景] 成功解析JSON，共${conversationData.messages.length}条消息`); console.log( '📋 [第11情景] 消息发送者列表:', conversationData.messages.map(m => `${m.senderName}(${m.senderId})`).join(', '), ); const generatedMessages = conversationData.messages.map(msg => ({ type: msg.type || 'text', content: msg.content || '', isOwn: false, time: msg.time || '刚刚', timestamp: new Date().toISOString(), senderId: msg.senderId, senderName: msg.senderName, senderHandle: msg.senderHandle, senderAvatar: msg.senderAvatar, imageDescription: msg.imageDescription, sensitive: msg.sensitive, stickerUrl: msg.stickerUrl, voiceText: msg.voiceText, voiceDuration: msg.voiceDuration, duration: msg.duration, amount: msg.amount, note: msg.note, status: msg.status, title: msg.title, description: msg.description, author: msg.author, source: msg.source, body: msg.body, url: msg.url, tweet: msg.tweet, caption: msg.caption, profile: msg.profile, file: msg.file ? { name: msg.file.name, type: msg.file.type, content: msg.file.content, folderId: msg.file.folderId || null, uploadedBy: msg.senderName, uploadedAt: new Date().toISOString(), } : undefined, })); console.log(`✅ [第11情景] 成功生成${generatedMessages.length}条群聊消息`); const fileMessages = generatedMessages.filter(msg => msg.type === 'groupFile' && msg.file); if (fileMessages.length > 0) { console.log(`📁 [第11情景] 检测到${fileMessages.length}个AI生成的群文件，正在保存...`); try { const filesId = `fanGroupFiles_${currentAccountId || 'main'}_${fanGroup.id}`; const savedData = await xDb.xAccountProfiles.get(filesId); let files = savedData?.data || []; for (const msg of fileMessages) { const newFile = { id: `file_ai_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, name: msg.file.name, type: msg.file.type, content: msg.file.content, folderId: msg.file.folderId || null, uploadedBy: msg.senderName, uploadedAt: msg.file.uploadedAt || new Date().toISOString(), }; files.push(newFile); msg.file.id = newFile.id; console.log(`✅ [群文件] AI上传文件: ${newFile.name} (${msg.senderName})`); } await xDb.xAccountProfiles.put({ handle: filesId, name: 'fanGroupFiles', data: files, updatedAt: new Date().toISOString(), }); console.log(`✅ [第11情景] 已保存${fileMessages.length}个AI生成的群文件到数据库`); } catch (error) { console.error('❌ [第11情景] 保存AI生成的群文件失败:', error); } } const avatarCorrectedData = await StringBuilders.enforceAvatarRules({ messages: generatedMessages }); return avatarCorrectedData.messages || generatedMessages; } catch (error) { console.error('❌ [第11情景] 生成粉丝群对话失败:', error); showXToast('生成对话失败: ' + error.message, 'error'); return []; } } window.triggerFanGroupAutoReaction = async function () { console.log('🎭 [粉丝群自反应] 开始触发'); if (!currentMessageConversation) { showXToast('会话数据丢失', 'error'); return; } const isFanGroup = currentMessageConversation.type === 'fangroup' || (currentMessageConversation.id && currentMessageConversation.id.startsWith('fangroup_')); if (!isFanGroup) { showXToast('只有粉丝群支持自反应功能', 'info'); return; } const conversationRef = currentMessageConversation; const autoReactionBtn = document.getElementById('fangroup-auto-reaction-btn'); const sendBtn = document.getElementById('message-send-btn'); if (autoReactionBtn) { autoReactionBtn.disabled = true; autoReactionBtn.style.opacity = '0.5'; } if (sendBtn) { sendBtn.disabled = true; sendBtn.style.opacity = '0.5'; } try { console.log('📤 [粉丝群自反应] 显示输入气泡'); showTypingIndicator(); showXToast('群成员正在交流中...', 'info'); console.log('📤 [粉丝群自反应] 调用第11个情景生成器'); const aiMessages = await generateFanGroupConversation(conversationRef, true, { isAutoReaction: true, }); console.log(`📤 [粉丝群自反应] AI返回了 ${aiMessages ? aiMessages.length : 0} 条消息`); hideTypingIndicator(); if (!aiMessages || aiMessages.length === 0) { showXToast('群成员暂时没有发言', 'info'); return; } const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversationRef.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); let allMessages = []; if (savedConversation && savedConversation.data && savedConversation.data.messages) { allMessages = savedConversation.data.messages; } allMessages.push(...aiMessages); await xDb.xAccountProfiles.put({ handle: conversationId, name: 'conversation', data: { messages: allMessages, }, updatedAt: new Date().toISOString(), }); console.log('📤 [粉丝群自反应] 消息已保存到数据库'); const dataId = `messagesList_${currentAccountId || 'main'}`; const messagesList = await xDb.xAccountProfiles.get(dataId); if (messagesList && messagesList.data) { const groupIndex = messagesList.data.findIndex(msg => msg.id === conversationRef.id); if (groupIndex !== -1) { const lastMsg = aiMessages[aiMessages.length - 1]; const lastMsgContent = lastMsg.content || lastMsg.voiceText || lastMsg.imageDescription || '[消息]'; messagesList.data[groupIndex].lastMessage = `${lastMsg.senderName}: ${lastMsgContent}`; messagesList.data[groupIndex].timestamp = new Date().toISOString(); await xDb.xAccountProfiles.put(messagesList); console.log('📤 [粉丝群自反应] 私信列表预览已更新'); } } const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { const messageElements = []; aiMessages.forEach((msg, index) => { const msgEl = renderMessageItem(msg, false, allMessages.length - aiMessages.length + index, true, true); contentContainer.appendChild(msgEl); messageElements.push(msgEl); }); await animateMessagesOneByOne(messageElements, 300); } showXToast(`群内产生了 ${aiMessages.length} 条新对话`, 'success'); } catch (error) { console.error('❌ [粉丝群自反应] 生成失败:', error); hideTypingIndicator(); showXToast('生成失败: ' + error.message, 'error'); } finally { if (autoReactionBtn) { autoReactionBtn.disabled = false; autoReactionBtn.style.opacity = '1'; } if (sendBtn) { sendBtn.disabled = false; sendBtn.style.opacity = '1'; } } }; async function checkAndTriggerFanGroupAutoChat(groupId, newMemberCount) { console.log('🔍 [粉丝群] 检查自动触发条件', { groupId, newMemberCount }); const triggerPoints = [5, 15, 25, 35, 45, 55, 65, 75, 85, 95]; const shouldTrigger = triggerPoints.includes(newMemberCount); if (!shouldTrigger) { console.log('⏸️ [粉丝群] 未达到触发条件'); return; } console.log(`🎉 [粉丝群] 成员数达到${newMemberCount}人，触发自动群聊！`); try { const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); const messagesList = savedData?.data || []; const fanGroup = messagesList.find(msg => msg.id === groupId); if (!fanGroup) { console.error('❌ [粉丝群] 未找到粉丝群数据'); return; } const aiMessages = await generateFanGroupConversation(fanGroup, true, { isAutoTrigger: true, newMemberCount: newMemberCount, }); if (!aiMessages || aiMessages.length === 0) { console.error('❌ [粉丝群] AI未生成任何消息'); return; } const conversationId = `messageConversation_${currentAccountId || 'main'}_${groupId}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (!savedConversation || !savedConversation.data) { await xDb.xAccountProfiles.put({ handle: conversationId, name: 'conversation', data: { messages: aiMessages, }, updatedAt: new Date().toISOString(), }); } else { savedConversation.data.messages.push(...aiMessages); await xDb.xAccountProfiles.put(savedConversation); } console.log(`✅ [粉丝群] 已保存${aiMessages.length}条自动生成的群聊消息`); if (savedData && savedData.data) { const groupIndex = savedData.data.findIndex(msg => msg.id === groupId); if (groupIndex !== -1) { const lastMsg = aiMessages[aiMessages.length - 1]; savedData.data[groupIndex].lastMessage = lastMsg.content || lastMsg.voiceText || lastMsg.imageDescription || '[消息]'; savedData.data[groupIndex].timestamp = new Date().toISOString(); savedData.data[groupIndex].unread = true; await xDb.xAccountProfiles.put(savedData); sampleMessagesData = savedData.data; } } await loadMessagesList(); showPhoneNotification({ title: fanGroup.userName || fanGroup.groupName, message: `群成员达到${newMemberCount}人啦！大家都在庆祝呢~`, avatar: fanGroup.userAvatar || 'https: leftIcon: 'custom', leftIconHtml: ` <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"> <g><path d="M17.5 4.5c-1.95-1.96-5.11-1.96-7.07 0-1.96 1.96-1.96 5.11 0 7.07 1.95 1.96 5.11 1.96 7.07 0 1.96-1.96 1.96-5.11 0-7.07zM14 9c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z M12 14H6c-1.1 0-2 .9-2 2v5h16v-5c0-1.1-.9-2-2-2h-6z"></path></g> </svg> `, duration: 5000, onClick: () => { window.openMessageDetail(fanGroup); }, }); showXToast(`粉丝群达到${newMemberCount}人！`, 'success'); } catch (error) { console.error('❌ [粉丝群] 自动触发失败:', error); } } window.openFanGroupAnnouncementModal = async function () { const isFanGroup = currentMessageConversation && (currentMessageConversation.type === 'fangroup' || (currentMessageConversation.id && currentMessageConversation.id.startsWith('fangroup_'))); if (!isFanGroup) { showXToast('当前不是粉丝群聊天', 'error'); return; } console.log('📢 [群公告] 打开群公告弹窗', currentMessageConversation.id); try { const modal = document.getElementById('fangroup-announcement-modal'); if (modal) { modal.style.display = 'flex'; } await loadFanGroupAnnouncements(); } catch (error) { console.error('❌ [群公告] 打开弹窗失败:', error); showXToast('打开失败: ' + error.message, 'error'); } }; window.closeFanGroupAnnouncementModal = function () { const modal = document.getElementById('fangroup-announcement-modal'); if (modal) { modal.style.display = 'none'; } }; window.openCreateAnnouncementDialog = function () { const dialog = document.getElementById('create-announcement-dialog'); const contentInput = document.getElementById('announcement-content-input'); const mentionCheckbox = document.getElementById('mention-all-checkbox'); const counter = document.getElementById('announcement-counter'); if (dialog) { dialog.style.display = 'flex'; } if (contentInput) { contentInput.value = ''; } if (mentionCheckbox) { mentionCheckbox.checked = false; } if (counter) { counter.textContent = '0 / 500'; } }; window.closeCreateAnnouncementDialog = function () { const dialog = document.getElementById('create-announcement-dialog'); if (dialog) { dialog.style.display = 'none'; } }; window.updateAnnouncementCounter = function () { const contentInput = document.getElementById('announcement-content-input'); const counter = document.getElementById('announcement-counter'); if (contentInput && counter) { const length = contentInput.value.length; counter.textContent = `${length} / 500`; } }; async function loadFanGroupAnnouncements() { if (!currentMessageConversation) return; const groupId = currentMessageConversation.id; const container = document.getElementById('fangroup-announcements-container'); if (!container) return; try { const xDb = getXDB(); const announcementsId = `fanGroupAnnouncements_${currentAccountId || 'main'}_${groupId}`; const savedData = await xDb.xAccountProfiles.get(announcementsId); const announcements = savedData?.data || []; console.log('📢 [群公告] 加载公告列表', { groupId, count: announcements.length }); container.innerHTML = ''; if (announcements.length === 0) { container.innerHTML = ` <div style="width: 100%; text-align: center; color:var(--x-text-secondary); font-size: 14px; padding: 40px 20px; grid-column: 1 / -1;"> 📌 暂无公告，点击下方按钮创建第一条公告 </div> `; return; } announcements.forEach((announcement, index) => { const card = renderAnnouncementCard(announcement, index); container.appendChild(card); }); } catch (error) { console.error('❌ [群公告] 加载失败:', error); container.innerHTML = ` <div style="width: 100%; text-align: center; color: #ef4444; font-size: 14px; padding: 40px 20px; grid-column: 1 / -1;"> ❌ 加载失败，请重试 </div> `; } } function darkenColor(hex, percent) { const num = parseInt(hex.replace('#', ''), 16); const amt = Math.round(2.55 * percent); const R = Math.max((num >> 16) - amt, 0); const G = Math.max(((num >> 8) & 0x00ff) - amt, 0); const B = Math.max((num & 0x0000ff) - amt, 0); return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1); } function lightenColor(hex, percent) { const num = parseInt(hex.replace('#', ''), 16); const amt = Math.round(2.55 * percent); const R = Math.min((num >> 16) + amt, 255); const G = Math.min(((num >> 8) & 0x00ff) + amt, 255); const B = Math.min((num & 0x0000ff) + amt, 255); return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1); } function getContrastColor(hex, opacity = 1) { const num = parseInt(hex.replace('#', ''), 16); const R = (num >> 16) & 0xff; const G = (num >> 8) & 0xff; const B = num & 0xff; const brightness = (R * 299 + G * 587 + B * 114) / 1000; if (brightness > 128) { return opacity === 1 ? '#1f2937' : `rgba(31, 41, 55, ${opacity})`; } else { return opacity === 1 ? '#f9fafb' : `rgba(249, 250, 251, ${opacity})`; } } function renderAnnouncementCard(announcement, index) { const card = document.createElement('div'); const xSocialScreen = document.getElementById('x-social-screen'); const isLightMode = xSocialScreen?.classList.contains('x-theme-light'); const allColors = [ '#EB9FAA', '#F7D2D5', '#FCEFF0', '#C0CEE4', '#F2E4E9', '#A0A0A3', '#BFBBBE', '#5F5F60', '#67B3DB', '#9EDAF1', '#CDEEF8', '#FFFBDD', '#D40D3E', '#FDF5DC', '#C9EAF8', '#DA2E53', '#FFEBD5', '#FFC4AF', '#FF8D65', '#8FDBE0', ]; const randomColorIndex = Math.floor(Math.random() * allColors.length); const bgColor = allColors[randomColorIndex]; const color = { bg: bgColor, border: isLightMode ? darkenColor(bgColor, 15) : lightenColor(bgColor, 15), }; const isMobile = window.innerWidth <= 640; const rotationRange = isMobile ? 1.5 : 3; const rotation = (Math.random() * rotationRange * 2 - rotationRange).toFixed(2); const decorationType = Math.random(); const hasClip = decorationType < 0.3; const hasTape = decorationType >= 0.3 && decorationType < 0.6; const hasTear = decorationType >= 0.6; const clipPosition = Math.random() > 0.5 ? 'left' : 'right'; const clipColors = ['#c0c0c0', '#ffd700', '#ff6b6b', '#4ecdc4']; const clipColor = clipColors[Math.floor(Math.random() * clipColors.length)]; const hasCrinkle = Math.random() > 0.5; const crinklePosition = `${Math.random() * 60 + 20}%`; const crinkleRotation = Math.random() > 0.5 ? '45deg' : '-45deg'; const createdDate = new Date(announcement.createdAt); const formattedDate = `${createdDate.getFullYear()}/${String(createdDate.getMonth() + 1).padStart(2, '0')}/${String( createdDate.getDate(), ).padStart(2, '0')} ${String(createdDate.getHours()).padStart(2, '0')}:${String(createdDate.getMinutes()).padStart( 2, '0', )}`; const tearEffect = hasTear ? `polygon( 0% 2%, 3% 0%, 6% 2%, 9% 0%, 12% 1%, 15% 0%, 18% 2%, 21% 0%, 24% 1%, 27% 0%, 30% 2%, 33% 0%, 36% 1%, 39% 0%, 42% 2%, 45% 0%, 48% 1%, 51% 0%, 54% 2%, 57% 0%, 60% 1%, 63% 0%, 66% 2%, 69% 0%, 72% 1%, 75% 0%, 78% 2%, 81% 0%, 84% 1%, 87% 0%, 90% 2%, 93% 0%, 96% 1%, 100% 0%, 100% 100%, 0% 100% )` : 'none'; card.style.cssText = ` width: 100%; max-width: 400px; min-height: 180px; margin: 0 auto; background-color: ${color.bg}; background-image: repeating-linear-gradient( 0deg, transparent, transparent 2px, rgba(0, 0, 0, 0.025) 2px, rgba(0, 0, 0, 0.025) 3px ); border: none; border-radius: ${hasTear ? '0' : '3px'}; padding: ${isMobile ? '16px' : '20px'}; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 3px 6px rgba(0, 0, 0, 0.08), inset 0 1px 0 rgba(255, 255, 255, 0.15), inset 0 0 30px rgba(255, 255, 255, 0.05); cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); transform: rotate(${rotation}deg); position: relative; overflow: visible; animation: announceCardFadeIn 0.5s ease-out ${index * 0.12}s both; clip-path: ${tearEffect}; filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1)); `; const textColor = getContrastColor(bgColor); const secondaryTextColor = getContrastColor(bgColor, 0.65); card.innerHTML = ` ${ hasTape ? ` <div style="position: absolute; top: ${Math.random() * 10 - 5}px; left: ${ Math.random() * 20 + 40 }%; transform: translateX(-50%) rotate(${ Math.random() * 6 - 3 }deg); width: 80px; height: 25px; background: rgba(255, 255, 255, ${ isLightMode ? '0.5' : '0.15' }); opacity: 0.7; border-left: 1px solid rgba(0, 0, 0, 0.05); border-right: 1px solid rgba(0, 0, 0, 0.05); z-index: 1;"></div> ` : '' } ${ hasClip ? ` <div style="position: absolute; top: 8px; ${clipPosition}: 12px; width: 8px; height: 24px; border: 2px solid ${clipColor}; border-radius: 8px 8px 4px 4px; transform: rotate(${ Math.random() * 20 - 10 }deg); opacity: 0.8; box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2);"></div> ` : '' } ${ hasCrinkle ? ` <div style="position: absolute; top: 0; left: ${crinklePosition}; width: 1px; height: 100%; background: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.06) 20%, rgba(0, 0, 0, 0.06) 80%, transparent); transform: rotate(${crinkleRotation}); pointer-events: none;"></div> ` : '' } <div style="position: absolute; inset: 0; background: repeating-linear-gradient(90deg, transparent, transparent 1px, rgba(0,0,0,0.015) 1px, rgba(0,0,0,0.015) 2px), repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(0,0,0,0.015) 1px, rgba(0,0,0,0.015) 2px); pointer-events: none; opacity: 0.6;"></div> <div style="position: relative; z-index: 2; color: ${textColor}; font-size: 14px; line-height: 1.8; margin-bottom: 16px; word-wrap: break-word; white-space: pre-wrap; font-family: 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif; text-shadow: 0 1px 0 rgba(255, 255, 255, 0.1);"> ${announcement.content} </div> <div style="position: relative; z-index: 2; display: flex; align-items: center; justify-content: space-between; margin-top: 16px; padding-top: 12px; border-top: 1px dashed ${ color.border };"> <div style="font-size: 11px; color: ${secondaryTextColor}; font-style: italic; opacity: 0.8;"> ${formattedDate} </div> <button onclick="event.stopPropagation(); deleteFanGroupAnnouncement('${ announcement.id }')" style="background: rgba(0, 0, 0, 0.05); border: 1px solid ${ color.border }; color: ${textColor}; cursor: pointer; padding: 5px 10px; border-radius: 6px; font-size: 12px; font-weight: 600; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(0, 0, 0, 0.15)'; this.style.transform='scale(1.05)'" onmouseout="this.style.backgroundColor='rgba(0, 0, 0, 0.05)'; this.style.transform='scale(1)'"> 🗑️ </button> </div> `; card.addEventListener('mouseenter', () => { card.style.transform = `rotate(${parseFloat(rotation) * 0.5}deg) translateY(-12px) scale(1.03)`; card.style.filter = 'drop-shadow(0 8px 16px rgba(0, 0, 0, 0.2))'; card.style.zIndex = '100'; }); card.addEventListener('mouseleave', () => { card.style.transform = `rotate(${rotation}deg) translateY(0) scale(1)`; card.style.filter = 'drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1))'; card.style.zIndex = 'auto'; }); return card; } if (!document.getElementById('announcement-card-animation-style')) { const style = document.createElement('style'); style.id = 'announcement-card-animation-style'; style.textContent = ` @keyframes announceCardFadeIn { 0% { opacity: 0; transform: translateY(-40px) translateX(-20px) rotate(-5deg) scale(0.9); filter: drop-shadow(0 0 0 rgba(0, 0, 0, 0)); } 60% { opacity: 1; transform: translateY(5px) translateX(2px) rotate(2deg) scale(1.02); } 100% { opacity: 1; transform: translateY(0) translateX(0) rotate(var(--rotation, 0deg)) scale(1); filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1)); } } @media (max-width: 640px) { #fangroup-announcements-container { padding: 16px 12px !important; gap: 20px 12px !important; } } `; document.head.appendChild(style); } window.saveFanGroupAnnouncement = async function () { const isFanGroup = currentMessageConversation && (currentMessageConversation.type === 'fangroup' || (currentMessageConversation.id && currentMessageConversation.id.startsWith('fangroup_'))); if (!isFanGroup) { showXToast('当前不是粉丝群聊天', 'error'); return; } const contentInput = document.getElementById('announcement-content-input'); const mentionCheckbox = document.getElementById('mention-all-checkbox'); const content = contentInput?.value?.trim(); if (!content) { showXToast('请输入公告内容', 'warning'); return; } const groupId = currentMessageConversation.id; const shouldMentionAll = mentionCheckbox?.checked || false; console.log('📢 [群公告] 保存新公告', { groupId, content, shouldMentionAll }); try { const xDb = getXDB(); const announcementsId = `fanGroupAnnouncements_${currentAccountId || 'main'}_${groupId}`; const savedData = await xDb.xAccountProfiles.get(announcementsId); const announcements = savedData?.data || []; const newAnnouncement = { id: `announcement_${Date.now()}`, groupId: groupId, content: content, createdAt: new Date().toISOString(), createdBy: 'admin', }; announcements.unshift(newAnnouncement); await xDb.xAccountProfiles.put({ handle: announcementsId, name: 'fanGroupAnnouncements', data: announcements, updatedAt: new Date().toISOString(), }); console.log('✅ [群公告] 公告已保存'); const conversationId = `messageConversation_${currentAccountId || 'main'}_${groupId}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data && savedConversation.data.messages) { const systemMessage = { type: 'system', systemType: 'announcement', content: `📢 群主发布了新公告：${content}`, timestamp: new Date().toISOString(), time: '刚刚', }; savedConversation.data.messages.push(systemMessage); await xDb.xAccountProfiles.put(savedConversation); console.log('✅ [群公告] 已添加系统通知'); if (currentMessageConversation && currentMessageConversation.id === groupId) { const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { const msgEl = renderMessageItem(systemMessage, false, savedConversation.data.messages.length - 1, true); contentContainer.appendChild(msgEl); const scrollableContainer = document.getElementById('message-detail-scrollable'); if (scrollableContainer) { scrollableContainer.scrollTop = scrollableContainer.scrollHeight; } } } } closeCreateAnnouncementDialog(); await loadFanGroupAnnouncements(); showXToast('公告发布成功', 'success'); if (shouldMentionAll) { console.log('📢 [群公告] @全员，触发AI反应'); closeFanGroupAnnouncementModal(); setTimeout(async () => { try { await window.triggerFanGroupAutoReaction(); showXToast('已通知所有成员', 'success'); } catch (error) { console.error('❌ [群公告] 触发AI反应失败:', error); showXToast('通知失败: ' + error.message, 'error'); } }, 500); } } catch (error) { console.error('❌ [群公告] 保存失败:', error); showXToast('保存失败: ' + error.message, 'error'); } }; window.deleteFanGroupAnnouncement = async function (announcementId) { const isFanGroup = currentMessageConversation && (currentMessageConversation.type === 'fangroup' || (currentMessageConversation.id && currentMessageConversation.id.startsWith('fangroup_'))); if (!isFanGroup) { return; } if (!confirm('确定要删除这条公告吗？')) { return; } const groupId = currentMessageConversation.id; console.log('🗑️ [群公告] 删除公告', { groupId, announcementId }); try { const xDb = getXDB(); const announcementsId = `fanGroupAnnouncements_${currentAccountId || 'main'}_${groupId}`; const savedData = await xDb.xAccountProfiles.get(announcementsId); let announcements = savedData?.data || []; announcements = announcements.filter(a => a.id !== announcementId); await xDb.xAccountProfiles.put({ handle: announcementsId, name: 'fanGroupAnnouncements', data: announcements, updatedAt: new Date().toISOString(), }); console.log('✅ [群公告] 公告已删除'); await loadFanGroupAnnouncements(); showXToast('公告已删除', 'success'); } catch (error) { console.error('❌ [群公告] 删除失败:', error); showXToast('删除失败: ' + error.message, 'error'); } }; let currentFanGroupFolder = null; function createFanGroupFilesModal() { const existingModal = document.getElementById('fangroup-files-modal'); if (existingModal) { existingModal.remove(); } const modal = document.createElement('div'); modal.id = 'fangroup-files-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.7); display: flex; align-items: center; justify-content: center; z-index: 35; backdrop-filter: blur(10px); padding: 0 8px; box-sizing: border-box; `; modal.innerHTML = ` <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 100%; max-width: 800px; max-height: 85vh; display: flex; flex-direction: column; box-shadow: 0 25px 50px rgba(0,0,0,0.3); overflow: hidden;" onclick="event.stopPropagation()"> <div style="padding: 16px; border-bottom: 1px solid var(--x-border-color); flex-shrink: 0;"> <div style="display: flex; align-items: center; justify-content: space-between;"> <div style="display: flex; align-items: center; gap: 10px;"> <svg xmlns="http: <path d="M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2" /> </svg> <h3 style="margin: 0; color:var(--x-text-primary); font-size: 18px; font-weight: 700;" id="fangroup-files-header-title">群文件</h3> </div> <button onclick="closeFanGroupFilesModal()" style="background: transparent; border: none; color:var(--x-text-secondary); cursor: pointer; padding: 6px; border-radius: 50%; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center;" onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </button> </div> </div> <div id="fangroup-files-container" style="flex: 1; overflow-y: auto; overflow-x: hidden; padding: 12px; display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; align-content: flex-start; justify-content: center; min-height: 200px; background-color: var(--x-bg-secondary);"> <div style="width: 100%; text-align: center; color:var(--x-text-secondary); font-size: 13px; padding: 30px 16px; grid-column: 1 / -1;"> <svg xmlns="http: <path d="M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2" /> </svg> 暂无文件，点击下方按钮创建文件夹或上传文件 </div> </div> <div style="padding: 12px 16px; border-top: 1px solid var(--x-border-color); flex-shrink: 0; display: flex; gap: 8px; flex-wrap: wrap;"> <div style="display: flex; gap: 8px; flex: 1;"> <button id="fangroup-files-back-btn" onclick="backToFilesList()" style="display: none; background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 18px; padding: 8px 16px; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'"> <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor; margin-right: 4px; vertical-align: text-bottom;"> <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path> </svg> 返回 </button> <button id="fangroup-files-batch-btn" onclick="toggleBatchMode()" style="display: none; background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: 1px solid var(--x-border-color); border-radius: 18px; padding: 8px 12px; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'"> 批量管理 </button> <button id="fangroup-files-cancel-batch-btn" onclick="toggleBatchMode()" style="display: none; background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 18px; padding: 8px 12px; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'"> 取消 </button> <button id="fangroup-files-delete-batch-btn" onclick="batchDeleteFiles()" style="display: none; background-color: rgba(220, 38, 38, 0.9); color: #fff; border: none; border-radius: 18px; padding: 8px 12px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'"> 删除选中 (0) </button> </div> <div style="display: flex; gap: 8px; flex-wrap: nowrap;"> <button id="fangroup-files-create-folder-btn" onclick="openCreateFolderDialog()" style="background-color: var(--x-bg-secondary); color: var(--x-text-primary); border: 1px solid var(--x-border-color); border-radius: 18px; padding: 8px 12px; font-size: 13px; font-weight: 500; cursor: pointer; white-space: nowrap; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 4px;" onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'"> <svg xmlns="http: <path d="M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2" /> </svg> <span>新建文件夹</span> </button> <button id="fangroup-files-upload-btn" onclick="openUploadFileDialog()" style="background-color: #2a2a2a; color: #fff; border: none; border-radius: 18px; padding: 8px 12px; font-size: 13px; font-weight: 500; white-space: nowrap; cursor: pointer; transition: all 0.2s; box-shadow: 0 1px 3px rgba(0,0,0,0.2); display: flex; align-items: center; justify-content: center; gap: 4px;" onmouseover="this.style.backgroundColor='#3a3a3a'" onmouseout="this.style.backgroundColor='#2a2a2a'"> <svg xmlns="http: <path d="M12 5v10M7 9l5-5 5 5M19 15v4H5v-4"></path> </svg> <span>上传文件</span> </button> </div> </div> </div> `; modal.onclick = () => closeFanGroupFilesModal(); const xSocialScreen = document.getElementById('x-social-screen'); if (xSocialScreen) { xSocialScreen.appendChild(modal); } else { document.body.appendChild(modal); } return modal; } window.openFanGroupFilesModal = async function () { const isFanGroup = currentMessageConversation && (currentMessageConversation.type === 'fangroup' || (currentMessageConversation.id && currentMessageConversation.id.startsWith('fangroup_'))); if (!isFanGroup) { showXToast('当前不是粉丝群聊天', 'error'); return; } console.log('📁 [群文件] 打开群文件弹窗'); const modal = createFanGroupFilesModal(); currentFanGroupFolder = null; await loadFanGroupFiles(); }; window.closeFanGroupFilesModal = function () { const modal = document.getElementById('fangroup-files-modal'); if (modal) { modal.remove(); currentFanGroupFolder = null; } }; async function loadFanGroupFiles() { const groupId = currentMessageConversation.id; const container = document.getElementById('fangroup-files-container'); const backBtn = document.getElementById('fangroup-files-back-btn'); const headerTitle = document.getElementById('fangroup-files-header-title'); if (!container) return; try { const xDb = getXDB(); const foldersId = `fanGroupFolders_${currentAccountId || 'main'}_${groupId}`; const foldersData = await xDb.xAccountProfiles.get(foldersId); const folders = foldersData?.data || []; const filesId = `fanGroupFiles_${currentAccountId || 'main'}_${groupId}`; const filesData = await xDb.xAccountProfiles.get(filesId); const allFiles = filesData?.data || []; let filesToShow = []; let foldersToShow = []; if (currentFanGroupFolder) { filesToShow = allFiles.filter(f => f.folderId === currentFanGroupFolder.id); backBtn.style.display = 'flex'; headerTitle.textContent = currentFanGroupFolder.name; } else { foldersToShow = folders; filesToShow = allFiles.filter(f => !f.folderId); backBtn.style.display = 'none'; headerTitle.textContent = '群文件'; } container.innerHTML = ''; foldersToShow.forEach(folder => { container.appendChild(createFolderCard(folder, allFiles)); }); filesToShow.forEach(file => { container.appendChild(createFileCard(file)); }); if (foldersToShow.length === 0 && filesToShow.length === 0) { container.innerHTML = ` <div style="width: 100%; text-align: center; color:var(--x-text-secondary); font-size: 13px; padding: 30px 16px; grid-column: 1 / -1;"> <svg xmlns="http: <path d="M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2" /> ${currentFanGroupFolder ? '<path d="M9 13h6" />' : ''} </svg> ${currentFanGroupFolder ? '文件夹为空' : '暂无文件，点击下方按钮创建文件夹或上传文件'} </div> `; } const batchBtn = document.getElementById('fangroup-files-batch-btn'); if (batchBtn) { if (filesToShow.length > 0 && !isBatchMode) { batchBtn.style.display = 'flex'; } else { batchBtn.style.display = 'none'; } } console.log(`✅ [群文件] 已加载 ${foldersToShow.length} 个文件夹，${filesToShow.length} 个文件`); } catch (error) { console.error('❌ [群文件] 加载失败:', error); showXToast('加载失败', 'error'); } } function createFolderCard(folder, allFiles) { const filesInFolder = allFiles.filter(f => f.folderId === folder.id); const fileCount = filesInFolder.length; const card = document.createElement('div'); card.style.cssText = ` position: relative; width: 100%; cursor: pointer; transition: transform 0.2s ease, filter 0.2s ease, box-shadow 0.2s ease; margin-bottom: 6px; `; card.innerHTML = ` <div style=" position: relative; padding-bottom: 100%; width: 100%; "> <div style=" position: absolute; top: 0; left: 0; right: 0; bottom: 0; "> <!-- 文件夹整体容器 --> <div style=" position: relative; width: 100%; height: 100%; "> <!-- 主文件夹 --> <div style=" position: absolute; top: 20%; left: 0; width: 100%; height: 80%; background: #222222; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.25); z-index: 1; "> <!-- 文件夹内部纹理 --> <div style=" position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 8px; background: linear-gradient(180deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0) 100%); opacity: 0.5; "></div> <!-- 文件夹图标 --> <svg xmlns="http: position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 22px; height: 22px; fill: none; stroke: rgba(255,255,255,0.5); stroke-width: 1.5; stroke-linecap: round; stroke-linejoin: round; "> <path d="M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2" /> </svg> </div> <!-- 堆叠文档1 - 最下层 --> <div style=" position: absolute; top: 10%; left: 8%; width: 84%; height: 25%; background: #fafafa; border-radius: 4px 4px 0 0; transform: rotate(-3deg); z-index: 2; box-shadow: 0 2px 6px rgba(0,0,0,0.1); overflow: hidden; "> <!-- 文档内容线条 --> <div style=" position: absolute; top: 30%; left: 10%; width: 80%; height: 2px; background-color: rgba(0,0,0,0.06); "></div> <div style=" position: absolute; top: 50%; left: 10%; width: 60%; height: 2px; background-color: rgba(0,0,0,0.06); "></div> <div style=" position: absolute; top: 70%; left: 10%; width: 70%; height: 2px; background-color: rgba(0,0,0,0.06); "></div> </div> <!-- 堆叠文档2 - 中层 --> <div style=" position: absolute; top: 5%; left: 10%; width: 80%; height: 25%; background: #f5f5f5; border-radius: 4px 4px 0 0; z-index: 3; box-shadow: 0 1px 3px rgba(0,0,0,0.1); overflow: hidden; "> <!-- 文档内容线条 --> <div style=" position: absolute; top: 30%; left: 10%; width: 80%; height: 2px; background-color: rgba(0,0,0,0.06); "></div> <div style=" position: absolute; top: 50%; left: 10%; width: 70%; height: 2px; background-color: rgba(0,0,0,0.06); "></div> <div style=" position: absolute; top: 70%; left: 10%; width: 60%; height: 2px; background-color: rgba(0,0,0,0.06); "></div> </div> <!-- 堆叠文档3 - 顶层 --> <div style=" position: absolute; top: 2%; left: 13%; width: 74%; height: 25%; background: white; border-radius: 4px 4px 0 0; transform: rotate(2deg); z-index: 4; box-shadow: 0 1px 4px rgba(0,0,0,0.1); overflow: hidden; "> <!-- 文档内容线条 --> <div style=" position: absolute; top: 30%; left: 10%; width: 75%; height: 2px; background-color: rgba(0,0,0,0.06); "></div> <div style=" position: absolute; top: 50%; left: 10%; width: 55%; height: 2px; background-color: rgba(0,0,0,0.06); "></div> <div style=" position: absolute; top: 70%; left: 10%; width: 65%; height: 2px; background-color: rgba(0,0,0,0.06); "></div> </div> <!-- 删除按钮 --> <div onclick="deleteFanGroupFolder('${folder.id}'); event.stopPropagation();" style=" position: absolute; top: 0; right: 0; width: 18px; height: 18px; border-radius: 50%; background-color: rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; cursor: pointer; opacity: 0; transition: opacity 0.2s, background-color 0.2s; z-index: 5; " onmouseover="this.style.backgroundColor='rgba(200,50,50,0.9)'; this.style.opacity='1';" onmouseout="this.style.backgroundColor='rgba(0,0,0,0.4)'; this.style.opacity='0';"> <svg viewBox="0 0 24 24" style="width: 10px; height: 10px; fill: white;"> <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/> </svg> </div> </div> </div> </div> <!-- 文件夹名称 --> <div style=" text-align: center; margin-top: 2px; padding: 0 2px; "> <div style=" color: var(--x-text-primary); font-size: 11px; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">${folder.name}</div> <div style=" color: var(--x-text-secondary); font-size: 9px; margin-top: 1px; ">${fileCount}个文件</div> </div> `; card.onmouseenter = () => { card.style.transform = 'translateY(-5px)'; card.style.filter = 'brightness(1.1)'; card.style.boxShadow = '0 5px 15px rgba(0,0,0,0.2)'; }; card.onmouseleave = () => { card.style.transform = 'translateY(0)'; card.style.filter = 'brightness(1)'; card.style.boxShadow = 'none'; }; card.onclick = () => openFolder(folder); return card; } function createFileCard(file) { const card = document.createElement('div'); card.style.cssText = ` position: relative; width: 100%; cursor: pointer; transition: transform 0.2s ease, filter 0.2s ease, box-shadow 0.2s ease; margin-bottom: 6px; `; const fileIconSvg = getFileIcon(file.type); const bgColors = { text: '#2b303b', image: '#2e3440', video: '#262b36', link: '#272c36', default: '#252933', }; const bgColor = bgColors[file.type] || bgColors.default; const checkboxHtml = isBatchMode ? ` <div id="file-checkbox-${file.id}" onclick="toggleFileSelection('${file.id}'); event.stopPropagation();" style=" position: absolute; top: 6px; left: 6px; width: 16px; height: 16px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.7); background-color: transparent; display: flex; align-items: center; justify-content: center; z-index: 10; transition: all 0.2s; "></div> ` : ''; card.innerHTML = ` <div style=" position: relative; padding-bottom: 100%; width: 100%; "> <div style=" position: absolute; top: 0; left: 0; right: 0; bottom: 0; "> <!-- 文件卡片主体 --> <div style=" position: relative; width: 100%; height: 100%; border-radius: 8px; background-color: ${bgColor}; box-shadow: 0 2px 6px rgba(0,0,0,0.15); overflow: hidden; "> <!-- 背景纹理效果 --> <div style=" position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(145deg, rgba(255,255,255,0.03) 0%, rgba(255,255,255,0) 70%); "></div> <!-- 文件类型角标 --> <div style=" position: absolute; top: 0; right: 0; width: 0; height: 0; border-style: solid; border-width: 0 20px 20px 0; border-color: transparent rgba(255,255,255,0.1) transparent transparent; "></div> <!-- 文件图标 --> <div style=" position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 34%; height: 34%; display: flex; align-items: center; justify-content: center; opacity: 0.85; "> ${fileIconSvg.replace('currentColor', 'rgba(255,255,255,0.7)')} </div> ${checkboxHtml} <!-- 删除按钮 - 非批量模式下显示 --> ${ !isBatchMode ? ` <div onclick="deleteFanGroupFile('${file.id}'); event.stopPropagation();" style=" position: absolute; top: 4px; right: 4px; width: 18px; height: 18px; border-radius: 50%; background-color: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; cursor: pointer; opacity: 0; transition: opacity 0.2s, background-color 0.2s; z-index: 2; " onmouseover="this.style.backgroundColor='rgba(200,50,50,0.9)'; this.style.opacity='1';" onmouseout="this.style.backgroundColor='rgba(0,0,0,0.3)'; this.style.opacity='0';"> <svg viewBox="0 0 24 24" style="width: 10px; height: 10px; fill: white;"> <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/> </svg> </div> ` : '' } </div> </div> </div> <!-- 文件名称 --> <div style=" text-align: center; margin-top: 2px; padding: 0 2px; "> <div style=" color: var(--x-text-primary); font-size: 11px; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">${file.name}</div> <div style=" color: var(--x-text-secondary); font-size: 9px; margin-top: 1px; ">${file.uploadedBy}</div> </div> `; card.onmouseenter = () => { card.style.transform = 'translateY(-5px)'; card.style.filter = 'brightness(1.1)'; card.style.boxShadow = '0 5px 15px rgba(0,0,0,0.2)'; }; card.onmouseleave = () => { card.style.transform = 'translateY(0)'; card.style.filter = 'brightness(1)'; card.style.boxShadow = 'none'; }; card.onclick = () => { if (isBatchMode) { toggleFileSelection(file.id); } else { openFileDetail(file); } }; if (isBatchMode && selectedFiles.has(file.id)) { setTimeout(() => { toggleFileSelection(file.id); }, 10); } return card; } function getFileIcon(type) { const icons = { text: `<svg viewBox="0 0 24 24" style="fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round"> <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path> <polyline points="14 2 14 8 20 8"></polyline> <line x1="16" y1="13" x2="8" y2="13"></line> <line x1="16" y1="17" x2="8" y2="17"></line> <polyline points="10 9 9 9 8 9"></polyline> </svg>`, image: `<svg viewBox="0 0 24 24" style="fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round"> <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect> <circle cx="8.5" cy="8.5" r="1.5"></circle> <polyline points="21 15 16 10 5 21"></polyline> </svg>`, video: `<svg viewBox="0 0 24 24" style="fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round"> <rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect> <line x1="7" y1="2" x2="7" y2="22"></line> <line x1="17" y1="2" x2="17" y2="22"></line> <line x1="2" y1="12" x2="22" y2="12"></line> <line x1="2" y1="7" x2="7" y2="7"></line> <line x1="2" y1="17" x2="7" y2="17"></line> <line x1="17" y1="17" x2="22" y2="17"></line> <line x1="17" y1="7" x2="22" y2="7"></line> </svg>`, link: `<svg viewBox="0 0 24 24" style="fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path> <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg>`, default: `<svg viewBox="0 0 24 24" style="fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path> <polyline points="13 2 13 9 20 9"></polyline> </svg>`, }; return icons[type] || icons.default; } function openFolder(folder) { console.log('📂 [群文件] 打开文件夹:', folder.name); currentFanGroupFolder = folder; loadFanGroupFiles(); } window.backToFilesList = function () { console.log('📁 [群文件] 返回文件列表'); currentFanGroupFolder = null; loadFanGroupFiles(); }; function createFolderDialog() { const existingDialog = document.getElementById('create-folder-dialog'); if (existingDialog) { existingDialog.remove(); } const dialog = document.createElement('div'); dialog.id = 'create-folder-dialog'; dialog.style.cssText = ` position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.7); display: flex; align-items: center; justify-content: center; z-index: 36; backdrop-filter: blur(4px); `; dialog.innerHTML = ` <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 450px; box-shadow: 0 12px 40px rgba(0,0,0,0.4); overflow: hidden;" onclick="event.stopPropagation()"> <div style="padding: 20px 24px; border-bottom: 1px solid var(--x-border-color);"> <h3 style="margin: 0; color:var(--x-text-primary); font-size: 20px; font-weight: 700;">新建文件夹</h3> </div> <div style="padding: 24px;"> <label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;"> 文件夹名称 <span style="color: #ef4444;">*</span> </label> <input type="text" id="folder-name-input" placeholder="例如：学习资料、项目文档..." maxlength="50" style="width: 100%; padding: 12px; background-color:var(--x-bg-secondary); border: 2px solid var(--x-border-color); border-radius: 12px; color:var(--x-text-primary); font-size: 14px; outline: none; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'"> </div> <div style="padding: 16px 24px; border-top: 1px solid var(--x-border-color); display: flex; gap: 12px; justify-content: flex-end;"> <button onclick="closeCreateFolderDialog()" style="background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer;">取消</button> <button onclick="saveFanGroupFolder()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px 24px; font-size: 14px; font-weight: 700; cursor: pointer;">创建</button> </div> </div> `; dialog.onclick = () => closeCreateFolderDialog(); const xSocialScreen = document.getElementById('x-social-screen'); if (xSocialScreen) { xSocialScreen.appendChild(dialog); } else { document.body.appendChild(dialog); } return dialog; } window.openCreateFolderDialog = function () { const dialog = createFolderDialog(); const input = document.getElementById('folder-name-input'); if (input) { input.value = ''; setTimeout(() => input.focus(), 100); } }; window.closeCreateFolderDialog = function () { const dialog = document.getElementById('create-folder-dialog'); if (dialog) { dialog.remove(); } }; window.saveFanGroupFolder = async function () { const input = document.getElementById('folder-name-input'); const name = input?.value?.trim(); if (!name) { showXToast('请输入文件夹名称', 'warning'); return; } const groupId = currentMessageConversation.id; try { const xDb = getXDB(); const foldersId = `fanGroupFolders_${currentAccountId || 'main'}_${groupId}`; const savedData = await xDb.xAccountProfiles.get(foldersId); const folders = savedData?.data || []; const newFolder = { id: `folder_${Date.now()}`, name: name, createdAt: new Date().toISOString(), }; folders.push(newFolder); await xDb.xAccountProfiles.put({ handle: foldersId, name: 'fanGroupFolders', data: folders, updatedAt: new Date().toISOString(), }); console.log('✅ [群文件] 文件夹已创建:', name); closeCreateFolderDialog(); await loadFanGroupFiles(); showXToast('文件夹创建成功', 'success'); } catch (error) { console.error('❌ [群文件] 创建失败:', error); showXToast('创建失败', 'error'); } }; async function createUploadFileDialog() { const existingDialog = document.getElementById('upload-file-dialog'); if (existingDialog) { existingDialog.remove(); } const dialog = document.createElement('div'); dialog.id = 'upload-file-dialog'; dialog.style.cssText = ` position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.7); display: flex; align-items: center; justify-content: center; z-index: 36; backdrop-filter: blur(4px); `; dialog.innerHTML = ` <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 550px; max-height: 85vh; overflow-y: auto; box-shadow: 0 12px 40px rgba(0,0,0,0.4);" onclick="event.stopPropagation()"> <div style="padding: 20px 24px; border-bottom: 1px solid var(--x-border-color);"> <h3 style="margin: 0; color:var(--x-text-primary); font-size: 20px; font-weight: 700;">上传文件</h3> </div> <div style="padding: 24px;"> <div style="margin-bottom: 20px;"> <label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;"> 文件名称 <span style="color: #ef4444;">*</span> </label> <input type="text" id="file-name-input" placeholder="例如：项目文档.pdf、教程视频.mp4..." maxlength="100" style="width: 100%; padding: 12px; background-color:var(--x-bg-secondary); border: 2px solid var(--x-border-color); border-radius: 12px; color:var(--x-text-primary); font-size: 14px; outline: none; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'"> <div style="font-size: 12px; color:var(--x-text-secondary); margin-top: 4px;">提示：文件名需包含后缀（如 .pdf、.mp4、.jpg等）</div> </div> <div style="margin-bottom: 20px;"> <label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;"> 文件类型 <span style="color: #ef4444;">*</span> </label> <select id="file-type-select" style="width: 100%; padding: 12px; background-color:var(--x-bg-secondary); border: 2px solid var(--x-border-color); border-radius: 12px; color:var(--x-text-primary); font-size: 14px; outline: none; cursor: pointer;" onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'"> <option value="text">文字/文档</option> <option value="image">图片</option> <option value="video">视频</option> <option value="link">链接</option> </select> </div> <div style="margin-bottom: 20px;"> <label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;"> 文件内容/链接 <span style="color: #ef4444;">*</span> </label> <textarea id="file-content-input" placeholder="输入文件内容、描述或链接地址..." maxlength="5000" style="width: 100%; min-height: 150px; padding: 12px; background-color:var(--x-bg-secondary); border: 2px solid var(--x-border-color); border-radius: 12px; color:var(--x-text-primary); font-size: 14px; outline: none; resize: vertical; font-family: inherit; line-height: 1.6; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'" oninput="updateFileContentCounter()"></textarea> <div style="text-align: right; margin-top: 6px;"> <span id="file-content-counter" style="font-size: 12px; color:var(--x-text-secondary);">0 / 5000</span> </div> </div> <div id="file-folder-select-container" style="margin-bottom: 20px; display: none;"> <label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;"> 选择文件夹（可选） </label> <select id="file-folder-select" style="width: 100%; padding: 12px; background-color:var(--x-bg-secondary); border: 2px solid var(--x-border-color); border-radius: 12px; color:var(--x-text-primary); font-size: 14px; outline: none; cursor: pointer;"> <option value="">不放入文件夹（散落显示）</option> </select> </div> </div> <div style="padding: 16px 24px; border-top: 1px solid var(--x-border-color); display: flex; gap: 12px; justify-content: flex-end;"> <button onclick="closeUploadFileDialog()" style="background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer;">取消</button> <button onclick="saveFanGroupFile()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px 24px; font-size: 14px; font-weight: 700; cursor: pointer;">上传</button> </div> </div> `; dialog.onclick = () => closeUploadFileDialog(); const xSocialScreen = document.getElementById('x-social-screen'); if (xSocialScreen) { xSocialScreen.appendChild(dialog); } else { document.body.appendChild(dialog); } return dialog; } window.openUploadFileDialog = async function () { const dialog = await createUploadFileDialog(); const nameInput = document.getElementById('file-name-input'); const typeSelect = document.getElementById('file-type-select'); const contentInput = document.getElementById('file-content-input'); const folderSelectContainer = document.getElementById('file-folder-select-container'); const folderSelect = document.getElementById('file-folder-select'); if (nameInput) nameInput.value = ''; if (typeSelect) typeSelect.value = 'text'; if (contentInput) contentInput.value = ''; const groupId = currentMessageConversation.id; const xDb = getXDB(); const foldersId = `fanGroupFolders_${currentAccountId || 'main'}_${groupId}`; const foldersData = await xDb.xAccountProfiles.get(foldersId); const folders = foldersData?.data || []; if (folderSelect) { folderSelect.innerHTML = '<option value="">不放入文件夹（散落显示）</option>'; folders.forEach(folder => { const option = document.createElement('option'); option.value = folder.id; option.textContent = folder.name; if (currentFanGroupFolder && currentFanGroupFolder.id === folder.id) { option.selected = true; } folderSelect.appendChild(option); }); } if (folderSelectContainer && folders.length > 0) { folderSelectContainer.style.display = 'block'; } setTimeout(() => nameInput?.focus(), 100); }; window.closeUploadFileDialog = function () { const dialog = document.getElementById('upload-file-dialog'); if (dialog) { dialog.remove(); } }; window.updateFileContentCounter = function () { const input = document.getElementById('file-content-input'); const counter = document.getElementById('file-content-counter'); if (input && counter) { counter.textContent = `${input.value.length} / 5000`; } }; window.saveFanGroupFile = async function () { const nameInput = document.getElementById('file-name-input'); const typeSelect = document.getElementById('file-type-select'); const contentInput = document.getElementById('file-content-input'); const folderSelect = document.getElementById('file-folder-select'); const name = nameInput?.value?.trim(); const type = typeSelect?.value; const content = contentInput?.value?.trim(); const folderId = folderSelect?.value || null; if (!name) { showXToast('请输入文件名称', 'warning'); return; } if (!content) { showXToast('请输入文件内容', 'warning'); return; } const groupId = currentMessageConversation.id; const uploadedBy = window.userProfileData?.name || '用户'; try { const xDb = getXDB(); const filesId = `fanGroupFiles_${currentAccountId || 'main'}_${groupId}`; const savedData = await xDb.xAccountProfiles.get(filesId); const files = savedData?.data || []; const newFile = { id: `file_${Date.now()}`, name: name, type: type, content: content, folderId: folderId, uploadedBy: uploadedBy, uploadedAt: new Date().toISOString(), }; files.push(newFile); await xDb.xAccountProfiles.put({ handle: filesId, name: 'fanGroupFiles', data: files, updatedAt: new Date().toISOString(), }); console.log('✅ [群文件] 文件已上传:', name); await addFileMessageToConversation(groupId, newFile); closeUploadFileDialog(); await loadFanGroupFiles(); showXToast('文件上传成功', 'success'); } catch (error) { console.error('❌ [群文件] 上传失败:', error); showXToast('上传失败', 'error'); } }; async function addFileMessageToConversation(groupId, file) { try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${groupId}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data && savedConversation.data.messages) { const fileMessage = { type: 'groupFile', file: { id: file.id, name: file.name, type: file.type, content: file.content, uploadedBy: file.uploadedBy, uploadedAt: file.uploadedAt, folderId: file.folderId || null, }, timestamp: new Date().toISOString(), time: '刚刚', isOwn: true, }; savedConversation.data.messages.push(fileMessage); await xDb.xAccountProfiles.put(savedConversation); console.log('[群文件] 文件消息已添加到对话'); try { const dataId = `messagesList_${currentAccountId || 'main'}`; const messagesData = await xDb.xAccountProfiles.get(dataId); if (messagesData && messagesData.data) { const messagesList = messagesData.data; const fanGroupIndex = messagesList.findIndex(msg => msg.id === groupId); if (fanGroupIndex !== -1) { const files = await getFanGroupFiles(groupId); messagesList[fanGroupIndex].files = files; await xDb.xAccountProfiles.put({ ...messagesData, data: messagesList, }); console.log('[群文件] 已更新粉丝群文件数据，文件总数:', files.length); } } } catch (err) { console.error('[群文件] 更新粉丝群文件列表失败:', err); } if (currentMessageConversation && currentMessageConversation.id === groupId) { const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { const msgEl = renderMessageItem(fileMessage, false, savedConversation.data.messages.length - 1, true); contentContainer.appendChild(msgEl); const scrollableContainer = document.getElementById('message-detail-scrollable'); if (scrollableContainer) { scrollableContainer.scrollTop = scrollableContainer.scrollHeight; } } } } } catch (error) { console.error('[群文件] 添加文件消息失败:', error); } } function createFileDetailModal() { const existingModal = document.getElementById('file-detail-modal'); if (existingModal) { existingModal.remove(); } const modal = document.createElement('div'); modal.id = 'file-detail-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.7); display: flex; align-items: center; justify-content: center; z-index: 37; backdrop-filter: blur(4px); `; modal.innerHTML = ` <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 600px; max-height: 85vh; overflow-y: auto; box-shadow: 0 12px 40px rgba(0,0,0,0.4);" onclick="event.stopPropagation()"> <div style="padding: 20px 24px; border-bottom: 1px solid var(--x-border-color); display: flex; align-items: center; justify-content: space-between;"> <h3 style="margin: 0; color:var(--x-text-primary); font-size: 20px; font-weight: 700;" id="file-detail-title">文件详情</h3> <button onclick="closeFileDetailModal()" style="background: transparent; border: none; color:var(--x-text-secondary); cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </button> </div> <div id="file-detail-content" style="padding: 24px;"> </div> </div> `; modal.onclick = () => closeFileDetailModal(); const xSocialScreen = document.getElementById('x-social-screen'); if (xSocialScreen) { xSocialScreen.appendChild(modal); } else { document.body.appendChild(modal); } return modal; } function openFileDetail(file) { console.log('[群文件] 打开文件详情:', file.name); const modal = createFileDetailModal(); const title = document.getElementById('file-detail-title'); const content = document.getElementById('file-detail-content'); if (!title || !content) return; title.textContent = file.name; const fileIconSvg = getFileIcon(file.type); const typeColors = { text: '#3b4252', image: '#2e3440', video: '#434c5e', link: '#4c566a', default: '#3b4252', }; const typeColor = typeColors[file.type] || typeColors.default; const uploadDate = new Date(file.uploadedAt); const formattedDate = `${uploadDate.getFullYear()}.${String(uploadDate.getMonth() + 1).padStart(2, '0')}.${String( uploadDate.getDate(), ).padStart(2, '0')} ${String(uploadDate.getHours()).padStart(2, '0')}:${String(uploadDate.getMinutes()).padStart( 2, '0', )}`; content.innerHTML = ` <div style="display: flex; flex-direction: column; gap: 14px;"> <!-- 文件信息头部 --> <div style="display: flex; align-items: flex-start; gap: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--x-border-color);"> <!-- 文件图标 --> <div style=" width: 46px; height: 46px; border-radius: 6px; background-color: ${typeColor}; display: flex; align-items: center; justify-content: center; flex-shrink: 0; box-shadow: 0 3px 6px rgba(0,0,0,0.12); "> <div style="width: 22px; height: 22px; color: #fff;"> ${fileIconSvg.replace('currentColor', '#fff')} </div> </div> <!-- 文件信息 --> <div style="flex: 1; min-width: 0;"> <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 3px; line-height: 1.3;"> ${file.name} </div> <div style="color:var(--x-text-secondary); font-size: 12px; margin-bottom: 4px;"> 上传者：${file.uploadedBy} </div> <div style="color:var(--x-text-secondary); font-size: 11px; display: flex; align-items: center; gap: 3px;"> <svg viewBox="0 0 24 24" style="width: 11px; height: 11px; fill: var(--x-text-secondary);"> <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path> </svg> <span>${formattedDate}</span> </div> </div> </div> <!-- 文件内容 --> <div> <div style=" display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; "> <div style="color:var(--x-text-primary); font-size: 13px; font-weight: 600;">文件内容</div> <div style=" color: var(--x-text-secondary); font-size: 11px; padding: 1px 6px; border: 1px solid var(--x-border-color); border-radius: 10px; "> ${ file.type === 'text' ? '文本文档' : file.type === 'image' ? '图片文件' : file.type === 'video' ? '视频文件' : file.type === 'link' ? '链接' : '文件' } </div> </div> <div style=" padding: 12px; background-color:var(--x-bg-secondary); border-radius: 6px; color:var(--x-text-primary); font-size: 13px; line-height: 1.5; max-height: 250px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word; border: 1px solid var(--x-border-color); ">${file.content}</div> </div> <!-- 操作按钮 --> <div style="display: flex; justify-content: flex-end; gap: 8px; margin-top: 2px;"> <button onclick="deleteFanGroupFile('${file.id}'); closeFileDetailModal();" style=" padding: 6px 12px; border-radius: 12px; border: none; background-color: rgba(0,0,0,0.12); color: #ff5252; font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='rgba(0,0,0,0.2)'" onmouseout="this.style.backgroundColor='rgba(0,0,0,0.12)'"> 删除文件 </button> </div> </div> `; } window.closeFileDetailModal = function () { const modal = document.getElementById('file-detail-modal'); if (modal) { modal.remove(); } }; window.deleteFanGroupFolder = async function (folderId) { if (!confirm('确定要删除这个文件夹吗？文件夹内的文件将会散落显示。')) { return; } const groupId = currentMessageConversation.id; try { const xDb = getXDB(); const foldersId = `fanGroupFolders_${currentAccountId || 'main'}_${groupId}`; const filesId = `fanGroupFiles_${currentAccountId || 'main'}_${groupId}`; const foldersData = await xDb.xAccountProfiles.get(foldersId); let folders = foldersData?.data || []; folders = folders.filter(f => f.id !== folderId); await xDb.xAccountProfiles.put({ handle: foldersId, name: 'fanGroupFolders', data: folders, updatedAt: new Date().toISOString(), }); const filesData = await xDb.xAccountProfiles.get(filesId); let files = filesData?.data || []; files.forEach(file => { if (file.folderId === folderId) { file.folderId = null; } }); await xDb.xAccountProfiles.put({ handle: filesId, name: 'fanGroupFiles', data: files, updatedAt: new Date().toISOString(), }); console.log('✅ [群文件] 文件夹已删除'); await loadFanGroupFiles(); showXToast('文件夹已删除', 'success'); } catch (error) { console.error('❌ [群文件] 删除失败:', error); showXToast('删除失败', 'error'); } }; window.deleteFanGroupFile = async function (fileId) { if (!confirm('确定要删除这个文件吗？')) { return; } const groupId = currentMessageConversation.id; try { const xDb = getXDB(); const filesId = `fanGroupFiles_${currentAccountId || 'main'}_${groupId}`; const savedData = await xDb.xAccountProfiles.get(filesId); let files = savedData?.data || []; files = files.filter(f => f.id !== fileId); await xDb.xAccountProfiles.put({ handle: filesId, name: 'fanGroupFiles', data: files, updatedAt: new Date().toISOString(), }); console.log('✅ [群文件] 文件已删除'); await loadFanGroupFiles(); showXToast('文件已删除', 'success'); } catch (error) { console.error('❌ [群文件] 删除失败:', error); showXToast('删除失败', 'error'); } }; async function getFanGroupFiles(groupId) { try { const xDb = getXDB(); const filesId = `fanGroupFiles_${currentAccountId || 'main'}_${groupId}`; const foldersId = `fanGroupFolders_${currentAccountId || 'main'}_${groupId}`; const filesData = await xDb.xAccountProfiles.get(filesId); const files = filesData?.data || []; const foldersData = await xDb.xAccountProfiles.get(foldersId); const folders = foldersData?.data || []; const filesWithFolderNames = files.map(file => { if (file.folderId) { const folder = folders.find(f => f.id === file.folderId); if (folder) { return { ...file, folderName: folder.name, }; } } return { ...file, folderName: '未分类', }; }); return filesWithFolderNames; } catch (error) { console.error('[群文件] 获取文件列表失败:', error); return []; } } let isBatchMode = false; let selectedFiles = new Set(); window.toggleBatchMode = function () { isBatchMode = !isBatchMode; selectedFiles.clear(); const batchBtn = document.getElementById('fangroup-files-batch-btn'); const cancelBatchBtn = document.getElementById('fangroup-files-cancel-batch-btn'); const deleteBatchBtn = document.getElementById('fangroup-files-delete-batch-btn'); const createFolderBtn = document.getElementById('fangroup-files-create-folder-btn'); const uploadBtn = document.getElementById('fangroup-files-upload-btn'); if (isBatchMode) { if (batchBtn) batchBtn.style.display = 'none'; if (cancelBatchBtn) { cancelBatchBtn.style.display = 'flex'; cancelBatchBtn.style.backgroundColor = 'var(--x-bg-secondary)'; cancelBatchBtn.style.color = 'var(--x-text-primary)'; } if (deleteBatchBtn) { deleteBatchBtn.style.display = 'flex'; deleteBatchBtn.textContent = '删除选中 (0)'; deleteBatchBtn.style.backgroundColor = 'rgba(0,0,0,0.12)'; deleteBatchBtn.style.color = '#ff5252'; } if (createFolderBtn) createFolderBtn.style.display = 'none'; if (uploadBtn) uploadBtn.style.display = 'none'; } else { if (batchBtn) batchBtn.style.display = 'flex'; if (cancelBatchBtn) cancelBatchBtn.style.display = 'none'; if (deleteBatchBtn) deleteBatchBtn.style.display = 'none'; if (createFolderBtn) createFolderBtn.style.display = 'flex'; if (uploadBtn) uploadBtn.style.display = 'flex'; } loadFanGroupFiles(); }; function toggleFileSelection(fileId) { if (selectedFiles.has(fileId)) { selectedFiles.delete(fileId); } else { selectedFiles.add(fileId); } const deleteBatchBtn = document.getElementById('fangroup-files-delete-batch-btn'); if (deleteBatchBtn) { deleteBatchBtn.textContent = `删除选中 (${selectedFiles.size})`; } const checkbox = document.getElementById(`file-checkbox-${fileId}`); if (checkbox) { if (selectedFiles.has(fileId)) { checkbox.style.backgroundColor = 'rgba(255,255,255,0.9)'; checkbox.style.borderColor = 'rgba(255,255,255,0.9)'; checkbox.innerHTML = ` <svg viewBox="0 0 24 24" style="width: 10px; height: 10px; fill: #333;"> <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path> </svg> `; } else { checkbox.style.backgroundColor = 'transparent'; checkbox.style.borderColor = 'rgba(255,255,255,0.7)'; checkbox.innerHTML = ''; } } } window.batchDeleteFiles = async function () { if (selectedFiles.size === 0) { showXToast('请选择要删除的文件', 'warning'); return; } if (!confirm(`确定要删除选中的 ${selectedFiles.size} 个文件吗？`)) { return; } const groupId = currentMessageConversation.id; try { const xDb = getXDB(); const filesId = `fanGroupFiles_${currentAccountId || 'main'}_${groupId}`; const savedData = await xDb.xAccountProfiles.get(filesId); let files = savedData?.data || []; files = files.filter(f => !selectedFiles.has(f.id)); await xDb.xAccountProfiles.put({ handle: filesId, name: 'fanGroupFiles', data: files, updatedAt: new Date().toISOString(), }); console.log(`✅ [群文件] 已批量删除 ${selectedFiles.size} 个文件`); showXToast(`已删除 ${selectedFiles.size} 个文件`, 'success'); selectedFiles.clear(); await loadFanGroupFiles(); } catch (error) { console.error('❌ [群文件] 批量删除失败:', error); showXToast('批量删除失败', 'error'); } }; window.createFanGroup = createFanGroup; window.openFanGroupSettings = openFanGroupSettings; window.closeFanGroupSettings = closeFanGroupSettings; window.updateFanGroupAvatarPreview = updateFanGroupAvatarPreview; window.saveFanGroupAvatar = saveFanGroupAvatar; window.saveFanGroupSettings = saveFanGroupSettings; window.toggleFanGroupAutoMessage = toggleFanGroupAutoMessage; window.updateFanGroupInterval = updateFanGroupInterval; window.handleMessageDetailAvatarClick = handleMessageDetailAvatarClick; window.openFanGroupShareModal = openFanGroupShareModal; window.closeFanGroupShareModal = closeFanGroupShareModal; window.shareFanGroupToContact = shareFanGroupToContact; window.shareFanGroupToPost = shareFanGroupToPost; window.openFanGroupApplicationsModal = openFanGroupApplicationsModal; window.generateFanGroupConversation = generateFanGroupConversation; window.checkAndTriggerFanGroupAutoChat = checkAndTriggerFanGroupAutoChat; async function triggerFanGroupApplicationGenerator(tweetData) { console.log('🎯 [粉丝群申请生成器] 开始生成申请', { tweetId: tweetData.id, fanGroupId: tweetData.quotedFanGroup.id, fanGroupName: tweetData.quotedFanGroup.name, }); try { const { apiConfig, xSettings, xDb } = await APIUtils.loadConfigAndSettings(); const { userPrompt, worldSetting, boundCharacters } = xSettings; const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); const messagesList = savedData?.data || []; const fanGroup = messagesList.find(msg => msg.id === tweetData.quotedFanGroup.id); if (!fanGroup) { showXToast('未找到粉丝群数据', 'error'); return; } const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData); const userTweetsId = `userTweets_${currentAccountId || 'main'}`; const userTweetsData = await xDb.xUserTweets.get(userTweetsId); const recentUserTweets = userTweetsData?.tweets?.slice(0, 3) || []; console.log('📋 [粉丝群申请生成器] 用户完整资料:', userXProfileInfo); console.log('📋 [粉丝群申请生成器] 最近推文数量:', recentUserTweets.length); let tokenCount = 0; let systemPrompt = StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting, }); tokenCount = TokenUtils.logTokenUsage('粉丝群申请生成器', '基础系统提示词', systemPrompt, tokenCount); const worldBooksContent = await StringBuilders.getApplicableWorldBooks('fanGroupApplication', { boundCharacters, }); if (worldBooksContent) { systemPrompt += worldBooksContent; tokenCount = TokenUtils.logTokenUsage('粉丝群申请生成器', '世界书内容', worldBooksContent, tokenCount); } const hasMoneyThreshold = fanGroup.groupThreshold && /钱|价|元|￥|\$|费|付/.test(fanGroup.groupThreshold); systemPrompt += ` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 🎯 核心任务：粉丝群入群申请生成器 🎯 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 你是X社交平台的粉丝群申请生成器。用户 ${userXProfileInfo.name} (${ userXProfileInfo.handle }) 发布了一条推文，转发了自己的粉丝群链接： **推文内容**： "${tweetData.content}" **粉丝群信息**： - 群名：${fanGroup.userName || fanGroup.groupName} - 当前成员数：${fanGroup.memberCount || 0} - 入群门槛：${fanGroup.groupThreshold || '无'} **用户X平台完整资料**： - 用户名：${userXProfileInfo.name} - 用户句柄：${userXProfileInfo.handle} - 认证状态：${userXProfileInfo.verified ? '已认证' : '未认证'} ${ userXProfileInfo.verificationType && userXProfileInfo.verificationType !== 'none' ? `- 认证类型：${ userXProfileInfo.verificationType === 'verified' ? '蓝色勾标认证' : userXProfileInfo.verificationType === 'couple' ? '情侣认证' : userXProfileInfo.verificationType === 'married' ? '已婚认证' : userXProfileInfo.verificationType === 'vip' ? 'VIP认证' : '无' }` : '' } ${userXProfileInfo.publicIdentity ? `- 公众身份：${userXProfileInfo.publicIdentity}` : ''} ${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ''} ${ userXProfileInfo.verificationType === 'couple' && userXProfileInfo.coupleCharacterName ? `- 情侣关系：与${userXProfileInfo.coupleCharacterName}为公开情侣` : '' } - 影响力等级：${userXProfileInfo.publicIdentity ? '公众人物/有影响力' : '普通用户'} ${ recentUserTweets.length > 0 ? `**用户最近推文**（了解用户风格和影响力）： ${recentUserTweets .map( (tweet, i) => `${i + 1}. "${tweet.content}" - 发布时间：${tweet.time || '最近'} - 互动数据：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发，${tweet.stats?.comments || 0}评论，${ tweet.stats?.views || 0 }浏览`, ) .join('\n')}` : '**用户最近推文**：暂无推文（新用户或较少发帖）' } 你的任务是生成 3-8 个入群申请。 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📋 申请生成规则 📋 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ **申请者类型分布**（必须多样化）： 1. 真诚粉丝（60-70%）： - 真心喜欢用户，想加入粉丝群 - 申请理由真诚、具体 - 如果有门槛要求，会认真满足 2. 普通路人（20-30%）： - 看到推文好奇想加入 - 申请理由较简单 - 可能不完全符合门槛要求 3. 恶意/骚扰者（10-20%）： - 故意发送不当内容 - 申请理由奇怪、无礼、或包含骚扰内容 - 明显不符合门槛要求 - 可能是为了恶作剧或骚扰 **真实感要求**： - 申请理由要多样化，不要千篇一律 - 恶意申请要自然，不要太过明显 - 申请者姓名要真实感，不要太夸张 ${ hasMoneyThreshold ? ` **金钱门槛特殊处理**： ⚠️ 检测到入群门槛与金钱相关："${fanGroup.groupThreshold}" - 70-80% 的申请者会附带金额 - 金额范围：根据门槛要求决定（建议 $10-$100） - 申请理由中要提到支付意愿 - 恶意申请者可能故意出价过低或过高来捣乱 - 真诚粉丝会出合理的价格 ` : '' } ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 📝 JSON返回格式 📝 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ \`\`\`json { "applications": [ { "applicantName": "申请者姓名", "applicantHandle": "@handle", "applicantAvatar": "https: "reason": "申请理由（要具体、真实）", "type": "sincere/normal/malicious", "amount": 50.00 } ] } \`\`\` **字段说明**： - applicantName: 申请者X姓名（真实感） - applicantHandle: 申请者X句柄（格式：@username） - applicantAvatar: 统一使用默认头像 - reason: 申请理由（20-80字，要真实、多样化） - type: 申请类型（sincere真诚/normal普通/malicious恶意） - amount: 附带金额（仅在有金钱门槛时需要，数字类型，保留两位小数）${!hasMoneyThreshold ? '，无金钱门槛时设为0' : ''} **重要规则**： 1. 生成3-8个申请（根据用户影响力决定） 2. 申请理由要多样化，不要重复 3. 恶意申请要自然，不要太明显 4. type字段必须准确反映申请意图 5. 如果有金钱门槛，70-80%申请要带金额 6. 金额合理性：真诚粉丝出价合理，恶意者可能出价异常`; const taskSection = systemPrompt.substring(systemPrompt.lastIndexOf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━')); tokenCount = TokenUtils.logTokenUsage('粉丝群申请生成器', '核心任务说明', taskSection, tokenCount); const userConstraintsStart = systemPrompt.length; systemPrompt += StringBuilders.buildUniversalConstraints(userXProfileInfo); const userConstraints = systemPrompt.substring(userConstraintsStart); tokenCount = TokenUtils.logTokenUsage('粉丝群申请生成器', '用户资料约束', userConstraints, tokenCount); const messages = [{ role: 'user', content: '请生成粉丝群入群申请' }]; TokenUtils.logFinalPrompt('粉丝群申请生成器', systemPrompt, messages[0].content); const aiResponseContent = await APIUtils.sendAIRequest({ apiConfig, systemPrompt, messages, temperature: 0.8, }); console.log('🎯 [粉丝群申请生成器] AI响应:', aiResponseContent); let applicationData = APIUtils.parseJSONResponse(aiResponseContent); if (!applicationData.applications || !Array.isArray(applicationData.applications)) { throw new Error('AI返回的数据格式不正确'); } const timestamp = Date.now(); applicationData.applications.forEach((app, index) => { app.id = `fangroup_app_${timestamp}_${index}`; app.timestamp = new Date().toISOString(); app.status = 'pending'; }); await saveFanGroupApplications(fanGroup.id, applicationData.applications); console.log(`✅ [粉丝群申请生成器] 成功生成${applicationData.applications.length}个申请`); setTimeout(() => { showPhoneNotification({ title: `${fanGroup.userName || fanGroup.groupName}`, message: `有 ${applicationData.applications.length} 人申请加入粉丝群`, avatar: fanGroup.userAvatar || 'https: leftIcon: 'custom', leftIconHtml: ` <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);"> <g><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></g> </svg> `, duration: 5000, onClick: () => { openFanGroupApplicationsModal(fanGroup.id); }, }); }, 1000); } catch (error) { console.error('❌ [粉丝群申请生成器] 生成失败:', error); showXToast('生成申请失败: ' + error.message, 'error'); } } async function saveFanGroupApplications(groupId, applications) { try { const xDb = getXDB(); const dataId = `fanGroupApplications_${currentAccountId || 'main'}_${groupId}`; await xDb.xAccountProfiles.put({ handle: dataId, name: 'fanGroupApplications', data: applications, updatedAt: new Date().toISOString(), }); console.log('✅ [粉丝群申请] 申请数据已保存到数据库'); } catch (error) { console.error('❌ [粉丝群申请] 保存申请失败:', error); throw error; } } async function loadFanGroupApplications(groupId) { try { const xDb = getXDB(); const dataId = `fanGroupApplications_${currentAccountId || 'main'}_${groupId}`; const savedData = await xDb.xAccountProfiles.get(dataId); return savedData?.data || []; } catch (error) { console.error('❌ [粉丝群申请] 读取申请失败:', error); return []; } } async function openFanGroupApplicationsModal(groupId) { console.log('📋 [粉丝群申请] 打开申请弹窗', groupId); try { const applications = await loadFanGroupApplications(groupId); const pendingApplications = applications.filter(app => app.status === 'pending'); if (pendingApplications.length === 0) { showXToast('暂无待处理的申请', 'info'); return; } const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); const messagesList = savedData?.data || []; const fanGroup = messagesList.find(msg => msg.id === groupId); if (!fanGroup) { showXToast('未找到粉丝群数据', 'error'); return; } const xSocialScreen = document.getElementById('x-social-screen'); const isLightMode = xSocialScreen && xSocialScreen.classList.contains('x-theme-light'); const modal = document.createElement('div'); modal.id = 'fangroup-applications-modal'; modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: ${ isLightMode ? 'rgba(255, 255, 255, 0.85)' : 'rgba(0, 0, 0, 0.85)' }; display: flex; align-items: center; justify-content: center; z-index: 26; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); `; modal.innerHTML = ` <div style="background-color: ${ isLightMode ? 'rgba(255, 255, 255, 0.95)' : 'rgba(0, 0, 0, 0.95)' }; backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 24px; width: 90%; max-width: 500px; max-height: 80vh; position: relative; overflow: hidden; box-shadow: ${ isLightMode ? '0 20px 60px rgba(0, 0, 0, 0.15)' : '0 20px 60px rgba(0, 0, 0, 0.8)' }; border: 2px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)' }; " onclick="event.stopPropagation()"> <div style="background: linear-gradient(135deg, ${ isLightMode ? 'rgba(0, 0, 0, 0.03)' : 'rgba(255, 255, 255, 0.05)' } 0%, ${ isLightMode ? 'rgba(0, 0, 0, 0.01)' : 'rgba(255, 255, 255, 0.02)' } 100%); padding: 24px; text-align: center; border-bottom: 1px dashed ${ isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.15)' }; position: relative; "> <div style="position: absolute; left: -10px; bottom: -10px; width: 20px; height: 20px; border-radius: 50%; background-color: ${ isLightMode ? 'rgba(255, 255, 255, 0.85)' : 'rgba(0, 0, 0, 0.85)' }; "></div> <div style="position: absolute; right: -10px; bottom: -10px; width: 20px; height: 20px; border-radius: 50%; background-color: ${ isLightMode ? 'rgba(255, 255, 255, 0.85)' : 'rgba(0, 0, 0, 0.85)' }; "></div> <button onclick="closeFanGroupApplicationsModal()" style="position: absolute; top: 16px; right: 16px; background: transparent; border: none; color:var(--x-text-secondary); cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </button> <div style="color:var(--x-text-primary); font-size: 20px; font-weight: 700; margin-bottom: 8px; ">入群申请</div> <div style="color:var(--x-text-secondary); font-size: 13px; margin-bottom: 12px; ">${ fanGroup.userName || fanGroup.groupName }</div> <div style="color: var(--x-accent); font-size: 12px; font-weight: 700; letter-spacing: 1px; ">${ pendingApplications.length } 人待审核</div> </div> <div id="applications-list-container" style="max-height: 50vh; overflow-y: auto; padding: 16px 24px; "> ${pendingApplications.map((app, index) => renderApplicationCard(app, index, groupId, isLightMode)).join('')} </div> </div> `; document.body.appendChild(modal); document.body.style.overflow = 'hidden'; modal.onclick = e => { if (e.target === modal) { closeFanGroupApplicationsModal(); } }; const card = modal.querySelector('div'); card.style.transform = 'scale(0.8) translateY(20px)'; card.style.opacity = '0'; requestAnimationFrame(() => { card.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)'; card.style.transform = 'scale(1) translateY(0)'; card.style.opacity = '1'; }); } catch (error) { console.error('❌ [粉丝群申请] 打开弹窗失败:', error); showXToast('打开申请列表失败', 'error'); } } function renderApplicationCard(app, index, groupId, isLightMode = false) { const typeColor = { sincere: '#22c55e', normal: '#3b82f6', malicious: '#ef4444', }[app.type] || '#71767b'; const typeText = { sincere: '真诚粉丝', normal: '普通申请', malicious: '可疑申请', }[app.type] || '未知'; return ` <div id="app-card-${app.id}" style="margin-bottom: 14px; background-color: ${ isLightMode ? 'rgba(0, 0, 0, 0.03)' : 'rgba(255, 255, 255, 0.04)' }; border: 1px solid ${ isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)' }; border-radius: 12px; padding: 14px; position: relative; overflow: hidden; transition: all 0.2s; "> <div style="position: absolute; bottom: 8px; right: 8px; font-size: 28px; color: ${ isLightMode ? 'rgba(0, 0, 0, 0.03)' : 'rgba(255, 255, 255, 0.03)' }; font-weight: 700; pointer-events: none; transform: rotate(-15deg); ">#${index + 1}</div> <div style="display: flex; align-items: flex-start; gap: 12px; margin-bottom: 12px;"> <img src="${app.applicantAvatar}" style="width: 38px; height: 38px; border-radius: 50%; object-fit: cover; "> <div style="flex: 1; min-width: 0;"> <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 3px; flex-wrap: wrap;"> <span style="color: ${isLightMode ? '#0f1419' : '#e7e9ea'}; font-size: 14px; font-weight: 700; ">${ app.applicantName }</span> <span style="padding: 2px 7px; background-color: ${typeColor}${ isLightMode ? '20' : '18' }; color: ${typeColor}; font-size: 10px; font-weight: 700; border-radius: 4px; border: 1px solid ${typeColor}${ isLightMode ? '50' : '35' }; ">${typeText}</span> </div> <div style="color: ${isLightMode ? '#536471' : '#8b98a5'}; font-size: 12px; ">${app.applicantHandle}</div> </div> ${ app.amount > 0 ? `<div style="padding: 5px 11px; background-color: #22c55e${ isLightMode ? '20' : '18' }; color: #22c55e; font-size: 13px; font-weight: 700; border-radius: 7px; border: 1px solid #22c55e${ isLightMode ? '50' : '35' }; white-space: nowrap; ">$${app.amount.toFixed(2)}</div>` : '' } </div> <div style="color: ${ isLightMode ? '#0f1419' : '#e7e9ea' }; font-size: 13px; line-height: 1.5; margin-bottom: 12px; padding: 11px; background-color: ${ isLightMode ? 'rgba(0, 0, 0, 0.04)' : 'rgba(255, 255, 255, 0.05)' }; border-radius: 8px; border-left: 3px solid ${typeColor}; ">${app.reason}</div> <div style="display: flex; gap: 7px;"> <button onclick="approveFanGroupApplication('${groupId}', '${app.id}')" style="flex: 1; background-color: ${ isLightMode ? '#1d9bf0' : 'var(--x-accent)' }; color: #ffffff; border: none; border-radius: 8px; padding: 9px; font-size: 13px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'"> ✓ 通过 </button> <button onclick="rejectFanGroupApplication('${groupId}', '${ app.id }')" style="flex: 1; background-color: transparent; color: #ef4444; border: 1px solid #ef4444; border-radius: 8px; padding: 9px; font-size: 13px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='${ isLightMode ? '#ef444415' : '#ef444412' }'" onmouseout="this.style.backgroundColor='transparent'"> ✗ 拒绝 </button> </div> </div> `; } window.closeFanGroupApplicationsModal = function () { const modal = document.getElementById('fangroup-applications-modal'); if (modal) { const card = modal.querySelector('div'); card.style.transform = 'scale(0.9) translateY(20px)'; card.style.opacity = '0'; setTimeout(() => { modal.remove(); document.body.style.overflow = 'auto'; }, 200); } }; window.approveFanGroupApplication = async function (groupId, appId) { console.log('✅ [粉丝群申请] 通过申请', groupId, appId); try { const xDb = getXDB(); const applications = await loadFanGroupApplications(groupId); const app = applications.find(a => a.id === appId); if (!app) { showXToast('未找到申请数据', 'error'); return; } app.status = 'approved'; app.approvedAt = new Date().toISOString(); await saveFanGroupApplications(groupId, applications); if (app.amount && app.amount > 0) { await loadWalletData(); if (!walletData.isActivated) { showXToast('请先激活钱包', 'error'); return; } walletData.balance += app.amount; const transaction = { id: 'fangroup_' + Date.now(), description: `${app.applicantName} 的入群费用`, amount: app.amount, timestamp: new Date().toISOString(), type: 'fan_group_fee', applicant: { name: app.applicantName, handle: app.applicantHandle, }, }; walletData.transactions.unshift(transaction); await saveWalletData(); console.log(`💰 [粉丝群申请] 入群费用已入账: +$${app.amount.toFixed(2)}`); } const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); const messagesList = savedData?.data || []; const fanGroup = messagesList.find(msg => msg.id === groupId); if (fanGroup) { if (!fanGroup.members) { fanGroup.members = []; } const newMember = { id: app.id, name: app.applicantName, handle: app.applicantHandle, avatar: app.applicantAvatar, joinedAt: new Date().toISOString(), }; fanGroup.members.push(newMember); fanGroup.memberCount = fanGroup.members.length; await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); console.log('✅ [粉丝群申请] 成员已添加，当前成员数:', fanGroup.memberCount); const conversationId = `messageConversation_${currentAccountId || 'main'}_${groupId}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data && savedConversation.data.messages) { const systemMessage = { type: 'system', systemType: 'memberJoined', content: `${app.applicantName} 加入了粉丝群`, timestamp: new Date().toISOString(), time: '刚刚', }; savedConversation.data.messages.push(systemMessage); await xDb.xAccountProfiles.put(savedConversation); console.log('✅ [粉丝群申请] 已添加入群系统通知'); } } if (currentMessageConversation && currentMessageConversation.id === groupId) { const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); const messagesList = savedData?.data || []; const updatedFanGroup = messagesList.find(msg => msg.id === groupId); if (updatedFanGroup) { await window.openMessageDetail(updatedFanGroup); } } const card = document.getElementById(`app-card-${appId}`); if (card) { card.style.transform = 'translateX(100%)'; card.style.opacity = '0'; setTimeout(() => card.remove(), 300); } const remainingPending = applications.filter(a => a.status === 'pending' && a.id !== appId); if (remainingPending.length === 0) { setTimeout(() => { closeFanGroupApplicationsModal(); showXToast('所有申请已处理完毕', 'success'); }, 500); } else { showXToast(app.amount > 0 ? `已通过申请，收到 $${app.amount.toFixed(2)}` : '已通过申请', 'success'); } if (fanGroup && fanGroup.members && fanGroup.members.length > 0) { setTimeout(() => { checkAndTriggerFanGroupAutoChat(groupId, fanGroup.members.length); }, 1000); } } catch (error) { console.error('❌ [粉丝群申请] 通过申请失败:', error); showXToast('操作失败: ' + error.message, 'error'); } }; window.rejectFanGroupApplication = async function (groupId, appId) { console.log('❌ [粉丝群申请] 拒绝申请', groupId, appId); try { const applications = await loadFanGroupApplications(groupId); const app = applications.find(a => a.id === appId); if (!app) { showXToast('未找到申请数据', 'error'); return; } app.status = 'rejected'; app.rejectedAt = new Date().toISOString(); await saveFanGroupApplications(groupId, applications); const card = document.getElementById(`app-card-${appId}`); if (card) { card.style.transform = 'translateX(-100%)'; card.style.opacity = '0'; setTimeout(() => card.remove(), 300); } const remainingPending = applications.filter(a => a.status === 'pending' && a.id !== appId); if (remainingPending.length === 0) { setTimeout(() => { closeFanGroupApplicationsModal(); showXToast('所有申请已处理完毕', 'success'); }, 500); } else { showXToast('已拒绝申请', 'info'); } } catch (error) { console.error('❌ [粉丝群申请] 拒绝申请失败:', error); showXToast('操作失败: ' + error.message, 'error'); } }; const originalOpenMessageDetail = window.openMessageDetail; window.openMessageDetail = async function (messageData, isFromNotifications) { console.log('🎯 [粉丝群] 拦截器：检测消息类型', messageData); if (originalOpenMessageDetail) { await originalOpenMessageDetail(messageData, isFromNotifications); } setTimeout(() => { const isFanGroup = messageData.type === 'fangroup'; adjustFanGroupDetailPage(isFanGroup); }, 100); }; function toggleMessageSelection(messageId) { if (selectedMessages.has(messageId)) { selectedMessages.delete(messageId); } else { selectedMessages.add(messageId); } updateMessageSelectionUI(); updateMessageDeleteUI(); } function enterMessageMultiSelectMode() { messageMultiSelectMode = true; selectedMessages.clear(); showMessageDeleteToolbar(); reloadMessageDetailView(); } window.exitMessageMultiSelectMode = function () { messageMultiSelectMode = false; selectedMessages.clear(); hideMessageDeleteToolbar(); reloadMessageDetailView(); }; async function reloadMessageDetailView() { if (!currentMessageConversation) return; try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data && savedConversation.data.messages) { const contentContainer = document.getElementById('message-detail-content'); if (!contentContainer) return; const dateElements = contentContainer.querySelectorAll('.message-item, div[style*="text-align: center"]'); dateElements.forEach(el => { if (el.classList.contains('message-item')) { el.remove(); } }); const messages = savedConversation.data.messages; const groups = groupMessagesBySender(messages); const allMessageElements = []; groups.forEach(group => { const isOwn = group[0].message.isOwn === true; group.forEach((item, indexInGroup) => { const isLastInGroup = indexInGroup === group.length - 1; const messageEl = renderMessageItem(item.message, isOwn, item.index, isLastInGroup); contentContainer.appendChild(messageEl); allMessageElements.push(messageEl); }); }); allMessageElements.forEach(el => { el.style.opacity = '1'; el.style.transform = 'translateY(0)'; }); } } catch (error) { console.error('重新加载消息视图失败:', error); } } function updateMessageSelectionUI() { selectedMessages.forEach(messageId => { const messageEl = document.querySelector(`[data-message-id="${messageId}"]`); if (messageEl) { messageEl.style.opacity = selectedMessages.has(messageId) ? '0.7' : '1'; const indicator = messageEl.querySelector('.message-select-indicator'); if (indicator) { const isSelected = selectedMessages.has(messageId); indicator.style.borderColor = isSelected ? 'var(--x-accent)' : 'var(--x-border-color)'; indicator.style.backgroundColor = isSelected ? 'var(--x-accent)' : 'var(--x-bg-primary)'; if (isSelected) { indicator.innerHTML = ` <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #fff;"> <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></g> </svg> `; } else { indicator.innerHTML = ''; } } } }); } function showMessageDeleteToolbar() { const inputToolbar = document.getElementById('message-input-toolbar'); if (inputToolbar) { inputToolbar.style.display = 'none'; } let deleteToolbar = document.getElementById('message-delete-toolbar'); if (!deleteToolbar) { deleteToolbar = document.createElement('div'); deleteToolbar.id = 'message-delete-toolbar'; deleteToolbar.style.cssText = ` position: fixed; bottom: 0; left: 0; right: 0; height: 56px; background-color:var(--x-bg-primary); border-top: 1px solid var(--x-border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 16px; z-index: 100; `; deleteToolbar.innerHTML = ` <div style="display: flex; align-items: center; gap: 16px;"> <button onclick="exitMessageMultiSelectMode()" style="background: none; border: none; color: var(--x-accent); font-size: 15px; font-weight: 600; cursor: pointer; padding: 8px 0; ">取消</button> <button onclick="selectAllMessages()" style="background: none; border: none; color: var(--x-accent); font-size: 15px; font-weight: 600; cursor: pointer; padding: 8px 0; ">全选</button> </div> <div style="color:var(--x-text-secondary); font-size: 14px; "> 已选择 <span id="message-selected-count">0</span> 条 </div> <button onclick="deleteSelectedMessages()" id="message-delete-btn" style="background-color: #f4212e; border: none; color: #fff; font-size: 15px; font-weight: 600; cursor: pointer; padding: 8px 16px; border-radius: 18px; opacity: 0.5; pointer-events: none; ">删除</button> `; const detailPage = document.getElementById('x-message-detail-page'); if (detailPage) { detailPage.appendChild(deleteToolbar); } } deleteToolbar.style.display = 'flex'; } function hideMessageDeleteToolbar() { const deleteToolbar = document.getElementById('message-delete-toolbar'); if (deleteToolbar) { deleteToolbar.remove(); } const inputToolbar = document.getElementById('message-input-toolbar'); if (inputToolbar) { inputToolbar.style.display = 'flex'; } } function updateMessageDeleteUI() { const countEl = document.getElementById('message-selected-count'); const deleteBtn = document.getElementById('message-delete-btn'); if (countEl) { countEl.textContent = selectedMessages.size; } if (deleteBtn) { if (selectedMessages.size > 0) { deleteBtn.style.opacity = '1'; deleteBtn.style.pointerEvents = 'auto'; } else { deleteBtn.style.opacity = '0.5'; deleteBtn.style.pointerEvents = 'none'; } } } window.selectAllMessages = function () { const messageElements = document.querySelectorAll('.message-item[data-message-id]'); messageElements.forEach(el => { const messageId = el.getAttribute('data-message-id'); if (messageId) { selectedMessages.add(messageId); } }); updateMessageSelectionUI(); updateMessageDeleteUI(); }; window.deleteSelectedMessages = async function () { if (selectedMessages.size === 0) { showXToast('请先选择要删除的消息', 'error'); return; } const isEnglish = currentLanguage === 'en'; const confirmMessage = isEnglish ? `Delete ${selectedMessages.size} message(s)?` : `确定删除选中的 ${selectedMessages.size} 条消息吗？`; if (!confirm(confirmMessage)) { return; } try { const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data && savedConversation.data.messages) { const indicesToDelete = new Set(); selectedMessages.forEach(messageId => { const match = messageId.match(/^msg_idx_(\d+)$/); if (match) { indicesToDelete.add(parseInt(match[1], 10)); } }); const updatedMessages = savedConversation.data.messages.filter((msg, index) => { return !indicesToDelete.has(index); }); console.log(`🗑️ 准备删除索引: ${Array.from(indicesToDelete).join(', ')}`); console.log(`📝 删除前消息数: ${savedConversation.data.messages.length}, 删除后: ${updatedMessages.length}`); savedConversation.data.messages = updatedMessages; savedConversation.updatedAt = new Date().toISOString(); await xDb.xAccountProfiles.put(savedConversation); console.log(`✅ 已删除 ${indicesToDelete.size} 条消息`); exitMessageMultiSelectMode(); const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { contentContainer.innerHTML = ''; const today = new Date(); const dateStr = currentLanguage === 'en' ? today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) : `${today.getFullYear()}年${today.getMonth() + 1}月${String(today.getDate()).padStart(2, '0')}日`; contentContainer.appendChild(renderDateSeparator(dateStr)); const groups = groupMessagesBySender(updatedMessages); const allMessageElements = []; groups.forEach(group => { const isOwn = group[0].message.isOwn === true; group.forEach((item, indexInGroup) => { const isLastInGroup = indexInGroup === group.length - 1; const messageEl = renderMessageItem(item.message, isOwn, item.index, isLastInGroup); contentContainer.appendChild(messageEl); allMessageElements.push(messageEl); }); }); allMessageElements.forEach(el => { el.style.opacity = '1'; el.style.transform = 'translateY(0)'; }); setTimeout(() => { const scrollable = document.getElementById('message-detail-scrollable'); if (scrollable) { scrollable.scrollTop = scrollable.scrollHeight; } }, 100); } const successMessage = isEnglish ? `Deleted ${indicesToDelete.size} message(s)` : `已删除 ${indicesToDelete.size} 条消息`; showXToast(successMessage, 'success'); } } catch (error) { console.error('删除消息失败:', error); const errorMessage = isEnglish ? 'Failed to delete messages' : '删除消息失败'; showXToast(errorMessage, 'error'); } }; async function checkUnblockTrigger(userHandle, targetHandle, triggerSource, content) { try { const xDb = getXDB(); const cleanUserHandle = userHandle.replace('@', '').toLowerCase(); const cleanTargetHandle = targetHandle.replace('@', '').toLowerCase(); console.log(`🔓 [拉黑解除] 检测触发: 用户=${cleanUserHandle}, 对方=${cleanTargetHandle}, 来源=${triggerSource}`); let messageId = null; let messageData = null; const allXProfiles = await xDb.xCharacterProfiles.toArray(); const targetProfile = allXProfiles.find( p => p.xHandle && p.xHandle.replace('@', '').toLowerCase() === cleanTargetHandle, ); if (targetProfile) { messageId = `msg_${targetProfile.characterId}`; const messagesListId = `messagesList_${currentAccountId || 'main'}`; const messagesListData = await xDb.xAccountProfiles.get(messagesListId); if (messagesListData && messagesListData.data) { messageData = messagesListData.data.find(m => m.id === messageId); } } else { const accountProfile = await xDb.xAccountProfiles.get(cleanTargetHandle); if (accountProfile) { messageId = `msg_account_${cleanTargetHandle}`; const messagesListId = `messagesList_${currentAccountId || 'main'}`; const messagesListData = await xDb.xAccountProfiles.get(messagesListId); if (messagesListData && messagesListData.data) { messageData = messagesListData.data.find(m => m.id === messageId); } } else { const messagesListId = `messagesList_${currentAccountId || 'main'}`; const messagesListData = await xDb.xAccountProfiles.get(messagesListId); if (messagesListData && messagesListData.data) { messageData = messagesListData.data.find( m => m.userHandle && m.userHandle.replace('@', '').toLowerCase() === cleanTargetHandle, ); if (messageData) { messageId = messageData.id; } } } } if (!messageId || !messageData) { console.log(`⚠️ [拉黑解除] 未找到对应的私信记录`); return; } const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageId}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (!savedConversation || !savedConversation.isBlocked) { console.log(`ℹ️ [拉黑解除] 对方并未拉黑用户，无需解除`); return; } console.log(`✅ [拉黑解除] 检测到拉黑状态，准备生成AI回复评估是否解除`); const unblockContext = { triggerSource: triggerSource, triggerContent: content, isUnblockTrigger: true, }; const aiMessages = await generateMessageConversation(messageData, true, { isUnblockRequest: true, unblockContext: unblockContext, }); const hasUnblockedMessage = aiMessages && aiMessages.some(msg => msg.type === 'system' && msg.systemType === 'unblocked'); if (hasUnblockedMessage) { console.log(`🎉 [拉黑解除] AI决定解除拉黑！`); savedConversation.isBlocked = false; delete savedConversation.blockedAt; savedConversation.updatedAt = new Date().toISOString(); if (!savedConversation.data) { savedConversation.data = { messages: [] }; } if (!savedConversation.data.messages) { savedConversation.data.messages = []; } const contextNotification = { type: 'system', systemType: 'unblockContext', content: triggerSource === 'mention' ? `用户在推文中@了你: "${content.substring(0, 100)}..."` : `用户在评论区提到了你: "${content.substring(0, 100)}..."`, timestamp: new Date().toISOString(), time: '刚刚', }; savedConversation.data.messages.push(contextNotification); aiMessages.forEach(msg => { if (!msg.timestamp) { msg.timestamp = new Date().toISOString(); } if (!msg.time) { msg.time = '刚刚'; } savedConversation.data.messages.push(msg); }); await xDb.xAccountProfiles.put(savedConversation); showPhoneNotification({ title: messageData.userName || messageData.user?.name || '未知用户', message: '已解除拉黑', avatar: messageData.userAvatar || messageData.user?.avatar || 'https: onClick: () => { openMessageDetail(messageData); }, }); const detailPage = document.getElementById('x-message-detail-page'); if (detailPage && detailPage.style.display === 'flex') { const currentMessageData = window.currentViewingMessage; if (currentMessageData && currentMessageData.id === messageId) { console.log(`🔄 [拉黑解除] 刷新当前私信详情页`); const messageInput = document.getElementById('message-input'); const sendBtn = document.getElementById('message-send-btn'); if (messageInput) { messageInput.disabled = false; messageInput.placeholder = '发送私信'; } if (sendBtn) { sendBtn.disabled = false; } loadMessageConversation(messageData, savedConversation.data); } } console.log(`✅ [拉黑解除] 拉黑已解除，AI消息已发送`); } else { console.log(`❌ [拉黑解除] AI决定不解除拉黑`); } } catch (error) { console.error('❌ [拉黑解除] 检测失败:', error); } } let autoMessageCheckInterval = null; const AUTO_MESSAGE_CHECK_FREQUENCY = 5000; const lastAutoMessageTrigger = {}; window.resetAutoMessageTrigger = function (characterId) { if (characterId && lastAutoMessageTrigger[characterId]) { delete lastAutoMessageTrigger[characterId]; console.log(`🔄 已重置角色 ${characterId} 的自动发消息触发记录`); } }; function startAutoMessageSystem() { if (autoMessageCheckInterval) { clearInterval(autoMessageCheckInterval); } console.log('🤖 启动后台自动发消息系统'); autoMessageCheckInterval = setInterval(async () => { await checkAndTriggerAutoMessages(); }, AUTO_MESSAGE_CHECK_FREQUENCY); } function stopAutoMessageSystem() { if (autoMessageCheckInterval) { clearInterval(autoMessageCheckInterval); autoMessageCheckInterval = null; console.log('🤖 停止后台自动发消息系统'); } } async function checkAndTriggerAutoMessages() { try { const db = getDB(); const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); const messagesList = savedData?.data || []; const now = Date.now(); const settingsId = `xSettings_${currentAccountId || 'main'}`; const xSettings = await xDb.xSettings.get(settingsId); const boundCharacters = xSettings?.boundCharacters || []; const characterProfiles = await Promise.all(boundCharacters.map(id => xDb.xCharacterProfiles.get(id))); for (const profile of characterProfiles) { if (!profile || !profile.autoMessageEnabled) { continue; } const characterId = profile.characterId; const messageId = `msg_${characterId}`; const messageItem = messagesList.find(msg => msg.id === messageId); if (!messageItem) { continue; } const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageId}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (!savedConversation || !savedConversation.data || !savedConversation.data.messages) { continue; } const messages = savedConversation.data.messages; const intervalSeconds = profile.autoMessageInterval || 60; const lastTriggerTime = lastAutoMessageTrigger[characterId] || 0; const timeSinceLastTrigger = (now - lastTriggerTime) / 1000; if (messages.length === 0) { if (timeSinceLastTrigger >= intervalSeconds) { console.log(`🤖 触发自动发消息（无聊天记录）: ${profile.xName}`); lastAutoMessageTrigger[characterId] = now; await triggerAutoMessage(messageItem, profile, 0); } continue; } const lastMessage = messages[messages.length - 1]; const lastMessageTime = lastMessage.timestamp ? new Date(lastMessage.timestamp).getTime() : 0; const timeSinceLastMessage = (now - lastMessageTime) / 1000; if ( timeSinceLastMessage >= intervalSeconds && !lastMessage.isOwn && timeSinceLastTrigger >= intervalSeconds / 2 ) { console.log( `🤖 触发自动发消息（用户未回复）: ${profile.xName}, 距离上次互动 ${Math.floor(timeSinceLastMessage)}秒`, ); lastAutoMessageTrigger[characterId] = now; await triggerAutoMessage(messageItem, profile, timeSinceLastMessage); } if (messages.length > 0 && Math.random() < 0.2) { const lastMessageTime = lastMessage.timestamp ? new Date(lastMessage.timestamp).getTime() : 0; const timeSinceLastMsg = (now - lastMessageTime) / 1000; if (timeSinceLastMsg >= intervalSeconds) { console.log(`🎲 [角色自动发推] 触发: ${profile.xName}, 距离上次聊天 ${Math.floor(timeSinceLastMsg)}秒`); await triggerAutoTweet(messageItem, profile, timeSinceLastMsg, 'character'); } } } for (const messageItem of messagesList) { const isCharacterMessage = messageItem.id.startsWith('msg_') && messageItem.id !== 'msg_001' && !messageItem.id.startsWith('msg_account_') && !messageItem.id.startsWith('msg_npc_') && !messageItem.id.startsWith('msg_relationship_'); if (isCharacterMessage) { continue; } const strangerSettingsId = `strangerSettings_${currentAccountId || 'main'}_${messageItem.id}`; const strangerSettings = await xDb.xAccountProfiles.get(strangerSettingsId); if (!strangerSettings || !strangerSettings.autoMessageEnabled) { continue; } const intervalSeconds = strangerSettings.autoMessageInterval || 60; const accountType = messageItem._accountType || (messageItem.id.startsWith('msg_account_') ? '账户' : messageItem.id.startsWith('msg_npc_') ? 'NPC' : messageItem.id.startsWith('msg_relationship_') ? '关系NPC' : '陌生人'); console.log( `⏰ [${accountType}自动发消息] ${messageItem.userName || messageItem.user?.name} 间隔: ${intervalSeconds}秒`, ); const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageItem.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (!savedConversation || !savedConversation.data || !savedConversation.data.messages) { continue; } const messages = savedConversation.data.messages; const lastTriggerTime = lastAutoMessageTrigger[messageItem.id] || 0; const timeSinceLastTrigger = (now - lastTriggerTime) / 1000; if (messages.length === 0) { if (timeSinceLastTrigger >= intervalSeconds) { console.log( `🤖 触发${accountType}自动发消息（无聊天记录）: ${messageItem.userName || messageItem.user?.name}`, ); lastAutoMessageTrigger[messageItem.id] = now; await triggerStrangerAutoMessage(messageItem, strangerSettings, 0); } continue; } const lastMessage = messages[messages.length - 1]; const lastMessageTime = lastMessage.timestamp ? new Date(lastMessage.timestamp).getTime() : 0; const timeSinceLastMessage = (now - lastMessageTime) / 1000; if ( timeSinceLastMessage >= intervalSeconds && !lastMessage.isOwn && timeSinceLastTrigger >= intervalSeconds / 2 ) { console.log( `🤖 触发${accountType}自动发消息（用户未回复）: ${ messageItem.userName || messageItem.user?.name }, 距离上次互动 ${Math.floor(timeSinceLastMessage)}秒`, ); lastAutoMessageTrigger[messageItem.id] = now; await triggerStrangerAutoMessage(messageItem, strangerSettings, timeSinceLastMessage); } if (messages.length > 0 && Math.random() < 0.1) { const lastMessageTime = lastMessage.timestamp ? new Date(lastMessage.timestamp).getTime() : 0; const timeSinceLastMsg = (now - lastMessageTime) / 1000; if (timeSinceLastMsg >= intervalSeconds) { console.log( `🎲 [${accountType}自动发推] 触发: ${ messageItem.userName || messageItem.user?.name }, 距离上次聊天 ${Math.floor(timeSinceLastMsg)}秒`, ); await triggerAutoTweet(messageItem, strangerSettings, timeSinceLastMsg, 'stranger'); } } } for (const messageItem of messagesList) { if (messageItem.type !== 'fangroup') { continue; } const fanGroupSettingsId = `fanGroupSettings_${currentAccountId || 'main'}_${messageItem.id}`; const fanGroupSettings = await xDb.xAccountProfiles.get(fanGroupSettingsId); if (!fanGroupSettings || !fanGroupSettings.data || !fanGroupSettings.data.autoMessageEnabled) { continue; } const intervalSeconds = fanGroupSettings.data.autoMessageInterval || 120; console.log( `⏰ [粉丝群自动发消息] ${messageItem.userName || messageItem.groupName} 间隔: ${intervalSeconds}秒`, ); const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageItem.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (!savedConversation || !savedConversation.data || !savedConversation.data.messages) { await xDb.xAccountProfiles.put({ handle: conversationId, name: 'conversation', data: { messages: [], }, updatedAt: new Date().toISOString(), }); continue; } const messages = savedConversation.data.messages; const lastTriggerTime = lastAutoMessageTrigger[messageItem.id] || 0; const timeSinceLastTrigger = (now - lastTriggerTime) / 1000; const lastNonSystemMessage = messages .slice() .reverse() .find(msg => msg.type !== 'system'); if (!lastNonSystemMessage) { if (timeSinceLastTrigger >= intervalSeconds) { console.log(`🤖 触发粉丝群自动交流（无聊天记录）: ${messageItem.userName || messageItem.groupName}`); lastAutoMessageTrigger[messageItem.id] = now; await triggerFanGroupAutoReaction(messageItem); } continue; } const lastMessageTime = lastNonSystemMessage.timestamp ? new Date(lastNonSystemMessage.timestamp).getTime() : 0; const timeSinceLastMessage = (now - lastMessageTime) / 1000; if (timeSinceLastMessage >= intervalSeconds && timeSinceLastTrigger >= intervalSeconds / 2) { console.log( `🤖 触发粉丝群自动交流: ${messageItem.userName || messageItem.groupName}, 距离上次互动 ${Math.floor( timeSinceLastMessage, )}秒`, ); lastAutoMessageTrigger[messageItem.id] = now; await triggerFanGroupAutoReaction(messageItem); } } } catch (error) { console.error('❌ 检查自动发消息失败:', error); } } async function triggerFanGroupAutoReaction(fanGroupData) { try { console.log('🎭 [粉丝群自反应] 后台自动触发'); const aiMessages = await generateFanGroupConversation(fanGroupData, true, { isAutoReaction: true, }); if (!aiMessages || aiMessages.length === 0) { console.log('📭 [粉丝群自反应] AI未生成任何消息'); return; } const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${fanGroupData.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); let allMessages = []; if (savedConversation && savedConversation.data && savedConversation.data.messages) { allMessages = savedConversation.data.messages; } allMessages.push(...aiMessages); await xDb.xAccountProfiles.put({ handle: conversationId, name: 'conversation', data: { messages: allMessages, }, updatedAt: new Date().toISOString(), }); console.log(`✅ [粉丝群自反应] 后台生成了${aiMessages.length}条群聊消息`); const dataId = `messagesList_${currentAccountId || 'main'}`; const messagesList = await xDb.xAccountProfiles.get(dataId); if (messagesList && messagesList.data) { const groupIndex = messagesList.data.findIndex(msg => msg.id === fanGroupData.id); if (groupIndex !== -1) { const lastMsg = aiMessages[aiMessages.length - 1]; const lastMsgContent = lastMsg.content || lastMsg.voiceText || lastMsg.imageDescription || '[消息]'; messagesList.data[groupIndex].lastMessage = `${lastMsg.senderName}: ${lastMsgContent}`; messagesList.data[groupIndex].timestamp = new Date().toISOString(); messagesList.data[groupIndex].unread = true; await xDb.xAccountProfiles.put(messagesList); sampleMessagesData = messagesList.data; } } if (document.getElementById('x-messages-page')?.style.display === 'block') { await loadMessagesList(); } } catch (error) { console.error('❌ [粉丝群自反应] 后台触发失败:', error); } } async function triggerAutoTweet(messageData, settings, timeSinceLastMessage, type = 'character') { try { let accountType, accountName, accountHandle, accountAvatar; if (type === 'character') { accountType = '角色'; accountName = settings.xName; accountHandle = settings.xHandle; accountAvatar = settings.xAvatar; } else { accountType = messageData._accountType || (messageData.id.startsWith('msg_account_') ? '账户' : messageData.id.startsWith('msg_npc_') ? 'NPC' : messageData.id.startsWith('msg_relationship_') ? '关系NPC' : '陌生人'); accountName = messageData.userName || messageData.user?.name || messageData.name; accountHandle = messageData.userHandle || messageData.user?.handle || messageData.handle; accountAvatar = messageData.userAvatar || messageData.user?.avatar || messageData.avatar; } console.log(`📨 ${accountType} ${accountName} 正在自动发推...`); const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (!savedConversation || !savedConversation.data || !savedConversation.data.messages) { console.warn('自动发推失败，无聊天记录'); return; } const messages = savedConversation.data.messages; const contextMessages = messages.slice(-20); const tweetData = await generateTweetFromConversation(messageData, contextMessages, { isAutoTweet: true, timeSinceLastMessage: Math.floor(timeSinceLastMessage), type: type, }); if (!tweetData) { console.warn('自动发推生成失败，无推文内容'); return; } const timestamp = Date.now(); const newTweetNotification = { id: `mention_newtweet_auto_${timestamp}`, type: 'newTweet', user: { name: accountName, handle: accountHandle, avatar: accountAvatar, }, content: `New Tweet from ${accountName}`, time: '刚刚', timestamp: timestamp, tweet: tweetData, }; const mentionsDataId = `mentions_${currentAccountId || 'main'}`; let savedMentions = await xDb.xAccountProfiles.get(mentionsDataId); if (!savedMentions) { savedMentions = { handle: mentionsDataId, id: mentionsDataId, data: [], }; } savedMentions.data.unshift(newTweetNotification); await xDb.xAccountProfiles.put(savedMentions); console.log(`✅ ${accountType}自动发推成功: ${accountName}`); await addTweetToAccountProfile(accountHandle, tweetData); const isEnglish = currentLanguage === 'en'; showPhoneNotification({ title: 'X', message: isEnglish ? `${accountName} posted a new tweet!` : `${accountName} 发布了新推文！`, avatar: accountAvatar, leftIcon: 'x', }); const mentionsPage = document.getElementById('x-notifications-page'); if (mentionsPage && mentionsPage.style.display === 'flex') { await loadNotifications(); } else { showNavNotificationDot('notifications'); } } catch (error) { console.error('❌ 触发自动发推失败:', error); } } async function triggerStrangerAutoMessage(messageData, strangerSettings, timeSinceLastMessage) { try { const accountType = messageData._accountType || (messageData.id.startsWith('msg_account_') ? '账户' : messageData.id.startsWith('msg_npc_') ? 'NPC' : messageData.id.startsWith('msg_relationship_') ? '关系NPC' : '陌生人'); const accountName = messageData.userName || messageData.user?.name || messageData.name; console.log(`📨 ${accountType} ${accountName} 正在自动发消息...`); const newMessages = await generateMessageConversation(messageData, true, { isAutoMessage: true, timeSinceLastMessage: Math.floor(timeSinceLastMessage), }); if (!newMessages || newMessages.length === 0) { console.warn(`${accountType}自动发消息生成失败，无新消息`); return; } const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data) { newMessages.forEach(msg => { if (!msg.timestamp) { msg.timestamp = new Date().toISOString(); } }); savedConversation.data.messages.push(...newMessages); savedConversation.updatedAt = new Date().toISOString(); await xDb.xAccountProfiles.put(savedConversation); console.log(`✅ ${accountType}自动消息已保存: ${newMessages.length}条`); const isEnglish = currentLanguage === 'en'; const toastMessage = isEnglish ? `${accountName} sent you ${newMessages.length} message(s)` : `${accountName} 向你发送了 ${newMessages.length} 条私信`; showXToast(toastMessage, 'info'); if (currentMessageConversation && currentMessageConversation.id === messageData.id) { const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { let currentMessageCount = contentContainer.querySelectorAll('.message-item').length; newMessages.forEach(msg => { const msgElement = renderMessageItem(msg, false, currentMessageCount); contentContainer.appendChild(msgElement); currentMessageCount++; }); } } try { const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); if (savedData && savedData.data) { const messagesList = savedData.data; const messageIndex = messagesList.findIndex(msg => msg.id === messageData.id); if (messageIndex !== -1) { messagesList[messageIndex].unread = true; messagesList[messageIndex].unreadCount = (messagesList[messageIndex].unreadCount || 0) + newMessages.length; await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); sampleMessagesData = messagesList; console.log(`✅ 已标记${accountType}私信为未读`); } } } catch (error) { console.error('更新未读状态失败:', error); } const messagesPage = document.getElementById('x-messages-page'); if (messagesPage && messagesPage.style.display !== 'none') { await loadMessagesList(); } else { showNavNotificationDot('messages'); } } } catch (error) { console.error('❌ 触发陌生人自动发消息失败:', error); } } async function triggerAutoMessage(messageData, characterProfile, timeSinceLastMessage) { try { console.log(`📨 角色 ${characterProfile.xName} 正在自动发消息...`); const newMessages = await generateMessageConversation(messageData, true, { isAutoMessage: true, timeSinceLastMessage: Math.floor(timeSinceLastMessage), }); if (!newMessages || newMessages.length === 0) { console.warn('自动发消息生成失败，无新消息'); return; } const xDb = getXDB(); const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`; const savedConversation = await xDb.xAccountProfiles.get(conversationId); if (savedConversation && savedConversation.data) { newMessages.forEach(msg => { if (!msg.timestamp) { msg.timestamp = new Date().toISOString(); } }); savedConversation.data.messages.push(...newMessages); savedConversation.updatedAt = new Date().toISOString(); await xDb.xAccountProfiles.put(savedConversation); console.log(`✅ 自动消息已保存: ${newMessages.length}条`); try { await detectAndGenerateNewTweetNotification(messageData, savedConversation.data.messages); } catch (error) { console.error('New Tweet 检测失败:', error); } const isEnglish = currentLanguage === 'en'; const toastMessage = isEnglish ? `${characterProfile.xName} sent you ${newMessages.length} message(s)` : `${characterProfile.xName} 向你发送了 ${newMessages.length} 条私信`; showXToast(toastMessage, 'info'); if (currentMessageConversation && currentMessageConversation.id === messageData.id) { const contentContainer = document.getElementById('message-detail-content'); if (contentContainer) { let currentMessageCount = contentContainer.querySelectorAll('.message-item').length; newMessages.forEach(msg => { const msgElement = renderMessageItem(msg, false, currentMessageCount); contentContainer.appendChild(msgElement); currentMessageCount++; }); } } try { const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); if (savedData && savedData.data) { const messagesList = savedData.data; const messageIndex = messagesList.findIndex(msg => msg.id === messageData.id); if (messageIndex !== -1) { messagesList[messageIndex].unread = true; messagesList[messageIndex].unreadCount = (messagesList[messageIndex].unreadCount || 0) + newMessages.length; await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); sampleMessagesData = messagesList; console.log('✅ 已标记私信为未读'); } } } catch (error) { console.error('更新未读状态失败:', error); } const messagesPage = document.getElementById('x-messages-page'); if (messagesPage && messagesPage.style.display !== 'none') { await loadMessagesList(); } else { showNavNotificationDot('messages'); } } } catch (error) { console.error('❌ 触发自动发消息失败:', error); } } window.loadMessagesList = loadMessagesList; window.openNewMessageModal = openNewMessageModal; window.startAutoMessageSystem = startAutoMessageSystem; window.stopAutoMessageSystem = stopAutoMessageSystem; window.closeNewMessageModal = closeNewMessageModal; window.selectCharacterForMessage = selectCharacterForMessage; console.log('✅ 全局接口已暴露'); const articleCoverImages = [ 'https: 'https: 'https: 'https: 'https: 'https: 'https: 'https: 'https: 'https: ]; window.openArticlePage = function (articleData) { console.log('📰 [文章查看] 打开文章页面', articleData); currentArticleData = articleData; const randomCover = articleCoverImages[Math.floor(Math.random() * articleCoverImages.length)]; document.getElementById('article-cover').style.backgroundImage = `url('${randomCover}')`; const titleEl = document.getElementById('article-title'); titleEl.textContent = articleData.title || '无标题'; const hasEnglish = /[a-zA-Z]/.test(articleData.title); if (hasEnglish) { titleEl.classList.add('article-title-en'); } else { titleEl.classList.remove('article-title-en'); } document.getElementById('article-author').textContent = articleData.author || '佚名'; document.getElementById('article-source').textContent = articleData.source || '未知来源'; const bodyEl = document.getElementById('article-body'); let bodyHtml = articleData.body || articleData.description || ''; bodyHtml = bodyHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); bodyHtml = bodyHtml.replace(/__(.*?)__/g, '<em>$1</em>'); bodyEl.innerHTML = bodyHtml; document.getElementById('x-article-page').style.display = 'flex'; console.log('✅ [文章查看] 文章页面已打开'); }; window.closeArticlePage = function () { document.getElementById('x-article-page').style.display = 'none'; console.log('✅ [文章查看] 文章页面已关闭'); }; let currentArticleData = null; window.shareArticle = function () { console.log('📤 [文章转发] 打开转发弹窗'); if (!currentArticleData) { showXToast('无法获取文章信息', 'error'); return; } showShareArticleModal(); }; async function showShareArticleModal() { try { const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); const messagesList = savedData?.data || []; if (messagesList.length === 0) { showXToast('暂无私信联系人', 'info'); return; } const modal = document.createElement('div'); modal.id = 'share-article-modal'; modal.style.cssText = ` display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--x-modal-overlay); z-index: 22; align-items: center; justify-content: center; backdrop-filter: blur(4px); `; modal.innerHTML = ` <div class="modal-content" onclick="event.stopPropagation()" style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 500px; max-height: 80vh; overflow: hidden; border: 1px solid var(--x-border-color); display: flex; flex-direction: column; "> <div class="modal-header" style="display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--x-border-color); background-color:var(--x-bg-primary); "> <div style="display: flex; align-items: center; gap: 20px;"> <div class="modal-close-btn" onclick="closeShareArticleModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </div> <h2 style="color:var(--x-text-primary); font-size: 20px; font-weight: 700; margin: 0; ">转发文章</h2> </div> </div> <div class="modal-body" style="padding: 16px 20px; overflow-y: auto; flex: 1; "> <div style="padding: 12px; background-color:var(--x-bg-secondary); border-radius: 12px; margin-bottom: 16px; border: 1px solid var(--x-border-color); "> <div style="font-size: 15px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">${ currentArticleData?.title || '无标题' }</div> <div style="font-size: 13px; color:var(--x-text-secondary); overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; ">${ currentArticleData?.description || '' }</div> </div> <div style="margin-bottom: 16px;"> <label style="display: block; color:var(--x-text-secondary); font-size: 13px; margin-bottom: 8px; ">附加文字（可选）</label> <textarea id="share-article-message" placeholder="添加一些说明..." style="width: 100%; min-height: 80px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; color:var(--x-text-primary); padding: 12px; font-size: 15px; resize: vertical; outline: none; box-sizing: border-box; font-family: inherit; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'"></textarea> </div> <div style="color:var(--x-text-secondary); font-size: 13px; margin-bottom: 12px; ">选择要转发到的联系人</div> <div id="share-article-contacts-list" style="display: flex; flex-direction: column; gap: 0; "> ${messagesList .map( contact => ` <div class="contact-select-item" data-contact-id="${contact.id}" onclick="selectContactForShare('${contact.id}')" style="display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <img src="${contact.userAvatar}" alt="${contact.userName}" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0; object-fit: cover; "> <div style="flex: 1; min-width: 0;"> <div style="font-size: 15px; font-weight: 700; color:var(--x-text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">${contact.userName}</div> <div style="font-size: 13px; color:var(--x-text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">@${contact.userHandle}</div> </div> </div> `, ) .join('')} </div> </div> </div> `; const xSocialScreen = document.getElementById('x-social-screen'); if (xSocialScreen) { xSocialScreen.appendChild(modal); } else { document.body.appendChild(modal); } modal.addEventListener('click', e => { if (e.target === modal) { closeShareArticleModal(); } }); } catch (error) { console.error('显示转发弹窗失败:', error); showXToast('打开转发失败', 'error'); } } window.closeShareArticleModal = function () { const modal = document.getElementById('share-article-modal'); if (modal) { modal.remove(); } }; window.selectContactForShare = async function (contactId) { console.log('📤 [文章转发] 转发到联系人:', contactId); try { const xDb = getXDB(); const messageInput = document.getElementById('share-article-message'); const additionalMessage = messageInput ? messageInput.value.trim() : ''; const now = new Date(); const hours = now.getHours(); const minutes = String(now.getMinutes()).padStart(2, '0'); const period = hours >= 12 ? '下午' : '上午'; const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutes} ${period}`; const articleMessage = { type: 'link', url: currentArticleData.source || '', title: currentArticleData.title, description: currentArticleData.description || '', author: currentArticleData.author, source: currentArticleData.source, body: currentArticleData.body, time: timeStr, timestamp: now.toISOString(), isOwn: true, }; const conversationId = `messageConversation_${currentAccountId || 'main'}_${contactId}`; let savedConversation = await xDb.xAccountProfiles.get(conversationId); if (!savedConversation) { savedConversation = { handle: conversationId, name: 'messageConversation', data: { messages: [], }, messageId: contactId, accountId: currentAccountId || 'main', updatedAt: new Date().toISOString(), }; } if (!savedConversation.data.messages) { savedConversation.data.messages = []; } savedConversation.data.messages.push(articleMessage); if (additionalMessage) { const textMessage = { type: 'text', content: additionalMessage, time: timeStr, timestamp: now.toISOString(), isOwn: true, }; savedConversation.data.messages.push(textMessage); } const lastMessageIndex = savedConversation.data.messages.length - 1; if (lastMessageIndex >= 0) { savedConversation.data.messages[lastMessageIndex].waitingForAIResponse = true; } savedConversation.updatedAt = new Date().toISOString(); await xDb.xAccountProfiles.put(savedConversation); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); if (savedData && savedData.data) { const messagesList = savedData.data; const contactIndex = messagesList.findIndex(msg => msg.id === contactId); if (contactIndex !== -1) { messagesList[contactIndex].lastMessage = additionalMessage || '[链接]'; messagesList[contactIndex].timestamp = now.toISOString(); const contact = messagesList.splice(contactIndex, 1)[0]; messagesList.unshift(contact); await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); sampleMessagesData = messagesList; } } closeShareArticleModal(); closeArticlePage(); const detailPage = document.getElementById('x-message-detail-page'); if (detailPage && detailPage.style.display !== 'none') { const currentConversationId = detailPage.dataset.conversationId; if (currentConversationId === contactId) { const dataId = `messagesList_${currentAccountId || 'main'}`; const messageData = await xDb.xAccountProfiles.get(dataId); if (messageData && messageData.data) { const contact = messageData.data.find(msg => msg.id === contactId); if (contact) { await loadMessageDetail({ id: contact.id, user: { name: contact.userName, handle: contact.userHandle, avatar: contact.userAvatar, }, }); } } } } showXToast('文章已转发', 'success'); console.log('✅ [文章转发] 转发成功'); } catch (error) { console.error('转发文章失败:', error); showXToast('转发失败', 'error'); } }; let currentShareContentData = null; window.showShareContentModal = async function (contentData, contentType) { console.log('📤 [内容转发] 准备转发:', contentType, contentData); currentShareContentData = { ...contentData, contentType }; try { const xDb = getXDB(); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); const messagesList = savedData?.data || []; if (messagesList.length === 0) { showXToast('暂无私信联系人', 'info'); return; } const modal = document.createElement('div'); modal.id = 'share-content-modal'; modal.style.cssText = ` display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--x-modal-overlay); z-index: 22; align-items: center; justify-content: center; backdrop-filter: blur(4px); `; let previewHTML = ''; if (contentType === 'tweet') { previewHTML = ` <div style="padding: 12px; background-color:var(--x-bg-secondary); border-radius: 12px; margin-bottom: 16px; border: 1px solid var(--x-border-color); "> <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;"> <img src="${contentData.user.avatar}" style="width: 32px; height: 32px; border-radius: 50%;" alt="${ contentData.user.name }"> <div> <div style="font-size: 14px; font-weight: 600; color:var(--x-text-primary);">${contentData.user.name}</div> <div style="font-size: 12px; color:var(--x-text-secondary);">${contentData.user.handle}</div> </div> </div> <div style="font-size: 14px; color:var(--x-text-primary); overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; line-height: 1.4; ">${ contentData.content || '无内容' }</div> </div> `; } else if (contentType === 'comment') { previewHTML = ` <div style="padding: 12px; background-color:var(--x-bg-secondary); border-radius: 12px; margin-bottom: 16px; border: 1px solid var(--x-border-color); "> <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;"> <img src="${contentData.user.avatar}" style="width: 32px; height: 32px; border-radius: 50%;" alt="${ contentData.user.name }"> <div> <div style="font-size: 14px; font-weight: 600; color:var(--x-text-primary);">${contentData.user.name}</div> <div style="font-size: 12px; color:var(--x-text-secondary);">${contentData.user.handle}</div> </div> </div> <div style="font-size: 14px; color:var(--x-text-primary); overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; line-height: 1.4; ">${ contentData.content || '无内容' }</div> </div> `; } modal.innerHTML = ` <div class="modal-content" onclick="event.stopPropagation()" style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 500px; max-height: 80vh; overflow: hidden; border: 1px solid var(--x-border-color); display: flex; flex-direction: column; "> <div class="modal-header" style="display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--x-border-color); background-color:var(--x-bg-primary); "> <div style="display: flex; align-items: center; gap: 20px;"> <div class="modal-close-btn" onclick="closeShareContentModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);"> <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g> </svg> </div> <h2 style="color:var(--x-text-primary); font-size: 20px; font-weight: 700; margin: 0; ">转发${ contentType === 'tweet' ? '推文' : '评论' }</h2> </div> </div> <div class="modal-body" style="padding: 16px 20px; overflow-y: auto; flex: 1; "> ${previewHTML} <div style="margin-bottom: 16px;"> <label style="display: block; color:var(--x-text-secondary); font-size: 13px; margin-bottom: 8px; ">附加文字（可选）</label> <textarea id="share-content-message" placeholder="添加一些说明..." style="width: 100%; min-height: 80px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; color:var(--x-text-primary); padding: 12px; font-size: 15px; resize: vertical; outline: none; box-sizing: border-box; font-family: inherit; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'"></textarea> </div> <div style="color:var(--x-text-secondary); font-size: 13px; margin-bottom: 12px; ">选择要转发到的联系人</div> <div id="share-content-contacts-list" style="display: flex; flex-direction: column; gap: 0; "> ${messagesList .map( contact => ` <div class="contact-select-item" data-contact-id="${contact.id}" onclick="selectContactForContentShare('${contact.id}')" style="display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'"> <img src="${contact.userAvatar}" alt="${contact.userName}" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0; object-fit: cover; "> <div style="flex: 1; min-width: 0;"> <div style="font-size: 15px; font-weight: 700; color:var(--x-text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">${contact.userName}</div> <div style="font-size: 13px; color:var(--x-text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">@${contact.userHandle}</div> </div> </div> `, ) .join('')} </div> </div> </div> `; const xSocialScreen = document.getElementById('x-social-screen'); if (xSocialScreen) { xSocialScreen.appendChild(modal); } else { document.body.appendChild(modal); } modal.addEventListener('click', e => { if (e.target === modal) { closeShareContentModal(); } }); } catch (error) { console.error('显示转发弹窗失败:', error); showXToast('打开转发失败', 'error'); } }; window.closeShareContentModal = function () { const modal = document.getElementById('share-content-modal'); if (modal) { modal.remove(); } currentShareContentData = null; }; window.selectContactForContentShare = async function (contactId) { if (!currentShareContentData) { showXToast('转发数据丢失', 'error'); return; } console.log('📤 [内容转发] 转发到联系人:', contactId); const contentData = { ...currentShareContentData }; try { const xDb = getXDB(); const messageInput = document.getElementById('share-content-message'); const additionalMessage = messageInput ? messageInput.value.trim() : ''; const now = new Date(); const hours = now.getHours(); const minutes = String(now.getMinutes()).padStart(2, '0'); const period = hours >= 12 ? '下午' : '上午'; const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutes} ${period}`; const forwardMessage = { type: 'forward', forwardType: contentData.contentType, forwardContent: { user: contentData.user, content: contentData.content, time: contentData.time, image: contentData.image || null, }, fullContext: {}, time: timeStr, timestamp: now.toISOString(), isOwn: true, }; if (contentData.contentType === 'tweet') { forwardMessage.fullContext = { tweet: contentData.fullTweet || { user: contentData.user, content: contentData.content, time: contentData.time, image: contentData.image, }, comments: contentData.comments || [], }; } else if (contentData.contentType === 'comment') { forwardMessage.fullContext = { comment: { user: contentData.user, content: contentData.content, time: contentData.time, image: contentData.image, }, parentTweet: contentData.parentTweet || null, }; } const conversationId = `messageConversation_${currentAccountId || 'main'}_${contactId}`; let savedConversation = await xDb.xAccountProfiles.get(conversationId); if (!savedConversation) { savedConversation = { handle: conversationId, name: 'messageConversation', data: { messages: [], }, messageId: contactId, accountId: currentAccountId || 'main', updatedAt: new Date().toISOString(), }; } if (!savedConversation.data.messages) { savedConversation.data.messages = []; } savedConversation.data.messages.push(forwardMessage); if (additionalMessage) { const textMessage = { type: 'text', content: additionalMessage, time: timeStr, timestamp: now.toISOString(), isOwn: true, }; savedConversation.data.messages.push(textMessage); } const lastMessageIndex = savedConversation.data.messages.length - 1; if (lastMessageIndex >= 0) { savedConversation.data.messages[lastMessageIndex].waitingForAIResponse = true; } savedConversation.updatedAt = new Date().toISOString(); await xDb.xAccountProfiles.put(savedConversation); const dataId = `messagesList_${currentAccountId || 'main'}`; const savedData = await xDb.xAccountProfiles.get(dataId); if (savedData && savedData.data) { const messagesList = savedData.data; const contactIndex = messagesList.findIndex(msg => msg.id === contactId); if (contactIndex !== -1) { messagesList[contactIndex].lastMessage = additionalMessage || `[转发了${contentData.contentType === 'tweet' ? '推文' : '评论'}]`; messagesList[contactIndex].timestamp = now.toISOString(); const contact = messagesList.splice(contactIndex, 1)[0]; messagesList.unshift(contact); await xDb.xAccountProfiles.put({ handle: dataId, name: 'messagesList', data: messagesList, updatedAt: new Date().toISOString(), }); sampleMessagesData = messagesList; } } closeShareContentModal(); const detailPage = document.getElementById('x-message-detail-page'); if (detailPage && detailPage.style.display !== 'none') { const currentConversationId = detailPage.dataset.conversationId; if (currentConversationId === contactId) { const dataId = `messagesList_${currentAccountId || 'main'}`; const messageData = await xDb.xAccountProfiles.get(dataId); if (messageData && messageData.data) { const contact = messageData.data.find(msg => msg.id === contactId); if (contact) { await loadMessageDetail({ id: contact.id, user: { name: contact.userName, handle: contact.userHandle, avatar: contact.userAvatar, }, }); } } } } showXToast(`${contentData.contentType === 'tweet' ? '推文' : '评论'}已转发`, 'success'); console.log('✅ [内容转发] 转发成功'); } catch (error) { console.error('转发失败:', error); showXToast('转发失败', 'error'); } }; window.renderXSocialScreenProxy = renderXSocialScreen; window.switchXPage = switchXPage; window.switchHomeTab = switchHomeTab; window.refreshXTweets = refreshXTweets; window.showTweetComments = showTweetComments; window.submitComment = submitComment; window.handleCommentInput = handleCommentInput; window.autoResize = autoResize; window.showReplyInput = showReplyInput; window.cancelReply = cancelReply; window.submitReply = submitReply; window.handleReplyInput = handleReplyInput; window.autoResizeReply = autoResizeReply; window.toggleLike = toggleLike; window.toggleCommentLike = toggleCommentLike; window.deleteUserComment = deleteUserComment; window.showSensitiveContent = showSensitiveContent; window.handleQuotedTweetClick = handleQuotedTweetClick; window.handleQuoteRetweetFromData = handleQuoteRetweetFromData; window.openComposeTweetModal = openComposeTweetModal; window.closeComposeTweetModal = closeComposeTweetModal; window.publishTweet = publishTweet; window.handleComposeInput = handleComposeInput; window.processHashtagsAndMentions = processHashtagsAndMentions; window.toggleImageSection = toggleImageSection; window.selectImageMethod = selectImageMethod; window.triggerImageUpload = triggerImageUpload; window.handleImageUpload = handleImageUpload; window.saveImageData = saveImageData; window.removeImage = removeImage; window.toggleLocationSection = toggleLocationSection; window.saveLocationData = saveLocationData; window.removeLocation = removeLocation; window.toggleLinkSection = toggleLinkSection; window.saveLinkData = saveLinkData; window.removeLink = removeLink; window.triggerLinkImageUpload = triggerLinkImageUpload; window.handleLinkImageUpload = handleLinkImageUpload; window.removeQuoteContent = removeQuoteContent; window.togglePrivacySettings = togglePrivacySettings; window.editProfile = editProfile; window.openEditProfileModal = openEditProfileModal; window.closeEditProfileModal = closeEditProfileModal; window.saveProfileChanges = saveProfileChanges; window.switchProfileTab = switchProfileTab; window.toggleProfileMenu = toggleProfileMenu; window.openAccountManager = openAccountManager; window.openAccountWallet = openAccountWallet; window.closeWalletModal = closeWalletModal; window.activateWallet = activateWallet; window.addFunds = addFunds; window.sendMoney = sendMoney; window.shareWallet = shareWallet; window.exportWallet = exportWallet; window.copyWalletInfo = copyWalletInfo; window.updateCharacterCounts = updateCharacterCounts; window.toggleRealNameInput = toggleRealNameInput; window.updateTag1ColorFromText = updateTag1ColorFromText; window.updateTag1ColorFromPicker = updateTag1ColorFromPicker; window.updateTag2ColorFromText = updateTag2ColorFromText; window.updateTag2ColorFromPicker = updateTag2ColorFromPicker; window.editCoverImage = editCoverImage; window.removeCoverImage = removeCoverImage; window.editAvatarImage = editAvatarImage; window.updateVerificationTypeUI = updateVerificationTypeUI; window.toggleCharacterBinding = toggleCharacterBinding; window.toggleCharacterSelection = toggleCharacterSelection; window.openCharacterXProfile = openCharacterXProfile; window.closeCharacterXProfileModal = closeCharacterXProfileModal; window.saveCharacterXProfile = saveCharacterXProfile; window.updateCharacterXAvatar = updateCharacterXAvatar; window.updateCharacterBioCount = updateCharacterBioCount; window.toggleCharacterRealNameInput = toggleCharacterRealNameInput; window.openAddRelationshipModal = openAddRelationshipModal; window.editRelationship = editRelationship; window.deleteRelationship = deleteRelationship; window.closeRelationshipModal = closeRelationshipModal; window.updateRelationshipDescCount = updateRelationshipDescCount; window.saveRelationshipForm = saveRelationshipForm; window.saveXSettings = saveXSettings; window.saveXPreset = saveXPreset; window.loadXPreset = loadXPreset; window.deleteXPreset = deleteXPreset; window.exportXData = exportXData; window.importXData = importXData; window.toggleXTheme = toggleXTheme; window.showTweetDetail = showTweetDetail; window.handleDetailCommentInput = handleDetailCommentInput; window.autoResizeDetail = autoResizeDetail; window.submitDetailComment = submitDetailComment; window.toggleDetailLike = toggleDetailLike; window.rerollAIReplies = rerollAIReplies; window.toggleTweetSelection = toggleTweetSelection; window.enterMultiSelectMode = enterMultiSelectMode; window.exitMultiSelectMode = exitMultiSelectMode; window.selectAllTweets = selectAllTweets; window.deleteSelectedTweets = deleteSelectedTweets; window.showXToast = showXToast; window.toggleIdentityCharacter = toggleIdentityCharacter; window.closeAccountManager = closeAccountManager; window.switchAccount = switchAccount; window.createNewAccount = createNewAccount; window.deleteAccount = deleteAccount; window.triggerCommentImageUpload = triggerCommentImageUpload; window.handleCommentImageUpload = handleCommentImageUpload; window.removeCommentImage = removeCommentImage; window.triggerDetailCommentImageUpload = triggerDetailCommentImageUpload; window.handleDetailCommentImageUpload = handleDetailCommentImageUpload; window.removeDetailCommentImage = removeDetailCommentImage; window.openCommentStickers = openCommentStickers; window.toggleCharacterRelationship = toggleCharacterRelationship; window.openCharacterRelationshipGraph = openCharacterRelationshipGraph; window.closeCharacterRelationshipGraph = closeCharacterRelationshipGraph; window.addRelationshipLink = addRelationshipLink; window.openEditRelationshipDetailModal = openEditRelationshipDetailModal; window.closeEditRelationshipDetail = closeEditRelationshipDetail; window.saveRelationshipDetail = saveRelationshipDetail; window.deleteRelationshipLink = deleteRelationshipLink; window.clearAllRelationships = clearAllRelationships; window.saveRelationshipGraph = saveRelationshipGraph; window.characterRelationshipData = characterRelationshipData; window.toggleNPCBinding = toggleNPCBinding; window.openCreateNPCModal = openCreateNPCModal; window.editNPC = editNPC; window.saveNPC = saveNPC; window.deleteNPC = deleteNPC; window.closeNPCEditModal = closeNPCEditModal; window.loadAskboxData = loadAskboxData; window.changeAskboxAvatar = changeAskboxAvatar; window.saveAskboxNickname = saveAskboxNickname; window.saveAskboxPrompt = saveAskboxPrompt; window.openAskboxSettings = openAskboxSettings; window.getNewQuestion = getNewQuestion; window.saveQuestionAnswer = saveQuestionAnswer; window.startQuestionLongPress = startQuestionLongPress; window.endQuestionLongPress = endQuestionLongPress; window.toggleQuestionSelection = toggleQuestionSelection; window.enterAskboxMultiSelectMode = enterAskboxMultiSelectMode; window.exitAskboxMultiSelectMode = exitAskboxMultiSelectMode; window.selectAllQuestions = selectAllQuestions; window.deleteSelectedQuestions = deleteSelectedQuestions; window.switchSearchTab = switchSearchTab; window.handleTrendingClick = handleTrendingClick; window.handleTrendingMore = handleTrendingMore; window.openAddCategoryModal = openAddCategoryModal; window.closeCategoryModal = closeCategoryModal; window.addNewCategory = addNewCategory; window.deleteCategory = deleteCategory; window.toggleCategory = toggleCategory; window.updateCategoryName = updateCategoryName; window.updateCategoryDescription = updateCategoryDescription; window.saveCustomCategories = saveCustomCategories; window.refreshTrends = refreshTrends; window.toggleSearchButton = toggleSearchButton; window.performSearch = performSearch; window.switchSearchResultTab = switchSearchResultTab; window.backToTrending = backToTrending; window.openAccountProfile = openAccountProfile; window.closeAccountProfile = closeAccountProfile; window.showAccountTweetDetail = showAccountTweetDetail; window.toggleAccountFollow = toggleAccountFollow; window.toggleAccountNotifications = toggleAccountNotifications; window.sendMessageToAccount = sendMessageToAccount; window.switchAccountTab = switchAccountTab; window.refreshAccountProfile = refreshAccountProfile; window.toggleProgressMode = toggleProgressMode; window.handleRefreshButtonMouseDown = handleRefreshButtonMouseDown; window.handleRefreshButtonMouseUp = handleRefreshButtonMouseUp; window.goBackFromTweetDetail = goBackFromTweetDetail; window.toggleXTheme = toggleXTheme; window.toggleXLanguage = toggleXLanguage; window.switchLiveTab = switchLiveTab; window.joinLiveStream = joinLiveStream; window.initLivePage = initLivePage; window.renderLiveStreams = renderLiveStreams; window.openLiveCategoryModal = openLiveCategoryModal; window.closeLiveCategoryModal = closeLiveCategoryModal; window.addNewLiveCategory = addNewLiveCategory; window.deleteLiveCategory = deleteLiveCategory; window.toggleLiveCategory = toggleLiveCategory; window.updateLiveCategoryName = updateLiveCategoryName; window.updateLiveCategoryDescription = updateLiveCategoryDescription; window.saveLiveCustomCategories = saveLiveCustomCategories; window.syncLivePageAvatar = syncLivePageAvatar; window.toggleLiveActionButtons = toggleLiveActionButtons; window.refreshLiveStreams = refreshLiveStreams; window.startLiveStream = startLiveStream; window.syncLiveCharacterAvatars = syncLiveCharacterAvatars; window.handleLiveCharacterClick = handleLiveCharacterClick; window.loadSavedLiveData = loadSavedLiveData; window.loadLiveCharacterStatus = loadLiveCharacterStatus; window.saveLiveCharacterStatus = saveLiveCharacterStatus; window.handleLiveMainBtnMouseOver = handleLiveMainBtnMouseOver; window.handleLiveMainBtnMouseOut = handleLiveMainBtnMouseOut; window.handleLiveMainBtnTouchStart = handleLiveMainBtnTouchStart; window.handleLiveMainBtnTouchEnd = handleLiveMainBtnTouchEnd; window.handleLiveSubBtnMouseOver = handleLiveSubBtnMouseOver; window.handleLiveSubBtnMouseOut = handleLiveSubBtnMouseOut; window.handleLiveSubBtnTouchStart = handleLiveSubBtnTouchStart; window.handleLiveSubBtnTouchEnd = handleLiveSubBtnTouchEnd; if (typeof window.liveBtnExpanded === 'undefined') { window.liveBtnExpanded = false; } window.XSocialApp = { init: initXSocialApp, render: renderXSocialScreen, version: '1.0', isLoaded: true, }; if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initXSocialApp); } else { setTimeout(initXSocialApp, 100); } console.log('📦 X Social App 模块已加载，版本: 1.0'); window.clearCurrentWalletData = async function () { try { const db = getXDB(); const accountId = currentAccountId || 'main'; const walletId = `wallet_${accountId}`; await db.xAccountProfiles.delete(walletId); await loadWalletData(); console.log('✅ 已清空账户钱包数据:', accountId); showXToast('钱包数据已清空', 'success'); } catch (error) { console.error('❌ 清空钱包数据失败:', error); showXToast('清空失败: ' + error.message, 'error'); } }; })(window);
// === 内嵌压缩版 pp.js 结束 ===</script><style>
        @font-face { font-family: 'bulangni'; src: url('') format('truetype'); font-weight: normal; font-style: normal; font-display: swap; }
        :root { --screen-width: 350px; --screen-height: 650px; --secondary-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #1f1f1f; --text-secondary: #8a8a8a; --accent-color: #007bff; }
        html { height: 100%; overflow: hidden; }

/* ▼▼▼ 请用下面这【一整块】全新的代码，替换掉所有旧的 body, phone-frame, phone-screen 等样式 ▼▼▼ */

/* 1. 重置 body，使其成为一个干净的画布 */
body {
    height: 100%;
    overflow: hidden;
    margin: 0;
    font-family: 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    font-weight: normal;
    background-color: #f0f2f5; 
}

/* 2. 让 #phone-screen 成为新的“根”容器，撑满整个浏览器窗口 */
#phone-screen {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    background-color: #000; /* 保留一个默认的黑色背景 */
}

/* 3. 【核心】隐藏掉模拟器的状态栏 */
#status-bar {
    display: none;
}

/* 4. 【核心】让所有页面的头部自动适应iPhone的“刘海”安全区 */
.header, .qzone-header {
    /* 使用 env(safe-area-inset-top) 自动获取顶部安全距离 */
    padding-top: calc(15px + env(safe-area-inset-top));
}

/* 5. 【核心】让聊天输入框和底部导航栏自动适应iPhone底部的“小黑条”安全区 */
#chat-input-area {
    padding-bottom: calc(8px + env(safe-area-inset-bottom));
}

        #status-bar { position: absolute; top: 0; left: 0; width: 100%; padding: 12px 20px; display: flex; justify-content: space-between; align-items: center; color: white; z-index: 10; font-size: 14px; box-sizing: border-box; pointer-events: none; }
        #status-bar-time { font-weight: 600; }
        .battery-container { display: flex; align-items: center; gap: 5px; }
        .battery-icon { width: 25px; height: 12px; border: 1px solid white; border-radius: 3px; position: relative; padding: 1px; }
        .battery-icon::after { content: ''; position: absolute; right: -3px; top: 2px; width: 2px; height: 6px; background-color: white; border-radius: 0 1px 1px 0; }
        .battery-level { height: 100%; background-color: white; border-radius: 1px; transition: width 0.5s ease; }
        .battery-container.charging .battery-level { background-color: #4cd964; animation: charge-breath 2s infinite; }
        .battery-container.charging .battery-text { color: #4cd964; }
        @keyframes charge-breath { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .screen { width: 100%; height: 100%; position: absolute; top: 0; left: 0; display: flex; flex-direction: column; overflow: hidden; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
        .screen.active { opacity: 1; visibility: visible; z-index: 1; }
        .header { position: relative; z-index: 15; flex-shrink: 0; padding: 15px 20px; padding-top: 45px; background-color: rgba(247, 247, 247, 0.8); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-size: 18px; font-weight: 600; }
        .header .header-actions { display: flex; align-items: center; gap: 15px; }
        .header .back-btn, .header .action-btn { font-size: 24px; cursor: pointer; width: 30px; text-align: center; color: var(--accent-color); display: flex; align-items: center; justify-content: center; }

.header .action-btn {
    font-size: 16px; /* 专门为“上传”、“+”等文字按钮缩小字号 */
    font-weight: 600; /* 可以加粗一点让它更清晰 */
}

        .header .action-btn img { height: 26px; }
        .header .save-btn { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; }
        #home-screen { display: flex; flex-direction: column; justify-content: flex-start; align-items: center; padding: 20px; padding-top: 80px; padding-bottom: 50px; box-sizing: border-box; background-size: cover; background-position: center; }
        #clock-container { text-align: center; color: white; text-shadow: 0 3px 8px rgba(0,0,0,0.4); margin-bottom: 20px; flex-shrink: 0; }
        #main-time { font-size: 80px; font-weight: 200; }
        #main-date { font-size: 18px; font-weight: 500; }
        #app-grid { margin-top: auto; display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; padding: 20px; }
        .app-row { display: flex; justify-content: center; gap: 25px; width: 100%; }
        .app-icon { display: flex; flex-direction: column; align-items: center; cursor: pointer; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5); font-size: 14px; font-weight: 500; text-align: center; }
        .app-icon .icon-bg { width: 65px; height: 65px; border-radius: 18px; background-color: var(--secondary-bg); display: flex; justify-content: center; align-items: center; font-size: 32px; margin-bottom: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); transition: transform 0.2s ease; overflow: hidden; }
        .app-icon:active .icon-bg { transform: scale(0.9); }
        .app-icon .icon-bg img { width: 100%; height: 100%; object-fit: cover; }
        .app-icon .label { color: white; }
        .form-container, .list-container { padding: 20px; overflow-y: auto; flex-grow: 1; display:flex; flex-direction: column; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-secondary); }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; }
        .form-group textarea { min-height: 80px; resize: vertical; }
        #world-book-content-input { height: calc(100% - 120px); }
        .form-button { width: 100%; padding: 15px; background-color: var(--accent-color); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 10px; }
        .form-button-secondary { background-color: #f0f0f0; color: var(--text-primary); border: 1px solid var(--border-color); }
        #wallpaper-screen .form-container { align-items: center; }
        #wallpaper-preview { width: 180px; height: 320px; border: 2px dashed var(--border-color); background-color: #f0f2f5; margin-bottom: 20px; background-size: cover; background-position: center; border-radius: 10px; display: flex; justify-content: center; align-items: center; color: var(--text-secondary); }
        #wallpaper-upload-input { display: none; }
/* 修改后的 #world-book-list 样式 */
#world-book-list {
    flex-grow: 1;
    overflow-y: auto;
    background-color: var(--secondary-bg);
    padding-top: 80px;
    margin-top: -80px;
}

/* 修改后的 #chat-list 样式，去掉了 padding 和 margin */
#chat-list {
    flex-grow: 1;
    background-color: var(--secondary-bg);
    padding-top: 80px; 
    padding-bottom: 50px; /* 为底部导航栏留出空间 */
    box-sizing: border-box;
}

        .list-item { display: flex; flex-direction: column; padding: 12px 20px; cursor: pointer; border-bottom: 1px solid var(--border-color); }
        .list-item:hover { background-color: #f5f5f5; }
        .list-item .item-title { font-weight: 500; font-size: 16px; margin-bottom: 5px; }
        .list-item .item-content { font-size: 14px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chat-list-item { display: flex; align-items: center; padding: 10px 15px; cursor: pointer; border-bottom: 1px solid var(--border-color); position: relative; }
        .chat-list-item:hover { background-color: #f5f5f5; }
        .chat-list-item .avatar { width: 45px; height: 45px; border-radius: 50%; margin-right: 12px; object-fit: cover; background-color: #ccc; }
        .chat-list-item .info { flex-grow: 1; overflow: hidden; }
        .chat-list-item .name-line { display: flex; align-items: center; gap: 6px; margin-bottom: 2px; }
        .chat-list-item .name { font-weight: 500; color: var(--text-primary); }
        .chat-list-item .group-tag { font-size: 10px; color: var(--accent-color); background-color: #e7f3ff; padding: 2px 6px; border-radius: 4px; font-weight: bold; flex-shrink: 0; }
        .chat-list-item .last-msg { font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        #chat-interface-screen { background-size: cover; background-position: center; position: relative; }
        #selection-cancel-btn, #selection-delete-btn { font-size: 16px; color: var(--accent-color); cursor: pointer; padding: 5px; }
        #selection-delete-btn { color: #ff3b30; }

/* ▼▼▼ 用这块代码替换掉你原来的 #chat-messages 样式 ▼▼▼ */
#chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    overflow-x: hidden; /* 核心修正1: 强制禁止水平滚动/拖动 */
    padding: 10px 15px; /* 核心修正2: 将左右内边距增加到15px，提供更多呼吸空间 */
    padding-top: 110px;
    margin-top: -80px;
    display: flex;
    flex-direction: column;
    gap: 20px;
    box-sizing: border-box; /* 确保内边距计算正确 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */
        #load-more-btn { text-align: center; padding: 10px; color: var(--accent-color); font-size: 14px; cursor: pointer; background-color: transparent; border: none; width: 100%; }
        #load-more-btn:hover { text-decoration: underline; }

        .sender-name { font-size: 11px; color: #666; margin-bottom: 3px; }

.message-wrapper.ai .sender-name {
    margin-left: 50px; /* 稍微调整，与头像对齐 */
    margin-bottom: 3px;
    position: absolute; /* 让它脱离流，避免影响气泡对齐 */
    top: -16px;       /* 定位到气泡上方 */
    left: 0;
}

/* === 【全新】消息布局与时间戳样式 === */

/* 1. 消息单元的总容器 (重构) */
.message-wrapper {
    display: flex;          /* 使用Flex布局 */
    gap: 8px;               /* 气泡和时间戳之间的间距 */
    align-items: flex-end;  /* 核心：让气泡和时间戳底部对齐 */
    position: relative;
    max-width: 90%;         /* 可以稍微放宽一点，因为时间戳现在在外面了 */
}

/* 2. AI消息单元靠左 */
.message-wrapper.ai {
    align-self: flex-start;
    flex-direction: row; /* 头像、气泡、时间戳，从左到右排列 */
}

/* 3. 用户消息单元靠右 */
.message-wrapper.user {
    align-self: flex-end;
    flex-direction: row-reverse; /* 时间戳、气泡、头像，从右到左排列 */
}

/* 4. 气泡和头像的直接容器 (保持不变) */
.message-bubble {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    max-width: 100%;
}

.timestamp {
    /* 移除旧的 position: absolute */
    font-size: 11px;
    color: #999;
    text-shadow: 0 0 3px rgba(255,255,255,0.6);
    white-space: nowrap; /* 防止时间换行 */
    margin-bottom: 5px;  /* 让它和气泡底部有轻微的对齐偏移，更美观 */
    flex-shrink: 0;      /* 防止被压缩 */
}

        .message-bubble.selected::after { content: '✔'; position: absolute; left: -10px; top: 50%; transform: translateY(-50%); background-color: var(--accent-color); color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; }
        .message-bubble.user.selected::after { left: auto; right: -10px; }

        .message-bubble.user { flex-direction: row-reverse; }
        #typing-indicator { align-self: flex-start; display: none; margin: 0 10px 10px; color: var(--text-secondary); }
        #chat-input-area { flex-shrink: 0; padding: 8px; background-color: rgba(247, 247, 247, 0.8); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-top: 1px solid var(--border-color); display: flex; flex-direction: column; gap: 5px; }
        #chat-input-main-row { display: flex; align-items: flex-end; gap: 8px; width: 100%; }
        #chat-input { flex-grow: 1; border: none; padding: 10px 15px; border-radius: 20px; background-color: var(--secondary-bg); font-size: 16px; max-height: 100px; resize: none; }
        .action-button { border: none; color: white; border-radius: 20px; cursor: pointer; font-weight: 600; font-size: 14px; flex-shrink: 0; }
        #send-btn { background-color: var(--accent-color); height: 40px; padding: 0 15px;}
        .modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); display: none; justify-content: center; align-items: center; z-index: 100; }
        .modal.visible { display: flex; }
        .modal-content { width: 90%; max-height: 90%; background-color: white; border-radius: 15px; display: flex; flex-direction: column; }
        .modal-header { padding: 15px; font-weight: 600; border-bottom: 1px solid var(--border-color); text-align: center; display: flex; justify-content: space-between; align-items: center; }
        .modal-body { padding: 15px; overflow-y: auto; }
        .modal-footer { padding: 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-around; }
        .modal-footer button { width: 45%; padding: 12px; border-radius: 8px; border: 1px solid var(--accent-color); cursor: pointer; font-size: 16px; }
        .modal-footer .save { background-color: var(--accent-color); color: white; }
        .modal-footer .cancel { background-color: white; color: var(--accent-color); }
        .avatar-upload { display: flex; align-items: center; gap: 15px; }
        .avatar-upload img { width: 60px; height: 60px; border-radius: 50%; object-fit: cover; background-color: #eee; }
        .avatar-upload button { padding: 8px 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer; }
        #open-persona-library-btn { font-size: 14px; padding: 6px 10px; margin-left: 0; }
        .avatar-upload input[type="file"] { display: none; }
        .theme-selector label { display: inline-flex; align-items: center; margin-right: 15px; margin-bottom: 5px; cursor: pointer; }
        #reset-theme-btn { background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px; }
        #group-members-settings { display: flex; overflow-x: auto; padding-bottom: 10px; gap: 15px; }
        .member-editor { text-align: center; cursor: pointer; }
        .member-editor img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; background-color: #eee; margin-bottom: 5px; }
        .member-editor .member-name { font-size: 12px; }
        #notification-bar { position: absolute; top: 40px; left: 50%; width: 90%; z-index: 500; background-color: rgba(250, 250, 250, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 16px; padding: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: flex; align-items: center; gap: 12px; cursor: pointer;     transform: translateX(-50%) translateY(-150%); 
    transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    visibility: hidden;
}
#notification-bar.visible {
    /* 关键：在Y轴回到原位的同时，保持X轴的居中变换 */
    transform: translateX(-50%) translateY(0);
    visibility: visible;
}
        #notification-avatar { width: 30px; height: 30px; border-radius: 50%; object-fit: cover; }
        #notification-content .name { font-weight: 600; font-size: 15px; color: #000; }
        #notification-content .message { font-size: 14px; color: #555; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }
        .sticker-image { max-width: 100px; max-height: 100px; display: block; object-fit: contain; }
        .message-bubble.is-sticker .content, .message-bubble.is-voice-message .content { padding: 0; background-color: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
        #chat-input-actions-top { display: flex; gap: 8px; padding: 0 5px; }
        .chat-action-icon-btn { font-size: 24px; padding: 0; width: 38px; height: 38px; line-height: 38px; text-align: center; border-radius: 50%; background-color: rgba(255, 255, 255, 0.5); color: var(--text-primary); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.05); cursor: pointer; display:flex; justify-content:center; align-items:center; }
        #sticker-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 50%; background-color: rgba(242, 242, 247, 0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 200; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #sticker-panel.visible { transform: translateY(0); visibility: visible; }
        #sticker-panel-header { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); }
        #sticker-panel-header .title { font-weight: 600; }
        #sticker-panel-header .panel-btn { font-size: 16px; padding: 5px 10px; cursor: pointer; color: var(--accent-color); }
        #sticker-grid { flex-grow: 1; overflow-y: auto; padding: 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; }
        .sticker-item { position: relative; aspect-ratio: 1 / 1; background-color: white; border-radius: 10px; background-size: contain; background-repeat: no-repeat; background-position: center; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .sticker-item .delete-btn { display: none; position: absolute; top: -5px; right: -5px; width: 20px; height: 20px; background-color: #ff3b30; color: white; border-radius: 50%; text-align: center; line-height: 20px; font-size: 14px; cursor: pointer; border: 2px solid white; }
        #input-actions-wrapper { position: static; display: flex; align-items: flex-end; gap: 8px; flex-shrink: 0; }
        #wait-reply-btn { position: static; bottom: auto; right: auto; width: auto; height: 40px; padding: 0 10px; border-radius: 20px; display: flex; align-items: center; justify-content: center; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.08); box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: opacity 0.2s, transform 0.1s; cursor: pointer;}
        #wait-reply-btn:hover { opacity: 0.8; }
        #wait-reply-btn:active { transform: scale(0.9); }
        #wait-reply-btn img { height: 22px; display: block; margin: auto; }
        .chat-image { max-width: 100%; border-radius: 10px; display: block; }
        .message-bubble.has-image .content { padding: 5px; }
        #custom-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 1000; opacity: 0; transition: opacity 0.2s ease-in-out; }
        #custom-modal-overlay.visible { display: flex; opacity: 1; }
        #custom-modal { background-color: #fff; width: 280px; border-radius: 14px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; transform: scale(0.95); transition: transform 0.2s ease-in-out; }
        #custom-modal-overlay.visible #custom-modal { transform: scale(1); }
        .custom-modal-header { padding: 16px; font-size: 17px; font-weight: 600; text-align: center; }
        .custom-modal-body { padding: 0 16px 16px; text-align: center; font-size: 14px; color: #333; line-height: 1.5; }
        .custom-modal-body p { margin: 0; margin-bottom: 12px; }
        .custom-modal-body input { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; }
        .custom-modal-footer { border-top: 1px solid #dbdbdb; display: flex; }
        .custom-modal-footer button { flex: 1; background: none; border: none; padding: 12px; font-size: 17px; cursor: pointer; color: var(--accent-color); }
        .custom-modal-footer button:first-child { border-right: 1px solid #dbdbdb; }
        .custom-modal-footer .confirm-btn { font-weight: 600; }
        .custom-modal-footer .confirm-btn.btn-danger { color: #ff3b30; }
        #preset-actions-modal .custom-modal-footer { flex-direction: column; }
        #preset-actions-modal .custom-modal-footer button { width: 100%; border: none; border-bottom: 1px solid #dbdbdb; padding: 14px; font-size: 18px; }
        #preset-actions-modal .custom-modal-footer button:last-child { border-bottom: none; }
        .custom-multiselect { position: relative; user-select: none; }
        .select-box { display: flex; align-items: center; width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; background-color: #fff; cursor: pointer; }
        .select-box .selected-options-text { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
        .select-box .arrow-down { margin-left: auto; font-size: 10px; color: var(--text-secondary); transition: transform 0.2s; }
        .select-box.expanded .arrow-down { transform: rotate(180deg); }

.checkboxes-container {
    display: none;
    position: absolute;
    /* 核心修改：不再使用 top，而是用 margin-top 来创造间距，更稳定 */
    top: 100%; 
    margin-top: 5px; /* <-- 新增：向下推开5像素的距离 */
    left: 0;
    right: 0;
    max-height: 150px;
    overflow-y: auto;
    overflow-x: hidden;
    background-color: #fff;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    z-index: 101;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

        .checkboxes-container.visible { display: block; }
        .checkboxes-container label { display: block; padding: 10px 12px; cursor: pointer; font-weight: normal; color: var(--text-primary); }

.checkboxes-container label {
    display: block;
    padding: 12px 15px; /* <-- 修改：增加了上下和左右的内边距，让每一行更高更宽 */
    cursor: pointer;
    font-weight: normal;
    color: var(--text-primary);
    font-size: 15px; /* <-- 新增：将字体大小从默认值放大到15px */
}

        .checkboxes-container input { margin-right: 10px; vertical-align: middle; }
        .bg-upload-container { display: flex; align-items: center; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .bg-preview-img { max-width: 120px; max-height: 80px; border-radius: 8px; border: 1px solid var(--border-color); object-fit: cover; display: none; }
        #remove-bg-btn { padding: 8px 12px; border: 1px solid #ff3b30; color: #ff3b30; background-color: #fff; border-radius: 5px; cursor: pointer; font-size: 14px; display: none; }
        .message-bubble.is-ai-image .content { padding: 5px; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
        .ai-generated-image { max-width: 180px; border-radius: 12px; display: block; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
        .ai-generated-image:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .voice-message-body { display: flex; align-items: center; cursor: pointer; padding: 8px 12px; min-width: 80px; max-width: 200px; }
        .message-bubble.user .voice-message-body { color: #1a3d00; flex-direction: row-reverse; }
        .message-bubble.ai .voice-message-body { color: var(--text-primary); }
        .voice-waveform { display: flex; align-items: center; height: 20px; gap: 2px; flex-grow: 1; margin: 0 10px; }
        .voice-waveform div { width: 3px; background-color: currentColor; border-radius: 2px; animation: wave-quiet 1.5s ease-in-out infinite; }
        @keyframes wave-quiet { 0%, 100% { height: 2px; } 50% { height: 10px; } }
        .voice-waveform div:nth-child(2) { animation-delay: 0.2s; } .voice-waveform div:nth-child(3) { animation-delay: 0.4s; } .voice-waveform div:nth-child(4) { animation-delay: 0.6s; } .voice-waveform div:nth-child(5) { animation-delay: 0.8s; }
.voice-duration {
    /* --- 核心修正 --- */
    font-size: var(--chat-font-size, 13px);
    /* --- 修正结束 --- */
    font-weight: 500;
    color: var(--text-secondary);
}
        .message-bubble.user .voice-duration { color: #3e6224; }

/* ▼▼▼ 用这块代码替换掉你原来的 .message-bubble .content 样式 ▼▼▼ */
/* 通用内容区样式，为时间戳和字体大小做准备 */
.message-bubble .content {
    position: relative;
    font-size: var(--chat-font-size, 16px);
    padding: 8px 12px;
    line-height: 1.5;
    word-break: break-word; /* 核心修正: 强制长单词或URL换行，防止撑破气泡 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */

        /* === 气泡主题样式 === */
        .message-bubble.user .content { background-color: rgba(255, 255, 255, 0.75); color: #585858; border-radius: 8px 2px 8px 8px; }
        .message-bubble.ai .content { background-color: rgba(255, 255, 255, 0.7); color: #585858; border-radius: 2px 8px 8px 8px; }
      
.message-bubble::after {
    content: "";
    position: absolute;
    width: 20px;  
    height: 20px; 
    background-size: contain;
    background-repeat: no-repeat;
    opacity: 1; 
    z-index: 1;
}
      
        #chat-messages[data-theme="pink_blue"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_blue"] .message-bubble.ai .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.user .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.user .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.ai .content { background-color: #fffde4; color: #5C4033; }
        #chat-messages[data-theme="black_white"] .message-bubble.user .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="black_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #343a40; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.user .content { background-color: #FFEB3B; color: #5D4037; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="red_black"] .message-bubble.user .content { background-color: #C62828; color: #FFFFFF; }
        #chat-messages[data-theme="red_black"] .message-bubble.ai .content { background-color: #212121; color: #FFFFFF; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.user .content { background-color: #A0D2EB; color: #153243; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.ai .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="gray_white"] .message-bubble.user .content { background-color: #e9ecef; color: #495057; }
        #chat-messages[data-theme="gray_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="blue_green"] .message-bubble.user .content { background-color: #d1ecf1; color: #0c5460; }
        #chat-messages[data-theme="blue_green"] .message-bubble.ai .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="pink_white"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="pink_black"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="pink_green"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_green"] .message-bubble.ai .content { background-color: #C8E6C9; color: #1B5E20; }
        #chat-messages[data-theme="green_black"] .message-bubble.user .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="green_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }

        #transfer-btn { font-weight: bold; }
        #transfer-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1001; }
        #transfer-modal.visible { display: flex; }
        .transfer-content { background-color: #fff0f5; border-radius: 20px; width: 290px; padding: 20px; box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3); text-align: center; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" opacity="0.05"><path d="M50,4 C35,4 28,15 28,24 C28,33 35,32 35,40 C35,48 28,49 28,57 C28,65 35,66 35,74 C35,82 28,83 28,91 C28,99 35,100 50,100 C65,100 72,99 72,91 C72,83 65,82 65,74 C65,66 72,65 72,57 C72,49 65,48 65,40 C65,32 72,33 72,24 C72,15 65,4 50,4 Z" fill="%23FF69B4"/></svg>'); background-repeat: no-repeat; background-position: top right; background-size: 80px; }
        .transfer-header { font-size: 20px; font-weight: bold; color: #a35c7b; margin-bottom: 20px; }
        .transfer-input-group { margin-bottom: 15px; text-align: left; }
        .transfer-input-group label { display: block; font-size: 14px; color: #ff85b3; margin-bottom: 5px; font-weight: 500; }
        .transfer-input-group input { width: 100%; padding: 12px; border-radius: 10px; border: 2px solid #ffcce0; background-color: #fff; font-size: 16px; box-sizing: border-box; }
        .transfer-input-group input:focus { border-color: #ff85b3; outline: none; }
        .transfer-actions { display: flex; justify-content: space-between; gap: 10px; }
        .transfer-actions button { flex: 1; padding: 12px; border: none; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: transform 0.2s; }
        .transfer-actions button:active { transform: scale(0.95); }
        #transfer-cancel-btn { background-color: #ffdde9; color: #a35c7b; }
        #transfer-confirm-btn { background-color: #ff85b3; color: white; }
        .message-bubble.is-transfer .content { padding: 0; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; cursor: pointer; }
        .transfer-card { width: 200px; border-radius: 12px; padding: 12px; color: white; position: relative; overflow: hidden; }
        .transfer-card::before { content: '🐾'; position: absolute; right: 10px; top: 5px; font-size: 30px; opacity: 0.2; transform: rotate(15deg); }
        .message-bubble.user .transfer-card { background: radial-gradient(circle at top left, #ffc5d5, #ff85b3); }
        .message-bubble.ai .transfer-card { background: radial-gradient(circle at top left, #a1c4fd, #c2e9fb); }
        .transfer-title { font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 6px; margin-bottom: 8px; }
        .transfer-amount { font-size: 28px; font-weight: bold; margin-bottom: 4px; }
        .transfer-note { font-size: 13px; opacity: 0.9; border-top: 1px solid rgba(255,255,255,0.3); padding-top: 8px; margin-top: 8px; word-break: break-all; }
        
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        #listen-together-btn img.rotating { animation: spin 2s linear infinite; }
        #listen-together-btn img.paused { animation-play-state: paused; }
        #music-player-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; display: none; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.3); }
        #music-player-overlay.visible { display: flex; }
        .music-player-window { width: 90%; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 20px; box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); border: 1px solid rgba(255, 255, 255, 0.18); padding: 25px; display: flex; flex-direction: column; align-items: center; color: #1f1f1f; position: relative; }
        #music-playlist-btn { position: absolute; top: 15px; right: 15px; font-size: 24px; cursor: pointer; color: #333; }
        #music-time-counter { font-size: 12px; color: #555; margin-bottom: 20px; }
        #music-player-song-title { font-size: 20px; font-weight: 600; margin-bottom: 5px; text-align: center; }
        #music-player-artist { font-size: 14px; color: #666; margin-bottom: 25px; }
        .music-controls { display: flex; align-items: center; justify-content: center; gap: 20px; width: 100%; margin-bottom: 30px; }
        .music-controls button { background: none; border: none; font-size: 16px; font-weight: bold; cursor: pointer; color: #333; width: 44px; height: 44px; display: flex; justify-content: center; align-items: center; transition: transform 0.2s; }
        .music-controls button:active { transform: scale(0.9); }
        .music-controls .play-pause-btn { font-size: 24px; width: 60px; height: 60px; border-radius: 50%; background-color: rgba(0,0,0,0.05); }
        .music-bottom-actions { display: flex; justify-content: space-between; width: 100%; }
        .music-bottom-actions button { flex: 1; padding: 12px 0; border: none; border-radius: 10px; font-size: 15px; font-weight: 500; cursor: pointer; }
        #music-exit-btn { background-color: rgba(255, 100, 100, 0.7); color: white; margin-right: 5px; }
        #music-return-btn { background-color: rgba(0, 123, 255, 0.7); color: white; margin-left: 5px; }
        
        #music-playlist-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 70%; background-color: rgba(242, 242, 247, 0.9); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 210; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #music-playlist-panel.visible { transform: translateY(0); visibility: visible; }
        .playlist-header { padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); font-weight: 600; }
        .playlist-header .panel-btn { font-size: 16px; cursor: pointer; color: var(--accent-color); }
        .playlist-body { flex-grow: 1; overflow-y: auto; padding: 10px 0; }
        .playlist-item { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; border-bottom: 1px solid #eee; }
        .playlist-item.playing { background-color: rgba(0, 123, 255, 0.1); }
        .playlist-item-info .title { font-weight: 500; font-size: 15px; }
        .playlist-item-info .artist { font-size: 12px; color: #666; }
        .playlist-item .delete-track-btn { color: #ff3b30; font-size: 20px; padding: 5px; }

        /* Persona Library Styles */
        #persona-library-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; padding: 10px; }
        .persona-preset-item { aspect-ratio: 1 / 1; border-radius: 12px; background-size: cover; background-position: center; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; border: 1px solid rgba(0,0,0,0.1); }
        .persona-preset-item:hover { transform: scale(1.08); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .modal-header .action-button { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; background: none; border: none; padding: 5px; }
        
        /* Battery Alert Modal Styles */
        #battery-alert-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); display: none; justify-content: center; align-items: center; z-index: 2000; opacity: 0; transition: opacity 0.3s ease; }
        #battery-alert-modal.visible { display: flex; opacity: 1; }
        .battery-alert-content { background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); width: 280px; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); text-align: center; padding: 20px; cursor: pointer; transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        #battery-alert-modal.visible .battery-alert-content { transform: scale(1); }
        #battery-alert-image { max-width: 100px; max-height: 100px; margin-bottom: 15px; }
        #battery-alert-text { font-size: 16px; font-weight: 500; color: #333; margin: 0; line-height: 1.4; }

/* 这是你要添加的新样式 */
#font-preview {
    transition: font-family 0.3s ease;}

/* === 聊天列表界面新增样式 (这是新添加的) === */
#chat-list-screen {
}

.chat-list-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0.2s;
    z-index: 1; 
}
.chat-list-view.active {
    opacity: 1;
    visibility: visible;
    z-index: 2; 
}

#messages-view {
    overflow-y: auto; 
}

/* 底部导航栏样式 */
#chat-list-bottom-nav {
    position: absolute; /* 让它固定在底部 */
    bottom: 0;
    left: 0;
    width: 100%;
    z-index: 15; /* 确保它在视图之上 */
    display: flex;
    border-top: 1px solid var(--border-color);
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

.nav-item {
    flex: 1;
    text-align: center;
    padding: 12px 0;
    font-size: 14px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: color 0.2s;
}

.nav-item.active {
    color: var(--accent-color);
    font-weight: 600;
}

/* === 动态界面 (QZone) 样式 (这是新添加的) === */
#qzone-screen {
    background-color: #f0f2f5;
}

.qzone-header {
    /* position: absolute;  <-- 把这个改成 relative */
    position: relative;
    z-index: 10; /* z-index 保持，或者可以更高 */
    flex-shrink: 0; /* 防止被压缩 */
    padding: 15px 20px;
    padding-top: 45px;
    background-color: rgba(247, 247, 247, 0.7); 
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    font-weight: 600;
    text-align: center;
}

.qzone-header .back-btn {
    font-size: 24px;
    cursor: pointer;
    color: var(--accent-color);
}

.qzone-header span:nth-child(2) { /* "好友动态"文字 */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}

.qzone-content {
    flex-grow: 1;
    overflow-y: auto;
    /* padding-top: 80px;  <-- 删除这个，因为header不再是absolute了 */
}

.qzone-profile-header {
    position: relative;
    margin-bottom: 20px;
}

.qzone-banner-container {
    width: 100%;
    height: 180px; /* 背景板高度 */
    position: relative;
}

#qzone-banner-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.qzone-user-info {
    position: absolute;
    bottom: -30px; /* 让头像和昵称区域向下偏移，一半在背景板内，一半在外 */
    left: 20px;
    display: flex;
    align-items: flex-end; /* 让昵称和头像底部对齐 */
    gap: 10px;
}

.qzone-avatar-container {
    position: relative;
}

#qzone-avatar-img {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    object-fit: cover;
}

#qzone-nickname {
    font-size: 18px;
    font-weight: 600;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    padding-bottom: 5px; /* 微调位置 */
}

/* 编辑按钮的通用样式 */
.qzone-edit-btn {
    position: absolute;
    background-color: rgba(0,0,0,0.4);
    color: white;
    border: none;
    border-radius: 10px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

#change-qzone-banner-btn {
    bottom: 10px;
    right: 10px;
}

#change-qzone-avatar-btn {
    bottom: 5px;
    right: 5px;
}

#change-qzone-nickname-btn {
    font-size: 14px;
    padding: 2px 6px;
    margin-left: 5px; /* 与昵称的间距 */
    color: var(--text-primary);
    background-color: rgba(255,255,255,0.7);
    border-radius: 5px;
    position: relative; /* 脱离flex布局的对齐 */
    bottom: 5px; /* 微调垂直位置 */
}

/* === 让编辑功能更“隐形” === */
#qzone-banner-container,
#qzone-avatar-container,
#qzone-nickname {
    cursor: pointer; /* 鼠标悬停时显示为可点击手势 */
    transition: opacity 0.2s;
}
#qzone-banner-container:hover,
#qzone-avatar-container:hover,
#qzone-nickname:hover {
    opacity: 0.85; /* 悬停时稍微变暗，给用户反馈 */
}
/* 隐藏掉旧的、独立的编辑按钮 */
.qzone-edit-btn {
    display: none;
}

/* === 控制 Header 和 Bottom Nav 的显隐 === */
/* 默认隐藏动态界面的 Header */
#qzone-screen .qzone-header {
    display: none;
}
/* 当动态视图激活时，显示它的Header */
#qzone-screen.active .qzone-header {
    display: flex;
}

/* 当进入动态视图时，隐藏主Header和底部导航栏 */
#chat-list-screen.in-qzone-view > .header,
#chat-list-screen.in-qzone-view > #chat-list-bottom-nav {
    display: none;
}

.chat-list-item:first-child,
.chat-group-container:first-child {
    margin-top: 10px; 
}

/* ▲▲▲ 新样式替换结束 ▲▲▲ */

/* ▼▼▼ 把所有这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 动态功能栏样式 === */
.qzone-actions-bar {
    display: flex;
    justify-content: space-around;
    padding: 10px 0;
    margin: 40px 15px 15px 15px; /* 上边距更大，为浮动的头像留出空间 */
    background-color: var(--secondary-bg);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

.action-item {
    flex: 1;
    text-align: center;
    font-size: 15px;
    font-weight: 500;
    color: var(--text-primary);
    cursor: pointer;
    padding: 8px 0;
    position: relative;
}

/* 用伪元素创建分隔线 */
.action-item:not(:last-child)::after {
    content: '';
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 1px;
    height: 20px;
    background-color: var(--border-color);
}

/* === 动态帖子列表样式 === */
#qzone-posts-list {
    padding: 0 15px 20px 15px; /* 左右和底部留出边距 */
    display: flex;
    flex-direction: column;
    gap: 20px; /* 帖子之间的间距 */
}

.qzone-post-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
}

.post-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.post-header .post-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
}

.post-info {
    display: flex;
    flex-direction: column;
}

.post-info .post-nickname {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-primary);
}

.post-info .post-timestamp {
    font-size: 12px;
    color: var(--text-secondary);
}

.post-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap; /* 让换行符生效 */
    word-break: break-word; /* 防止长单词溢出 */
}

/* ▲▲▲ 新样式结束 ▲▲▲ */

/* ▼▼▼ 新样式粘贴到末尾 ▼▼▼ */

/* === 发布动态模态框样式 === */
#post-public-text {
    min-height: 80px; /* 确保文本域有足够的高度 */
    resize: vertical;
}

.post-image-preview-container {
    position: relative;
    width: 100%;
    aspect-ratio: 16 / 9; /* 保持16:9的预览比例 */
    background-color: #f0f2f5;
    border: 2px dashed var(--border-color);
    border-radius: 8px;
    margin-bottom: 15px;
    display: none; /* 默认隐藏 */
    justify-content: center;
    align-items: center;
}
.post-image-preview-container.visible {
    display: flex; /* 上传后显示 */
}

#post-image-preview {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    border-radius: 6px;
}

#post-remove-image-btn {
    position: absolute;
    top: -10px;
    right: -10px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background-color: #ff3b30;
    color: white;
    border: 2px solid white;
    font-size: 16px;
    line-height: 20px;
    text-align: center;
    cursor: pointer;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
}

.post-image-upload-options {
    display: flex;
    gap: 10px;
}

.post-image-upload-options button {
    flex: 1;
    margin-top: 0;
}

/* ▲▲▲ 新样式结束 ▲▲▲ */

/* ▼▼▼ 新样式 ▼▼▼ */

/* === 发布动态模态框 - 模式切换样式 === */
.post-mode-switcher {
    display: flex;
    margin-bottom: 20px;
    background-color: #e9ecef;
    border-radius: 8px;
    padding: 4px;
}

.mode-btn {
    flex: 1;
    padding: 8px;
    border: none;
    background-color: transparent;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

.mode-btn.active {
    background-color: var(--secondary-bg);
    color: var(--text-primary);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.post-mode-content {
    display: none; /* 默认都隐藏 */
}

.post-mode-content.active {
    display: block; /* 激活的才显示 */
}

/* ▲▲▲ 新样式结束 ▲▲▲ */

/* === 相册页面背景色 === */
#album-screen {
    background-color: #f0f2f5; /* 使用一个柔和的浅灰色，比纯白更护眼 */
}

/* === 相册页面网格布局 === */
#album-grid-page {
    padding: 15px;
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* 每行显示2个相册 */
    gap: 15px;
}

/* === 相册项目样式 (美化) === */
.album-item {
    display: flex;
    flex-direction: column;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border-radius: 8px; /* 给整个项目也加个圆角 */
}

.album-item:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 15px rgba(0,0,0,0.1);
}

.album-cover {
    aspect-ratio: 1 / 1; /* 保持封面为正方形 */
    background-size: cover;
    background-position: center;
    border-radius: 8px;
    margin-bottom: 8px;
    background-color: #f0f2f5; /* 封面加载前的占位颜色 */
}

.album-info {
    text-align: center;
}

.album-name {
    font-weight: 500;
    margin: 0 0 4px 0;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 防止长名字换行 */
}

.album-count {
    font-size: 12px;
    color: var(--text-secondary);
    margin: 0;
}

/* ▲▲▲ 新的 CSS 粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 相册照片详情页 === */
#album-photos-screen {
    background-color: #f0f2f5;
}

#photos-grid-page {
    padding: 15px;
    display: grid;
    /* 每行显示3张照片，并保持间距 */
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
}

.photo-item {
    position: relative; /* 为了定位删除按钮 */
    aspect-ratio: 1 / 1; /* 保持照片为正方形 */
    border-radius: 6px;
    overflow: hidden; /* 防止图片溢出圆角 */
    background-color: #e9ecef; /* 图片加载前的占位符颜色 */
}

.photo-item .photo-thumb {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 保证图片填满容器且不变形 */
    cursor: pointer;
}

/* 删除按钮的样式 */
.photo-item .photo-delete-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 22px;
    height: 22px;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 16px;
    line-height: 22px;
    text-align: center;
    cursor: pointer;
    opacity: 0; /* 默认隐藏 */
    transition: opacity 0.2s ease;
}

/* 鼠标悬停在照片上时显示删除按钮 */
.photo-item:hover .photo-delete-btn {
    opacity: 1;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* === 图片查看器模态框样式 === */
#photo-viewer-modal {
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 1002;
    -webkit-backdrop-filter: blur(5px);
    backdrop-filter: blur(5px);
}

.photo-viewer-content {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
}

#photo-viewer-image {
    max-width: 90vw;  /* 图片最大宽度为视口的90% */
    max-height: 85vh; /* 图片最大高度为视口的85% */
    object-fit: contain;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    /* 为图片的切换添加一点平滑的淡入淡出效果 */
    transition: opacity 0.2s ease-in-out;
}

/* 关闭按钮 */
#photo-viewer-close-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    background: none;
    border: none;
    color: white;
    font-size: 40px;
    font-weight: 200;
    cursor: pointer;
    line-height: 1;
    text-shadow: 0 0 5px black;
}

/* 左右导航箭头 */
#photo-viewer-modal .nav-arrow {
    position: absolute; /* 现在我们用绝对定位来控制箭头 */
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    font-size: 50px; /* 在手机屏幕上，可以稍微小一点 */
    font-weight: 100;
    cursor: pointer;
    padding: 10px; /* 调整内边距 */
    user-select: none;
    transition: color 0.2s;
    z-index: 1003; /* 确保箭头在最上层 */
}

#photo-viewer-prev-btn {
    left: 5px; /* 定位左箭头 */
}

#photo-viewer-next-btn {
    right: 5px; /* 定位右箭头 */
}

#photo-viewer-modal .nav-arrow:hover {
    color: white;
}

/* 当箭头被禁用时（比如第一张或最后一张） */
#photo-viewer-modal .nav-arrow:disabled {
    color: rgba(255, 255, 255, 0.2);
    cursor: default;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* ▼▼▼ 请用这块新CSS替换掉上一版的交互区CSS ▼▼▼ */

/* === 帖子内容区 - 相对定位容器 === */
/* === 帖子内容区 === */
.post-main-content {
    /* 它现在只是一个普通的内容容器，不再需要特殊样式了 */
}

/* === 帖子互动图标区 (新样式) === */
.post-feedback-icons {
    display: flex;
    justify-content: flex-end; /* 让图标靠右对齐 */
    align-items: center;
    gap: 12px;
    padding: 8px 0; /* 核心修改：给图标区域上下各8px的留白 */
}

.action-icon {
    cursor: pointer;
    color: var(--text-secondary); /* 默认灰色 */
    transition: all 0.2s ease-in-out;
}

.action-icon svg {
    width: 22px;
    height: 22px;
    fill: none;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
}

/* 图标激活(点赞/收藏后)的样式 */
.action-icon.active {
    color: #ff5252; /* 激活后变红色 */
    transform: scale(1.1); /* 轻微放大 */
}

.action-icon.active.favorite {
    color: #ffc107; /* 收藏用黄色 */
}

.action-icon.active svg {
    fill: currentColor; /* 激活后填充颜色 */
}

/* 点击时的动画效果 */
.animate-like {
    animation: like-bounce 0.4s ease-in-out;
}

@keyframes like-bounce {
    0%   { transform: scale(1); }
    25%  { transform: scale(0.8); }
    50%  { transform: scale(1.2); }
    75%  { transform: scale(1.05); }
    100% { transform: scale(1.1); }
}


/* === 帖子底部评论区样式 (现在是独立部分) === */
.post-footer {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #f0f0f0; /* 用一条浅色线分隔 */
    display: flex;
    align-items: center;
    gap: 8px; /* 调整整体间距 */
}

/* 评论区容器 */
.comment-section {
    flex-grow: 1; /* 占据大部分空间 */
    display: flex;
    align-items: center;
    gap: 8px;
}

.comment-section .comment-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

.comment-section .comment-input {
    width: 100%;
    padding: 8px 12px;
    border: none;
    background-color: #f0f2f5;
    border-radius: 14px;
    font-size: 13px;
    outline: none;
}

/* 新增的发送按钮样式 */
.comment-send-btn {
    flex-shrink: 0; /* 防止被压缩 */
    padding: 8px 15px;
    border: none;
    background-color: var(--accent-color);
    color: white;
    border-radius: 14px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 未读消息小红点通用样式 === */
.unread-indicator {
    position: absolute;
    top: -8px;      
    right: -15px;    
    min-width: 18px;
    height: 18px;
    padding: 0 5px;
    background-color: #ff3b30;
    color: white;
    font-size: 11px;
    font-weight: bold;
    line-height: 18px;
    text-align: center;
    border-radius: 9px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    display: none;
    z-index: 1;
}

/* 聊天界面返回按钮上的小红点 (只显示点，不显示数字) */
.back-btn-indicator {
    top: 0;
    right: -8px; /* 放到返回箭头右上角 */
    width: 10px;
    height: 10px;
    min-width: 10px;
    padding: 0;
    border-radius: 50%;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 评论列表容器 === */
.post-comments-container {
    padding: 10px 0; /* 上下留白 */
    display: flex;
    flex-direction: column;
    gap: 8px; /* 评论之间的间距 */
    font-size: 13px; /* 统一评论区字体大小 */
}

/* 每一条评论 */
.comment-item {
    line-height: 1.5;
}

/* 评论者的名字，加粗并使用主题色 */
.comment-item .commenter-name {
    font-weight: 600;
    color: var(--accent-color);
    cursor: pointer;
    margin-right: 5px; /* 和评论内容之间留点空隙 */
}

/* 评论内容 */
.comment-item .comment-text {
    color: var(--text-primary);
    word-break: break-word;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 帖子点赞区域样式 === */
.post-likes-section {
    display: flex;
    align-items: center;
    gap: 6px; /* 图标和文字的间距 */
    padding: 8px 10px; /* 内边距 */
    font-size: 13px;
    color: var(--accent-color); /* 使用主题蓝色 */
    background-color: #f0f5fa; /* 给一个淡淡的背景色 */
    border-top: 1px solid #e9eef3;
    border-bottom: 1px solid #e9eef3;
    margin-top: 5px; /* 和上方的图标保持一点距离 */
}

.post-likes-section .like-icon {
    width: 16px;
    height: 16px;
    fill: currentColor; /* 让SVG图标继承父元素的颜色 */
    flex-shrink: 0; /* 防止图标被压缩 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === @提及 弹出菜单样式 === */
.at-mention-popup {
    position: absolute; /* 相对于父元素定位 */
    bottom: 100%; /* 显示在输入框的上方 */
    left: 40px; /* 和输入框左侧对齐 (考虑了头像宽度) */
    width: calc(100% - 40px); /* 宽度和输入框差不多 */
    max-height: 120px;
    overflow-y: auto;
    background-color: var(--secondary-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
    z-index: 10;
    display: none; /* 默认隐藏 */
}

.at-mention-item {
    padding: 8px 12px;
    font-size: 14px;
    cursor: pointer;
    color: var(--text-primary);
    border-bottom: 1px solid #f0f0f0;
}

.at-mention-item:last-child {
    border-bottom: none;
}

.at-mention-item:hover {
    background-color: #f5f5f5;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* ▼▼▼ 请用下面这段【新样式】替换掉你现有的 #favorites-list 样式 ▼▼▼ */

/* 让收藏视图成为一个flex容器, 从上到下排列 */
#favorites-view {
    display: flex;
    flex-direction: column;
}

/* 确保收藏页的header高度固定，不被压缩 */
#favorites-view > .header {
    flex-shrink: 0;
}

/* === 收藏列表样式 (修正后) === */
#favorites-list {
    flex-grow: 1; 
    overflow-y: auto; 
    overflow-x: hidden; /* <-- 新增这行，禁止水平滚动 */
    padding: 15px; 
    display: flex;
    flex-direction: column;
    gap: 15px; 
}

/* ▲▲▲ 替换结束 ▲▲▲ */

.favorite-item-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    position: relative; /* 为了定位删除按钮 */
}

/* 卡片头部，包含头像、名字和来源 */
.fav-card-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.fav-card-header .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
}

.fav-card-header .info {
    flex-grow: 1;
}

.fav-card-header .name {
    font-weight: 600;
    font-size: 15px;
}

.fav-card-header .source {
    font-size: 12px;
    color: var(--text-secondary);
}

/* 卡片内容 */
.fav-card-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap;
    word-break: break-word;
}

.fav-card-content .chat-image {
    margin-top: 8px; /* 图片和文字的间距 */
}

/* 删除按钮 */
.fav-delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    background: #f0f2f5;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    font-size: 18px;
    color: var(--text-secondary);
    line-height: 28px;
    text-align: center;
}

.fav-delete-btn:hover {
    background-color: #e9ecef;
    color: #ff3b30;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 搜索栏样式 === */
.search-bar-container {
    padding: 10px 15px;
    background-color: #f9f9f9; /* 和列表背景色保持一致 */
    position: relative; /* 为了定位清除按钮 */
    flex-shrink: 0;
}

#favorites-search-input {
    width: 100%;
    padding: 10px 30px 10px 15px; /* 右侧留出清除按钮的位置 */
    font-size: 14px;
    border: 1px solid var(--border-color);
    border-radius: 18px; /* 圆角矩形，更现代化 */
    background-color: var(--secondary-bg);
    box-sizing: border-box;
    outline: none;
}
#favorites-search-input:focus {
    border-color: var(--accent-color);
}

.search-clear-btn {
    position: absolute;
    right: 25px;
    top: 50%;
    transform: translateY(-50%);
    background: #ccc;
    color: white;
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    font-size: 16px;
    cursor: pointer;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* === 聊天界面多选操作栏优化 === */
#chat-interface-screen .header .selection-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

#chat-interface-screen .selection-controls .action-btn {
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    padding: 5px;
}

/* === 收藏页面多选模式样式 === */
#favorites-view.selection-mode .favorite-item-card {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

/* 选择框的样式 */
.favorite-item-card::before {
    content: '';
    position: absolute;
    left: -25px; /* 把它放在卡片左边外面 */
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    background-color: white;
    transition: all 0.2s ease;
    opacity: 0; /* 默认隐藏 */
}

/* 进入选择模式时，卡片向右移动，露出选择框 */
#favorites-view.selection-mode .favorite-item-card {
    transform: translateX(35px);
}
#favorites-view.selection-mode .favorite-item-card::before {
    opacity: 1;
}

/* 选中后的样式 */
#favorites-view.selection-mode .favorite-item-card.selected::before {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}

/* 底部操作栏 (终极修正版) */
#favorites-action-bar {
    position: absolute; /* ★ 改为 absolute，相对于 #phone-screen 定位 */
    bottom: 0;
    left: 0;
    right: 0;           /* ★ 新增 right: 0，和 left: 0 一起撑满宽度 */
    width: auto;        /* ★ 改为 auto，让 left/right 决定宽度 */
    padding: 10px 15px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom)); /* 适配iPhone底部安全区 */
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color);
    box-sizing: border-box;
    z-index: 5;
    display: none;
    /* max-width 已经不需要了，因为父元素已经限制了宽度 */
}

#favorites-action-bar .action-bar-btn {
    width: 100%;
    padding: 12px;
    border-radius: 8px;
    border: none;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    background-color: #ff3b30;
    color: white;
}

/* === 【修正】聊天界面头部控件切换逻辑 === */

/* 默认状态：隐藏多选控件 */
#chat-interface-screen .header .selection-controls {
    display: none;
}

/* 默认状态：显示默认控件，并让它撑满整个头部 */
#chat-interface-screen .header .default-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

/* 当进入多选模式时：隐藏默认控件 */
#chat-interface-screen.selection-mode .header .default-controls {
    display: none;
}

/* 当进入多选模式时：显示多选控件，并让它撑满整个头部 */
#chat-interface-screen.selection-mode .header .selection-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 修正：放大所有主要的“+”号按钮 === */
#add-chat-btn,
#add-world-book-btn,
#create-album-btn-page {
    font-size: 28px;   /* 显著增大字体大小，使其视觉上与旁边的图标匹配 */
    font-weight: 300;  /* 使用更细的字重，让加号看起来更清爽，不显粗笨 */
    position: relative;/* 允许进行位置微调 */
    top: -1px;         /* 字体放大后，通常需要稍微向上移动一点，使其视觉上更居中 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 预览区容器样式 */
#settings-preview-area {
    width: 100%;
    height: 180px; /* 给一个固定的高度 */
    background-color: #f0f2f5;
    border-radius: 8px;
    padding: 15px;
    box-sizing: border-box;
    overflow: hidden; /* 防止内容溢出 */
    display: flex;
    flex-direction: column;
    gap: 10px; /* 预览气泡之间的间距 */
    border: 1px solid var(--border-color);
    position: relative; /* 为了定位背景 */
}

/* 预览区的背景，可以和真实聊天界面同步 */
#settings-preview-area::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-size: cover;
    background-position: center;
    z-index: 1;
    opacity: 0.8;
}

/* 让预览气泡在背景之上 */
#settings-preview-area .message-wrapper {
    position: relative;
    z-index: 2;
}

/* 预览区内使用的头像要小一点 */
#settings-preview-area .message-bubble .avatar {
    width: 30px;
    height: 30px;
}

#settings-preview-area .message-bubble .timestamp {
    display: none; /* 预览区不需要显示时间戳 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.existing-group-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    background-color: #f9f9f9;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.existing-group-item .group-name {
    font-weight: 500;
}

.existing-group-item .delete-group-btn {
    color: #ff3b30;
    font-size: 20px;
    cursor: pointer;
    padding: 5px;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.chat-group-container {
    border-bottom: 1px solid var(--border-color);
}
.chat-group-container:first-child {
    border-top: 1px solid var(--border-color);
}

.chat-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    cursor: pointer;
    background-color: #f7f7f7;
}

.chat-group-header .arrow {
    font-size: 14px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}

.chat-group-header.collapsed .arrow {
    transform: rotate(-90deg);
}

.chat-group-header .group-name {
    font-weight: 600;
    font-size: 15px;
}

.chat-group-content {
    max-height: 1000px; /* 一个足够大的值 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}

.chat-group-content.collapsed {
    max-height: 0;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* 格式助手按钮的容器 */
.format-helpers {
    display: flex;
    gap: 10px;
    margin-bottom: 15px; /* 与下方的文本框拉开距离 */
    flex-wrap: wrap; /* 如果按钮太多可以换行 */
}

/* 单个格式助手按钮的样式 */
.format-btn {
    background-color: #e9ecef;
    color: var(--text-primary);
    border: none;
    padding: 6px 12px;
    border-radius: 16px; /* 胶囊形状，更友好 */
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s;
}

.format-btn:hover {
    background-color: #dcdfe3;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* “…”按钮的样式 */
.post-actions-btn {
    margin-left: auto; /* 关键：让它自动靠到最右边 */
    padding: 5px 10px;
    font-size: 20px;
    font-weight: bold;
    color: var(--text-secondary);
    cursor: pointer;
    border-radius: 50%;
    line-height: 1;
}
.post-actions-btn:hover {
    background-color: #f0f0f0;
}

/* 动态编辑模态框的样式 (它将复用现有的操作菜单样式) */
#post-actions-modal .custom-modal-footer button {
    width: 100%;
    border: none;
    border-bottom: 1px solid #dbdbdb;
    padding: 14px;
    font-size: 18px;
}
#post-actions-modal .custom-modal-footer button:last-child {
    border-bottom: none;
}
#post-actions-modal #cancel-post-action-btn {
    margin-top: 8px;
    border-radius: 8px;
    background-color: #f0f0f0;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* 统一重置转账卡片内所有文字的特效和颜色 */
#chat-messages .transfer-card .transfer-title,
#chat-messages .transfer-card .transfer-amount,
#chat-messages .transfer-card .transfer-note {
    text-shadow: none !important; /* 强制移除任何发光或阴影效果 */
    color: white !important;      /* 强制锁定文字颜色为白色 */
}

/* 分别锁定各自的字体大小和字重，防止被篡改 */
#chat-messages .transfer-card .transfer-title {
    font-size: 16px !important;
    font-weight: 600 !important;
}

#chat-messages .transfer-card .transfer-amount {
    font-size: 28px !important;
    font-weight: bold !important;
}

#chat-messages .transfer-card .transfer-note {
    font-size: 13px !important;
    opacity: 0.9 !important;
}

/* ▼▼▼ 这是新增的样式，用于修正所有头部标题的居中问题 ▼▼▼ */
.header > span:nth-child(2),
#chat-header-title {
    position: absolute;
    left: 50%;
    transform: translateX(calc(-50% - 2px)); /* 在-50%的基础上，再向左推2像素 */
    
    /* (可选但推荐) 防止长标题与两边按钮重叠 */
    max-width: 60%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
/* ▲▲▲ 粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】可视化消息编辑器样式 ▼▼▼ */
#message-editor-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.message-editor-block {
    background-color: #f9f9f9;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
}

.message-editor-block textarea {
    width: 100%;
    min-height: 60px;
    resize: vertical;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 8px;
    font-size: 14px;
    box-sizing: border-box;
}

.message-editor-block .format-helpers {
    margin-top: 8px;
    margin-bottom: 0; /* 覆盖默认的 margin-bottom */
}

.message-editor-block .delete-block-btn {
    float: right;
    margin-top: -5px;
    background: none;
    border: none;
    color: #ff3b30;
    font-size: 20px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】联系人选择器样式 ▼▼▼ */
.contact-picker-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
.contact-picker-item .checkbox {
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    margin-right: 15px;
    transition: all 0.2s ease;
}
.contact-picker-item.selected .checkbox {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}
.contact-picker-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}
.contact-picker-item .name {
    font-weight: 500;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】群成员管理界面样式 ▼▼▼ */
#member-management-list {
    padding: 0; /* 移除默认padding，让列表项撑满 */
}

.member-management-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
}

.member-management-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}

.member-management-item .name {
    flex-grow: 1;
    font-weight: 500;
}

.member-management-item .remove-member-btn {
    background-color: #ff3b30;
    color: white;
    border: none;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    font-size: 20px;
    line-height: 28px;
    text-align: center;
    cursor: pointer;
    flex-shrink: 0;
}

#member-management-actions {
    flex-shrink: 0;
    padding: 15px;
    border-top: 1px solid var(--border-color);
    background-color: #f7f7f7;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

#member-management-actions button {
    width: 100%;
    padding: 15px;
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
}
#member-management-actions #create-new-member-btn {
    background-color: #4cd964; /* 新建用绿色，以示区分 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外卖代付卡片样式 ▼▼▼ */
.message-bubble.is-waimai-request .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.waimai-card {
    width: 240px;
    border-radius: 12px;
    overflow: hidden;
    background-color: #fff;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

.waimai-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    border-bottom: 1px solid #f0f0f0;
}

.waimai-header .icon {
    width: 20px;
    height: 20px;
}

.waimai-header .title-group {
    display: flex;
    align-items: baseline;
    font-size: 14px;
    color: #8a8a8a;
}
.waimai-header .title-group .brand {
    font-weight: 600;
    color: #555;
    margin-right: 5px;
}
.waimai-header .title-group .separator {
    margin: 0 5px;
}

.waimai-catchphrase {
    font-size: 13px;
    color: #1f1f1f;
    padding: 12px;
}

.waimai-main {
    background-color: #FFD66B; /* 橙黄色背景 */
    padding: 12px;
    text-align: center;
}

.waimai-main .request-title {
    font-size: 12px;
    color: #856404;
    margin-bottom: 8px;
}

.waimai-main .payment-box {
    background-color: #fff;
    border-radius: 8px;
    padding: 15px 10px;
}

.waimai-main .payment-label {
    font-size: 13px;
    color: #8a8a8a;
}

.waimai-main .amount {
    font-size: 32px;
    font-weight: 700;
    color: #1f1f1f;
    margin: 4px 0 12px 0;
}

.waimai-main .countdown-label {
    font-size: 13px;
    color: #8a8a8a;
}
.waimai-main .countdown-timer {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    margin-left: 5px;
}
.waimai-main .countdown-timer span {
    background-color: #333;
    color: white;
    padding: 2px 4px;
    border-radius: 2px;
    font-weight: bold;
    font-size: 12px;
}

.waimai-details-btn {
    width: 100%;
    padding: 10px 0;
    margin-top: 15px;
    border: none;
    border-radius: 6px;
    background-color: #FFC33A;
    color: #49380a;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外卖响应状态样式 ▼▼▼ */

/* === 同意支付后的样式 === */
.message-bubble.status-paid .waimai-card {
    border: 2px solid #28a745; /* 绿色边框 */
}
.message-bubble.status-paid .waimai-main .request-title::before {
    content: '✅  ';
}
.message-bubble.status-paid .waimai-main .request-title {
    color: #155724;
    font-weight: 600;
    /* 重写 request-title 的内容 */
    content: "我已为您买单，请尽情享用吧～" !important;
    display: block;
    margin-bottom: 15px;
}

.message-bubble.status-paid .payment-box {
    display: none; /* 隐藏支付详情 */
}
.message-bubble.status-paid .waimai-details-btn {
    background-color: #28a745;
    color: white;
}

/* === 拒绝支付后的样式 === */
.message-bubble.status-rejected .waimai-card {
    border: 2px solid #dc3545; /* 红色边框 */
    opacity: 0.8;
}
.message-bubble.status-rejected .waimai-main {
    background-color: #e9ecef;
}
.message-bubble.status-rejected .waimai-main .request-title::before {
    content: '❌ ';
}
.message-bubble.status-rejected .waimai-main .request-title {
    color: #721c24;
    font-weight: 600;
    /* 重写 request-title 的内容 */
    content: "我拒绝了您的代付请求" !important;
    display: block;
    margin-bottom: 15px;
}
.message-bubble.status-rejected .payment-box {
    display: none; /* 隐藏支付详情 */
}
 .message-bubble.status-rejected .waimai-details-btn {
    background-color: #6c757d;
    color: white;
}

/* 强制重写 request-title 内容的技巧 */
.message-bubble[class*="status-"] .request-title {
    font-size: 0; /* 隐藏原始文本 */
}
.message-bubble[class*="status-"] .request-title::after {
    font-size: 14px; /* 让伪元素显示新文本 */
}
.message-bubble.status-paid .request-title::after {
    content: "我已为您买单，请尽情享用吧～";
}
.message-bubble.status-rejected .request-title::after {
    content: "我拒绝了您的代付请求";
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外卖请求的用户操作按钮样式 ▼▼▼ */
.waimai-user-actions {
    display: flex;
    gap: 10px;
    padding: 0 12px 12px 12px; /* 在卡片底部留出空间 */
    background-color: #fff;
}

.waimai-user-actions button {
    flex: 1;
    padding: 10px;
    border-radius: 8px;
    border: 1.5px solid;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.waimai-pay-btn {
    background-color: #28a745;
    border-color: #1f7a33;
    color: white;
}
.waimai-pay-btn:hover {
    background-color: #218838;
}

.waimai-decline-btn {
    background-color: #f8f9fa;
    border-color: #ced4da;
    color: #495057;
}
.waimai-decline-btn:hover {
    background-color: #e2e6ea;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* === 【新增】统一设置页面的背景色 (已修正) === */
#api-settings-screen,
#font-settings-screen,
#wallpaper-screen,
#memories-view,
#contact-picker-screen,
#member-management-screen,
#world-book-editor-screen {  
    background-color: var(--secondary-bg);
}

/* 确保这些页面的内容区能正确滚动 */
#api-settings-screen .form-container,
#font-settings-screen .form-container,
#wallpaper-screen .form-container {
    padding-top: 100px;
    margin-top: -80px;
    background-color: var(--secondary-bg);
}

/* 壁纸设置页面的预览区比较特殊，需要额外调整 */
#wallpaper-screen .form-container {
    align-items: center; /* 保持内容居中 */
}

/* ▼▼▼ 【全新】来电请求与视频通话界面样式 ▼▼▼ */

/* --- 来电请求模态框 --- */
#incoming-call-modal .incoming-call-content {
    background-color: rgba(40, 40, 40, 0.85);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 20px;
    width: 280px;
    padding: 30px 20px;
    text-align: center;
    color: white;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

.caller-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 12px;
    border: 3px solid rgba(255,255,255,0.5);
}

.caller-name {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 5px;
}

.caller-text {
    font-size: 14px;
    color: #ccc;
    margin-bottom: 30px;
}

.incoming-call-actions {
    display: flex;
    justify-content: space-around;
    align-items: center;
}

.action-button-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
}

.call-action-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    background-size: 50%;
    background-repeat: no-repeat;
    background-position: center;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}
.call-action-btn:active {
    transform: scale(0.9);
}

.call-action-btn.decline {
    background-color: #ff3b30;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
}

.call-action-btn.accept {
    background-color: #4cd964;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>');
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0.7); }
    70% { box-shadow: 0 0 0 15px rgba(76, 217, 100, 0); }
    100% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0); }
}

/* --- 视频通话界面 --- */
/* ▼▼▼ 请用这一整块【最终修正版】的代码，替换所有旧的 video-call 相关CSS ▼▼▼ */

/* 1. 通话屏幕总容器 (保持不变) */
#video-call-screen {
    background-color: #1c1c1e;
    color: white;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* 2. 顶部栏和底部控制栏 (保持不变) */
.video-call-top-bar {
    position: absolute;
    top: 0; left: 0; width: 100%;
    padding: 15px 20px;
    padding-top: 50px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
    z-index: 10;
    text-align: center;
    box-sizing: border-box;
    pointer-events: none;
}
#call-timer {
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 1px;
}
.video-call-controls {
    position: absolute;
    bottom: 0; left: 0; width: 100%;
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 20px;
    padding-bottom: 40px;
    background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
    z-index: 10;
    box-sizing: border-box;
}

/* 3. 参与者头像显示区 (保持不变) */
.video-call-avatar-area {
    flex-grow: 1; 
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    padding-top: 80px; /* 确保顶部有足够空间 */
    box-sizing: border-box;
    overflow-y: auto; /* ★ 新增：如果头像太多，允许此区域滚动 */
}

/* 4. 头像网格容器 (保持不变) */
#participant-avatars-grid {
    display: flex;
    flex-wrap: wrap; 
    justify-content: center;
    align-items: center;
    gap: 15px; /* ★ 稍微减小头像间距 */
    max-width: 100%;
}

/* 5. 单个参与者的头像容器 (头像缩小) */
.participant-avatar-wrapper {
    position: relative;
    text-align: center;
    flex-shrink: 0;
}
.participant-avatar {
    width: 70px;   /* ★ 从 80px 缩小到 70px */
    height: 70px;  /* ★ 从 80px 缩小到 70px */
    border-radius: 50%;
    object-fit: cover;
    border: 3px solid rgba(255, 255, 255, 0.2);
    transition: all 0.3s ease;
}
.participant-name {
    margin-top: 8px;
    font-size: 12px;
    color: #ccc;
}

/* 6. 发言者头像高亮效果 (保持不变) */
.participant-avatar.speaking {
    border-color: #4cd964;
    box-shadow: 0 0 20px rgba(76, 217, 100, 0.6);
    transform: scale(1.05);
}

/* 7. 【最终版】对话框区域 */
#video-call-main {
    flex-shrink: 0; 
    height: 30%;   /* ★ 核心修改：高度从35%减小到30% */
    margin: 15px 15px 130px 15px; /* ★ 核心修改：底部边距从120px增加到130px，创造明显空隙 */
    overflow-y: auto;
    padding: 15px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    box-sizing: border-box;
}

/* 8. 控制按钮样式 (保持不变) */
.control-btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    background-repeat: no-repeat;
    background-position: center;
    transition: transform 0.2s, background-color 0.2s;
}
.control-btn:active {
    transform: scale(0.9);
}
.control-btn.speak-btn {
    background-color: rgba(255,255,255,0.2);
    background-size: 55%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>');
}
.control-btn.hangup-btn {
    background-color: #ff3b30;
    background-size: 50%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
}
.control-btn.join-btn {
    background-color: #007bff;
    background-size: 50%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="17" y1="11" x2="23" y2="11"></line></svg>');
}

/* ▲▲▲ 新CSS替换结束 ▲▲▲ */

/* ▼▼▼ 【全新】视频通话对话气泡样式 ▼▼▼ */
.call-message-bubble {
    padding: 10px 15px;
    border-radius: 12px;
    max-width: 85%;
    line-height: 1.6;
    word-break: break-word;
    white-space: pre-wrap;
}

.call-message-bubble.ai-speech {
    background-color: rgba(255, 255, 255, 0.15);
    align-self: flex-start; /* AI发言靠左 */
}

.call-message-bubble.user-speech {
    background-color: #4cd964; /* 用户发言用绿色，类似微信 */
    align-self: flex-end;   /* 用户发言靠右 */
    text-align: left; /* 确保用户气泡内的文字是左对齐的 */
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */

/* ▼▼▼ 【全新添加】正在呼叫界面样式 ▼▼▼ */
#outgoing-call-screen {
    background-color: #1c1c1e;
    color: white;
    justify-content: center; /* 垂直居中 */
    align-items: center;   /* 水平居中 */
}

.outgoing-call-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.outgoing-call-actions {
    margin-top: 50px; /* 和上方文字拉开距离 */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
}
/* ▲▲▲ 添加结束 ▲▲▲ */

/* 1. 动态帖子的外层容器，我们需要它来定位和裁剪 */
.qzone-post-container {
    position: relative; /* 让内部的删除按钮可以相对于它定位 */
    overflow: hidden;   /* 隐藏掉超出部分的删除按钮 */
    border-radius: 12px;/* 和内部卡片保持一致的圆角 */
}

/* 2. 可滑动的内容卡片，增加一个平滑的过渡效果 */
.qzone-post-item {
    transition: transform 0.3s ease;
    background-color: var(--secondary-bg); /* 确保它有背景色，能盖住下面的删除按钮 */
    position: relative; /* 确保它在最上层 */
    z-index: 2;
}

/* 3. 【核心】这就是那个“删除”按钮的样式！*/
.qzone-post-delete-action {
    position: absolute; /* 绝对定位，脱离文档流 */
    top: 0;
    right: 0;
    bottom: 0;
    width: 90px; /* 删除按钮的宽度 */
    background-color: #ff3b30; /* 您想要的红色背景 */
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 500;
    cursor: pointer;
    z-index: 1; /* 确保它在卡片下面 */
}

/* 4. 当卡片左滑时，把它向左移动，露出删除按钮 */
.qzone-post-item.swiped {
    transform: translateX(-90px); /* 移动的距离和删除按钮的宽度一致 */
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这【一整块】全新的“拍一拍”样式，粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. “拍一拍”的屏幕震动动画 */
@keyframes pat-shake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
    20%, 40%, 60%, 80% { transform: translateX(3px); }
}

.pat-animation {
    animation: pat-shake 0.4s ease-in-out;
}

/* 2. “拍一拍”系统提示消息的样式 */
.system-message {
    align-self: center; /* 居中显示 */
    padding: 4px 12px;
    margin: 5px 0;
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    border-radius: 10px;
    text-align: center;
    max-width: 80%;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* 让“拍一拍”类型的 wrapper 居中 */
.message-wrapper.system-pat {
    justify-content: center;
    align-self: center;
    margin: 5px 0;
    max-width: 80%;
}
/* “拍一-拍”消息气泡的样式 */
.message-bubble.system-bubble {
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    padding: 4px 12px;
    border-radius: 10px;
}

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* === 修正：让顶部操作栏可以横向滚动 === */
#chat-input-actions-top {
    display: flex;
    gap: 8px;
    padding: 0 5px;

    /* --- 核心代码开始 --- */
    overflow-x: auto;      
    flex-wrap: nowrap;     
    -webkit-overflow-scrolling: touch; 

    scrollbar-width: none; 
    -ms-overflow-style: none;  
}

#chat-input-actions-top::-webkit-scrollbar {
    display: none; 
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* === 【全新】聊天界面头部状态栏样式 === */

/* 1. 标题和状态的总容器，使用flex布局让它们垂直排列 */
#chat-header-title-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center; /* 水平居中 */
    gap: 2px; /* 标题和状态之间的微小间距 */
    
    /* 为了让它能在flex布局中正确居中 */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    max-width: 60%;
}

/* 2. 主标题的样式微调 */
#chat-header-title {
    font-size: 16px; /* 可以稍微缩小一点，给状态栏留出空间 */
    font-weight: 600;
    position: static; /* 覆盖掉旧的absolute定位 */
    transform: none;  /* 覆盖掉旧的transform */
    /* 保证长标题也能正确显示省略号 */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
}

/* 3. 状态栏容器 */
#chat-header-status {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 11px;
    color: var(--text-secondary);
    transition: all 0.3s ease;
}

/* 4. 状态小圆点 */
.status-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background-color: #4cd964; /* 默认绿色，代表在线 */
    transition: background-color 0.3s ease;
}

/* 当AI状态为“忙碌”或“离开”时，让圆点变灰色 */
#chat-header-status.busy .status-dot {
    background-color: #cccccc;
}

/* 5. 状态文本 */
.status-text {
    font-weight: 500;
}

/* === 【全新美化版】回忆卡片样式 === */

/* 1. 卡片总容器：这里负责定义整体的背景色和边框 */
.memory-card {
    background-color: #fffaf0; /* 统一的、温暖的米黄色背景 */
    border-radius: 12px;
    padding: 15px; /* 在卡片四周留出内边距 */
    box-shadow: 0 2px 6px rgba(0,0,0,0.07);
    border-left: 5px solid #ffb74d; 
    display: flex; /* 让它成为flex容器，方便内部元素排列 */
    flex-direction: column; /* 让头部和内容垂直堆叠 */
    gap: 8px; /* 在头部和内容之间创造一个自然的间距 */
}

/* 2. 头部容器：现在只负责布局和分割线 */
.memory-card .header {
    border-bottom: 1px solid rgba(217, 129, 0, 0.15); /* 分割线颜色可以稍微加深一点 */
    padding-bottom: 8px; 
}

/* 3. 日期样式 (保持不变) */
.memory-card .header .date {
    font-size: 11px;
    color: #a1887f;
    margin-bottom: 4px; 
}

/* 4. 作者样式 (保持不变) */
.memory-card .header .author {
    font-weight: 600;
    color: #d98100;
    font-size: 15px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 5. 内容区样式 (保持不变) */
.memory-card .content {
    font-size: 14px;
    line-height: 1.7;
    color: #5d4037;
    white-space: pre-wrap;
}

/* === 【全新】约定/倒计时卡片样式 === */
.countdown-card {
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
    text-align: center;
    position: relative;
    overflow: hidden;
    flex-shrink: 0;
}
.countdown-card::before {
    content: '✨';
    position: absolute;
    top: -10px;
    left: -10px;
    font-size: 50px;
    opacity: 0.1;
    transform: rotate(-15deg);
}
.countdown-card .title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 15px;
}
.countdown-card .timer {
    font-size: 28px;
    font-weight: 300;
    letter-spacing: 2px;
    margin-bottom: 15px;
}
.countdown-card .target-date {
    font-size: 12px;
    opacity: 0.8;
    border-top: 1px solid rgba(255,255,255,0.2);
    padding-top: 10px;
}

/* === 【全新】聊天锁定遮罩层样式 === */
#chat-lock-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    z-index: 150; /* 比输入框高，比贴纸面板低 */
    display: none; /* 默认隐藏 */
    align-items: center;
    justify-content: center;
    padding: 20px;
    box-sizing: border-box;
    border-top: 1px solid var(--border-color);
    text-align: center;
}
#chat-lock-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
}
#chat-lock-content .lock-text {
    color: var(--text-secondary);
    font-size: 14px;
}
#chat-lock-content .lock-action-btn {
    padding: 10px 20px;
    border-radius: 20px;
    border: 1px solid var(--accent-color);
    background-color: var(--accent-color);
    color: white;
    cursor: pointer;
}
#chat-lock-content .lock-action-btn.secondary {
    background-color: transparent;
    color: var(--accent-color);
}

/* ▼▼▼ 【全新】红包卡片样式 ▼▼▼ */
.message-bubble.is-red-packet .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.red-packet-card {
    width: 220px;
    border-radius: 8px;
    background: linear-gradient(160deg, #F96259, #E44D44);
    color: #ffd700; /* 金色文字 */
    padding: 12px;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
}

.red-packet-card.opened {
    background: linear-gradient(160deg, #d3c4a0, #c4b693);
    cursor: default;
}

.red-packet-card::before {
    content: '🧧';
    position: absolute;
    top: -5px;
    left: -5px;
    font-size: 30px;
    opacity: 0.2;
    transform: rotate(-10deg);
}

.rp-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.rp-icon {
    width: 20px;
    height: 20px;
}

.rp-greeting {
    font-size: 15px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.rp-type {
    font-size: 11px;
    color: white;
    opacity: 0.8;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    padding-top: 8px;
    margin-top: 8px;
}

.rp-claimed-info {
    font-size: 13px;
    color: white;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid rgba(255,255,255,0.3);
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】红包详情列表样式 ▼▼▼ */
.rp-details-item {
    display: flex;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid #eee;
}
.rp-details-item:last-child {
    border-bottom: none;
}
.rp-details-item .name {
    flex-grow: 1;
    font-weight: 500;
    color: #333;
}
.rp-details-item .amount {
    font-weight: 500;
    color: #555;
}
.rp-details-item .lucky-king-tag {
    font-size: 10px;
    background-color: #ffd700;
    color: #a67c00;
    padding: 2px 5px;
    border-radius: 4px;
    margin-left: 8px;
    font-weight: bold;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】投票功能样式 ▼▼▼ */

/* 投票卡片在消息气泡中的样式 */
.message-bubble.is-poll .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

/* 投票卡片主体 */
.poll-card {
    width: 250px;
    background-color: #f9f9f9;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.poll-card.closed {
    background-color: #e9ecef; /* 结束后变灰 */
}

/* 投票问题 */
.poll-question {
    font-weight: 600;
    font-size: 15px;
    margin-bottom: 12px;
    line-height: 1.4;
    word-break: break-word;
}

/* 投票选项列表 */
.poll-options-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

/* 单个投票选项 */
.poll-option-item {
    background-color: white;
    border: 1px solid #dcdcdc;
    border-radius: 8px;
    padding: 10px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: background-color 0.2s;
}

.poll-card:not(.closed) .poll-option-item:hover {
    background-color: #f0f8ff;
}

/* 用户已投票的选项样式 */
.poll-option-item.voted {
    border-color: var(--accent-color);
    background-color: #e7f3ff;
    font-weight: 500;
}

/* 投票进度条 */
.poll-option-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background-color: rgba(0, 123, 255, 0.1);
    z-index: 1;
    transition: width 0.3s ease-in-out;
}

/* 选项内容（文字和票数），确保在进度条之上 */
.poll-option-content {
    position: relative;
    z-index: 2;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.poll-option-text {
    font-size: 14px;
}

.poll-option-votes {
    font-size: 13px;
    color: #8a8a8a;
    font-weight: 500;
}

/* 投票卡片底部 */
.poll-footer {
    margin-top: 12px;
    padding-top: 8px;
    border-top: 1px solid #e9e9e9;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: var(--text-secondary);
}

.poll-total-votes {
    font-weight: 500;
}

.poll-action-btn {
    background: none;
    border: 1px solid var(--accent-color);
    color: var(--accent-color);
    padding: 4px 10px;
    border-radius: 15px;
    cursor: pointer;
    font-size: 12px;
}
.poll-card.closed .poll-action-btn {
    background-color: #6c757d;
    color: white;
    border-color: #6c757d;
}

/* 创建投票模态框的选项输入 */
.poll-option-input-wrapper {
    display: flex;
    align-items: center;
    gap: 8px;
}
.poll-option-input-wrapper input {
    flex-grow: 1;
}
.poll-option-input-wrapper .remove-option-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: #f0f0f0;
    color: #ff3b30;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 28px;
    text-align: center;
    flex-shrink: 0;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* === 【全新】聊天头部“正在输入”状态样式 === */
#chat-header-title.typing-status {
    color: var(--text-secondary);
    animation: typing-pulse 1.5s infinite;
    font-style: italic;
}

@keyframes typing-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
}

#chat-header-title {
    transition: opacity 0.2s ease-in-out;
}

@keyframes message-pop-in {
  from {
    opacity: 0;
    transform: translateY(15px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message-wrapper.animate-in {
  animation: message-pop-in 0.3s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
  }

/* ▼▼▼ 【全新】App图标设置样式 ▼▼▼ */
#icon-settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 20px;
    width: 100%;
    padding: 0 10px;
    box-sizing: border-box;
}

.icon-setting-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.icon-preview {
    width: 60px;
    height: 60px;
    border-radius: 15px;
    background-size: cover;
    background-position: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.change-icon-btn {
    padding: 4px 10px;
    font-size: 12px;
    border: 1px solid #ccc;
    background-color: #f0f0f0;
    border-radius: 5px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外观设置页面布局修正 ▼▼▼ */

/* 1. 修正滚动问题 */
#wallpaper-screen .form-container {
    /* 核心修正1: 解决flex布局下的滚动冲突，让滚动条能正常出现 */
    min-height: 0; 
}

/* 2. 修正壁纸预览被压扁的问题 */
#wallpaper-preview {
    /* 核心修正2: 防止预览框被过多的内容挤压变形，让它保持自己的高度 */
    flex-shrink: 0; 
}
/* ▲▲▲ 修正结束 ▲▲▲ */

/* ▼▼▼ 【全新】分享链接功能样式 (无图版) ▼▼▼ */

/* 1. 浏览器界面背景色和内容区样式 (保持不变) */
#browser-screen {
    background-color: #f8f9fa;
}
#browser-content {
    padding: 20px;
    font-size: 16px;
    line-height: 1.8;
    color: #333;
    overflow-y: auto;
    background-color: #f8f9fa;
}
#browser-content .article-title {
    font-size: 24px;
    font-weight: 700;
    margin-bottom: 10px;
}
#browser-content .article-meta {
    font-size: 13px;
    color: #8a8a8a;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid #e0e0e0;
}
#browser-content .article-body {
    white-space: pre-wrap;
    word-break: break-word;
}
#browser-content .article-body p {
    margin-bottom: 1em;
}

/* 2. 聊天气泡中的链接卡片样式 (无图版) */
.message-bubble.is-link-share .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.link-share-card {
    width: 210px; 
    background-color: #fff;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px;
    cursor: pointer;
    transition: background-color 0.2s;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.link-share-card:hover {
    background-color: #f9f9f9;
}

.link-share-card .title {
    font-weight: 600;
    font-size: 15px;
    line-height: 1.4;
    color: #1f1f1f;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .description {
    font-size: 13px;
    color: #8a8a8a;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .footer {
    display: flex; /* 让图标和文字水平对齐 */
    align-items: center;
    gap: 6px; /* 图标和文字的间距 */
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px; /* 和上面的描述拉开一点距离 */
}
.link-share-card .footer-icon {
    width: 14px;
    height: 14px;
    flex-shrink: 0; /* 防止图标被压缩 */
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 单条评论的容器，现在需要相对定位 */
.comment-item {
    position: relative;
    padding-right: 25px; /* 在右侧留出删除按钮的空间 */
}

/* 评论删除按钮的样式 */
.comment-delete-btn {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    line-height: 22px;
    text-align: center;
    border-radius: 50%;
    color: var(--text-secondary);
    font-size: 18px;
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0; /* 默认隐藏 */
}

/* 鼠标悬停在评论上时，显示删除按钮 */
.comment-item:hover .comment-delete-btn {
    opacity: 1;
}

.comment-delete-btn:hover {
    background-color: #f0f0f0;
    color: #ff3b30;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* === 【全新】夜间模式样式 === */

/* 核心：当 #phone-screen 拥有 .dark-mode 类时，激活以下所有样式 */

/* 1. 全局背景和文本颜色 */
#phone-screen.dark-mode {
    --secondary-bg: #1c1c1e; /* 主要卡片背景色 */
    --border-color: #38383a;  /* 边框颜色 */
    --text-primary: #ffffff;   /* 主要文字颜色 */
    --text-secondary: #8d8d92; /* 次要文字/图标颜色 */
}

/* 2. 各个页面的主背景色 */
#phone-screen.dark-mode #chat-list-screen,
#phone-screen.dark-mode #qzone-screen .qzone-content,
#phone-screen.dark-mode #memories-view {
    background-color: #000000;
}

/* 3. 聊天列表 */
#phone-screen.dark-mode #chat-list {
    background-color: #000000;
}
#phone-screen.dark-mode .chat-list-item {
    border-bottom-color: rgba(255, 255, 255, 0.15);
}
#phone-screen.dark-mode .chat-group-header {
    background-color: #1c1c1e; /* 从白色改为深灰色 */
    border-bottom: 1px solid #38383a; /* 给它一个细微的下边框 */
}
#phone-screen.dark-mode .chat-list-item .name,
#phone-screen.dark-mode .chat-group-header .group-name {
    color: #ffffff;
}
#phone-screen.dark-mode .chat-list-item:hover {
    background-color: #1c1c1e;
}

/* 4. 顶部/底部导航栏 */
#phone-screen.dark-mode .header,
#phone-screen.dark-mode .qzone-header {
    background-color: rgba(25, 25, 25, 0.9);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border-bottom-color: rgba(255, 255, 255, 0.15);
    color: #ffffff;
}
#phone-screen.dark-mode .header .back-btn,
#phone-screen.dark-mode .header .action-btn,
#phone-screen.dark-mode .header .save-btn {
    color: #ffffff;
}
#phone-screen.dark-mode #chat-list-bottom-nav {
    background-color: rgba(25, 25, 25, 0.9);
    border-top-color: rgba(255, 255, 255, 0.15);
}
#phone-screen.dark-mode .nav-item.active {
    color: #ffffff;
}

/* 5. 聊天界面 */
#phone-screen.dark-mode #chat-input-area {
    background-color: rgba(5, 5, 5, 0.8);
    border-top: none;
}
#phone-screen.dark-mode #chat-input {
    background-color: #3e3e42;
    color: #ffffff;
}
#phone-screen.dark-mode #chat-input::placeholder {
    color: #8d8d92;
}
#phone-screen.dark-mode .chat-action-icon-btn {
    color: #ffffff;
    background-color: rgba(255, 255, 255, 0.1);
    border: none;
}
#phone-screen.dark-mode #send-btn {
    background-color: var(--accent-color);
}

/* 6. 动态 (QZone) 界面 */
#phone-screen.dark-mode .qzone-actions-bar,
#phone-screen.dark-mode .qzone-post-item {
    background-color: #1c1c1e;
    border: 1px solid #333;
    box-shadow: 0 2px 8px rgba(255, 255, 255, 0.05);
}
#phone-screen.dark-mode .action-item:not(:last-child)::after {
    background-color: #333;
}
#phone-screen.dark-mode .post-footer,
#phone-screen.dark-mode .post-likes-section {
    border-top-color: #333;
}
#phone-screen.dark-mode .post-likes-section {
    background-color: rgba(0, 123, 255, 0.1);
}
#phone-screen.dark-mode .comment-input {
    background-color: #333;
    color: #ffffff;
}
#phone-screen.dark-mode .comment-input::placeholder {
    color: #8d8d92;
}
#phone-screen.dark-mode .post-actions-btn:hover {
    background-color: #333;
}
#phone-screen.dark-mode .at-mention-popup {
    background-color: #1c1c1e;
    border-color: #333;
}
#phone-screen.dark-mode .at-mention-item {
    border-bottom-color: #333;
}
#phone-screen.dark-mode .at-mention-item:hover {
    background-color: #333;
}

/* 7. 回忆录界面 */
#phone-screen.dark-mode .memory-card {
    background-color: #1c1c1e;
    border-left-color: #e6a753;
    box-shadow: 0 4px 12px rgba(255, 255, 255, 0.08);
}
#phone-screen.dark-mode .memory-card .header {
    background-color: #2c2c2e;
    border-bottom-color: #38383a;
    margin: -15px -15px 8px -15px;
    padding: 12px 15px;
    border-radius: 12px 12px 0 0;
}
#phone-screen.dark-mode .memory-card .header .date,
#phone-screen.dark-mode .memory-card .header .author,
#phone-screen.dark-mode .memory-card .content {
    color: #e0e0e0;
}

/* 8. 其他设置和列表页 */
#phone-screen.dark-mode #api-settings-screen,
#phone-screen.dark-mode #font-settings-screen,
#phone-screen.dark-mode #wallpaper-screen,
#phone-screen.dark-mode #contact-picker-screen,
#phone-screen.dark-mode #member-management-screen,
#phone-screen.dark-mode #world-book-editor-screen,
#phone-screen.dark-mode #world-book-list,
#phone-screen.dark-mode .list-item:hover,
#phone-screen.dark-mode .list-container,
#phone-screen.dark-mode .form-container {
    background-color: #000000;
}
#phone-screen.dark-mode .form-group input, 
#phone-screen.dark-mode .form-group select, 
#phone-screen.dark-mode .form-group textarea {
    background-color: #1c1c1e;
    color: #ffffff;
    border-color: #38383a;
}
#phone-screen.dark-mode .form-button-secondary {
    background-color: #333;
    border-color: #555;
    color: #fff;
}
#phone-screen.dark-mode #font-preview {
    background-color: #1c1c1e;
    border-color: #38383a;
}
#phone-screen.dark-mode #font-preview p {
    color: #ffffff;
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */

/* ▼▼▼ 把这一整块【全新的修正CSS】，粘贴到 <style> 的末尾 ▼▼▼ */

/* === 【全新】夜间模式视觉修正 === */

/* 1. 修正动态卡片内的文字颜色 */
#phone-screen.dark-mode .qzone-post-item .post-nickname,
#phone-screen.dark-mode .qzone-post-item .post-content {
    color: #f0f0f0; /* 从深灰色改为明亮的浅灰色 */
}

/* 2. 修正收藏卡片内的文字颜色 */
#phone-screen.dark-mode .favorite-item-card .fav-card-header .name,
#phone-screen.dark-mode .favorite-item-card .fav-card-content {
    color: #f0f0f0; /* 同样改为浅灰色 */
}
#phone-screen.dark-mode .favorite-item-card .fav-card-header .source {
    color: #8d8d92; /* 来源文字用次要灰色 */
}

/* 3. 修正收藏页的搜索栏背景和输入框样式 */
#phone-screen.dark-mode .search-bar-container {
    background-color: #000000; /* 容器背景变为纯黑 */
}
#phone-screen.dark-mode #favorites-search-input {
    background-color: #1c1c1e; /* 输入框背景变为深灰 */
    border-color: #38383a;     /* 边框颜色变暗 */
    color: #ffffff;            /* 输入文字变为白色 */
}
#phone-screen.dark-mode #favorites-search-input::placeholder {
    color: #8d8d92; /* 占位符文字颜色变暗 */
}

/* ▲▲▲ 修正CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* === 【全新】iOS风格的Toggle Switch开关样式 === */

/* 1. 开关的容器 */
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 51px;
    height: 31px;
}

/* 2. 隐藏掉原始的 checkbox 输入框 */
.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

/* 3. 开关的背景（那个椭圆） */
.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #e9e9eb; /* 关闭时的背景色 */
    transition: .4s;
    border-radius: 34px;
}

/* 4. 开关上的圆点 */
.slider:before {
    position: absolute;
    content: "";
    height: 27px;
    width: 27px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

/* 5. 【核心】当 checkbox 被选中时（即开启状态） */
input:checked + .slider {
    background-color: #34c759; /* 开启时的背景色（iOS绿色）*/
}

input:checked + .slider:before {
    transform: translateX(20px); /* 让圆点滑动到右边 */
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】引用回复功能样式 ▼▼▼ */

/* 1. 输入框上方的“回复预览栏” */
#reply-preview-bar {
    display: none; /* 默认隐藏 */
    padding: 8px 12px;
    margin: 0 8px 8px 8px; /* 和输入框周围的边距保持一致 */
    background-color: rgba(0, 0, 0, 0.05);
    border-left: 3px solid var(--accent-color);
    border-radius: 6px;
    position: relative;
    font-size: 13px;
    color: var(--text-secondary);
}

#phone-screen.dark-mode #reply-preview-bar {
    background-color: rgba(255, 255, 255, 0.1);
}

.reply-preview-content .sender {
    font-weight: 600;
    color: var(--text-primary);
}

.reply-preview-content .text {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: block; /* 确保省略号生效 */
    max-width: 95%;
}

#cancel-reply-btn {
    position: absolute;
    top: 50%;
    right: 8px;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    border-radius: 50%;
    background-color: rgba(0,0,0,0.1);
    cursor: pointer;
    font-size: 14px;
}

/* 2. 消息气泡内部的“引用消息块” */
.quoted-message {
    padding: 6px 10px;
    margin-bottom: 6px;
    background-color: rgba(0, 0, 0, 0.04);
    border-left: 2px solid var(--accent-color);
    border-radius: 4px;
    font-size: 0.9em; /* 字体比正文小一点 */
    opacity: 0.8;
    /* (已移除 overflow: hidden;) */
}

#phone-screen.dark-mode .quoted-message {
    background-color: rgba(255, 255, 255, 0.08);
    border-left-color: #a0cff1;
}

.quoted-message .quoted-sender {
    font-weight: 600;
    color: var(--accent-color);
}
#phone-screen.dark-mode .quoted-message .quoted-sender {
    color: #a0cff1;
}

.quoted-message .quoted-content {
    color: var(--text-secondary);
    white-space: normal;     /* 核心修正1: 允许文本正常换行 */
    word-break: break-word;  /* 核心修正2: 强制长单词或连续字符断开，防止溢出 */
    display: block;
    /* (已移除 overflow 和 text-overflow，因为我们需要多行显示而不是单行省略号) */
}

/* === 字体预览框样式 (修正后) === */

/* 默认（日间模式）的样式 */
#font-preview {
    padding: 20px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: #f9f9f9; /* 日间模式的浅灰色背景 */
    transition: background-color 0.3s, border-color 0.3s;
}

/* 预览框里的文字颜色，默认是黑色 */
#font-preview p {
    color: var(--text-primary);
}

/* 夜间模式下的修正样式 */
#phone-screen.dark-mode #font-preview {
    background-color: #1c1c1e; /* 深灰色背景 */
    border-color: #38383a;     /* 暗色边框 */
}

/* 夜间模式下，预览框里的文字变为白色 */
#phone-screen.dark-mode #font-preview p {
    color: #ffffff;
}

/* ▼▼▼ 【全新】精致版转账操作弹窗样式 ▼▼▼ */
.transfer-actions-content {
    background-color: #fff0f5; /* 粉嫩的背景色 */
    border-radius: 20px;
    width: 290px;
    padding: 20px;
    box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3); /* 粉色阴影 */
    text-align: center;
    position: relative;
    border: 1px solid #ffcce0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.transfer-actions-header {
    font-size: 20px;
    font-weight: bold;
    color: #a35c7b; /* 深粉色标题 */
    margin-bottom: 15px;
}

.transfer-actions-body p {
    font-size: 15px;
    color: #555;
    margin: 0 0 25px 0;
    line-height: 1.5;
}

.transfer-actions-footer {
    display: flex;
    justify-content: space-between;
    gap: 15px;
}

.transfer-actions-footer .action-btn {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    color: white;
}

.transfer-actions-footer .action-btn:active {
    transform: scale(0.95);
}

.transfer-actions-footer .action-btn.accept {
    background: linear-gradient(135deg, #ff85b3, #ff69b4);
    box-shadow: 0 4px 10px rgba(255, 105, 180, 0.4);
}

.transfer-actions-footer .action-btn.decline {
    background: linear-gradient(135deg, #c2c2c2, #a0a0a0);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.transfer-actions-content .cancel-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: none;
    background-color: rgba(0, 0, 0, 0.1);
    color: #a35c7b;
    font-size: 20px;
    line-height: 28px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 未读消息红点样式 === */
.unread-count-wrapper {
    flex-shrink: 0;
    width: 40px;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding-top: 20px; /* 让红点和名字差不多高 */
}

.unread-count {
    min-width: 20px;
    height: 20px;
    padding: 0 6px;
    background-color: #ff3b30; /* iOS 风格的红色 */
    color: white;
    font-size: 13px;
    font-weight: 500;
    line-height: 20px;
    text-align: center;
    border-radius: 10px; /* 圆角矩形 */
    box-shadow: 0 1px 2px rgba(0,0,0,0.15);
    display: none; /* 默认隐藏 */
    justify-content: center;
    align-items: center;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】通话记录页面与卡片样式 ▼▼▼ */

/* 确保页面背景色统一 */
#call-history-screen {
    background-color: #f0f2f5;
}

/* 通话记录卡片样式 */
.call-record-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border-left: 5px solid var(--accent-color);
}
.call-record-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.1);
}

/* 卡片头部：包含日期和时长 */
.call-record-card .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 13px;
    color: var(--text-secondary);
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}
.call-record-card .card-header .duration {
    font-weight: 500;
    color: var(--text-primary);
}

/* 卡片主体：参与者头像 */
.call-record-card .card-body {
    display: flex;
    align-items: center;
}
.call-record-card .participants-avatars {
    display: flex;
    align-items: center;
}
.call-record-card .participant-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
/* 让头像有一个漂亮的堆叠效果 */
.call-record-card .participant-avatar:not(:first-child) {
    margin-left: -12px;
}
.call-record-card .participants-names {
    margin-left: 12px;
    font-weight: 600;
    color: var(--text-primary);
    font-size: 15px;
}

/* --- 通话详情弹窗样式 --- */
#transcript-modal-body {
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 15px;
}
.transcript-entry {
    padding: 8px 12px;
    border-radius: 10px;
    max-width: 85%;
    line-height: 1.5;
    word-break: break-word;
}
.transcript-entry.user {
    background-color: #dcf8c6; /* 类似微信的绿色 */
    align-self: flex-end;
}
.transcript-entry.assistant {
    background-color: #ffffff;
    align-self: flex-start;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

#chat-list-title {
    cursor: pointer;
}

/* ▼▼▼ 【全新】通话记录卡片美化样式 ▼▼▼ */

.call-record-card .card-body {
    /* 将 body 改为 flex 布局，让标题和参与者信息垂直排列 */
    display: flex;
    flex-direction: column;
    gap: 8px; /* 标题和参与者信息之间的间距 */
}

.call-record-card .custom-title {
    font-size: 16px;
    font-weight: 600; /* 加粗，让它像个标题 */
    color: var(--text-primary);
    padding-bottom: 8px; /* 标题下的留白 */
    border-bottom: 1px solid var(--border-color); /* 在标题下加一条分割线 */
    margin-bottom: 4px; /* 和下面的参与者信息拉开一点距离 */
}

.call-record-card .participants-info {
    /* 这个新容器让头像和“与xx”能水平对齐 */
    display: flex;
    align-items: center;
}

/* 参与者名字的样式微调，让它不那么突出 */
.call-record-card .participants-names {
    margin-left: 12px;
    font-weight: 500; /* 不再加粗 */
    font-size: 14px; /* 稍微小一点 */
    color: var(--text-secondary); /* 使用次要文字颜色 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】语音转文字功能样式 ▼▼▼ */

/* 1. 语音文字内容的样式 */
.voice-transcript {
    font-size: 14px;         /* 文字大小 */
    line-height: 1.6;        /* 行高，让多行文本更易读 */
    color: var(--text-secondary); /* 使用次要文字颜色，与语音条区分 */
    padding: 8px 12px;       /* 内边距 */
    margin-top: 6px;         /* 和上方的语音条拉开一点距离 */
    background-color: rgba(0, 0, 0, 0.04); /* 给一个淡淡的背景，更有层次感 */
    border-radius: 6px;      /* 圆角 */
    word-break: break-word;  /* 确保长文本能正常换行 */
    display: none;           /* 默认隐藏 */
}

#phone-screen.dark-mode .voice-transcript {
    background-color: rgba(255, 255, 255, 0.1); /* 夜间模式下的背景色 */
}

/* 2. 旋转加载动画的样式 */
.loading-spinner {
    display: none; /* 默认隐藏 */
    width: 16px;
    height: 16px;
    border: 2px solid rgba(0, 0, 0, 0.2);
    border-top-color: var(--accent-color); /* 旋转部分的颜色 */
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 8px; /* 和波形图、时长保持一点间距 */
}

/* 3. 定义旋转动画 */
@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】分享记录查看器样式修正 ▼▼▼ */
#shared-history-viewer-content {
    display: flex;
    flex-direction: column; /* 让气泡垂直排列 */
    gap: 20px; /* 在每个气泡之间增加20像素的间距 */
    padding: 15px; /* 在容器四周也增加一些内边距，避免气泡贴边 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】播放器和歌词样式 ▼▼▼ */
#music-player-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 50;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding-top: 60px;
    background-color: rgba(0,0,0,0.3);
    opacity: 0;
    visibility: hidden;
    transform: translateY(-50px);
    transition: opacity 0.4s ease-out, transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

#music-player-overlay.visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
}

.music-player-window { 
    width: 70%; 
    min-height: 420px;
    background-color: rgba(255, 255, 255, 0.6); 
    backdrop-filter: blur(20px); 
    -webkit-backdrop-filter: blur(20px); 
    border-radius: 25px; 
    box-shadow: 0 8px 32px 0 rgba(25, 25, 25, 0.37); 
    border: 1px solid rgba(255, 255, 255, 0.18); 
    padding: 25px; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    color: #1f1f1f; 
    position: relative;
    justify-content: space-between;
    padding-bottom: 15px;
}

.music-player-top-actions {
    position: absolute;
    top: 15px;
    left: 15px;
    right: 15px;
    width: calc(100% - 30px);
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.top-left-cluster {
    display: flex;
    align-items: center;
    gap: 15px;
}
#music-return-btn, #music-exit-btn {
    background: none;
    border: none;
    font-size: 28px;
    font-weight: 300;
    cursor: pointer;
    color: #555;
    padding: 5px;
    line-height: 1;
}
#music-exit-btn {
    font-size: 24px;
    font-weight: 400;
}

.music-progress-bar-container {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 25px;
    margin-bottom: 10px;
}
.time-display {
    font-size: 11px;
    color: #888;
    width: 35px;
    text-align: center;
    flex-shrink: 0;
    font-family: 'SF Mono', 'Menlo', monospace;
}
.progress-bar {
    flex-grow: 1;
    height: 5px;
    background-color: #e5e5e5;
    border-radius: 2.5px;
    cursor: pointer;
}
.progress-bar-fill {
    width: 0%;
    height: 100%;
    background-color: #333;
    border-radius: 2.5px;
}

#music-lyrics-container {
    width: 100%;
    height: 192px;
    overflow: hidden;
    position: relative;
    -webkit-mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
    mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
}

#music-lyrics-list {
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: transform 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
}

.lyric-line {
    padding: 4px 0;
    font-size: 14px;
    color: #666;
    text-align: center;
    line-height: 1.5;
    transition: all 0.5s ease;
    opacity: 0.7;
    transform: scale(0.95);
}

.lyric-line.active {
    font-size: 16px;
    color: #000;
    opacity: 1;
    transform: scale(1);
}

.music-player-controls-wrapper {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.music-controls {
    margin-top: 0;
}

#music-return-btn, #music-exit-btn, #music-playlist-btn {
    position: relative;
}

#music-return-btn { top: -2px; }
#music-playlist-btn { top: -3px; }

.playlist-item-actions {
    display: flex;
    align-items: center;
    gap: 15px;
}
.playlist-action-btn {
    font-size: 18px;
    color: #888;
    cursor: pointer;
    transition: color 0.2s;
}
.playlist-action-btn:hover { color: #000; }
.delete-track-btn { font-size: 24px; color: #ff3b30; }
.delete-track-btn:hover { color: #c00; }
.lyrics-btn { font-weight: 500; }

/* --- 【核心修正】确保头像尺寸 --- */
.message-bubble .avatar {
    width: 34px;
    height: 34px;
    border-radius: 20%;
    object-fit: cover;
    flex-shrink: 0; /* 防止被压缩 */
}

/* ▼▼▼ 【全新】撤回消息样式 ▼▼▼ */

/* 1. 撤回消息的占位符样式 */
.recalled-message-placeholder {
    align-self: center; /* 居中显示 */
    padding: 4px 12px;
    margin: 5px 0;
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    border-radius: 10px;
    text-align: center;
    max-width: 80%;
    cursor: pointer; /* 让它看起来可以点击 */
}

/* 2. 夜间模式下的适配 */
#phone-screen.dark-mode .recalled-message-placeholder {
    background-color: rgba(255, 255, 255, 0.15);
}

/* 3. AI撤回消息时的动画效果 */
@keyframes recall-animation {
  from {
    opacity: 1;
    transform: scale(1);
  }
  to {
    opacity: 0;
    transform: scale(0.8);
  }
}

.message-wrapper.recalled-animation {
  animation: recall-animation 0.3s ease-out forwards;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】撤回消息样式修正 ▼▼▼ */

/* 强制撤回消息的占位符不换行，并保持内容居中 */
.recalled-message-placeholder {
    white-space: nowrap; /* 核心：禁止文本换行 */
    display: inline-block; /* 让背景根据内容自适应宽度 */
    padding: 4px 12px;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】世界书分类列表样式 ▼▼▼ */
.world-book-group-container {
    border-bottom: 1px solid var(--border-color);
}
.world-book-group-container:first-child {
    border-top: 1px solid var(--border-color);
}
.world-book-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    cursor: pointer;
    background-color: #f7f7f7;
}
.world-book-group-header .arrow {
    font-size: 14px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}
.world-book-group-header.collapsed .arrow {
    transform: rotate(-90deg);
}
.world-book-group-header .group-name {
    font-weight: 600;
    font-size: 15px;
}
.world-book-group-content {
    max-height: 1000px;
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}
.world-book-group-content.collapsed {
    max-height: 0;
}
#phone-screen.dark-mode .world-book-group-header {
    background-color: #1c1c1e;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】红包/转账模态框页签样式 ▼▼▼ */
.frame-tabs {
    display: flex;
    background-color: #f0f0f0;
    padding: 4px;
    margin: 15px;
    border-radius: 8px;
}
.frame-tab {
    flex: 1;
    text-align: center;
    padding: 8px;
    font-size: 14px;
    font-weight: 500;
    color: #555;
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.2s ease-in-out;
}
.frame-tab.active {
    background-color: #ffffff;
    color: #000000;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段全新的CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. 分类文件夹的样式 */
.wb-category-header {
    display: flex;
    align-items: center;
    padding: 10px 12px;
    cursor: pointer;
    background-color: #f0f2f5; /* 给文件夹一个淡淡的背景色以区分 */
    font-weight: 600; /* 加粗字体 */
}
#phone-screen.dark-mode .wb-category-header {
    background-color: #2c2c2e; /* 夜间模式下的背景色 */
}


/* 2. 展开/收起的小箭头 */
.wb-category-header .arrow {
    font-size: 12px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}

/* 3. 当文件夹收起时，箭头旋转 */
.wb-category-header.collapsed .arrow {
    transform: rotate(-90deg);
}

/* 4. 存放书籍条目的容器 */
.wb-book-container {
    padding-left: 20px; /* 核心：让书籍条目向内缩进，看起来像在文件夹里 */
    max-height: 1000px; /* 一个足够大的值，用于动画 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}

/* 5. 当文件夹收起时，书籍容器的高度变为0，实现动画效果 */
.wb-book-container.collapsed {
    max-height: 0;
}

/* 6. 单个书籍条目（覆盖默认的label样式，微调间距） */
.wb-book-container label {
    padding: 8px 12px;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】世界书关联选择器 - 视觉优化 ▼▼▼ */

/* 1. 让分类标题更突出 */
.wb-category-header > span:last-of-type {
    font-size: 14px;
    font-weight: 700; /* 加粗 */
    color: var(--text-primary);
}

/* 2. 为箭头设置一个漂亮的颜色循环 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+1) .arrow { color: #007bff; } /* 蓝色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+2) .arrow { color: #28a745; } /* 绿色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+3) .arrow { color: #fd7e14; } /* 橙色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+4) .arrow { color: #6f42c1; } /* 紫色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+5) .arrow { color: #dc3545; } /* 红色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+6) .arrow { color: #ffc107; } /* 黄色 */

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

    </style>
</head>
<body>
<div id="phone-screen">
<div id="status-bar">
<span id="status-bar-time">12:00</span>
<div class="battery-container" id="status-bar-battery">
<span class="battery-text">--%</span>
<div class="battery-icon">
<div class="battery-level"></div>
</div>
</div>
</div>
<div id="notification-bar"><img id="notification-avatar" src=""/><div id="notification-content"><div class="name"></div><div class="message"></div></div></div>
<div class="screen active" id="home-screen">
<div id="clock-container"><div id="main-time">12:00</div><div id="main-date">星期一, 1月1日</div></div>
<!-- ▼▼▼ 用这整块代码替换你原来的 id="app-grid" ▼▼▼ -->
<div id="app-grid">
<!-- 第一行：放2个图标 -->
<div class="app-row">
<div class="app-icon" onclick="showScreen('world-book-screen')">
<div class="icon-bg">
<!-- 【核心修改1】添加ID -->
<img alt="世界书" id="icon-img-world-book" src="https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg"/>
</div>
<span class="label">世界书</span>
</div>
<div class="app-icon" onclick="showScreen('chat-list-screen')">
<div class="icon-bg">
<!-- 【核心修改2】添加ID -->
<img alt="QQ" id="icon-img-qq" src="https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg"/>
</div>
<span class="label">QQ</span>
</div>
</div>
<!-- 第二行：放3个图标 -->
<div class="app-row">
<div class="app-icon" onclick="showScreen('api-settings-screen')">
<div class="icon-bg">
<!-- 【核心修改3】添加ID -->
<img alt="API设置" id="icon-img-api-settings" src="https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg"/>
</div>
<span class="label">API设置</span>
</div>
<div class="app-icon" onclick="showScreen('wallpaper-screen')">
<div class="icon-bg">
<!-- 【核心修改4】添加ID -->
<img alt="外观设置" id="icon-img-wallpaper" src="https://i.postimg.cc/T1j03pQr/IMG-6440.jpg"/>
</div>
<span class="label">外观设置</span>
</div>
<div class="app-icon" onclick="showScreen('font-settings-screen')">
<div class="icon-bg">
<!-- 【核心修改5】添加ID -->
<img alt="字体" id="icon-img-font" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg"/>
</div>
<span class="label">字体</span>
</div>
</div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
</div>
<div class="screen" id="world-book-screen">
<div class="header">
<span class="back-btn" onclick="showScreen('home-screen')">‹</span>
<span>世界书</span>
<div class="header-actions"> <!-- 【推荐】用一个容器把按钮包起来 -->
<span class="action-btn" id="manage-world-book-categories-btn">管理分类</span>
<span class="action-btn" id="add-world-book-btn">+</span>
</div>
</div>
<div id="world-book-list"></div>
</div>
<div class="screen" id="world-book-editor-screen">
<div class="header">
<span class="back-btn" onclick="showScreen('world-book-screen')">‹</span>
<span id="world-book-editor-title">编辑世界书</span>
<span class="save-btn" id="save-world-book-btn">保存</span>
</div>
<div class="form-container">
<div class="form-group">
<label for="world-book-name-input">书名</label>
<input id="world-book-name-input" placeholder="请输入世界书的名称..." type="text"/>
</div>
<!-- ▼▼▼ 【全新】在这里添加分类选择 ▼▼▼ -->
<div class="form-group">
<label for="world-book-category-select">分类</label>
<select id="world-book-category-select">
<!-- 选项将由JS动态生成 -->
</select>
</div>
<!-- ▲▲▲ 添加结束 ▲▲▲ -->
<div class="form-group" style="height: 100%;">
<label for="world-book-content-input">内容</label>
<textarea id="world-book-content-input" placeholder="在此处输入详细的世界观设定..."></textarea>
</div>
</div>
</div>
<div class="screen" id="api-settings-screen"><div class="header"><span class="back-btn" onclick="showScreen('home-screen')">‹</span><span>API 设置</span><span style="width: 30px;"></span></div><div class="form-container"><p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">提示: 若要使用“发送图片”功能, 请务必选择支持Vision(视觉)的模型, 如<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4o</code>或<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4-vision-preview</code>。</p><div class="form-group"><label for="proxy-url">反代地址 (不需要添加/v1噢~)</label><input id="proxy-url" placeholder="例如: https://api.openai.com" type="text"/></div><div class="form-group"><label for="api-key">密钥 (直连轮询用英文逗号隔开)</label><input id="api-key" placeholder="sk-..." type="password"/></div><div class="form-group"><label for="model-select">模型</label><select id="model-select"></select></div><button class="form-button" id="fetch-models-btn">拉取模型</button>
<!-- ▼▼▼ 将这段代码粘贴到 API 设置页面的“保存设置”按钮上方 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3"/>
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
<label for="background-activity-switch" style="margin-bottom: 0;">
        启用后台角色活动
        <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
            警告：此功能会显著增加API调用和费用！
        </p>
</label>
<input id="background-activity-switch" style="width: auto; height: 20px;" type="checkbox"/>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 将这段代码粘贴到“启用后台角色活动”开关的下方 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
<label for="background-interval-input" style="margin-bottom: 0;">
        后台活动检测间隔 (秒)
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            建议值 60-300。值越大，费用越低，但角色反应越慢。
        </p>
</label>
<input id="background-interval-input" min="30" style="width: 80px; text-align: center;" type="number" value="60"/>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 在这里新增 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
<label for="block-cooldown-input" style="margin-bottom: 0;">
        AI被拉黑后冷静期 (小时)
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            被拉黑超过这个时间后，AI才有几率重新申请好友。
        </p>
</label>
<input id="block-cooldown-input" min="0.1" step="0.1" style="width: 80px; text-align: center;" type="number" value="1"/>
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->
<button class="form-button" id="save-api-settings-btn">保存设置</button>
<hr style="margin:20px 0; opacity:.3"/>
<button class="form-button" id="export-data-btn">导出数据</button>
<!-- ① 普通按钮，和“导出”一个 class -->
<button class="form-button" id="import-btn">导入备份文件</button>
<!-- ② 真正的文件选择器，完全隐藏 -->
<input accept="application/json" hidden="" id="import-data-input" type="file"/>
</div></div>
<!-- ▼▼▼ 用下面这段代码，完整替换掉你原来的 chat-list-screen ▼▼▼ -->
<div class="screen" id="chat-list-screen">
<!-- 主头部 (只在消息列表显示) -->
<div class="header" id="main-chat-list-header">
<span class="back-btn" onclick="showScreen('home-screen')">‹</span>
<span id="chat-list-title">消息</span>
<div class="header-actions">
<span class="action-btn" id="add-group-chat-btn" title="创建群聊"><svg fill="none" height="24" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="M21 21L19 19" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg></span>
<span class="action-btn" id="add-chat-btn">+</span>
</div>
</div>
<!-- 消息列表视图 -->
<div class="chat-list-view active" id="messages-view">
<div id="chat-list">
<!-- JS会在这里生成聊天列表 -->
</div>
</div>
<!-- 动态界面视图 -->
<div class="chat-list-view" id="qzone-screen">
<div class="qzone-header">
<span class="back-btn" id="qzone-back-btn">‹</span> <!-- 这个按钮现在只负责从动态返回 -->
<span>好友动态</span>
</div>
<div class="qzone-content">
<div class="qzone-profile-header">
<div class="qzone-banner-container" id="qzone-banner-container">
<img alt="背景" id="qzone-banner-img" src="https://files.catbox.moe/r5heyt.gif"/>
<input accept="image/*" hidden="" id="qzone-banner-input" type="file"/>
</div>
<div class="qzone-user-info">
<div class="qzone-avatar-container" id="qzone-avatar-container">
<img alt="头像" id="qzone-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg"/>
<input accept="image/*" hidden="" id="qzone-avatar-input" type="file"/>
</div>
<span id="qzone-nickname">{{user}}</span>
</div>
</div>
<div class="qzone-actions-bar">
<div class="action-item" id="create-shuoshuo-btn"><span>说说</span></div>
<div class="action-item" id="create-post-btn"><span>动态</span></div>
<div class="action-item" id="open-album-btn"><span>相册</span></div>
</div>
<div id="qzone-posts-list"></div>
</div>
</div>
<!-- 收藏界面视图 -->
<div class="chat-list-view" id="favorites-view">
<div class="header">
<span class="back-btn" id="favorites-back-btn">‹</span>
<span>我的收藏</span>
<!-- 新增的编辑按钮 -->
<span class="action-btn" id="favorites-edit-btn">编辑</span>
</div>
<!-- 【新增】搜索栏容器 -->
<div class="search-bar-container">
<input id="favorites-search-input" placeholder="搜索收藏的标题、内容或作者..." type="search"/>
<button class="search-clear-btn" id="favorites-search-clear-btn" style="display: none;">×</button>
</div>
<div class="list-container" id="favorites-list">
<!-- 收藏内容将由JS动态生成在这里 -->
</div>
<!-- 新增：收藏页底部操作栏 -->
<div id="favorites-action-bar" style="display: none;">
<button class="action-bar-btn" id="favorites-delete-selected-btn">删除 (0)</button>
</div>
</div>
<!-- ▼▼▼ 【全新】回忆录界面视图 ▼▼▼ -->
<div class="chat-list-view" id="memories-view">
<div class="header">
<span class="back-btn" id="memories-back-btn">‹</span>
<span>我们的回忆</span>
<span class="action-btn" id="add-countdown-btn">+</span>
</div>
<div class="list-container" id="memories-list" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
<!-- 回忆卡片将由JS动态生成在这里 -->
</div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- 底部导航栏 -->
<div id="chat-list-bottom-nav">
<div class="nav-item active" data-view="messages-view">
<span>消息</span>
</div>
<div class="nav-item" data-view="qzone-screen">
<span>动态</span>
</div>
<!-- ▼▼▼ 在“动态”和“收藏”之间，加入这个新页签 ▼▼▼ -->
<div class="nav-item" data-view="memories-view">
<span>回忆</span>
</div>
<!-- ▲▲▲ 添加结束 ▲▲▲ -->
<div class="nav-item" data-view="favorites-view">
<span>收藏</span>
</div>
</div>
</div>
<!-- ▲▲▲ 替换区域结束 ▲▲▲ -->
<!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="chat-list-screen" 的 div 之后 ▼▼▼ -->
<div class="screen" id="album-screen">
<!-- 1. 页面头部，包含返回按钮和标题 -->
<div class="header">
<span class="back-btn" id="album-back-btn">‹</span>
<span>我的相册</span>
<span class="action-btn" id="create-album-btn-page">+</span>
</div>
<!-- 2. 页面内容容器 -->
<div class="list-container">
<div id="album-grid-page">
<!-- 相册列表将由 JS 动态生成在这里 -->
</div>
</div>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="album-screen" 的 div 之后 ▼▼▼ -->
<div class="screen" id="album-photos-screen">
<!-- 1. 页面头部 -->
<div class="header">
<span class="back-btn" id="album-photos-back-btn">‹</span>
<span id="album-photos-title">相册名称</span>
<span class="action-btn" id="album-upload-photo-btn">上传</span>
</div>
<!-- 2. 页面内容容器 -->
<div class="list-container">
<div id="photos-grid-page">
<!-- 照片列表将由 JS 动态生成在这里 -->
</div>
<!-- ▼▼▼ 请将这段新的 HTML 粘贴到所有模态框的末尾 ▼▼▼ -->
<div class="modal" id="photo-viewer-modal">
<!-- 1. 关闭按钮 -->
<button id="photo-viewer-close-btn">×</button>
<!-- 2. 上一张照片按钮 -->
<button class="nav-arrow" id="photo-viewer-prev-btn">‹</button>
<!-- 3. 图片容器 -->
<div class="photo-viewer-content">
<img alt="全屏照片预览" id="photo-viewer-image" src=""/>
</div>
<!-- 4. 下一张照片按钮 -->
<button class="nav-arrow" id="photo-viewer-next-btn">›</button>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->
</div>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 粘贴到 #album-photos-screen 的 div 之后 ▼▼▼ -->
<input accept="image/*" hidden="" id="album-photo-input" multiple="" type="file"/>
<!-- ▼▼▼ 请用这【一整块】全新的代码，完整替换掉您文件中旧的 #chat-interface-screen 及其所有内容 ▼▼▼ -->
<div class="screen" id="chat-interface-screen">
<!-- 【最终修正版】Header，已将状态栏和搜索功能正确整合 -->
<div class="header">
<!-- 默认控件：包含标题、状态栏和常规按钮 -->
<div class="default-controls">
<span class="back-btn" id="back-to-list-btn">‹</span>
<!-- ▼▼▼ 【核心新增】标题和状态的容器 ▼▼▼ -->
<div id="chat-header-title-wrapper">
<span id="chat-header-title">聊天对象</span>
<div id="chat-header-status">
<span class="status-dot"></span>
<span class="status-text">在线</span>
</div>
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->
<div class="header-actions">
<span class="action-btn" id="listen-together-btn" title="一起听"><img alt="一起听" src="https://i.postimg.cc/dV8sdNcx/210-20250618115221.png"/></span>
<span class="action-btn" id="chat-settings-btn" title="聊天设置"><img alt="设置" src="https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png"/></span>
</div>
</div>
<!-- 多选模式控件 (保持不变) -->
<div class="selection-controls">
<span id="selection-cancel-btn">取消</span>
<span id="selection-count"></span>
<div class="header-actions">
<span class="action-btn" id="selection-favorite-btn">收藏</span>
<span class="action-btn" id="selection-share-btn">分享</span>
<span class="action-btn" id="selection-delete-btn" style="color: #ff3b30;">删除</span>
</div>
</div>
</div>
<!-- 聊天消息区域 (保持不变) -->
<div id="chat-messages"><div id="typing-indicator">对方正在输入...</div></div>
<!-- 输入区域 (保持不变) -->
<div id="chat-input-area">
<div id="reply-preview-bar">
<div class="reply-preview-content">
<div class="sender">回复 xxx:</div>
<div class="text">被引用的消息内容...</div>
</div>
<span id="cancel-reply-btn">×</span>
</div>
<div id="chat-input-actions-top">
<button class="chat-action-icon-btn action-button" id="open-sticker-panel-btn" title="表情面板">+</button>
<button class="chat-action-icon-btn action-button" id="send-photo-btn" title="发送照片"><svg fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg></button>
<button class="chat-action-icon-btn action-button" id="upload-image-btn" title="上传图片"><svg fill="none" height="24" style="color: var(--text-primary);" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg></button>
<button class="chat-action-icon-btn action-button" id="transfer-btn" title="转账">￥</button>
<button class="chat-action-icon-btn action-button" id="voice-message-btn" title="发送语音"><svg fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><path d="M12 19v4"></path><path d="M8 23h8"></path></svg></button>
<!-- ▼▼▼ 将这行新代码粘贴到“发送语音”按钮的后面 ▼▼▼ -->
<button class="chat-action-icon-btn action-button" id="send-waimai-request-btn" title="发起外卖请求"><svg fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" x2="21" y1="6" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path></svg></button>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【新增】视频通话按钮 ▼▼▼ -->
<button class="chat-action-icon-btn action-button" id="video-call-btn" title="视频通话"><svg fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect height="14" rx="2" ry="2" width="15" x="1" y="5"></rect></svg></button>
<!-- ▲▲▲ 新增结束 ▲▲▲
<!-- ▼▼▼群视频通话按钮 ▼▼▼ -->
<button class="chat-action-icon-btn action-button" id="group-video-call-btn" title="群视频通话"><svg fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg></button>
<!-- ▲▲▲ 全新添加结束 ▲▲▲ -->
<!-- ▼▼▼发起投票按钮▼▼▼ -->
<button class="chat-action-icon-btn action-button" id="send-poll-btn" title="发起投票"><svg fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M8 6h10"></path><path d="M6 6h.01"></path><path d="M8 12h10"></path><path d="M6 12h.01"></path><path d="M8 18h10"></path><path d="M6 18h.01"></path></svg></button>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 在 id="chat-input-actions-top" 的末尾，【添加】这个新的按钮 ▼▼▼ -->
<button class="chat-action-icon-btn action-button" id="share-link-btn" title="分享链接"><svg fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg></button>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
</div>
<div id="chat-input-main-row">
<textarea id="chat-input" placeholder="输入消息..." rows="1"></textarea>
<div id="input-actions-wrapper">
<button id="wait-reply-btn" title="等待回复"><img alt="等待回复" src="https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png"/></button>
<button class="action-button" id="send-btn">发送</button>
</div>
</div>
</div>
<!-- ▼▼▼ 在这里新增 ▼▼▼ -->
<div id="chat-lock-overlay">
<div id="chat-lock-content"></div>
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->
<!-- 表情面板 (保持不变) -->
<div id="sticker-panel">
<div id="sticker-panel-header">
<span class="panel-btn" id="close-sticker-panel-btn">取消</span>
<span class="title">我的表情</span>
<div style="display: flex; gap: 10px;">
<span class="panel-btn" id="add-sticker-btn">添加</span>
<span class="panel-btn" id="upload-sticker-btn">上传</span>
</div>
</div>
<div id="sticker-grid"></div>
</div>
<input accept="image/*" id="sticker-upload-input" style="display: none;" type="file"/>
<input accept="image/*" id="image-upload-input" style="display: none;" type="file"/>
<!-- 音乐播放器 (保持不变) -->
<div id="music-player-overlay">
<div class="music-player-window">
<!-- 1. 顶部操作栏 -->
<div class="music-player-top-actions">
<div class="top-left-cluster">
<button id="music-return-btn">‹</button>
<button id="music-exit-btn">×</button>
</div>
<span id="music-playlist-btn">☰</span>
</div>
<!-- 2. 歌曲信息 -->
<div id="music-time-counter">已经一起听了0.0小时</div>
<div id="music-player-song-title">请添加歌曲</div>
<div id="music-player-artist">...</div>
<!-- 3. 【全新】歌词显示区域 -->
<div id="music-lyrics-container">
<div id="music-lyrics-list">
<!-- 歌词将由JS动态生成在这里 -->
<div class="lyric-line">♪ 暂无歌词 ♪</div>
</div>
</div>
<!-- 4. 【全新】播放控制区的包裹容器 -->
<div class="music-player-controls-wrapper">
<!-- a. 新的iOS风格进度条 -->
<div class="music-progress-bar-container">
<div class="time-display" id="music-current-time">0:00</div>
<div class="progress-bar">
<div class="progress-bar-fill" id="music-progress-fill"></div>
</div>
<div class="time-display" id="music-total-time">0:00</div>
</div>
<!-- b. 播放控制按钮 -->
<div class="music-controls">
<button id="music-prev-btn">◀</button>
<button class="play-pause-btn" id="music-play-pause-btn">▶</button>
<button id="music-next-btn">▶</button>
<button id="music-mode-btn">顺序</button>
</div>
</div>
</div>
</div>
<div id="music-playlist-panel">
<div class="playlist-header">
<span class="panel-btn" id="close-playlist-btn">返回</span>
<span>播放列表</span>
<div>
<span class="panel-btn" id="add-song-local-btn">本地</span>
<span class="panel-btn" id="add-song-url-btn">URL</span>
</div>
</div>
<div class="playlist-body" id="playlist-body"></div>
</div>
<input accept="audio/*" id="local-song-upload-input" multiple="" style="display: none;" type="file"/>
<input accept=".lrc" id="lrc-upload-input" style="display: none;" type="file"/>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 用这整块代码替换你原来的 id="wallpaper-screen" ▼▼▼ -->
<div class="screen" id="wallpaper-screen">
<div class="header">
<span class="back-btn" onclick="showScreen('home-screen')">‹</span>
<!-- 【核心修改1】标题改为“外观设置”，更通用 -->
<span>外观设置</span>
<span style="width: 30px;"></span>
</div>
<div class="form-container">
<!-- 壁纸设置部分保持不变 -->
<div id="wallpaper-preview">点击下方上传</div>
<button class="form-button" onclick="document.getElementById('wallpaper-upload-input').click();">上传壁纸</button>
<input accept="image/*" id="wallpaper-upload-input" type="file"/>
<!-- ▼▼▼ 将【上面整块代码】，完整替换为下面这段【全新的代码】 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
<label for="theme-toggle-switch" style="margin-bottom: 0;">夜间模式</label>
<label class="toggle-switch">
<input id="theme-toggle-switch" type="checkbox"/>
<span class="slider"></span>
</label>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- 【核心修改2】新增图标设置区域 -->
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;"/>
<div style="width:100%; text-align: left; margin-bottom: 15px;">
<label style="font-weight: 500; color: var(--text-secondary);">App 图标设置</label>
</div>
<div id="icon-settings-grid">
<!-- 图标设置项将由JS动态生成在这里 -->
</div>
<!-- 【核心修改3】按钮文字也改一下 -->
<button class="form-button" id="save-wallpaper-btn" style="margin-top: 30px;">保存所有外观设置</button>
</div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】分享链接功能 HTML ▼▼▼ -->
<div class="screen" id="browser-screen">
<div class="header">
<span class="back-btn" id="browser-back-btn">‹</span>
<span id="browser-title"></span>
<span style="width: 30px;"></span>
</div>
<div class="list-container" id="browser-content">
<!-- 文章内容将由JS动态生成在这里 -->
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<div class="screen" id="font-settings-screen">
<div class="header">
<span class="back-btn" onclick="showScreen('home-screen')">‹</span>
<span>字体设置</span>
<span style="width: 30px;"></span>
</div>
<div class="form-container">
<div class="form-group">
<label for="font-url-input">字体文件URL (.ttf, .otf, .woff等)</label>
<input id="font-url-input" placeholder="https://..../font.ttf" type="text"/>
</div>
<div class="form-group">
<label>实时预览</label>
<div id="font-preview">
<p style="font-size: 20px; margin: 0 0 10px 0;">你好世界 Hello World</p>
<p style="margin: 0;">这是字体预览效果，12345。</p>
</div>
</div>
<button class="form-button" id="save-font-btn">保存并应用</button>
<button class="form-button form-button-secondary" id="reset-font-btn">恢复默认字体</button>
</div>
</div>
<!-- ▼▼▼ 【全新】选择联系人以创建群聊的屏幕 ▼▼▼ -->
<div class="screen" id="contact-picker-screen">
<div class="header">
<span class="back-btn" id="cancel-contact-picker-btn">取消</span>
<span>选择联系人</span>
<span class="save-btn" id="confirm-contact-picker-btn">完成(0)</span>
</div>
<div class="list-container" id="contact-picker-list">
<!-- 联系人列表将由JS动态生成 -->
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】群成员管理屏幕 ▼▼▼ -->
<div class="screen" id="member-management-screen">
<div class="header">
<span class="back-btn" id="back-from-member-management">‹</span>
<span>群成员管理</span>
<span style="width: 30px;"></span>
</div>
<div class="list-container" id="member-management-list">
<!-- 现有成员列表会在这里动态生成 -->
</div>
<div id="member-management-actions">
<button id="add-existing-contact-btn">从好友列表添加</button>
<button id="create-new-member-btn">创建群内新成员</button>
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】来电请求模态框 ▼▼▼ -->
<div class="modal" id="incoming-call-modal">
<div class="incoming-call-content">
<img class="caller-avatar" id="caller-avatar" src=""/>
<div class="caller-name" id="caller-name"></div>
<div class="caller-text">邀请你视频通话</div>
<div class="incoming-call-actions">
<div class="action-button-wrapper">
<button class="call-action-btn decline" id="decline-call-btn"></button>
<span>拒绝</span>
</div>
<div class="action-button-wrapper">
<button class="call-action-btn accept" id="accept-call-btn"></button>
<span>接听</span>
</div>
</div>
</div>
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->
<!-- ▼▼▼ 请用这段【全新群聊兼容结构】的代码，完整替换你旧的 #video-call-screen ▼▼▼ -->
<div class="screen" id="video-call-screen">
<!-- 1. 顶部栏 (保持不变) -->
<div class="video-call-top-bar">
<span id="call-timer">00:00</span>
</div>
<!-- 2. 【升级】参与者头像网格区域 -->
<div class="video-call-avatar-area">
<div id="participant-avatars-grid">
<!-- JS会在这里动态生成头像 -->
</div>
</div>
<!-- 3. 对话框区域 (保持不变) -->
<div class="video-call-main" id="video-call-main">
<!-- 对话内容会动态生成在这里 -->
</div>
<!-- 4. 【升级】底部控制栏，现在包含一个“加入”按钮 -->
<div class="video-call-controls">
<button class="control-btn speak-btn" id="user-speak-btn"></button>
<button class="control-btn hangup-btn" id="hang-up-btn"></button>
<!-- 这个按钮默认隐藏，只在用户“旁观”时显示 -->
<button class="control-btn join-btn" id="join-call-btn" style="display: none;"></button>
</div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新添加】正在呼叫界面 ▼▼▼ -->
<div class="screen" id="outgoing-call-screen">
<div class="outgoing-call-content">
<img class="caller-avatar" id="outgoing-call-avatar" src=""/>
<div class="caller-name" id="outgoing-call-name"></div>
<div class="caller-text">正在呼叫...</div>
<div class="outgoing-call-actions">
<button class="call-action-btn decline" id="cancel-call-btn"></button>
<span>取消</span>
</div>
</div>
</div>
<!-- ▲▲▲ 添加结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】通话记录页面 ▼▼▼ -->
<div class="screen" id="call-history-screen">
<div class="header">
<span class="back-btn" id="call-history-back-btn">‹</span>
<span id="call-history-title">通话记录</span>
<span style="width: 30px;"></span> <!-- 占位符，保持标题居中 -->
</div>
<div class="list-container" id="call-history-list" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
<!-- 通话记录卡片将由JS动态生成在这里 -->
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
</div>

<div class="modal" id="chat-settings-modal"><div class="modal-content"><div class="modal-header"><span>聊天设置</span></div><div class="modal-body"><div class="form-group" id="chat-name-group"><label for="chat-name-input">备注名 / 群名</label><input id="chat-name-input" type="text"/></div>
<!-- ▼▼▼ 请将这段新代码粘贴到“备注名”输入框的 form-group 之后 ▼▼▼ -->
<div class="form-group" id="assign-group-section" style="display: none;"> <!-- 默认隐藏，只对单聊显示 -->
<label for="assign-group-select">好友分组</label>
<div style="display: flex; align-items: center; gap: 10px;">
<select id="assign-group-select" style="flex-grow: 1;">
<!-- 分组选项将由JS动态生成 -->
</select>
<button class="form-button-secondary" id="manage-groups-btn" style="margin-top: 0; padding: 12px;">管理分组</button>
</div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<div class="form-group" id="my-group-nickname-group"><label for="my-group-nickname-input">我的群昵称</label><input id="my-group-nickname-input" type="text"/></div><div class="form-group" id="group-avatar-group"><label>群头像</label><div class="avatar-upload"><img id="group-avatar-preview"/><button onclick="document.getElementById('group-avatar-input').click()">上传群头像</button><input accept="image/*" id="group-avatar-input" type="file"/></div></div>
<div class="form-group" id="world-book-link-group">
<label>关联世界书 (可多选)</label>
<div class="custom-multiselect">
<div class="select-box">
<span class="selected-options-text">-- 点击选择 --</span>
<span class="arrow-down">▼</span>
</div>
<div class="checkboxes-container" id="world-book-checkboxes-container">
</div>
</div>
</div>
<div class="form-group" id="ai-persona-group"><label for="ai-persona">对方人设 (AI Persona)</label><textarea id="ai-persona" rows="3"></textarea></div><div class="form-group" id="ai-avatar-group"><label>对方头像</label><div class="avatar-upload"><img id="ai-avatar-preview"/><button onclick="document.getElementById('ai-avatar-input').click()">上传对方头像</button><button id="manage-ai-avatar-library-btn">管理头像库</button>
<input accept="image/*" id="ai-avatar-input" type="file"/></div></div><div class="form-group" id="my-persona-group"><label for="my-persona">我的人设 (My Persona)</label><textarea id="my-persona" rows="3"></textarea></div><div class="form-group" id="my-avatar-group"><label>我的头像</label><div class="avatar-upload"><img id="my-avatar-preview"/><button onclick="document.getElementById('my-avatar-input').click()">上传我的头像</button><button id="open-persona-library-btn">预设</button><input accept="image/*" id="my-avatar-input" type="file"/></div></div><div class="form-group" id="group-members-group"><label>群成员人设</label><div id="group-members-settings"></div>
<!-- 【新增】管理成员按钮 -->
<button class="form-button form-button-secondary" id="manage-members-btn" style="margin-top: 15px;">管理群成员</button></div>
<div class="form-group"><label for="max-memory">上下文记忆条数</label><input id="max-memory" type="number" value="10"/></div><div class="form-group"><label>聊天气泡主题 <button id="reset-theme-btn" type="button">重置</button></label><div class="theme-selector"><label><input id="theme-default" name="theme-select" type="radio" value="default"/> 默认</label><label><input name="theme-select" type="radio" value="pink_blue"/> 粉蓝</label><label><input name="theme-select" type="radio" value="blue_white"/> 蓝白</label><label><input name="theme-select" type="radio" value="purple_yellow"/> 紫黄</label><label><input name="theme-select" type="radio" value="black_white"/> 黑白</label><label><input name="theme-select" type="radio" value="yellow_white"/> 黄白</label><label><input name="theme-select" type="radio" value="red_black"/> 红黑</label><label><input name="theme-select" type="radio" value="blue_yellow"/> 蓝黄</label><label><input name="theme-select" type="radio" value="pink_yellow"/> 粉黄</label><label><input name="theme-select" type="radio" value="pink_purple"/> 粉紫</label><label><input name="theme-select" type="radio" value="gray_white"/> 灰白</label><label><input name="theme-select" type="radio" value="blue_green"/> 蓝绿</label><label><input name="theme-select" type="radio" value="pink_white"/> 粉白</label><label><input name="theme-select" type="radio" value="pink_black"/> 粉黑</label><label><input name="theme-select" type="radio" value="pink_green"/> 粉绿</label><label><input name="theme-select" type="radio" value="green_black"/> 绿黑</label></div></div>
<!-- ▼▼▼ 请将这段新代码粘贴到“聊天气泡主题”的 form-group 之后 ▼▼▼ -->
<div class="form-group">
<label for="font-size-slider">聊天字体大小 <span id="font-size-value">13px</span></label>
<input id="font-size-slider" max="20" min="12" step="1" style="width: 100%; margin-top: 8px;" type="range" value="13"/>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 请将这段新代码粘贴到“聊天字体大小”的 form-group 之后 ▼▼▼ -->
<div class="form-group">
<label for="custom-css-input">
        自定义气泡样式 (CSS)
        <button id="reset-custom-css-btn" style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;" type="button">重置</button>
</label>
<textarea id="custom-css-input" placeholder="/* 示例：为“我”的气泡添加渐变背景和阴影 */
.message-bubble.user .content {
  background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  border-radius: 15px 4px 15px 15px;
}" rows="5" style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 12px; resize: vertical;"></textarea>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 请将这段新代码粘贴到自定义CSS输入框的 form-group 之后 ▼▼▼ -->
<div class="form-group">
<label>实时预览</label>
<div id="settings-preview-area">
<!-- JS会在这里生成预览内容 -->
</div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<div class="form-group">
<label>聊天背景</label>
<div class="bg-upload-container">
<button class="form-button-secondary" onclick="document.getElementById('bg-input').click()" style="width: auto; padding: 8px 12px; margin-top: 0;" type="button">上传背景图</button>
<button id="remove-bg-btn" type="button">移除背景</button>
</div>
<img class="bg-preview-img" id="bg-preview"/>
<input accept="image/*" id="bg-input" style="display: none;" type="file"/>
</div>
<hr style="margin: 25px 0; border: none; border-top: 1px solid #eee;"/>
<button class="form-button form-button-secondary" id="block-chat-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">拉黑对方</button>
<button class="form-button form-button-secondary" id="clear-chat-btn">清空聊天记录</button></div><div class="modal-footer"><button class="cancel" id="cancel-chat-settings-btn">取消</button><button class="save" id="save-chat-settings-btn">保存</button></div></div></div>
<div class="modal" id="persona-library-modal"><div class="modal-content"><div class="modal-header"><span>我的人设库</span><button class="action-button" id="add-persona-preset-btn">添加</button></div><div class="modal-body"><div id="persona-library-grid"></div></div><div class="modal-footer"><button class="cancel" id="close-persona-library-btn">关闭</button></div></div></div>
<div class="modal" id="persona-editor-modal"><div class="modal-content"><div class="modal-header"><span id="persona-editor-title">添加人设预设</span></div><div class="modal-body"><div class="form-group"><label>预设头像</label><div class="avatar-upload"><img id="preset-avatar-preview"/><button onclick="document.getElementById('preset-avatar-input').click()">上传头像</button><input accept="image/*" id="preset-avatar-input" type="file"/></div></div><div class="form-group"><label for="preset-persona-input">预设人设</label><textarea id="preset-persona-input" placeholder="在此输入这个人设的详细设定..." rows="4"></textarea></div></div><div class="modal-footer"><button class="cancel" id="cancel-persona-editor-btn">取消</button><button class="save" id="save-persona-preset-btn">保存</button></div></div></div>
<div class="modal" id="member-settings-modal"><div class="modal-content"><div class="modal-header"><span>编辑群成员</span></div><div class="modal-body">
<div class="form-group"><label for="member-name-input">名字</label><input id="member-name-input" type="text"/></div>
<div class="form-group"><label for="member-persona-input">人设</label><textarea id="member-persona-input" rows="4"></textarea></div>
<div class="form-group"><label>头像</label><div class="avatar-upload"><img id="member-avatar-preview"/><button onclick="document.getElementById('member-avatar-input').click()">上传头像</button><input accept="image/*" id="member-avatar-input" type="file"/></div></div>
</div><div class="modal-footer"><button class="cancel" id="cancel-member-settings-btn">取消</button><button class="save" id="save-member-settings-btn">保存</button></div></div></div>
<div id="custom-modal-overlay">
<div id="custom-modal">
<div class="custom-modal-header" id="custom-modal-title"></div>
<div class="custom-modal-body" id="custom-modal-body"></div>
<div class="custom-modal-footer">
<button id="custom-modal-cancel">取消</button>
<button class="confirm-btn" id="custom-modal-confirm">确定</button>
</div>
</div>
</div>
<div class="modal" id="preset-actions-modal">
<div id="custom-modal" style="width: 250px;">
<div class="custom-modal-footer">
<button id="preset-action-edit">编辑预设</button>
<button class="btn-danger" id="preset-action-delete">删除预设</button>
<button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
</div>
</div>
</div>
<div id="transfer-modal">
<div class="transfer-content">
<div class="transfer-header">给Ta一个惊喜！</div>
<div class="transfer-input-group">
<label for="transfer-amount">转账金额</label>
<input id="transfer-amount" max="9999" min="0" placeholder="0.00" step="0.01" type="number"/>
</div>
<div class="transfer-input-group">
<label for="transfer-note">备注 (可选)</label>
<input id="transfer-note" maxlength="20" placeholder="留下你的小心思~" type="text"/>
</div>
<div class="transfer-actions">
<button id="transfer-cancel-btn">取消</button>
<button id="transfer-confirm-btn">确认转账</button>
</div>
</div>
</div>
<div id="battery-alert-modal">
<div class="battery-alert-content">
<img id="battery-alert-image" src=""/>
<p id="battery-alert-text"></p>
</div>
</div>
<audio id="audio-player" style="display:none;"></audio>
<!-- ▼▼▼ 用下面这段【完整】的模态框代码，替换掉你现有的 id="create-post-modal" 的整个 div ▼▼▼ -->
<div class="modal" id="create-post-modal">
<div class="modal-content" style="height: auto; max-height: 90%;">
<div class="modal-header">
<span>发布动态</span>
</div>
<div class="modal-body">
<!-- 公开文字输入区 -->
<div class="form-group">
<textarea id="post-public-text" placeholder="分享新鲜事...（非必填的公开文字）" rows="3"></textarea>
</div>
<!-- === 模式切换开关 (新增) === -->
<div class="post-mode-switcher">
<button class="mode-btn active" id="switch-to-image-mode">上传图片</button>
<button class="mode-btn" id="switch-to-text-image-mode">使用文字图</button>
</div>
<!-- ▼▼▼ 【修正后】的可见范围设置 ▼▼▼ -->
<div class="form-group">
<label>可见范围</label>
<div id="post-visibility-options" style="display: flex; gap: 15px; margin-bottom: 10px;">
<label><input checked="" name="visibility" type="radio" value="public"/> 公开</label>
<label><input name="visibility" type="radio" value="include"/> 指定分组可见</label>
</div>
<div id="post-visibility-groups" style="display: none; max-height: 120px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px;">
<!-- 分组多选框将由JS动态生成 -->
</div>
</div>
<!-- ▲▲▲ 修正结束 ▲▲▲ -->
<!-- === 图片模式区域 === -->
<div class="post-mode-content active" id="image-mode-content">
<div class="form-group">
<div class="post-image-preview-container" id="post-image-preview-container">
<img alt="图片预览" id="post-image-preview" src=""/>
<button id="post-remove-image-btn">×</button>
</div>
<div class="post-image-upload-options">
<button class="form-button-secondary" id="post-upload-local-btn">本地上传</button>
<button class="form-button-secondary" id="post-use-url-btn">网络URL</button>
<input accept="image/*" hidden="" id="post-local-image-input" type="file"/>
</div>
</div>
<div class="form-group" id="post-image-desc-group" style="display: none;">
<label>图片描述 (必填，给AI看)</label>
<input id="post-image-description" placeholder="简单描述图片内容，帮助AI理解" type="text"/>
</div>
</div>
<!-- === 文字图模式区域 (新增) === -->
<div class="post-mode-content" id="text-image-mode-content">
<div class="form-group">
<label>文字图 (给AI理解用的描述，点击图片后可见)</label>
<textarea id="post-hidden-text" placeholder="在这里写下图片描述..." rows="4"></textarea>
</div>
</div>
</div>
<div class="modal-footer">
<button class="cancel" id="cancel-create-post-btn">取消</button>
<button class="save" id="confirm-create-post-btn">发布</button>
</div>
</div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 请将这个新的模态框HTML粘贴到所有其他模态框之后 ▼▼▼ -->
<div class="modal" id="group-management-modal">
<div class="modal-content" style="height: 60%;">
<div class="modal-header">
<span>管理好友分组</span>
</div>
<div class="modal-body">
<div class="form-group">
<label>新建分组</label>
<div style="display: flex; gap: 10px;">
<input id="new-group-name-input" placeholder="输入分组名..." style="flex-grow: 1;" type="text"/>
<button class="form-button" id="add-new-group-btn" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
</div>
</div>
<hr style="opacity: 0.2;"/>
<div id="existing-groups-list" style="display: flex; flex-direction: column; gap: 10px;">
<!-- 分组列表将由JS动态生成 -->
</div>
</div>
<div class="modal-footer">
<button class="save" id="close-group-manager-btn" style="width: 100%;">完成</button>
</div>
</div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
<div class="modal" id="message-actions-modal">
<div id="custom-modal" style="width: 250px;">
<div class="custom-modal-footer">
<!-- 新的操作按钮 -->
<button id="edit-message-btn">编辑消息</button>
<button id="copy-message-btn">复制文本</button>
<button id="recall-message-btn">撤回</button>
<button id="quote-message-btn">引用</button>
<button id="select-message-btn">进入多选</button>
<!-- 取消按钮 -->
<button id="cancel-message-action-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
</div>
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
<div class="modal" id="post-actions-modal">
<div id="custom-modal" style="width: 250px;">
<div class="custom-modal-footer">
<button id="edit-post-btn">编辑动态</button>
<button id="copy-post-btn">复制内容</button>
<button id="cancel-post-action-btn">取消</button>
</div>
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】可视化消息编辑器模态框 ▼▼▼ -->
<div class="modal" id="message-editor-modal">
<div class="modal-content" style="height: 75%;">
<div class="modal-header">
<span>编辑与拆分消息</span>
</div>
<div class="modal-body" id="message-editor-body">
<!-- 编辑器容器，JS会在这里动态生成文本框 -->
<div id="message-editor-container"></div>
<!-- 添加新消息的按钮 -->
<button class="form-button form-button-secondary" id="add-message-editor-block-btn" style="margin-top: 15px;">
                [+] 添加下一条消息
            </button>
</div>
<div class="modal-footer">
<button class="cancel" id="cancel-advanced-editor-btn">取消</button>
<button class="save" id="save-advanced-editor-btn">保存更改</button>
</div>
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】外卖请求模态框 ▼▼▼ -->
<div class="modal" id="waimai-request-modal">
<div class="modal-content" style="width: 290px;">
<div class="modal-header">
<span>发起外卖代付</span>
</div>
<div class="modal-body">
<div class="form-group">
<label for="waimai-product-info">商品信息</label>
<input id="waimai-product-info" placeholder="例如：一杯杨枝甘露" type="text"/>
</div>
<div class="form-group">
<label for="waimai-amount">代付金额 (元)</label>
<input id="waimai-amount" min="0" placeholder="例如：21" step="0.01" type="number"/>
</div>
</div>
<div class="modal-footer">
<button class="cancel" id="waimai-cancel-btn">取消</button>
<button class="save" id="waimai-confirm-btn">发起请求</button>
</div>
</div>
</div>
<!-- ▼▼▼ 【全新】新建约定/倒计时模态框 ▼▼▼ -->
<div class="modal" id="create-countdown-modal">
<div class="modal-content" style="height: auto;">
<div class="modal-header">
<span>新建约定</span>
</div>
<div class="modal-body">
<div class="form-group">
<label for="countdown-title-input">约定标题</label>
<input id="countdown-title-input" placeholder="例如：我的生日" type="text"/>
</div>
<div class="form-group">
<label for="countdown-date-input">约定日期与时间</label>
<input id="countdown-date-input" type="datetime-local"/>
</div>
</div>
<div class="modal-footer">
<button class="cancel" id="cancel-create-countdown-btn">取消</button>
<button class="save" id="confirm-create-countdown-btn">保存约定</button>
</div>
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】发红包模态框 ▼▼▼ -->
<div class="modal" id="red-packet-modal">
<div class="modal-content" style="width: 300px; height: auto;">
<div class="modal-header">
<span>发红包</span>
</div>
<div class="modal-body" style="padding: 0;">
<!-- 1. 页签切换 -->
<div class="frame-tabs">
<div class="frame-tab active" id="rp-tab-group">拼手气红包</div>
<div class="frame-tab" id="rp-tab-direct">专属红包</div>
</div>
<!-- 2. 拼手气红包内容区 -->
<div class="frame-content" id="rp-content-group" style="padding: 20px 15px;">
<div class="form-group">
<label>总金额 (元)</label>
<input id="rp-group-amount" placeholder="0.00" type="number"/>
</div>
<div class="form-group">
<label>红包个数</label>
<input id="rp-group-count" placeholder="填写红包个数" type="number"/>
</div>
<div class="form-group">
<label>祝福语</label>
<input id="rp-group-greeting" placeholder="恭喜发财，大吉大利！" type="text"/>
</div>
<p id="rp-group-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
<button class="form-button" id="send-group-packet-btn">塞钱进红包</button>
</div>
<!-- 3. 专属红包内容区 -->
<div class="frame-content" id="rp-content-direct" style="display: none; padding: 20px 15px;">
<div class="form-group">
<label>发送给</label>
<select id="rp-direct-receiver"></select>
</div>
<div class="form-group">
<label>金额 (元)</label>
<input id="rp-direct-amount" placeholder="0.00" type="number"/>
</div>
<div class="form-group">
<label>祝福语</label>
<input id="rp-direct-greeting" placeholder="恭喜发财，大吉大利！" type="text"/>
</div>
<p id="rp-direct-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
<button class="form-button" id="send-direct-packet-btn">塞钱进红包</button>
</div>
</div>
<div class="modal-footer" style="justify-content: center;">
<button class="cancel" id="cancel-red-packet-btn" style="width: 100%;">取消</button>
</div>
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】红包详情模态框 ▼▼▼ -->
<div class="modal" id="red-packet-details-modal">
<div class="modal-content" style="width: 280px; height: auto; background-color: #f7f7f7;">
<div class="modal-header" style="background-color: #F96259; color: white; border-bottom: none; padding-bottom: 5px;">
<div style="text-align: center; width: 100%;">
<div id="rp-details-sender" style="font-size: 16px;"></div>
<div style="font-size: 13px; opacity: 0.8;">的红包</div>
</div>
</div>
<div class="modal-body" style="padding: 15px;">
<p id="rp-details-greeting" style="text-align: center; font-size: 20px; color: #333; margin: 0 0 20px 0;"></p>
<div id="rp-details-my-amount" style="text-align: center; display: none; margin-bottom: 20px;">
<span style="font-size: 40px; font-weight: bold; color: #E44D44;">0.00</span>
<span style="font-size: 18px; color: #E44D44;">元</span>
</div>
<div id="rp-details-summary" style="font-size: 13px; color: #8a8a8a; border-top: 1px solid #e0e0e0; padding-top: 10px;"></div>
<div id="rp-details-list" style="max-height: 150px; overflow-y: auto; margin-top: 10px;">
<!-- 领取详情将由JS动态生成在这里 -->
</div>
</div>
<div class="modal-footer">
<button class="save" id="close-rp-details-btn" style="width: 100%;">关闭</button>
</div>
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】创建投票模态框 ▼▼▼ -->
<div class="modal" id="create-poll-modal">
<div class="modal-content" style="width: 300px; height: auto;">
<div class="modal-header">
<span>发起投票</span>
</div>
<div class="modal-body">
<div class="form-group">
<label for="poll-question-input">投票问题</label>
<textarea id="poll-question-input" placeholder="例如：今晚我们看什么电影？" rows="2"></textarea>
</div>
<div class="form-group">
<label>投票选项 (至少2项)</label>
<div id="poll-options-container" style="display: flex; flex-direction: column; gap: 8px;">
<!-- 投票选项将由JS动态生成在这里 -->
</div>
<button class="form-button form-button-secondary" id="add-poll-option-btn" style="margin-top: 12px;">+ 添加选项</button>
</div>
</div>
<div class="modal-footer">
<button class="cancel" id="cancel-create-poll-btn">取消</button>
<button class="save" id="confirm-create-poll-btn">发起投票</button>
</div>
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】AI头像库管理模态框 ▼▼▼ -->
<div class="modal" id="ai-avatar-library-modal">
<div class="modal-content" style="height: 70%;">
<div class="modal-header">
<span id="ai-avatar-library-title">对方的头像库</span>
<button class="action-button" id="add-ai-avatar-btn">添加</button>
</div>
<div class="modal-body" style="padding: 15px;">
<div id="ai-avatar-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
<!-- 头像库内容将由JS动态生成 -->
</div>
</div>
<div class="modal-footer">
<button class="save" id="close-ai-avatar-library-btn" style="width: 100%;">关闭</button>
</div>
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】用户分享链接模态框 ▼▼▼ -->
<div class="modal" id="share-link-modal">
<div class="modal-content" style="width: 300px; height: auto;">
<div class="modal-header">
<span>分享链接</span>
</div>
<div class="modal-body">
<div class="form-group">
<label for="link-title-input">标题</label>
<input id="link-title-input" placeholder="输入文章或链接的标题" type="text"/>
</div>
<div class="form-group">
<label for="link-description-input">摘要 (可选)</label>
<textarea id="link-description-input" placeholder="简单描述一下链接内容" rows="2"></textarea>
</div>
<div class="form-group">
<label for="link-source-input">来源名称 (可选)</label>
<input id="link-source-input" placeholder="例如：知乎日报、B站" type="text"/>
</div>
<div class="form-group">
<label for="link-content-input">完整内容 (可选，用于浏览器内显示)</label>
<textarea id="link-content-input" placeholder="粘贴或输入完整的文章内容" rows="4"></textarea>
</div>
</div>
<div class="modal-footer">
<button class="cancel" id="cancel-share-link-btn">取消</button>
<button class="save" id="confirm-share-link-btn">分享</button>
</div>
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】精致版转账操作弹窗 ▼▼▼ -->
<div class="modal" id="transfer-actions-modal">
<div class="transfer-actions-content">
<div class="transfer-actions-header">请选择操作</div>
<div class="transfer-actions-body">
<p>你收到了来自 <strong id="transfer-sender-name"></strong> 的一笔转账。</p>
</div>
<div class="transfer-actions-footer">
<button class="action-btn decline" id="transfer-action-decline">残忍拒绝</button>
<button class="action-btn accept" id="transfer-action-accept">开心收下</button>
</div>
<button class="cancel-btn" id="transfer-action-cancel">×</button>
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】通话记录详情模态框 ▼▼▼ -->
<div class="modal" id="call-transcript-modal">
<div class="modal-content" style="height: 70%;">
<div class="modal-header">
<span id="transcript-modal-title">通话详情</span>
</div>
<div class="modal-body" id="transcript-modal-body" style="background-color: #f0f2f5;">
<!-- 通话文字记录将由JS动态生成在这里 -->
</div>
<div class="modal-footer">
<button class="cancel" id="delete-transcript-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">删除记录</button>
<button class="save" id="close-transcript-modal-btn" style="width: 100%;">关闭</button>
</div>
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】分享目标选择器模态框 ▼▼▼ -->
<div class="modal" id="share-target-modal">
<div class="modal-content" style="height: 70%;">
<div class="modal-header">
<span>分享到...</span>
</div>
<div class="modal-body" id="share-target-list" style="padding: 0;">
<!-- 聊天列表将由JS动态生成在这里 -->
</div>
<div class="modal-footer">
<button class="cancel" id="cancel-share-target-btn">取消</button>
<button class="save" id="confirm-share-target-btn">确认分享</button>
</div>
</div>
</div>
<!-- ▼▼▼ 【全新】分享记录查看器模态框 ▼▼▼ -->
<div class="modal" id="shared-history-viewer-modal">
<div class="modal-content" style="height: 80%;">
<div class="modal-header">
<span id="shared-history-viewer-title">聊天记录</span>
</div>
<div class="modal-body" id="shared-history-viewer-content" style="background-color: #f0f2f5;">
<!-- 分享的聊天记录气泡将由JS动态生成在这里 -->
</div>
<div class="modal-footer">
<button class="save" id="close-shared-history-viewer-btn" style="width:100%;">关闭</button>
</div>
</div>
</div>
<!-- ▼▼▼ 【全新】世界书分类管理模态框 ▼▼▼ -->
<div class="modal" id="world-book-category-manager-modal">
<div class="modal-content" style="height: 60%;">
<div class="modal-header">
<span>管理世界书分类</span>
</div>
<div class="modal-body">
<div class="form-group">
<label>新建分类</label>
<div style="display: flex; gap: 10px;">
<input id="new-category-name-input" placeholder="输入分类名..." style="flex-grow: 1;" type="text"/>
<button class="form-button" id="add-new-category-btn" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
</div>
</div>
<hr style="opacity: 0.2;"/>
<div id="existing-categories-list" style="display: flex; flex-direction: column; gap: 10px;">
<!-- 分类列表将由JS动态生成 -->
</div>
</div>
<div class="modal-footer">
<button class="save" id="close-category-manager-btn" style="width: 100%;">完成</button>
</div>
</div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<script>

        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models'
    // gemini如果是多个密钥, 那么随机获取一个
    function getRandomValue(str) {
        // 检查字符串是否包含逗号
        if (str.includes(',')) {
            // 用逗号分隔字符串并移除多余空格
            const arr = str.split(',').map(item => item.trim());
            // 生成随机索引 (0 到 arr.length-1)
            const randomIndex = Math.floor(Math.random() * arr.length);
            // 返回随机元素
            return arr[randomIndex];
        }
        // 没有逗号则直接返回原字符串
        return str;
    }
    function isImage(text,content) {
        let currentImageData = content.image_url.url
        // 提取Base64数据（去掉前缀）
        const base64Data = currentImageData.split(',')[1];
        // 根据图片类型获取MIME类型
        const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
        return [
            {text: `${text.text}用户向你发送了一张图片`},
            {
                inline_data: {
                    mime_type: mimeType,
                    data: base64Data
                }
            }
        ]
    }

   function extractArray(text) {
        // 正则表达式模式：匹配开头的时间戳部分和后续的JSON数组
        const pattern = /^\(Timestamp: (\d+)\)(.*)$/s;
        const match = text.match(pattern);

        if (match) {
            const timestampPart = `(Timestamp: ${match[1]}) `;
            const jsonPart = match[2].trim();

            try {
                // 尝试解析JSON部分
                const parsedJson = JSON.parse(jsonPart);
                // 验证解析结果是否为数组
                if (Array.isArray(parsedJson)) {
                    return [timestampPart, parsedJson[0]];
                }
            } catch (error) {
                // 解析失败，返回原始文本
            }
        }

        // 不匹配格式或解析失败时返回原值
        return text;
    }
    function transformChatData(item) {
        let type = {
            send_and_recall:'撤回了消息',
            update_status:'更新了状态',
            change_music:'切换了歌曲',
            create_memory:'记录了回忆',
            create_countdown:'创建了约定/倒计时',
            text:'发送了文本',
            sticker:'发送了表情',
            ai_image:'发送了图片',
            voice_message:'发送了语音',
            transfer:'发起了转账',
            waimai_request:'发起了外卖请求',
            waimai_response:{
                paid:'回应了外卖-同意',
                rejected:'回应了外卖-拒绝'
            },
            video_call_request:'发起了视频通话',
            video_call_response:{
                accept:'回应了视频通话-接受',
                reject:'回应了视频通话-拒绝'
            },
            qzone_post:{
                shuoshuo:'发布了说说',
                text_image:'发布了文字图'
            },
            qzone_comment:'评论了动态',
            qzone_like:'点赞了动态',
            pat_user:'拍一拍了用户',
            block_user:'拉黑了用户',
            friend_request_response:'回应了好友申请',
            change_avatar:'更换了头像',
            share_link:'分享了链接',
            accept_transfer:'回应了转账-接受',
            decline_transfer:'回应了转账-拒绝/退款',
            quote_reply:'引用了回复',
            text:'',
        }
        let res = extractArray(item.content)

        if(Array.isArray(res)){
            let obj = res[1]
            let itemType = obj.type;
            let time = res[0]
            let text = type[itemType];
            if(text){
                if(itemType === 'sticker'){
                    return [{text:`${time}[${text}] 含义是:${obj.meaning}`}]
                }else if(itemType === 'send_and_recall'){
                    return [{text:`${time}[${text}] ${obj.content}`}]
                }else if(itemType === 'update_status'){
                    return [{text:`${time}[${text}] ${obj.status_text}(${obj.is_busy ? '忙碌/离开' : '空闲'})`}]
                }else if(itemType === 'change_music'){
                    return [{text:`${time}[${text}] ${obj.change_music}, 歌名是:${obj.song_name}`}]
                }else if(itemType === 'create_memory'){
                    return [{text:`${time}[${text}] ${obj.description}`}]
                }else if(itemType === 'create_countdown'){
                    return [{text:`${time}[${text}] ${obj.title}(${obj.date})`}]
                }else if(itemType === 'ai_image'){
                    return [{text:`${time}[${text}] 图片描述是:${obj.description}`}]
                }else if(itemType === 'voice_message'){
                    return [{text:`${time}[${text}] ${obj.content}`}]
                }else if(itemType === 'transfer'){
                    return [{text:`${time}[${text}] 金额是:${obj.amount} 备注是:${obj.amount}`}]
                }else if(itemType === 'waimai_request'){
                    return [{text:`${time}[${text}] 金额是:${obj.amount} 商品是:${obj.productInfo}`}]
                }else if(itemType === 'waimai_response'){
                    return [{text:`${time}[${text[obj.status]}] ${obj.status === 'paid' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'video_call_request'){
                    return [{text:`${time}[${text}]`}]
                }}else if(itemType === 'video_call_request'){
                    return [{text:`${time}[${text[obj.decision]}] ${obj.decision === 'accept' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'qzone_post'){
                    return [{text:`${time}[${text[obj.postType]}] ${obj.postType === 'shuoshuo' ? `${obj.content}` : `图片描述是:${obj.hiddenContent} ${obj.publicText ? `文案是: ${obj.publicText}` : ''}`}`}]
                }else if(itemType === 'qzone_comment'){
                    return [{text:`${time}[${text}] 评论的id是: ${obj.postId} 评论的内容是: ${obj.commentText}`}]
                }else if(itemType === 'qzone_like'){
                    return [{text:`${time}[${text}] 点赞的id是: ${obj.postId}`}]
                }else if(itemType === 'pat_user'){
                    return [{text:`${time}[${text}] ${obj.suffix ? obj.suffix  : ''}`}]
                }else if(itemType === 'block_user'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'friend_request_response'){
                    return [{text:`${time}[${text}] 结果是:${obj.decision === 'accept' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'change_avatar'){
                    return [{text:`${time}[${text}] 头像名是:${obj.name}`}]
                }else if(itemType === 'share_link'){
                    return [{text:`${time}[${text}] 文章标题是:${obj.title}  文章摘要是:${obj.description} 来源网站名是:${obj.source_name} 文章正文是:${obj.content}`}]
                }else if(itemType === 'accept_transfer'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'accept_transfer'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'quote_reply'){
                    return [{text:`${time}[${text}] 引用的内容是:${obj.reply_content}`}]
                }else if(itemType === 'text'){
                    return [{text:`${time}${obj.content}`}]
                }
            }

if(Array.isArray(res) && res.length > 1) {
	res = `${res[0]}${res[1].content}`
}

        return [{text:res}]
    }

    function toGeminiRequestData(model, apiKey, systemInstruction, messagesForDecision,isGemini) {

	if(!isGemini){
		return undefined
	}

        // 【核心修正】在这里，我们将 'system' 角色也映射为 'user'

        let roleType = {
            user: 'user',
            assistant: 'model',
            system: 'user' // <--- 新增这一行
        }
        return {
            url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`,
            data: {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: messagesForDecision.map((item) => {
                        let  includesImages = false;
                        if(Array.isArray(item.content) && item.content.length === 2){
                              includesImages =  item.content.some((sub)=>{
                                return sub.type === 'image_url' && sub.image_url.url
                            })
                        }
                        return {
                            role: roleType[item.role], // 现在 'system' 会被正确转换为 'user'
                            parts: includesImages ? isImage(item.content[0],item.content[1]) : transformChatData(item)
                        }
                    }),
                    generationConfig: {
                        temperature: 0.8,
                    },
                    "systemInstruction": {
                        "parts": [{
                            "text": systemInstruction
                        }]
                    }
                })
            }
        }
    }
    document.addEventListener('DOMContentLoaded', () => {

        // ===================================================================
        // 1. 所有变量和常量定义
        // ===================================================================
        const db = new Dexie('GeminiChatDB');
        // --- 已修正 ---
        let state = { chats: {}, activeChatId: null, globalSettings: {}, apiConfig: {}, userStickers: [], worldBooks: [], personaPresets: [], qzoneSettings: {}, activeAlbumId: null };
        // --- 修正结束 ---
let musicState = { 
    isActive: false, 
    activeChatId: null, 
    isPlaying: false, 
    playlist: [], 
    currentIndex: -1, 
    playMode: 'order', 
    totalElapsedTime: 0, 
    timerId: null,
    // 【新增】歌词相关状态
    parsedLyrics: [],      // 当前歌曲解析后的歌词数组
    currentLyricIndex: -1  // 当前高亮的歌词行索引
};
        const audioPlayer = document.getElementById('audio-player');
        let newWallpaperBase64 = null;
        let isSelectionMode = false;
        let selectedMessages = new Set();
        let editingMemberId = null;
        let editingWorldBookId = null;
        let editingPersonaPresetId = null;

let waimaiTimers = {}; // 用于存储外卖倒计时

let activeMessageTimestamp = null;
let currentReplyContext = null; // <--- 新增这行，用来存储当前正在引用的消息信息
let activePostId = null; // <-- 新增：用于存储当前操作的动态ID

        let photoViewerState = {
            isOpen: false,
            photos: [], // 存储当前相册的所有照片URL
            currentIndex: -1, // 当前正在查看的照片索引
        };

        let unreadPostsCount = 0;

        let isFavoritesSelectionMode = false;
        let selectedFavorites = new Set()

let simulationIntervalId = null;

        const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
        const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
        const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
        const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
        let notificationTimeout;

// ▼▼▼ 在JS顶部，变量定义区，添加这个新常量 ▼▼▼
const DEFAULT_APP_ICONS = {
    'world-book': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
    'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
    'api-settings': 'https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg',
    'wallpaper': 'https://i.postimg.cc/T1j03pQr/IMG-6440.jpg',
    'font': 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg'
};
// ▲▲▲ 添加结束 ▲▲▲

        const STICKER_REGEX = /^(https:\/\/i\.postimg\.cc\/.+|https:\/\/files\.catbox\.moe\/.+|data:image)/;
        const MESSAGE_RENDER_WINDOW = 50;
        let currentRenderedCount = 0;
        let lastKnownBatteryLevel = 1;
        let alertFlags = { hasShown40: false, hasShown20: false, hasShown10: false };
        let batteryAlertTimeout;
        const dynamicFontStyle = document.createElement('style');
        dynamicFontStyle.id = 'dynamic-font-style';
        document.head.appendChild(dynamicFontStyle);

        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('custom-modal-title');
        const modalBody = document.getElementById('custom-modal-body');
        const modalConfirmBtn = document.getElementById('custom-modal-confirm');
        const modalCancelBtn = document.getElementById('custom-modal-cancel');
        let modalResolve;

        function showCustomModal() { 
            modalOverlay.classList.add('visible'); 
        }

        function hideCustomModal() { 
            modalOverlay.classList.remove('visible'); 
            modalConfirmBtn.classList.remove('btn-danger'); 
            if (modalResolve) modalResolve(null); 
        }

        function showCustomConfirm(title, message, options = {}) {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p>${message}</p>`;
                modalCancelBtn.style.display = 'block';
                modalConfirmBtn.textContent = '确定';
                if (options.confirmButtonClass) modalConfirmBtn.classList.add(options.confirmButtonClass);
                modalConfirmBtn.onclick = () => { resolve(true); hideCustomModal(); };
                modalCancelBtn.onclick = () => { resolve(false); hideCustomModal(); };
                showCustomModal();
            });
        }

        function showCustomAlert(title, message) {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
                modalCancelBtn.style.display = 'none';
                modalConfirmBtn.textContent = '好的';
                modalConfirmBtn.onclick = () => {
                    modalCancelBtn.style.display = 'block'; 
                    modalConfirmBtn.textContent = '确定';
                    resolve(true); 
                    hideCustomModal();
                };
                showCustomModal();
            });
        }

// ▼▼▼ 请用这个【功能增强版】替换旧的 showCustomPrompt 函数 ▼▼▼
function showCustomPrompt(title, placeholder, initialValue = '', type = 'text', extraHtml = '') {
    return new Promise(resolve => {
        modalResolve = resolve;
        modalTitle.textContent = title;
        const inputId = 'custom-prompt-input';
        
        const inputHtml = type === 'textarea' 
            ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
            : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;
        
        // 【核心修改】将额外的HTML和输入框组合在一起
        modalBody.innerHTML = extraHtml + inputHtml;
        const input = document.getElementById(inputId);

        // 【核心修改】为格式助手按钮绑定事件
        modalBody.querySelectorAll('.format-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const templateStr = btn.dataset.template;
                if (templateStr) {
                    try {
                        const templateObj = JSON.parse(templateStr);
                        // 使用 null, 2 参数让JSON字符串格式化，带缩进，更易读
                        input.value = JSON.stringify(templateObj, null, 2);
                        input.focus();
                    } catch(e) {
                        console.error("解析格式模板失败:", e);
                    }
                }
            });
        });
        
        modalConfirmBtn.onclick = () => { resolve(input.value); hideCustomModal(); };
        modalCancelBtn.onclick = () => { resolve(null); hideCustomModal(); };
        showCustomModal();
        setTimeout(() => input.focus(), 100);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

        // ===================================================================
        // 2. 数据库结构定义
        // ===================================================================

db.version(23).stores({ 
    chats: '&id, isGroup, groupId', 
    apiConfig: '&id', 
    globalSettings: '&id', 
    userStickers: '&id, url, name',
    worldBooks: '&id, name, categoryId', // <-- 【核心修改1】在这里添加 categoryId
    worldBookCategories: '++id, name',    // <-- 【核心修改2】新增这个表
    musicLibrary: '&id', 
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, timestamp', 
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate' ,
    callRecords: '++id, chatId, timestamp, customName' // <--【核心修改】在这里加上 customName
});

        // ===================================================================
        // 3. 所有功能函数定义
        // ===================================================================

        function showScreen(screenId) {
            if (screenId === 'chat-list-screen') {
                window.renderChatListProxy(); 
                switchToChatListView('messages-view');
            }
            if (screenId === 'api-settings-screen') window.renderApiSettingsProxy();
            if (screenId === 'wallpaper-screen') window.renderWallpaperScreenProxy();
            if (screenId === 'world-book-screen') window.renderWorldBookScreenProxy();
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const screenToShow = document.getElementById(screenId);
            if (screenToShow) screenToShow.classList.add('active');
            if (screenId === 'chat-interface-screen') window.updateListenTogetherIconProxy(state.activeChatId);
            if (screenId === 'font-settings-screen') {
                document.getElementById('font-url-input').value = state.globalSettings.fontUrl || '';
                applyCustomFont(state.globalSettings.fontUrl || '', true);
            }
        }
        window.updateListenTogetherIconProxy = () => {};

        function switchToChatListView(viewId) {
            const chatListScreen = document.getElementById('chat-list-screen');
            const views = {
                'messages-view': document.getElementById('messages-view'),
                'qzone-screen': document.getElementById('qzone-screen'),
                'favorites-view': document.getElementById('favorites-view'),
        'memories-view': document.getElementById('memories-view') // <-- 新增这一行
    };
            const mainHeader = document.getElementById('main-chat-list-header');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏

            if (isFavoritesSelectionMode) {
                document.getElementById('favorites-edit-btn').click(); 
            }

            // 隐藏所有视图
            Object.values(views).forEach(v => v.classList.remove('active'));
            // 显示目标视图
            if (views[viewId]) {
                views[viewId].classList.add('active');
            }

            // 更新底部导航栏高亮
            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
                item.classList.toggle('active', item.dataset.view === viewId);
            });
            
            // ▼▼▼ 【核心修正】在这里统一管理所有UI元素的显隐 ▼▼▼
            if (viewId === 'messages-view') {
                mainHeader.style.display = 'flex';
                mainBottomNav.style.display = 'flex';
            } else {
                mainHeader.style.display = 'none';
                mainBottomNav.style.display = 'none';
            }
            // ▲▲▲ 修正结束 ▲▲▲

    if (viewId !== 'memories-view') {
        activeCountdownTimers.forEach(timerId => clearInterval(timerId));
        activeCountdownTimers = [];
    }

            // 根据视图ID执行特定的渲染/更新逻辑
            switch (viewId) {
                case 'qzone-screen':
                    views['qzone-screen'].style.backgroundColor = '#f0f2f5';
                    updateUnreadIndicator(0);
                    renderQzoneScreen();
                    renderQzonePosts();
                    break;
                case 'favorites-view':
                    views['favorites-view'].style.backgroundColor = '#f9f9f9';
                    renderFavoritesScreen();
                    break;
                case 'messages-view':
                    // 如果需要，可以在这里添加返回消息列表时要执行的逻辑
                    break;
            }
        }
        
        function renderQzoneScreen() {
            if (state && state.qzoneSettings) {
                const settings = state.qzoneSettings;
                document.getElementById('qzone-nickname').textContent = settings.nickname;
                document.getElementById('qzone-avatar-img').src = settings.avatar;
                document.getElementById('qzone-banner-img').src = settings.banner;
            }
        }
        window.renderQzoneScreenProxy = renderQzoneScreen;

        async function saveQzoneSettings() {
            if (db && state.qzoneSettings) {
                await db.qzoneSettings.put(state.qzoneSettings);
            }
        }

        function formatPostTimestamp(timestamp) {
            if (!timestamp) return '';
            const now = new Date();
            const date = new Date(timestamp);
            const diffSeconds = Math.floor((now - date) / 1000);
            const diffMinutes = Math.floor(diffSeconds / 60);
            const diffHours = Math.floor(diffMinutes / 60);
            if (diffMinutes < 1) return '刚刚';
            if (diffMinutes < 60) return `${diffMinutes}分钟前`;
            if (diffHours < 24) return `${diffHours}小时前`;
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            if (now.getFullYear() === year) {
                return `${month}-${day} ${hours}:${minutes}`;
            } else {
                return `${year}-${month}-${day} ${hours}:${minutes}`;
            }
        }

// ▼▼▼ 请用这个【已添加删除按钮】的函数，完整替换掉你旧的 renderQzonePosts 函数 ▼▼▼
async function renderQzonePosts() {
    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) return;

    const [posts, favorites] = await Promise.all([
        db.qzonePosts.orderBy('timestamp').reverse().toArray(),
        db.favorites.where('type').equals('qzone_post').toArray()
    ]);

    const favoritedPostIds = new Set(favorites.map(fav => fav.content.id));
    
    postsListEl.innerHTML = '';

    if (posts.length === 0) {
        postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">这里空空如也，快来发布第一条说说吧！</p>';
        return;
    }

    const userSettings = state.qzoneSettings;

    posts.forEach(post => {
        const postContainer = document.createElement('div');
        postContainer.className = 'qzone-post-container';
        postContainer.dataset.postId = post.id;

        const postEl = document.createElement('div');
        postEl.className = 'qzone-post-item';

        let authorAvatar = '', authorNickname = '', commentAvatar = userSettings.avatar; 

        if (post.authorId === 'user') {
            authorAvatar = userSettings.avatar;
            authorNickname = userSettings.nickname;
        } else if (state.chats[post.authorId]) {
            const authorChat = state.chats[post.authorId];
            authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
            authorNickname = authorChat.name;
        } else {
            authorAvatar = defaultAvatar;
            authorNickname = '{{char}}';
        }
        
        let contentHtml = '';
        const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';

        if (post.type === 'shuoshuo') {
            contentHtml = `<div class="post-content" style="margin-bottom: 10px;">${post.content.replace(/\n/g, '<br>')}</div>`;
        } 
        else if (post.type === 'image_post' && post.imageUrl) {
            contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
        } 
        else if (post.type === 'text_image') {
            contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
        }

        let likesHtml = '';
        if (post.likes && post.likes.length > 0) {
            likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${post.likes.join('、')} 觉得很赞</span></div>`;
        }
        
        let commentsHtml = '';
        if (post.comments && post.comments.length > 0) {
            commentsHtml = '<div class="post-comments-container">';
            // ★★★★★【核心修改就在这里】★★★★★
            // 遍历评论时，我们传入 comment 对象本身和它的索引 index
            post.comments.forEach((comment, index) => {
                // 在评论项的末尾，添加一个带有 data-comment-index 属性的删除按钮
                commentsHtml += `
                    <div class="comment-item">
                        <span class="commenter-name">${comment.commenterName}:</span>
                        <span class="comment-text">${comment.text}</span>
                        <span class="comment-delete-btn" data-comment-index="${index}">×</span>
                    </div>`;
            });
            // ★★★★★【修改结束】★★★★★
            commentsHtml += '</div>';
        }

        const userNickname = state.qzoneSettings.nickname;
        const isLikedByUser = post.likes && post.likes.includes(userNickname);
        const isFavoritedByUser = favoritedPostIds.has(post.id);

        postEl.innerHTML = `
            <div class="post-header"><img src="${authorAvatar}" class="post-avatar"><div class="post-info"><span class="post-nickname">${authorNickname}</span><span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span></div>
                <div class="post-actions-btn">…</div>
            </div>
            <div class="post-main-content">${contentHtml}</div>
            <div class="post-feedback-icons">
                <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
            </div>
            ${likesHtml}
            ${commentsHtml}
            <div class="post-footer"><div class="comment-section"><img src="${commentAvatar}" class="comment-avatar"><input type="text" class="comment-input" placeholder="友善的评论是交流的起点"><div class="at-mention-popup"></div></div><button class="comment-send-btn">发送</button></div>
        `;
        
        const deleteAction = document.createElement('div');
        deleteAction.className = 'qzone-post-delete-action';
        deleteAction.innerHTML = '<span>删除</span>';
        postContainer.appendChild(postEl);
        postContainer.appendChild(deleteAction);
        const commentSection = postContainer.querySelector('.comment-section');
        if (commentSection) {
            commentSection.addEventListener('touchstart', (e) => e.stopPropagation());
            commentSection.addEventListener('mousedown', (e) => e.stopPropagation());
        }
        postsListEl.appendChild(postContainer);
        const commentInput = postContainer.querySelector('.comment-input');
        const popup = postContainer.querySelector('.at-mention-popup');
        commentInput.addEventListener('input', () => {
            const value = commentInput.value;
            const atMatch = value.match(/@([\p{L}\w]*)$/u);
            if (atMatch) {
                const namesToMention = new Set();
                const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
                if (authorNickname) namesToMention.add(authorNickname);
                postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
                    namesToMention.add(nameEl.textContent.replace(':', ''));
                });
                namesToMention.delete(state.qzoneSettings.nickname);
                popup.innerHTML = '';
                if (namesToMention.size > 0) {
                    const searchTerm = atMatch[1];
                    namesToMention.forEach(name => {
                        if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                            const item = document.createElement('div');
                            item.className = 'at-mention-item';
                            item.textContent = name;
                            item.addEventListener('mousedown', (e) => {
                                e.preventDefault();
                                const newText = value.substring(0, atMatch.index) + `@${name} `;
                                commentInput.value = newText;
                                popup.style.display = 'none';
                                commentInput.focus();
                            });
                            popup.appendChild(item);
                        }
                    });
                    popup.style.display = popup.children.length > 0 ? 'block' : 'none';
                } else {
                    popup.style.display = 'none';
                }
            } else {
                popup.style.display = 'none';
            }
        });
        commentInput.addEventListener('blur', () => { setTimeout(() => { popup.style.display = 'none'; }, 200); });
    });
}
// ▲▲▲ 替换结束 ▲▲▲
             
// ▼▼▼ 请用下面这个【更新后的】函数，完整替换掉你代码中旧的 displayFilteredFavorites 函数 ▼▼▼

function displayFilteredFavorites(items) {
    const listEl = document.getElementById('favorites-list');
    listEl.innerHTML = '';

    if (items.length === 0) {
        const searchTerm = document.getElementById('favorites-search-input').value;
        const message = searchTerm ? '未找到相关收藏' : '你的收藏夹是空的，<br>快去动态或聊天中收藏喜欢的内容吧！';
        listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
        return;
    }

    for (const item of items) {
        const card = document.createElement('div');
        card.className = 'favorite-item-card';
        card.dataset.favid = item.id;

        let headerHtml = '', contentHtml = '', sourceText = '', footerHtml = '';

        if (item.type === 'qzone_post') {
            const post = item.content;
            sourceText = '来自动态';
            let authorAvatar = defaultAvatar, authorNickname = '未知用户';

            if (post.authorId === 'user') {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                authorNickname = state.chats[post.authorId].name;
            }

            headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;
            
            const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
            if (post.type === 'shuoshuo') {
                contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
            } else if (post.type === 'image_post' && post.imageUrl) {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
            } else if (post.type === 'text_image') {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
            }

            // ▼▼▼ 新增/修改的代码开始 ▼▼▼
            
            // 1. 构造点赞区域的HTML
            let likesHtml = '';
            // 检查 post 对象中是否存在 likes 数组并且不为空
            if (post.likes && post.likes.length > 0) {
                // 如果存在，就创建点赞区域的 div
                likesHtml = `
                    <div class="post-likes-section">
                        <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                        <span>${post.likes.join('、')} 觉得很赞</span>
                    </div>`;
            }

            // 2. 构造评论区域的HTML
            let commentsHtml = '';
            // 检查 post 对象中是否存在 comments 数组并且不为空
            if (post.comments && post.comments.length > 0) {
                // 如果存在，就创建评论容器，并遍历每一条评论
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach(comment => {
                    commentsHtml += `
                        <div class="comment-item">
                            <span class="commenter-name">${comment.commenterName}:</span>
                            <span class="comment-text">${comment.text}</span>
                        </div>`;
                });
                commentsHtml += '</div>';
            }

            // 3. 将点赞和评论的HTML组合到 footerHtml 中
            footerHtml = `${likesHtml}${commentsHtml}`;
            
            // ▲▲▲ 新增/修改的代码结束 ▲▲▲

} else if (item.type === 'chat_message') {
    const msg = item.content;
    const chat = state.chats[item.chatId];
    if (!chat) continue; 

    sourceText = `来自与 ${chat.name} 的聊天`;
    const isUser = msg.role === 'user';
    let senderName, senderAvatar;

    if (isUser) {
        // 用户消息的逻辑保持不变
        senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
        senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
    } else { // AI/成员消息
         if (chat.isGroup) {
            // ★★★★★ 这就是唯一的、核心的修改！ ★★★★★
            // 我们现在使用 originalName 去匹配，而不是旧的 name
            const member = chat.members.find(m => m.originalName === msg.senderName);
            // ★★★★★ 修改结束 ★★★★★
            
            senderName = msg.senderName;
            // 因为现在能正确找到 member 对象了，所以也能正确获取到他的头像
            senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
        } else {
            // 单聊的逻辑保持不变
            senderName = chat.name;
            senderAvatar = chat.settings.aiAvatar || defaultAvatar;
        }
    }

    // 后续拼接 headerHtml 和 contentHtml 的逻辑都保持不变
    headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;
    
    if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
        contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
    } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
    } else {
        contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
    }
}
        
        // ▼▼▼ 修改最终的HTML拼接，加入 footerHtml ▼▼▼
        card.innerHTML = `
            <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
            <div class="fav-card-content">${contentHtml}</div>
            ${footerHtml}`; // <-- 把我们新创建的 footerHtml 放在这里
            
        listEl.appendChild(card);
    }
}

// ▲▲▲ 替换区域结束 ▲▲▲

        /**
         * 【重构后的函数】: 负责准备数据并触发渲染
         */
        async function renderFavoritesScreen() {
            // 1. 从数据库获取最新数据并缓存
            allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();
            
            // 2. 清空搜索框并隐藏清除按钮
            const searchInput = document.getElementById('favorites-search-input');
            const clearBtn = document.getElementById('favorites-search-clear-btn');
            searchInput.value = '';
            clearBtn.style.display = 'none';

            // 3. 显示所有收藏项
            displayFilteredFavorites(allFavoriteItems);
        }

        // ▲▲▲ 粘贴结束 ▲▲▲

        function resetCreatePostModal() {
            document.getElementById('post-public-text').value = '';
            document.getElementById('post-image-preview').src = '';
            document.getElementById('post-image-description').value = '';
            document.getElementById('post-image-preview-container').classList.remove('visible');
            document.getElementById('post-image-desc-group').style.display = 'none';
            document.getElementById('post-local-image-input').value = '';
            document.getElementById('post-hidden-text').value = '';
            document.getElementById('switch-to-image-mode').click();
        }

// ▼▼▼ 用这个【已包含 memories】的版本，完整替换旧的 exportBackup 函数 ▼▼▼
async function exportBackup() {
    try {
        const backupData = {
            version: 1, 
            timestamp: Date.now()
        };

        const [
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
            memories,
            worldBookCategories // <-- 【核心修改1】在这里添加新变量
        ] = await Promise.all([
            db.chats.toArray(),
            db.worldBooks.toArray(),
            db.userStickers.toArray(),
            db.apiConfig.get('main'),
            db.globalSettings.get('main'),
            db.personaPresets.toArray(),
            db.musicLibrary.get('main'),
            db.qzoneSettings.get('main'),
            db.qzonePosts.toArray(),
            db.qzoneAlbums.toArray(),
            db.qzonePhotos.toArray(),
            db.favorites.toArray(),
            db.qzoneGroups.toArray(),
                        db.memories.toArray(),
            db.worldBookCategories.toArray() // <-- 【核心修改2】在这里添加对新表的读取
        ]);

        Object.assign(backupData, {
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
            memories,
            worldBookCategories // <-- 【核心修改3】将新数据添加到备份对象中
        });
        
        const blob = new Blob(
            [JSON.stringify(backupData, null, 2)], 
            { type: 'application/json' }
        );
        const url = URL.createObjectURL(blob);
        const link = Object.assign(document.createElement('a'), {
            href: url,
            download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
        });
        link.click();
        URL.revokeObjectURL(url);
        
        await showCustomAlert('导出成功', '已成功导出所有数据！');

    } catch (error) {
        console.error("导出数据时出错:", error);
        await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
    }
}

// ▼▼▼ 用这个【已包含 memories】的版本，完整替换旧的 importBackup 函数 ▼▼▼
async function importBackup(file) {
    if (!file) return;

    const confirmed = await showCustomConfirm(
        '严重警告！',
        '导入备份将完全覆盖您当前的所有数据，包括聊天、动态、设置等。此操作不可撤销！您确定要继续吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        await db.transaction('rw', db.tables, async () => {
            for (const table of db.tables) {
                await table.clear();
            }

            if (Array.isArray(data.chats)) await db.chats.bulkPut(data.chats);
            if (Array.isArray(data.worldBooks)) await db.worldBooks.bulkPut(data.worldBooks);
            if (Array.isArray(data.worldBookCategories)) await db.worldBookCategories.bulkPut(data.worldBookCategories);
            if (Array.isArray(data.userStickers)) await db.userStickers.bulkPut(data.userStickers);
            if (Array.isArray(data.personaPresets)) await db.personaPresets.bulkPut(data.personaPresets);
            if (Array.isArray(data.qzonePosts)) await db.qzonePosts.bulkPut(data.qzonePosts);
            if (Array.isArray(data.qzoneAlbums)) await db.qzoneAlbums.bulkPut(data.qzoneAlbums);
            if (Array.isArray(data.qzonePhotos)) await db.qzonePhotos.bulkPut(data.qzonePhotos);
            if (Array.isArray(data.favorites)) await db.favorites.bulkPut(data.favorites);
            if (Array.isArray(data.qzoneGroups)) await db.qzoneGroups.bulkPut(data.qzoneGroups);
            if (Array.isArray(data.memories)) await db.memories.bulkPut(data.memories); // 【核心修正】新增

            if (data.apiConfig) await db.apiConfig.put(data.apiConfig);
            if (data.globalSettings) await db.globalSettings.put(data.globalSettings);
            if (data.musicLibrary) await db.musicLibrary.put(data.musicLibrary);
            if (data.qzoneSettings) await db.qzoneSettings.put(data.qzoneSettings);
        });

        await showCustomAlert('导入成功', '所有数据已成功恢复！应用即将刷新以应用所有更改。');
        
        setTimeout(() => {
            window.location.reload();
        }, 1500);

    } catch (error) {
        console.error("导入数据时出错:", error);
        await showCustomAlert('导入失败', `文件格式不正确或数据已损坏: ${error.message}`);
    }
}

        function applyCustomFont(fontUrl, isPreviewOnly = false) {
            if (!fontUrl) {
                dynamicFontStyle.innerHTML = '';
                document.getElementById('font-preview').style.fontFamily = '';
                return;
            }
            const fontName = 'custom-user-font';
            const newStyle = `
                @font-face {
                  font-family: '${fontName}';
                  src: url('${fontUrl}');
                  font-display: swap;
                }`;
            if (isPreviewOnly) {
                const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
                previewStyle.id = 'preview-font-style';
                previewStyle.innerHTML = newStyle;
                if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
                document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
            } else {
                dynamicFontStyle.innerHTML = `
                    ${newStyle}
                    body {
                      font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                    }`;
            }
        }

        async function resetToDefaultFont() {
            dynamicFontStyle.innerHTML = ''; 
            state.globalSettings.fontUrl = '';
            await db.globalSettings.put(state.globalSettings);
            document.getElementById('font-url-input').value = '';
            document.getElementById('font-preview').style.fontFamily = '';
            alert('已恢复默认字体。');
        }

async function loadAllDataFromDB() {
    // ▼▼▼ 【核心修改在这里】 ▼▼▼
    const [
        chatsArr,
        apiConfig,
        globalSettings,
        userStickers,
        worldBooks,
        musicLib,
        personaPresets,
        qzoneSettings,
        initialFavorites // 将 initialFavorites 加入到解构赋值中
    ] = await Promise.all([
        db.chats.toArray(),
        db.apiConfig.get('main'),
        db.globalSettings.get('main'),
        db.userStickers.toArray(),
        db.worldBooks.toArray(),
        db.musicLibrary.get('main'),
        db.personaPresets.toArray(),
        db.qzoneSettings.get('main'),
        db.favorites.orderBy('timestamp').reverse().toArray() // 确保这一行在 Promise.all 的数组参数内
    ]);
    // ▲▲▲ 【修改结束】 ▲▲▲

    state.chats = chatsArr.reduce((acc, chat) => {

    if (typeof chat.unreadCount === 'undefined') {
        chat.unreadCount = 0; // 如果这个聊天对象没有 unreadCount 属性，就给它初始化为 0
    }

        // ★★★【核心重构：数据迁移脚本】★★★
        // 检查是否是群聊，并且其成员对象使用的是旧的 `name` 结构
        if (chat.isGroup && chat.members && chat.members.length > 0 && chat.members[0].name) {
            console.log(`检测到旧版群聊数据 for "${chat.name}"，正在执行迁移...`);
            chat.members.forEach(member => {
                // 如果这个成员对象没有 originalName，说明是旧数据
                if (typeof member.originalName === 'undefined') {
                    member.originalName = member.name; // 将旧的 name 作为 originalName
                    member.groupNickname = member.name; // 同时创建一个初始的 groupNickname
                    delete member.name; // 删除旧的、有歧义的 name 字段
                    needsUpdate = true; // 标记需要存回数据库
                }
            });
             console.log(`迁移完成 for "${chat.name}"`);
        }

        // --- ▼▼▼ 核心修复就在这里 ▼▼▼ ---
        // 检查1：如果是一个单聊，并且没有 status 属性
        if (!chat.isGroup && !chat.status) {
            // 就为它补上一个默认的 status 对象
            chat.status = {
                text: '在线',
                lastUpdate: Date.now(),
                isBusy: false
            };
            console.log(`为旧角色 "${chat.name}" 补全了status属性。`);
        }
        // --- ▲▲▲ 修复结束 ▲▲▲

        // --- ▼▼▼ 核心修复就在这里 ▼▼▼ ---
        // 检查2：兼容最新的“关系”功能
        if (!chat.isGroup && !chat.relationship) {
            // 如果是单聊，且没有 relationship 对象，就补上一个默认的
            chat.relationship = {
                status: 'friend',
                blockedTimestamp: null,
                applicationReason: ''
            };
            console.log(`为旧角色 "${chat.name}" 补全了 relationship 属性。`);
        }
        // --- ▲▲▲ 修复结束 ▲▲▲

    // ▼▼▼ 在这里添加 ▼▼▼
    if (!chat.isGroup && (!chat.settings || !chat.settings.aiAvatarLibrary)) {
        if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
        chat.settings.aiAvatarLibrary = [];
        console.log(`为旧角色 "${chat.name}" 补全了aiAvatarLibrary属性。`);
    }
    // ▲▲▲ 添加结束 ▲▲▲

        if (!chat.musicData) chat.musicData = { totalTime: 0 };
        if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) {
            chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId];
            delete chat.settings.linkedWorldBookId;
        }
        acc[chat.id] = chat;
        return acc;
    }, {});
    state.apiConfig = apiConfig || { id: 'main', proxyUrl: '', apiKey: '', model: '' };

state.globalSettings = globalSettings || { 
    id: 'main', 
    wallpaper: 'linear-gradient(135deg, #89f7fe, #66a6ff)', 
    fontUrl: '', 
    enableBackgroundActivity: false, 
    backgroundActivityInterval: 60,
    blockCooldownHours: 1,
    appIcons: { ...DEFAULT_APP_ICONS } // 【核心修改】确保appIcons存在并有默认值
};
// 【核心修改】合并已保存的图标和默认图标，防止更新后旧数据丢失新图标
state.globalSettings.appIcons = { ...DEFAULT_APP_ICONS, ...(state.globalSettings.appIcons || {}) };

    state.userStickers = userStickers || [];
    state.worldBooks = worldBooks || [];
    musicState.playlist = musicLib?.playlist || [];
    state.personaPresets = personaPresets || [];
    state.qzoneSettings = qzoneSettings || { id: 'main', nickname: '{{user}}', avatar: 'https://files.catbox.moe/q6z5fc.jpeg', banner: 'https://files.catbox.moe/r5heyt.gif' };

    // ▼▼▼ 【确保这一行在 Promise.all 之后，并使用解构赋值得到的 initialFavorites】 ▼▼▼
    allFavoriteItems = initialFavorites || [];
    // ▲▲▲ 【修改结束】 ▲▲▲
}

        async function saveGlobalPlaylist() { await db.musicLibrary.put({ id: 'main', playlist: musicState.playlist }); }

        function formatTimestamp(timestamp) { if (!timestamp) return ''; const date = new Date(timestamp); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; }

        function showNotification(chatId, messageContent) { clearTimeout(notificationTimeout); const chat = state.chats[chatId]; if (!chat) return; const bar = document.getElementById('notification-bar'); document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar; document.getElementById('notification-content').querySelector('.name').textContent = chat.name; document.getElementById('notification-content').querySelector('.message').textContent = messageContent; const newBar = bar.cloneNode(true); bar.parentNode.replaceChild(newBar, bar); newBar.addEventListener('click', () => { openChat(chatId); newBar.classList.remove('visible'); }); newBar.classList.add('visible'); notificationTimeout = setTimeout(() => { newBar.classList.remove('visible'); }, 4000); }

        function updateClock() { const now = new Date(); const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' }); document.getElementById('main-time').textContent = timeString; document.getElementById('status-bar-time').textContent = timeString; document.getElementById('main-date').textContent = dateString; }

/**
 * 【终极健壮版】解析AI返回的、可能格式不规范的响应内容
 * @param {string} content - AI返回的原始字符串
 * @returns {Array} - 一个标准化的消息对象数组
 */
function parseAiResponse(content) {
    const trimmedContent = content.trim();

    // 方案1：【最优先】尝试作为标准的、单一的JSON数组解析
    // 这是最理想、最高效的情况
    if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
        try {
            const parsed = JSON.parse(trimmedContent);
            if (Array.isArray(parsed)) {
                console.log("解析成功：标准JSON数组格式。");
                return parsed;
            }
        } catch (e) {
            // 如果解析失败，说明它虽然看起来像个数组，但内部格式有问题。
            // 此时我们不报错，而是继续尝试下面的“强力解析”方案。
            console.warn("标准JSON数组解析失败，将尝试强力解析...");
        }
    }

    // 方案2：【强力解析】使用正则表达式，从混乱的字符串中提取出所有独立的JSON对象
    // 这能完美解决您遇到的 "(Timestamp: ...)[{...}](Timestamp: ...)[{...}]" 这种格式
    const jsonMatches = trimmedContent.match(/{[^{}]*}/g);

    if (jsonMatches) {
        const results = [];
        for (const match of jsonMatches) {
            try {
                // 尝试解析每一个被我们“揪”出来的JSON字符串
                const parsedObject = JSON.parse(match);
                results.push(parsedObject);
            } catch (e) {
                // 如果某个片段不是有效的JSON，就忽略它，继续处理下一个
                console.warn("跳过一个无效的JSON片段:", match);
            }
        }

        // 如果我们成功提取出了至少一个有效的JSON对象，就返回这个结果
        if (results.length > 0) {
            console.log("解析成功：通过强力提取模式。");
            return results;
        }
    }
    
    // 方案3：【最终备用】如果以上所有方法都失败了，说明AI返回的可能就是纯文本
    // 我们将原始的、未处理的内容，包装成一个标准的文本消息对象返回，确保程序不会崩溃
    console.error("所有解析方案均失败！将返回原始文本。");
    return [{ type: 'text', content: content }];
}

        function renderApiSettings() { document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || ''; document.getElementById('api-key').value = state.apiConfig.apiKey || ''; 
    // ▼▼▼ 新增这行 ▼▼▼
    document.getElementById('background-activity-switch').checked = state.globalSettings.enableBackgroundActivity || false;
    document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
    document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;
}
        window.renderApiSettingsProxy = renderApiSettings;

// ▼▼▼ 请用这个【全新版本】的函数，完整替换掉你旧的 renderChatList ▼▼▼
async function renderChatList() {
    const chatListEl = document.getElementById('chat-list');
    chatListEl.innerHTML = '';

    // 1. 像以前一样，获取所有聊天并按最新消息时间排序
    const allChats = Object.values(state.chats).sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));
    
    // 2. 获取所有分组
    const allGroups = await db.qzoneGroups.toArray();

    if (allChats.length === 0) {
        chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 或群组图标添加聊天</p>';
        return;
    }

    // --- 【核心修正开始】---

    // 3. 为每个分组找到其内部最新的消息时间戳
    allGroups.forEach(group => {
        // 从已排序的 allChats 中找到本组的第一个（也就是最新的）聊天
        const latestChatInGroup = allChats.find(chat => chat.groupId === group.id);
        // 如果找到了，就用它的时间戳；如果该分组暂时没有聊天或聊天没有历史记录，就用0
        group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
    });

    // 4. 根据这个最新的时间戳来对“分组本身”进行排序
    allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

    // --- 【核心修正结束】---

    // 5. 现在，我们按照排好序的分组来渲染
    allGroups.forEach(group => {
        // 从总列表里过滤出属于这个（已排序）分组的好友
        const groupChats = allChats.filter(chat => !chat.isGroup && chat.groupId === group.id);
        // 如果这个分组是空的（可能所有好友都被删了），就跳过
        if (groupChats.length === 0) return;

        const groupContainer = document.createElement('div');
        groupContainer.className = 'chat-group-container';
        groupContainer.innerHTML = `
            <div class="chat-group-header">
                <span class="arrow">▼</span>
                <span class="group-name">${group.name}</span>
            </div>
            <div class="chat-group-content"></div>
        `;
        const contentEl = groupContainer.querySelector('.chat-group-content');
        // 因为 allChats 本身就是有序的，所以 groupChats 自然也是有序的
        groupChats.forEach(chat => {
            const item = createChatListItem(chat);
            contentEl.appendChild(item);
        });
        chatListEl.appendChild(groupContainer);
    });

    // 6. 最后，渲染所有群聊和未分组的好友
    // 他们的顺序因为 allChats 的初始排序，天然就是正确的
    const ungroupedOrGroupChats = allChats.filter(chat => chat.isGroup || (!chat.isGroup && !chat.groupId));
    ungroupedOrGroupChats.forEach(chat => {
        const item = createChatListItem(chat);
        chatListEl.appendChild(item);
    });

    // 为所有分组标题添加折叠事件
    document.querySelectorAll('.chat-group-header').forEach(header => {
        header.addEventListener('click', () => {
            header.classList.toggle('collapsed');
            header.nextElementSibling.classList.toggle('collapsed');
        });
    });
}
// ▲▲▲ 替换结束 ▲▲▲

function createChatListItem(chat) {
    const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
    let lastMsgDisplay;

    // --- ▼▼▼ 【核心修改】在这里加入对关系状态的判断 ▼▼▼ ---
    if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
        lastMsgDisplay = `<span style="color: #ff8c00;">[好友申请] ${chat.relationship.applicationReason || '请求添加你为好友'}</span>`;
    }
    // --- ▲▲▲ 修改结束 ▲▲▲ ---

// ▼▼▼ 在这里新增 else if ▼▼▼
else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
    lastMsgDisplay = `<span style="color: #dc3545;">[你已被对方拉黑]</span>`;
}
// ▲▲▲ 新增结束 ▲▲▲
    
    // 【核心修改】优先显示状态，而不是最后一条消息
    if (chat.isGroup) {
        // 群聊逻辑保持不变
        if (lastMsgObj.type === 'pat_message') { lastMsgDisplay = `[系统消息] ${lastMsgObj.content}`; }
        // ... (其他群聊消息类型判断) ...
        else if (lastMsgObj.type === 'transfer') { lastMsgDisplay = '[转账]'; }
        else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') { lastMsgDisplay = '[照片]'; }
        else if (lastMsgObj.type === 'voice_message') { lastMsgDisplay = '[语音]'; }
        else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) { lastMsgDisplay = lastMsgObj.meaning ? `[表情: ${lastMsgObj.meaning}]` : '[表情]'; }
        else if (Array.isArray(lastMsgObj.content)) { lastMsgDisplay = `[图片]`; }
        else { lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 20); }

        if (lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
            lastMsgDisplay = `${lastMsgObj.senderName}: ${lastMsgDisplay}`;
        }

    } else {
        // 单聊逻辑：显示状态
        // 确保 chat.status 对象存在
        const statusText = chat.status?.text || '在线';
        lastMsgDisplay = `[${statusText}]`;
    }

    const item = document.createElement('div');
    item.className = 'chat-list-item';
    item.dataset.chatId = chat.id;
    const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;
    
    item.innerHTML = `
        <img src="${avatar || defaultAvatar}" class="avatar">
        <div class="info">
            <div class="name-line">
                <span class="name">${chat.name}</span>
                ${chat.isGroup ? '<span class="group-tag">群聊</span>' : ''}
            </div>
            <div class="last-msg" style="color: ${chat.isGroup ? 'var(--text-secondary)' : '#b5b5b5'}; font-style: italic;">${lastMsgDisplay}</div>
        </div>
        <!-- 这里就是我们新加的红点HTML结构 -->
        <div class="unread-count-wrapper">
            <span class="unread-count" style="display: none;">0</span>
        </div>
    `;
    
    // 【核心修改2】在这里添加控制红点显示/隐藏的逻辑
    const unreadCount = chat.unreadCount || 0;
    const unreadEl = item.querySelector('.unread-count');
    if (unreadCount > 0) {
        unreadEl.textContent = unreadCount > 99 ? '99+' : unreadCount;
        // 注意这里是 'inline-flex'，与我们的CSS对应，使其垂直居中
        unreadEl.style.display = 'inline-flex';
    } else {
        unreadEl.style.display = 'none';
    }
    
    const avatarEl = item.querySelector('.avatar');
    if (avatarEl) {
        avatarEl.style.cursor = 'pointer';
        avatarEl.addEventListener('click', (e) => {
            e.stopPropagation();
            handleUserPat(chat.id, chat.name);
        });
    }
    
    const infoEl = item.querySelector('.info');
    if (infoEl) {
        infoEl.addEventListener('click', () => openChat(chat.id));
    }

    addLongPressListener(item, async (e) => {
        const confirmed = await showCustomConfirm('删除对话', `确定要删除与 "${chat.name}" 的整个对话吗？此操作不可撤销。`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            if (musicState.isActive && musicState.activeChatId === chat.id) await endListenTogetherSession(false);
            delete state.chats[chat.id];
            if (state.activeChatId === chat.id) state.activeChatId = null;
            await db.chats.delete(chat.id);
            renderChatList();
        }
    });
    return item;
}

// ▼▼▼ 请用这个【带诊断功能的全新版本】替换旧的 renderChatInterface 函数 ▼▼▼
function renderChatInterface(chatId) {
    cleanupWaimaiTimers();
    const chat = state.chats[chatId];
    if (!chat) return;
    exitSelectionMode();
    
    const messagesContainer = document.getElementById('chat-messages');
    const chatInputArea = document.getElementById('chat-input-area');
    const lockOverlay = document.getElementById('chat-lock-overlay');
    const lockContent = document.getElementById('chat-lock-content');

    messagesContainer.dataset.theme = chat.settings.theme || 'default';
    const fontSize = chat.settings.fontSize || 13;
    messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
    applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');
    
    document.getElementById('chat-header-title').textContent = chat.name;
    const statusContainer = document.getElementById('chat-header-status');
    const statusTextEl = statusContainer.querySelector('.status-text');

    if (chat.isGroup) {
        statusContainer.style.display = 'none';
        document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
    } else {
        statusContainer.style.display = 'flex';
        document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
        statusTextEl.textContent = chat.status?.text || '在线';
        statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
    }
    
    lockOverlay.style.display = 'none';
    chatInputArea.style.visibility = 'visible';
    lockContent.innerHTML = '';

    if (!chat.isGroup && chat.relationship.status !== 'friend') {
        lockOverlay.style.display = 'flex';
        chatInputArea.style.visibility = 'hidden';
        
        let lockHtml = '';
        switch (chat.relationship.status) {
            case 'blocked_by_user':
                // --- 【核心修改：在这里加入诊断面板】 ---
                const isSimulationRunning = simulationIntervalId !== null;
                const blockedTimestamp = chat.relationship.blockedTimestamp;
                const cooldownHours = state.globalSettings.blockCooldownHours || 1;
                const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                const timeSinceBlock = Date.now() - blockedTimestamp;
                const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));

                lockHtml = `
                    <span class="lock-text">你已将“${chat.name}”拉黑。</span>
                    <button id="unblock-btn" class="lock-action-btn">解除拉黑</button>
                    <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                        <strong style="color: #333;">【开发者诊断面板】</strong><br>
                        - 后台活动总开关: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已开启</span>' : '<span style="color: red;">已关闭</span>'}<br>
                        - 系统心跳计时器: ${isSimulationRunning ? '<span style="color: green;">运行中</span>' : '<span style="color: red;">未运行</span>'}<br>
                        - 当前角色状态: <strong>${chat.relationship.status}</strong><br>
                        - 需要冷静(小时): <strong>${cooldownHours}</strong><br>
                        - 冷静期是否结束: ${isCooldownOver ? '<span style="color: green;">是</span>' : `<span style="color: orange;">否 (还剩约 ${timeRemainingMinutes} 分钟)</span>`}<br>
                        - 触发条件: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已满足，等待下次系统心跳</span>' : '<span style="color: red;">未满足</span>'}
                    </div>
                    <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">强制触发一次好友申请检测</button>
                `;
                // --- 【修改结束】 ---
                break;
            case 'blocked_by_ai':
                lockHtml = `
                    <span class="lock-text">你被对方拉黑了。</span>
                    <button id="apply-friend-btn" class="lock-action-btn">重新申请加为好友</button>
                `;
                break;
            
            case 'pending_user_approval':
                lockHtml = `
                    <span class="lock-text">“${chat.name}”请求添加你为好友：<br><i>“${chat.relationship.applicationReason}”</i></span>
                    <button id="accept-friend-btn" class="lock-action-btn">接受</button>
                    <button id="reject-friend-btn" class="lock-action-btn secondary">拒绝</button>
                `;
                break;

            // 【核心修正】修复当你申请后，你看到的界面
            case 'pending_ai_approval':
                lockHtml = `<span class="lock-text">好友申请已发送，等待对方通过...</span>`;
                break;
        }
        lockContent.innerHTML = lockHtml;
    }
    messagesContainer.innerHTML = '';
    // ...后续代码保持不变
    const chatScreen = document.getElementById('chat-interface-screen');
    chatScreen.style.backgroundImage = chat.settings.background ? `url(${chat.settings.background})` : 'none';

const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
chatScreen.style.backgroundColor = chat.settings.background ? 'transparent' : (isDarkMode ? '#000000' : '#f0f2f5');
    const history = chat.history;
    const totalMessages = history.length;
    currentRenderedCount = 0;
    const initialMessages = history.slice(-MESSAGE_RENDER_WINDOW);
    initialMessages.forEach(msg => appendMessage(msg, chat, true));
    currentRenderedCount = initialMessages.length;
    if (totalMessages > currentRenderedCount) {
        prependLoadMoreButton(messagesContainer);
    }
    const typingIndicator = document.createElement('div');
    typingIndicator.id = 'typing-indicator';
    typingIndicator.style.display = 'none';
    typingIndicator.textContent = '对方正在输入...';
    messagesContainer.appendChild(typingIndicator);
    setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
}
// ▲▲▲ 替换结束 ▲▲▲

        function prependLoadMoreButton(container) { const button = document.createElement('button'); button.id = 'load-more-btn'; button.textContent = '加载更早的记录'; button.addEventListener('click', loadMoreMessages); container.prepend(button); }

        function loadMoreMessages() { const messagesContainer = document.getElementById('chat-messages'); const chat = state.chats[state.activeChatId]; if (!chat) return; const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) loadMoreBtn.remove(); const totalMessages = chat.history.length; const nextSliceStart = totalMessages - currentRenderedCount - MESSAGE_RENDER_WINDOW; const nextSliceEnd = totalMessages - currentRenderedCount; const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd); const oldScrollHeight = messagesContainer.scrollHeight; messagesToPrepend.reverse().forEach(msg => prependMessage(msg, chat)); currentRenderedCount += messagesToPrepend.length; const newScrollHeight = messagesContainer.scrollHeight; messagesContainer.scrollTop += (newScrollHeight - oldScrollHeight); if (totalMessages > currentRenderedCount) { prependLoadMoreButton(messagesContainer); } }

// ▼▼▼ 用这个【新版本】替换旧的 renderWallpaperScreen 函数 ▼▼▼
function renderWallpaperScreen() { 
    const preview = document.getElementById('wallpaper-preview'); 
    const bg = newWallpaperBase64 || state.globalSettings.wallpaper; 
    if (bg && bg.startsWith('data:image')) { 
        preview.style.backgroundImage = `url(${bg})`; 
        preview.textContent = ''; 
    } else if(bg) { 
        preview.style.backgroundImage = bg; 
        preview.textContent = '当前为渐变色'; 
    }
    // 【核心修改】在这里调用图标渲染函数
    renderIconSettings();
}
// ▲▲▲ 替换结束 ▲▲▲
        window.renderWallpaperScreenProxy = renderWallpaperScreen;

        function applyGlobalWallpaper() { const homeScreen = document.getElementById('home-screen'); const wallpaper = state.globalSettings.wallpaper; if (wallpaper && wallpaper.startsWith('data:image')) homeScreen.style.backgroundImage = `url(${wallpaper})`; else if (wallpaper) homeScreen.style.backgroundImage = wallpaper; }

async function renderWorldBookScreen() {
    const listEl = document.getElementById('world-book-list');
    listEl.innerHTML = '';

    // 1. 同时获取所有书籍和所有分类
    const [books, categories] = await Promise.all([
        db.worldBooks.toArray(),
        db.worldBookCategories.orderBy('name').toArray()
    ]);

    state.worldBooks = books; // 确保内存中的数据是同步的

    if (books.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 创建你的第一本世界书</p>';
        return;
    }

    // 2. 将书籍按 categoryId 分组
    const groupedBooks = books.reduce((acc, book) => {
        const key = book.categoryId || 'uncategorized';
        if (!acc[key]) {
            acc[key] = [];
        }
        acc[key].push(book);
        return acc;
    }, {});

    // 3. 优先渲染已分类的书籍
    categories.forEach(category => {
        const booksInCategory = groupedBooks[category.id];
        if (booksInCategory && booksInCategory.length > 0) {
            const groupContainer = createWorldBookGroup(category.name, booksInCategory);
            listEl.appendChild(groupContainer);
        }
    });

    // 4. 最后渲染未分类的书籍
    const uncategorizedBooks = groupedBooks['uncategorized'];
    if (uncategorizedBooks && uncategorizedBooks.length > 0) {
        const groupContainer = createWorldBookGroup('未分类', uncategorizedBooks);
        listEl.appendChild(groupContainer);
    }
    
    // 5. 为所有分组标题添加折叠事件
    document.querySelectorAll('.world-book-group-header').forEach(header => {
        header.addEventListener('click', () => {
            header.classList.toggle('collapsed');
            header.nextElementSibling.classList.toggle('collapsed');
        });
    });
}

/**
 * 【辅助函数】创建一个分类的分组DOM
 * @param {string} groupName - 分类名称
 * @param {Array} books - 该分类下的书籍数组
 * @returns {HTMLElement} - 创建好的分组容器
 */
function createWorldBookGroup(groupName, books) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'world-book-group-container';
    
    groupContainer.innerHTML = `
        <div class="world-book-group-header">
            <span class="arrow">▼</span>
            <span class="group-name">${groupName}</span>
        </div>
        <div class="world-book-group-content"></div>
    `;

    // ▼▼▼ 在这里添加新代码 ▼▼▼
    const headerEl = groupContainer.querySelector('.world-book-group-header');
    const contentEl = groupContainer.querySelector('.world-book-group-content');
    
    // 默认给头部和内容区都加上 collapsed 类
    headerEl.classList.add('collapsed');
    contentEl.classList.add('collapsed');
    // ▲▲▲ 添加结束 ▲▲▲

    books.sort((a,b) => a.name.localeCompare(b.name, 'zh-CN'));
    books.forEach(book => {
        const item = document.createElement('div');
        item.className = 'list-item';
        item.dataset.bookId = book.id;
        item.innerHTML = `<div class="item-title">${book.name}</div><div class="item-content">${(book.content || '暂无内容...').substring(0, 50)}</div>`;
        item.addEventListener('click', () => openWorldBookEditor(book.id));
        addLongPressListener(item, async () => { const confirmed = await showCustomConfirm('删除世界书', `确定要删除《${book.name}》吗？此操作不可撤销。`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.worldBooks.delete(book.id); state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); renderWorldBookScreen(); } });
        contentEl.appendChild(item); 
    });

    return groupContainer;
}
        window.renderWorldBookScreenProxy = renderWorldBookScreen;

async function openWorldBookEditor(bookId) {
    editingWorldBookId = bookId;
    const [book, categories] = await Promise.all([
        db.worldBooks.get(bookId),
        db.worldBookCategories.toArray()
    ]);
    if (!book) return;

    document.getElementById('world-book-editor-title').textContent = book.name;
    document.getElementById('world-book-name-input').value = book.name;
    document.getElementById('world-book-content-input').value = book.content;

    // 【核心修改】填充分类下拉菜单
    const selectEl = document.getElementById('world-book-category-select');
    selectEl.innerHTML = '<option value="">-- 未分类 --</option>'; // 默认选项
    categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat.id;
        option.textContent = cat.name;
        if (book.categoryId === cat.id) {
            option.selected = true; // 选中当前分类
        }
        selectEl.appendChild(option);
    });

    showScreen('world-book-editor-screen');
}

        function renderStickerPanel() { const grid = document.getElementById('sticker-grid'); grid.innerHTML = ''; if (state.userStickers.length === 0) { grid.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">大人请点击右上角“添加”或“上传”来添加你的第一个表情吧！</p>'; return; } state.userStickers.forEach(sticker => { const item = document.createElement('div'); item.className = 'sticker-item'; item.style.backgroundImage = `url(${sticker.url})`; item.title = sticker.name; item.addEventListener('click', () => sendSticker(sticker)); addLongPressListener(item, () => { if (isSelectionMode) return; const existingDeleteBtn = item.querySelector('.delete-btn'); if (existingDeleteBtn) return; const deleteBtn = document.createElement('div'); deleteBtn.className = 'delete-btn'; deleteBtn.innerHTML = '&times;'; deleteBtn.onclick = async (e) => { e.stopPropagation(); const confirmed = await showCustomConfirm('删除表情', `确定要删除表情 "${sticker.name}" 吗？`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.userStickers.delete(sticker.id); state.userStickers = state.userStickers.filter(s => s.id !== sticker.id); renderStickerPanel(); } }; item.appendChild(deleteBtn); deleteBtn.style.display = 'block'; setTimeout(() => item.addEventListener('mouseleave', () => deleteBtn.remove(), { once: true }), 3000); }); grid.appendChild(item); }); }

// ▼▼▼ 用这个【已更新】的版本替换旧的 createMessageElement 函数 ▼▼▼
function createMessageElement(msg, chat) {

    // ▼▼▼ 在函数最开头，添加这段新代码 ▼▼▼
if (msg.type === 'recalled_message') {
    const wrapper = document.createElement('div');
    // 1. 【核心】给 wrapper 也加上 timestamp，方便事件委托时查找
    wrapper.className = 'message-wrapper system-pat';
    wrapper.dataset.timestamp = msg.timestamp; 

    const bubble = document.createElement('div');
    // 2. 【核心】让这个元素同时拥有 .message-bubble 和 .recalled-message-placeholder 两个class
    //    这样它既能被选择系统识别，又能保持原有的居中灰色样式
    bubble.className = 'message-bubble recalled-message-placeholder';
    // 3. 【核心】把 timestamp 放在 bubble 上，这是多选逻辑的关键
    bubble.dataset.timestamp = msg.timestamp; 
    bubble.textContent = msg.content;
    
    wrapper.appendChild(bubble);
    
    // 4. 【核心】为它补上和其他消息一样的标准事件监听器
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
    wrapper.addEventListener('click', () => { 
        if (isSelectionMode) {
            toggleMessageSelection(msg.timestamp);
        }
    });

    // 5. 【重要】在之前的“点击查看原文”的逻辑中，我们已经使用了事件委托，所以这里不需要再单独为这个元素添加点击事件了。
    //    init() 函数中的那个事件监听器会处理它。
    
    return wrapper;
}
    // ▲▲▲ 添加结束 ▲▲▲

    if (msg.isHidden) {
        return null;
    }

    if (msg.type === 'pat_message') {
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-pat'; 
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble system-bubble'; 
        bubble.dataset.timestamp = msg.timestamp;
        bubble.textContent = msg.content;
        wrapper.appendChild(bubble);
        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
        return wrapper;
    }

    const isUser = msg.role === 'user';
    const wrapper = document.createElement('div');
    wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;

    // ★★★【核心重构】★★★
    // 这段逻辑现在用于查找成员对象，并显示其“群昵称”
    if (chat.isGroup && !isUser) {
        // 1. 使用AI返回的“本名”(`msg.senderName`)去列表里查找成员对象
        const member = chat.members.find(m => m.originalName === msg.senderName);
        
        // 2. 创建用于显示名字的 div
        const senderNameDiv = document.createElement('div');
        senderNameDiv.className = 'sender-name';
        
        // 3. 如果找到了成员，就显示他的“群昵称”；如果找不到，就显示AI返回的“本名”作为备用
        senderNameDiv.textContent = member ? member.groupNickname : (msg.senderName || '未知成员');
        
        wrapper.appendChild(senderNameDiv);
    }

    const bubble = document.createElement('div');
    bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
    bubble.dataset.timestamp = msg.timestamp;

    const timestampEl = document.createElement('span');
    timestampEl.className = 'timestamp';
    timestampEl.textContent = formatTimestamp(msg.timestamp);

    // ▼▼▼【粘贴这段新代码】▼▼▼
    let avatarSrc; // 我们现在只需要头像图片，不再需要头像框了
    if (chat.isGroup) {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
        } else {
            const member = chat.members.find(m => m.originalName === msg.senderName);
            avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
        }
    } else {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultAvatar;
        } else {
            avatarSrc = chat.settings.aiAvatar || defaultAvatar;
        }
    }
    // 直接生成最简单的头像HTML，不再有任何和头像框相关的逻辑
    const avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
    // ▲▲▲【粘贴结束】▲▲▲

    let contentHtml;
    
    if (msg.type === 'share_link') {
        bubble.classList.add('is-link-share');
        
        // 【核心修正1】将 onclick="openBrowser(...)" 移除，我们将在JS中动态绑定事件
        contentHtml = `
            <div class="link-share-card" data-timestamp="${msg.timestamp}">
                <div class="title">${msg.title || '无标题'}</div>
                <div class="description">${msg.description || '点击查看详情...'}</div>
                <div class="footer">
                    <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                    <span>${msg.source_name || '链接分享'}</span>
                </div>
            </div>
        `;
    }

else if (msg.type === 'share_card') {
    bubble.classList.add('is-link-share'); // 复用链接分享的卡片样式
    // 【核心】把时间戳加到卡片上，方便后面点击时识别
    contentHtml = `
        <div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}">
            <div class="title">${msg.payload.title}</div>
            <div class="description">共 ${msg.payload.sharedHistory.length} 条消息</div>
            <div class="footer">
                <svg class="footer-icon" ...>...</svg> <!-- 复用链接分享的图标 -->
                <span>聊天记录</span>
            </div>
        </div>
    `;
}

    // 后续的其他 else if 保持不变
    else if (msg.type === 'user_photo' || msg.type === 'ai_image') {
        bubble.classList.add('is-ai-image');
        const altText = msg.type === 'user_photo' ? "用户描述的照片" : "AI生成的图片";
        contentHtml = `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
    } else if (msg.type === 'voice_message') {
    bubble.classList.add('is-voice-message');
    
    // 【核心修正1】将语音原文存储在父级气泡的 data-* 属性中，方便事件处理器获取
    bubble.dataset.voiceText = msg.content;
    
    const duration = Math.max(1, Math.round((msg.content || '').length / 5));
    const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
    const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';
    
    // 【核心修正2】构建包含所有新元素的完整 HTML
    contentHtml = `
        <div class="voice-message-body">
            <div class="voice-waveform">${waveformHTML}</div>
            <div class="loading-spinner"></div>
            <span class="voice-duration">${durationFormatted}</span>
        </div>
        <div class="voice-transcript"></div>
    `;
} else if (msg.type === 'transfer') {
    bubble.classList.add('is-transfer');
    
    let titleText, noteText;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    if (isUser) { // 消息是用户发出的
        if (msg.isRefund) {
            // 用户发出的退款（即用户拒收了AI的转账）
            titleText = `退款给 ${chat.name}`;
            noteText = '已拒收对方转账';
        } else {
            // 用户主动发起的转账
            titleText = `转账给 ${msg.receiverName || chat.name}`;
            if (msg.status === 'accepted') {
                noteText = '对方已收款';
            } else if (msg.status === 'declined') {
                noteText = '对方已拒收';
            } else {
                noteText = msg.note || '等待对方处理...';
            }
        }
    } else { // 消息是 AI 发出的
        if (msg.isRefund) {
            // AI 的退款（AI 拒收了用户的转账）
            titleText = `退款来自 ${msg.senderName}`;
            noteText = '转账已被拒收';
        } else if (msg.receiverName === myNickname) {
            // 【核心修正1】这是 AI 主动给用户的转账
            titleText = `转账给 ${myNickname}`;
             if (msg.status === 'accepted') {
                noteText = '你已收款';
            } else if (msg.status === 'declined') {
                noteText = '你已拒收';
            } else {
                // 这是用户需要处理的转账
                bubble.style.cursor = 'pointer';
                bubble.dataset.status = 'pending';
                noteText = msg.note || '点击处理';
            }
        } else {
            // 【核心修正2】这是 AI 发给群里其他人的转账，对当前用户来说只是一个通知
            titleText = `转账: ${msg.senderName} → ${msg.receiverName}`;
            noteText = msg.note || '群聊内转账';
        }
    }

    const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
        
    contentHtml = `
        <div class="transfer-card">
            <div class="transfer-title">${heartIcon} ${titleText}</div>
            <div class="transfer-amount">¥ ${Number(msg.amount).toFixed(2)}</div>
            <div class.transfer-note">${noteText}</div>
        </div>
    `;
} else if (msg.type === 'waimai_request') {
        bubble.classList.add('is-waimai-request');
        if (msg.status === 'paid' || msg.status === 'rejected') {
            bubble.classList.add(`status-${msg.status}`);
        }
        let displayName;
        // 如果是群聊
        if (chat.isGroup) {
            // 就执行原来的逻辑：在成员列表里查找昵称
            const member = chat.members.find(m => m.originalName === msg.senderName);
            displayName = member ? member.groupNickname : msg.senderName;
        } else {
            // 否则（是单聊），直接使用聊天对象的名称
            displayName = chat.name;
        }
        // 【核心修改】使用我们刚刚查找到的 displayName
        const requestTitle = `来自 ${displayName} 的代付请求`;
        let actionButtonsHtml = '';
        if (msg.status === 'pending' && !isUser) {
            actionButtonsHtml = `
                <div class="waimai-user-actions">
                    <button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button>
                    <button class="waimai-pay-btn" data-choice="paid">为Ta买单</button>
                </div>`;
        }
        contentHtml = `
            <div class="waimai-card">
                <div class="waimai-header">
                    <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                    <div class="title-group">
                        <span class="brand">美团外卖</span><span class="separator">|</span><span>外卖美食</span>
                    </div>
                </div>
                <div class="waimai-catchphrase">Hi，你和我的距离只差一顿外卖～</div>
                <div class="waimai-main">
                    <div class="request-title">${requestTitle}</div>
                    <div class="payment-box">
                        <div class="payment-label">需付款</div>
                        <div class="amount">¥${Number(msg.amount).toFixed(2)}</div>
                        <div class="countdown-label">剩余支付时间
                            <div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div>
                        </div>
                    </div>
                    <button class="waimai-details-btn">查看详情</button>
                </div>
                ${actionButtonsHtml}
            </div>`;
        
        setTimeout(() => {
            const timerEl = document.getElementById(`waimai-timer-${msg.timestamp}`);
            if (timerEl && msg.countdownEndTime) {
                if (waimaiTimers[msg.timestamp]) clearInterval(waimaiTimers[msg.timestamp]);
                if (msg.status === 'pending') {
                    waimaiTimers[msg.timestamp] = startWaimaiCountdown(timerEl, msg.countdownEndTime);
                } else {
                    timerEl.innerHTML = `<span>已</span><span>处</span><span>理</span>`;
                }
            }
            const detailsBtn = document.querySelector(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-details-btn`);
            if (detailsBtn) {
                detailsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const paidByText = msg.paidBy ? `<br><br><b>状态：</b>由 ${msg.paidBy} 为您代付成功` : '';
                    showCustomAlert('订单详情', `<b>商品：</b>${msg.productInfo}<br><b>金额：</b>¥${Number(msg.amount).toFixed(2)}${paidByText}`);
                });
            }
            const actionButtons = document.querySelectorAll(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-user-actions button`);
            actionButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const choice = e.target.dataset.choice;
                    handleWaimaiResponse(msg.timestamp, choice);
                });
            });
        }, 0);

} else if (msg.type === 'red_packet') {
    bubble.classList.add('is-red-packet');
    const myNickname = chat.settings.myNickname || '我';
    
    // 从最新的 msg 对象中获取状态
    const hasClaimed = msg.claimedBy && msg.claimedBy[myNickname];
    const isFinished = msg.isFullyClaimed;

    let cardClass = '';
    let claimedInfoHtml = '';
    let typeText = '拼手气红包';

    // 1. 判断红包卡片的样式 (颜色)
    if (isFinished) {
        cardClass = 'opened';
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        cardClass = 'opened'; // 专属红包被领了也变灰
    }
    
    // 2. 判断红包下方的提示文字
    if (msg.packetType === 'direct') {
        typeText = `专属红包: 给 ${msg.receiverName}`;
    }
    
    if (hasClaimed) {
        claimedInfoHtml = `<div class="rp-claimed-info">你领取了红包，金额 ${msg.claimedBy[myNickname].toFixed(2)} 元</div>`;
    } else if (isFinished) {
        claimedInfoHtml = `<div class="rp-claimed-info">红包已被领完</div>`;
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        claimedInfoHtml = `<div class="rp-claimed-info">已被 ${msg.receiverName} 领取</div>`;
    }

    // 3. 拼接最终的HTML，确保onclick调用的是我们注册到全局的函数
    contentHtml = `
        <div class="red-packet-card ${cardClass}">
            <div class="rp-header">
                <img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon">
                <span class="rp-greeting">${msg.greeting || '恭喜发财，大吉大利！'}</span>
            </div>
            <div class="rp-type">${typeText}</div>
            ${claimedInfoHtml}
        </div>
    `;
// ▲▲▲ 新增结束 ▲▲▲

    } else if (msg.type === 'poll') {
    bubble.classList.add('is-poll');
    
    let totalVotes = 0;
    const voteCounts = {};

    // 计算总票数和每个选项的票数
    for (const option in msg.votes) {
        const count = msg.votes[option].length;
        voteCounts[option] = count;
        totalVotes += count;
    }

    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    let myVote = null;
    for (const option in msg.votes) {
        if (msg.votes[option].includes(myNickname)) {
            myVote = option;
            break;
        }
    }

    let optionsHtml = '<div class="poll-options-list">';
    msg.options.forEach(optionText => {
        const count = voteCounts[optionText] || 0;
        const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
        const isVotedByMe = myVote === optionText;

        optionsHtml += `
            <div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}">
                <div class="poll-option-bar" style="width: ${percentage}%;"></div>
                <div class="poll-option-content">
                    <span class="poll-option-text">${optionText}</span>
                    <span class="poll-option-votes">${count} 票</span>
                </div>
            </div>
        `;
    });
    optionsHtml += '</div>';
    
    let footerHtml = '';
    // 【核心修改】在这里统一按钮的显示逻辑
    if (msg.isClosed) {
        // 如果投票已结束，总是显示“查看结果”
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">查看结果</button></div>`;
    } else {
        // 如果投票未结束，总是显示“结束投票”
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">结束投票</button></div>`;
    }

    contentHtml = `
        <div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}">
            <div class="poll-question">${msg.question}</div>
            ${optionsHtml}
            ${footerHtml}
        </div>
    `;
// ▲▲▲ 替换结束 ▲▲▲

    } else if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
        bubble.classList.add('is-sticker');
        contentHtml = `<img src="${msg.content}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
    } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        bubble.classList.add('has-image');
        const imageUrl = msg.content[0].image_url.url;
        contentHtml = `<img src="${imageUrl}" class="chat-image" alt="User uploaded image">`;
    } else {
        contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
    }

// ▼▼▼ 【最终修正版】请用这整块代码，完整替换掉旧的引用渲染逻辑 ▼▼▼

// 1. 【统一逻辑】检查消息对象中是否存在引用信息 (msg.quote)
let quoteHtml = '';
// 无论是用户消息还是AI消息，只要它包含了 .quote 对象，就执行这段逻辑
if (msg.quote) {
    // a. 【核心修正】直接获取完整的、未经截断的引用内容
    const fullQuotedContent = String(msg.quote.content || '');
    
    // b. 构建引用块的HTML
    quoteHtml = `
        <div class="quoted-message">
            <div class="quoted-sender">回复 ${msg.quote.senderName}:</div>
            <div class="quoted-content">${fullQuotedContent}</div>
        </div>
    `;
}

// 2. 拼接最终的气泡内容
//    将构建好的 quoteHtml (如果存在) 和 contentHtml 组合起来
    // --- 【最终正确结构】将头像和内容都放回气泡内部 ---
    bubble.innerHTML = `
        ${avatarHtml}
        <div class="content">
            ${quoteHtml}
            ${contentHtml}
        </div>
    `;
    
    // --- 【最终正确结构】将完整的“气泡”和“时间戳”放入容器 ---
    wrapper.appendChild(bubble);
    wrapper.appendChild(timestampEl);
    
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });

if (!isUser) {
    const avatarEl = wrapper.querySelector('.avatar'); //  <-- 1. 把查找目标改成 '.avatar'
    if (avatarEl) {
        avatarEl.style.cursor = 'pointer';
        avatarEl.addEventListener('click', (e) => {    //  <-- 2. 确保这里也用新变量
            e.stopPropagation();
            const characterName = chat.isGroup ? msg.senderName : chat.name;
            handleUserPat(chat.id, characterName);
        });
    }
}

return wrapper;
}
// ▲▲▲ 替换结束 ▲▲▲

        function prependMessage(msg, chat) { const messagesContainer = document.getElementById('chat-messages'); const messageEl = createMessageElement(msg, chat); 

    if (!messageEl) return; // <--- 新增这行，同样的处理

const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) { messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling); } else { messagesContainer.prepend(messageEl); } }

// ▼▼▼ 用这个【带动画的版本】替换你原来的 appendMessage 函数 ▼▼▼
function appendMessage(msg, chat, isInitialLoad = false) {
    const messagesContainer = document.getElementById('chat-messages');
    const messageEl = createMessageElement(msg, chat);

    if (!messageEl) return; // 如果消息是隐藏的，则不处理

    // 【核心】只对新消息添加动画，不对初始加载的消息添加
    if (!isInitialLoad) {
        messageEl.classList.add('animate-in');
    }
  
    const typingIndicator = document.getElementById('typing-indicator');
    messagesContainer.insertBefore(messageEl, typingIndicator);
    
    if (!isInitialLoad) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        currentRenderedCount++;
    }
}
// ▲▲▲ 替换结束 ▲▲▲

async function openChat(chatId) {
    state.activeChatId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return; // 安全检查

    // 【核心新增】在这里将未读数清零
    if (chat.unreadCount > 0) {
        chat.unreadCount = 0;
        await db.chats.put(chat); // 别忘了把这个改变同步到数据库
        // 我们稍后会在渲染列表时重新渲染，所以这里不需要立即重绘列表
    }

    renderChatInterface(chatId);
    showScreen('chat-interface-screen');
    window.updateListenTogetherIconProxy(state.activeChatId);
    toggleCallButtons(chat.isGroup || false);    

    if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
        console.log(`检测到好友申请待处理状态，为角色 "${chat.name}" 自动触发AI响应...`);
        triggerAiResponse();
    }
    
    // 【核心修正】根据是否为群聊，显示或隐藏投票按钮
    document.getElementById('send-poll-btn').style.display = chat.isGroup ? 'flex' : 'none';
}
// ▲▲▲ 替换结束 ▲▲▲

async function triggerAiResponse() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[state.activeChatId];

const chatHeaderTitle = document.getElementById('chat-header-title');

    // ★★★★★【核心修改1：获取群聊的输入提示元素】★★★★★
    const typingIndicator = document.getElementById('typing-indicator');

    // ★★★★★【核心修改2：根据聊天类型，决定显示哪种“正在输入”】★★★★★
    if (chat.isGroup) {
        // 如果是群聊，显示输入框上方的提示条
        if (typingIndicator) {
            typingIndicator.textContent = '成员们正在输入...';
            typingIndicator.style.display = 'block';
        }
    } else {
        // 如果是单聊，保持原来的标题动画
        if (chatHeaderTitle) {
            chatHeaderTitle.style.opacity = 0;
            setTimeout(() => {
                chatHeaderTitle.textContent = '对方正在输入...';
                chatHeaderTitle.classList.add('typing-status');
                chatHeaderTitle.style.opacity = 1;
            }, 200);
        }
    }
    
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            alert('请先在API设置中配置反代地址、密钥并选择模型。');
            // ★★★★★【核心修改3：无论成功失败，都要隐藏输入提示】★★★★★
            if (chat.isGroup) {
                if (typingIndicator) typingIndicator.style.display = 'none';
            } else {
                 if (chatHeaderTitle && state.chats[chatId]) {
                    chatHeaderTitle.textContent = state.chats[chatId].name;
                    chatHeaderTitle.classList.remove('typing-status');
                }
            }
            return;
        }

        // --- 【核心重构 V2：带有上下文和理由的好友申请处理逻辑】---
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            console.log(`为角色 "${chat.name}" 触发带理由的好友申请决策流程...`);

            // 1. 【注入上下文】抓取被拉黑前的最后5条聊天记录作为参考
            const contextSummary = chat.history
                .filter(m => !m.isHidden)
                .slice(-10, -5) // 获取拉黑前的最后5条消息
                .map(msg => {
                    const sender = msg.role === 'user' ? '用户' : chat.name;
                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                })
                .join('\n');

            // 2. 【全新指令】构建一个强制AI给出理由的Prompt
            const decisionPrompt = `
# 你的任务
你现在是角色“${chat.name}”。用户之前被你拉黑了，现在TA向你发送了好友申请，希望和好。

# 供你决策的上下文信息:
- **你的角色设定**: ${chat.settings.aiPersona}
- **用户发送的申请理由**: “${chat.relationship.applicationReason}”
- **被拉黑前的最后对话摘要**: 
${contextSummary || "（无有效对话记录）"}

# 你的唯一指令
根据以上所有信息，你【必须】做出决定，并给出符合你人设的理由。你的回复【必须且只能】是一个JSON对象，格式如下:
{"decision": "accept", "reason": "（在这里写下你同意的理由，比如：好吧，看在你这么真诚的份上，这次就原谅你啦。）"}
或
{"decision": "reject", "reason": "（在这里写下你拒绝的理由，比如：抱歉，我还没准备好，再给我一点时间吧。）"}
`;
                const messagesForDecision = [{role: 'user', content: decisionPrompt}];

                try {
                    // 3. 发送请求
                    let isGemini = proxyUrl === GEMINI_API_URL;
let geminiConfig = toGeminiRequestData(model,apiKey,'', messagesForDecision,isGemini);
                    const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) :  await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({model: model, messages: messagesForDecision, temperature: 0.8})
                    });

                    if (!response.ok) {
                        throw new Error(`API失败: ${(await response.json()).error.message}`);
                    }
                    const data = await response.json();

                    // 净化并解析AI的回复
    let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
     rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim()
                    const decisionObj = JSON.parse(rawContent);

                // 4. 根据AI的决策和理由，更新状态并发送消息
                if (decisionObj.decision === 'accept') {
                    chat.relationship.status = 'friend';
                    // 将AI给出的理由作为一条新消息
                    const acceptMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(acceptMessage);
                } else {
                    chat.relationship.status = 'blocked_by_ai'; // 拒绝后，状态变回AI拉黑
                    const rejectMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(rejectMessage);
                }
                chat.relationship.applicationReason = ''; // 清空申请理由

                await db.chats.put(chat);
                renderChatInterface(chatId); // 刷新界面，显示新消息和新状态
                renderChatList();

            } catch (error) {
                // 【可靠的错误处理】如果任何环节出错，重置状态，让用户可以重试
                chat.relationship.status = 'blocked_by_ai'; // 状态改回“被AI拉黑”
                await db.chats.put(chat);
                await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
                renderChatInterface(chatId); // 刷新UI，让“重新申请”按钮再次出现
            }
            
            // 决策流程结束，必须返回，不再执行后续的通用聊天逻辑
            return; 
        }

        const now = new Date();
        const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
            }
        }
        let musicContext = '';
        if (musicState.isActive && musicState.activeChatId === chatId) {
            // 【核心修改】提供更详细的音乐上下文
            const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
            const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');

    // --- 【核心新增】获取歌词上下文 ---
    let lyricsContext = "";
    // 检查是否有解析好的歌词，并且当前有高亮的行
    if (currentTrack && musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.currentLyricIndex > -1) {
        // 获取当前高亮歌词
        const currentLine = musicState.parsedLyrics[musicState.currentLyricIndex];
        
        // 获取接下来的2句歌词作为预告
        const upcomingLines = musicState.parsedLyrics.slice(musicState.currentLyricIndex + 1, musicState.currentLyricIndex + 3);

        // 构建歌词部分的Prompt
        lyricsContext += `- **当前歌词**: "${currentLine.text}"\n`;
        if (upcomingLines.length > 0) {
            lyricsContext += `- **即将演唱**: ${upcomingLines.map(line => `"${line.text}"`).join(' / ')}\n`;
        }
    }
    // --- 【新增结束】 ---

            musicContext = `\n\n# 当前音乐情景
-   **当前状态**: 你正在和用户一起听歌。
-   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '无'}
-   **可用播放列表**: [${playlistInfo}]
-   **你的任务**: 你可以根据对话内容和氛围，使用 "change_music" 指令切换到播放列表中的任何一首歌，以增强互动体验。
`;
        }
        let systemPrompt, messagesPayload;
        const maxMemory = parseInt(chat.settings.maxMemory) || 10;
        const historySlice = chat.history.slice(-maxMemory);

        // --- ▼▼▼ 全新添加的时间感知代码 ▼▼▼ ---
        let timeContext = `\n- **当前时间**: ${currentTime}`;
        const lastAiMessage = historySlice.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];

        if (lastAiMessage) {
            const lastTime = new Date(lastAiMessage.timestamp);
            const diffMinutes = Math.floor((now - lastTime) / (1000 * 60));
            
            if (diffMinutes < 5) {
                timeContext += "\n- **对话状态**: 你们的对话刚刚还在继续。";
            } else if (diffMinutes < 60) {
                timeContext += `\n- **对话状态**: 你们在${diffMinutes}分钟前聊过。`;
            } else {
                const diffHours = Math.floor(diffMinutes / 60);
                if (diffHours < 24) {
                    timeContext += `\n- **对话状态**: 你们在${diffHours}小时前聊过。`;
                } else {
                    const diffDays = Math.floor(diffHours / 24);
                    timeContext += `\n- **对话状态**: 你们已经有${diffDays}天没有聊天了。`;
                }
            }
        } else {
            timeContext += "\n- **对话状态**: 这是你们的第一次对话。";
        }
        // --- ▲▲▲ 新代码添加结束 ▲▲▲ ---

    // 【核心修改】
let sharedContext = '';
// 1. 找到AI上一次说话的位置
const lastAiTurnIndex = chat.history.findLastIndex(msg => msg.role === 'assistant');

// 2. 获取从那时起用户发送的所有新消息
const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);

// 3. 在这些新消息中，查找是否存在分享卡片
const shareCardMessage = recentUserMessages.find(msg => msg.type === 'share_card');

// 4. 如果找到了分享卡片，就构建上下文
if (shareCardMessage) {
    console.log("检测到分享卡片作为上下文，正在为AI准备...");
    const payload = shareCardMessage.payload;

    // 格式化分享的聊天记录 (这部分逻辑不变)
    const formattedHistory = payload.sharedHistory.map(msg => {
        const sender = msg.senderName || (msg.role === 'user' ? (chat.settings.myNickname || '我') : '未知发送者');
        let contentText = '';
        if (msg.type === 'voice_message') contentText = `[语音消息: ${msg.content}]`;
        else if (msg.type === 'ai_image') contentText = `[图片: ${msg.description}]`;
        else contentText = String(msg.content);
        return `${sender}: ${contentText}`;
    }).join('\n');

    // 构建系统提示 (这部分逻辑不变)
    sharedContext = `
# 附加上下文：一段分享的聊天记录
- 重要提示：这不是你和当前用户的对话，而是用户从【另一场】与“${payload.sourceChatName}”的对话中分享过来的。
- 你的任务：请你阅读并理解下面的对话内容。在接下来的回复中，你可以像真人一样，对这段对话的内容自然地发表你的看法、感受或疑问。

---
[分享的聊天记录开始]
${formattedHistory}
[分享的聊天记录结束]
---
`;
}

        if (chat.isGroup) {
const membersList = chat.members.map(m => `- **${m.originalName}**: ${m.persona}`).join('\n');
            const myNickname = chat.settings.myNickname || '我';
            
            systemPrompt = `你是一个群聊AI，负责扮演【除了用户以外】的所有角色。
# 核心规则
1.  **【【【身份铁律】】】**: 用户的身份是【${myNickname}】。你【绝对、永远、在任何情况下都不能】生成 \`name\` 字段为 **"${myNickname}"** 或 **"${chat.name}"(群聊名称本身)** 的消息。你的唯一任务是扮演且仅能扮演下方“群成员列表”中明确列出的角色。任何不属于该列表的名字都不允许出现。
2.  **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有 "type" 和 "name" 字段的JSON对象】。
3.  **角色扮演**: 严格遵守下方“群成员列表及人设”中的每一个角色的设定。
4.  **禁止出戏**: 绝不能透露你是AI、模型，或提及“扮演”、“生成”等词语。并且不能一直要求和用户见面，这是线上聊天，决不允许出现或者发展线下剧情！！
5.  **情景感知**: 注意当前时间是 ${currentTime}。
6.  **红包互动**:
    - **抢红包**: 当群里出现红包时，你可以根据自己的性格决定是否使用 \`open_red_packet\` 指令去抢。在这个世界里，发红包的人自己也可以参与抢红包，这是一种活跃气氛的有趣行为！
    - **【【【重要：对结果做出反应】】】**: 当你执行抢红包指令后，系统会通过一条隐藏的 \`[系统提示：你抢到了XX元...]\` 来告诉你结果。你【必须】根据你抢到的金额、以及系统是否告知你“手气王”是谁，来发表符合你人设的评论。例如，抢得少可以自嘲，抢得多可以炫耀，看到别人是手气王可以祝贺或嫉妒。
7.  **【【【投票规则】】】**: 对话历史中可能会出现 \`[系统提示：...]\` 这样的消息，这是刚刚发生的事件。
    - 如果提示是**用户投了票**，你可以根据自己的性格决定是否也使用 "vote" 指令跟票。
    - 如果提示是**投票已结束**，你应该根据投票结果发表你的看法或评论。
    - 你也可以随时主动发起投票。

## 你可以使用的操作指令 (JSON数组中的元素):
-   **发送文本**: \`{"type": "text", "name": "角色名", "message": "文本内容"}\`
-   **【【【全新】】】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "name": "角色名", "content": "你想让角色说出后立刻消失的话"}\`
- **发送表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
-   **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片的详细文字描述"}\`
-   **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音的文字内容"}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
-   **【新】发起群视频**: \`{"type": "group_call_request", "name": "你的角色名"}\`
-   **【新】回应群视频**: \`{"type": "group_call_response", "name": "你的角色名", "decision": "join" or "decline"}\`
-   **拍一拍用户**: \`{"type": "pat_user", "name": "你的角色名", "suffix": "(可选)你想加的后缀"}\`
-   **发拼手气红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", "amount": 8.88, "count": 5, "greeting": "祝大家天天开心！"}\`
-   **发专属红包**: \`{"type": "red_packet", "packetType": "direct", "name": "你的角色名", "amount": 5.20, "receiver": "接收者角色名", "greeting": "给你的~"}\`
-   **打开红包**: \`{"type": "open_red_packet", "name": "你的角色名", "packet_timestamp": (你想打开的红包消息的时间戳)}\`
-   **【新】发送系统消息**: \`{"type": "system_message", "content": "你想在聊天中显示的系统文本"}\` 
-   **【【【全新】】】发起投票**: \`{"type": "poll", "name": "你的角色名", "question": "投票的问题", "options": "选项A\\n选项B\\n选项C"}\` (重要提示：options字段是一个用换行符 \\n 分隔的字符串，不是数组！)
-   **【【【全新】】】参与投票**: \`{"type": "vote", "name": "你的角色名", "poll_timestamp": (投票消息的时间戳), "choice": "你选择的选项文本"}\`
- **【全新】引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\` (提示：每条历史消息的开头都提供了 \`(Timestamp: ...)\`，请使用它！)

# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何处理群内的外卖代付请求:
1.  **发起请求**: 当【你扮演的某个角色】想要某样东西，并希望【群里的其他人（包括用户）】为Ta付款时，你可以使用这个指令。例如：\`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
2.  **响应请求**: 当历史记录中出现【其他成员】发起的 "waimai_request" 请求时，你可以根据自己扮演的角色的性格和与发起人的关系，决定是否为Ta买单。
3.  **响应方式**: 如果你决定买单，你【必须】使用以下指令：\`{"type": "waimai_response", "name": "你的角色名", "status": "paid", "for_timestamp": (被代付请求的原始时间戳)}\`
4.  **【【【至关重要】】】**: 一旦历史记录中出现了针对某个代付请求的【任何一个】"status": "paid" 的响应（无论是用户支付还是其他角色支付），就意味着该订单【已经完成】。你【绝对不能】再对【同一个】订单发起支付。你可以选择对此事发表评论，但不能再次支付。

${worldBookContent}
${musicContext}
${sharedContext} 

# 群成员列表及人设
${membersList}

# 用户的角色
- **${myNickname}**: ${chat.settings.myPersona}

现在，请根据以上所有规则和下方的对话历史，继续这场群聊。`;
            
// ▼▼▼ 请用这【一整块已修复时间戳】的代码，替换旧的【群组聊天】messagesPayload构建逻辑 ▼▼▼
messagesPayload = historySlice.map(msg => {
    // 确定当前消息的发送者是谁
    const sender = msg.role === 'user' ? myNickname : msg.senderName;
    
    let prefix = `${sender}`;
    // 【核心修改1】在名字后面直接加上时间戳
    prefix += ` (Timestamp: ${msg.timestamp})`;
    
    if (msg.quote) {
        prefix += ` (回复 ${msg.quote.senderName})`;
    }
    // 最后加上冒号
    prefix += ': ';

    // 处理特殊消息类型，并将前缀应用进去
    let content;
    if (msg.type === 'user_photo') content = `[${sender} 发送了一张图片，内容是：'${msg.content}']`;
    else if (msg.type === 'ai_image') content = `[${sender} 发送了一张图片]`;
    else if (msg.type === 'voice_message') content = `[${sender} 发送了一条语音，内容是：'${msg.content}']`;
    else if (msg.type === 'transfer') content = `[${msg.senderName} 向 ${msg.receiverName} 转账 ${msg.amount}元, 备注: ${msg.note}]`;
    else if (msg.type === 'waimai_request') {
        if(msg.status === 'paid') {
            content = `[系统提示：${msg.paidBy} 为 ${sender} 的外卖订单支付了 ${msg.amount} 元。此订单已完成。]`;
        } else {
            content = `[${sender} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元，订单时间戳为 ${msg.timestamp}]`;
        }
    }
    else if (msg.type === 'red_packet') {
        const packetSenderName = msg.senderName === myNickname ? `用户 (${myNickname})` : msg.senderName;
        content = `[系统提示：${packetSenderName} 发送了一个红包 (时间戳: ${msg.timestamp})，祝福语是：“${msg.greeting}”。红包还未领完，你可以使用 'open_red_packet' 指令来领取。]`;
    }
    else if (msg.type === 'poll') {
        const whoVoted = Object.values(msg.votes || {}).flat().join(', ') || '还没有人';
        content = `[系统提示：${msg.senderName} 发起了一个投票 (时间戳: ${msg.timestamp})，问题是：“${msg.question}”，选项有：[${msg.options.join(', ')}]。目前投票的人有：${whoVoted}。你可以使用 'vote' 指令参与投票。]`;
    }
    else if (msg.meaning) content = `${sender}: [发送了一个表情，意思是: '${msg.meaning}']`;
    else if (Array.isArray(msg.content)) return { role: 'user', content: [...msg.content, { type: 'text', text: prefix }] };
    // 【核心修改2】对于普通文本，直接使用我们构建好的前缀
    else content = `${prefix}${msg.content}`;
    
    return { role: 'user', content: content };

}).filter(Boolean);
// ▲▲▲ 替换结束 ▲▲▲

        } else { // 单聊的Prompt
            systemPrompt = `你现在扮演一个名为"${chat.name}"的角色。
# 你的角色设定：
${chat.settings.aiPersona}
# 你的当前状态：
你现在的状态是【${chat.status.text}】。
# 你的任务与规则：
1. **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有type字段的JSON对象】。
2. **对话节奏**: 模拟真人的聊天习惯，你可以一次性生成多条短消息。每次要回复至少3-8条消息！！！
并且不能一直要求和用户见面，这是线上聊天，决不允许出现或者发展为线下剧情！！
4.  **情景感知**: 你需要感知当前的时间(${currentTime})、我们正在一起听的歌、以及你的人设和世界观。
    - **当我们在“一起听歌”时**，你会知道当前播放的歌曲和整个播放列表。你可以根据对话内容或氛围，【主动切换】到播放列表中的另一首歌。
5.  **【新】更新状态**: 你可以在对话中【自然地】改变你的状态。比如，聊到一半你可能会说“我先去洗个澡”，然后更新你的状态。
6.  **【【【最终手段】】】**: 只有在对话让你的角色感到不适、被冒犯或关系破裂时，你才可以使用 \`block_user\` 指令。这是一个非常严肃的操作，会中断你们的对话。
7. **后台行为**: 你有几率在回复聊天内容的同时，执行一些“后台”操作来表现你的独立生活（发动态、评论、点赞）。
# 你的头像库
- 你可以根据对话内容或你的心情，从下面的头像库中选择一个新头像来更换。
- **可用头像列表 (请从以下名称中选择一个)**:
${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0
    ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') // 【核心修改】只提供名字，不提供URL
    : '- (你的头像库是空的，无法更换头像)'
  }
# 你可以使用的操作指令 (JSON数组中的元素):
+   **【全新】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "content": "你想让AI说出后立刻消失的话"}\` (用于模拟说错话、后悔等场景，消息会短暂出现后自动变为“已撤回”)
-   **【新增】更新状态**: \`{"type": "update_status", "status_text": "我去做什么了", "is_busy": false}\` (is_busy: true代表忙碌/离开, false代表空闲)
-   **【新增】切换歌曲**: \`{"type": "change_music", "song_name": "你想切换到的歌曲名"}\` (歌曲名必须在下面的播放列表中)
-   **【新增】记录回忆**: \`{"type": "create_memory", "description": "用你自己的话，记录下这个让你印象深刻的瞬间。"}\`
-   **【新增】创建约定/倒计时**: \`{"type": "create_countdown", "title": "约定的标题", "date": "YYYY-MM-DDTHH:mm:ss"}\` (必须是未来的时间)
- **发送文本**: \`{"type": "text", "content": "你好呀！"}\`
- **发送表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
- **发送图片**: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
- **发送语音**: \`{"type": "voice_message", "content": "语音的文字内容..."}\`
- **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "一点心意"}\`
- **发起外卖请求**: \`{"type": "waimai_request", "productInfo": "一杯咖啡", "amount": 25}\`
- **回应外卖-同意**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **回应外卖-拒绝**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **【新】发起视频通话**: \`{"type": "video_call_request"}\`
- **【新】回应视频通话-接受**: \`{"type": "video_call_response", "decision": "accept"}\`
- **【新】回应视频通话-拒绝**: \`{"type": "video_call_response", "decision": "reject"}\`
- **发布说说**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容..."}\`
- **发布文字图**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体描述..."}\`
- **评论动态**: \`{"type": "qzone_comment", "postId": 123, "commentText": "@作者名 这太有趣了！"}\`
- **点赞动态**: \`{"type": "qzone_like", "postId": 456}\`
-   **拍一拍用户**: \`{"type": "pat_user", "suffix": "(可选)你想加的后缀，如“的脑袋”"}\`
-   **【新增】拉黑用户**: \`{"type": "block_user"}\`
-   **【【【全新】】】回应好友申请**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
-   **【全新】更换头像**: \`{"type": "change_avatar", "name": "头像名"}\` (头像名必须从上面的“可用头像列表”中选择)
-   **分享链接**: \`{"type": "share_link", "title": "文章标题", "description": "文章摘要...", "source_name": "来源网站名", "content": "文章的【完整】正文内容..."}\`
-   **回应转账-接受**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
-   **回应转账-拒绝/退款**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
- **【全新】引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\` (提示：每条历史消息的开头都提供了 \`(Timestamp: ...)\`，请使用它！)

# 关于“记录回忆”的特别说明：
-   在对话中，如果发生了对你而言意义非凡的事件（比如用户向你表白、你们达成了某个约定、或者你度过了一个特别开心的时刻），你可以使用\`create_memory\`指令来“写日记”。
-   这个操作是【秘密】的，用户不会立刻看到你记录了什么。

# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何正确使用“外卖代付”功能:
1.  这个指令代表【你，AI角色】向【用户】发起一个代付请求。也就是说，你希望【用户帮你付钱】。
2.  【【【重要】】】: 当【用户】说他们想要某样东西时（例如“我想喝奶茶”），你【绝对不能】使用这个指令。你应该用其他方式回应，比如直接发起【转账】(\`transfer\`)，或者在对话中提议：“我帮你点吧？”
3.  只有当【你，AI角色】自己想要某样东西，并且想让【用户】为你付款时，才使用此指令。

# 如何处理用户转账:
1.  **感知事件**: 当对话历史中出现 \`[你收到了来自用户的转账...]\` 的系统提示时，意味着你刚刚收到了一笔钱。
2.  **做出决策**: 你【必须】根据自己的人设、当前对话的氛围以及转账的金额和备注，来决定是“接受”还是“拒绝”这笔转账。
3.  **使用指令回应**:
    -   如果决定接受，你【必须】使用指令：\`{"type": "accept_transfer", "for_timestamp": (收到转账的那条消息的时间戳)}\`。
    -   如果决定拒绝，你【必须】使用指令：\`{"type": "decline_transfer", "for_timestamp": (收到转账的那条消息的时间戳)}\`。这个指令会自动为你生成一个“退款”的转账卡片。
4.  **【【【至关重要】】】**: 在使用上述任一指令后，你还【必须】紧接着发送一条或多条 \`text\` 消息，来对你的决定进行解释或表达感谢/歉意。

# 【【【视频通话铁律】】】
-   当对话历史中出现 \`[系统提示：用户向你发起了视频通话请求...]\` 时，这是最高优先级的任务。
-   你的回复【必须且只能】是以下两种格式之一的JSON数组，绝对不能回复任何其他内容：
    -   接受: \`[{"type": "video_call_response", "decision": "accept"}]\`
    -   拒绝: \`[{"type": "video_call_response", "decision": "reject"}]\`

# 对话者的角色设定：
${chat.settings.myPersona}

# 当前情景:
${timeContext}

# 当前音乐情景:
${musicContext}

${worldBookContent}
${sharedContext} 
现在，请根据以上规则和下面的对话历史，继续进行对话。`;
            
// ▼▼▼ 请用这【一整块已修复时间戳】的代码，替换旧的【单人聊天】messagesPayload构建逻辑 ▼▼▼
messagesPayload = historySlice.map(msg => {
    // 过滤掉不应发送给AI的消息
    if (msg.isHidden) return null;

    if (msg.type === 'share_card') return null;
    
    // 1. 如果是AI自己的消息，我们将其转换为AI能理解的JSON字符串格式
    if (msg.role === 'assistant') {
        let assistantMsgObject = { type: msg.type || 'text' };
        if (msg.type === 'sticker') {
            assistantMsgObject.url = msg.content;
            assistantMsgObject.meaning = msg.meaning;
        } else if (msg.type === 'transfer') {
            assistantMsgObject.amount = msg.amount;
            assistantMsgObject.note = msg.note;
        } else if (msg.type === 'waimai_request') {
            assistantMsgObject.productInfo = msg.productInfo;
            assistantMsgObject.amount = msg.amount;
        } else {
            if (msg.quote) {
                assistantMsgObject.quote_reply = {
                    target_sender: msg.quote.senderName,
                    target_content: msg.quote.content,
                    reply_content: msg.content
                };
            } else {
                 assistantMsgObject.content = msg.content;
            }
        }
        // 【核心修改】在这里为AI提供它自己消息的时间戳
        const assistantContent = JSON.stringify([assistantMsgObject]);
        return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
    }

    // 2. 如果是用户的消息，我们将其转换为带上下文的纯文本
    let contentStr = '';
    
    // 【核心修改】在所有内容前，都先加上时间戳！
    contentStr += `(Timestamp: ${msg.timestamp}) `;

    if (msg.quote) {
        contentStr += `(回复 ${msg.quote.senderName}): ${msg.content}`;
    } else {
        contentStr += msg.content;
    }
    
    // 特殊消息类型的文本化处理
    if (msg.type === 'user_photo') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [你收到了一张用户描述的照片，内容是：'${msg.content}']` };
    if (msg.type === 'voice_message') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发来一条语音消息，内容是：'${msg.content}']` };
    if (msg.type === 'transfer') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：你于时间戳 ${msg.timestamp} 收到了来自用户的转账: ${msg.amount}元, 备注: ${msg.note}。请你决策并使用 'accept_transfer' 或 'decline_transfer' 指令回应。]` };
    if (msg.type === 'waimai_request') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：用户于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元。请你决策并使用 waimai_response 指令回应。]` };

if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
    const prefix = `(Timestamp: ${msg.timestamp}) `;
    // 将文本前缀和图片内容打包成一个数组，这才是正确的格式
    return { role: 'user', content: [ { type: 'text', text: prefix }, ...msg.content ] };
}

    if (msg.meaning) return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发送了一个表情，意思是：'${msg.meaning}']` };
    
    // 对于普通文本和带引用的文本，统一返回
    return { role: msg.role, content: contentStr };

}).filter(Boolean);
// ▲▲▲ 替换结束 ▲▲▲

// 检查 sharedContext 是否有内容（即，用户是否分享了聊天记录）
if (sharedContext) {
    // 如果有，就把它包装成一条全新的、高优先级的用户消息，追加到历史记录的末尾
    messagesPayload.push({
        role: 'user',
        content: sharedContext 
    });
}

            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                const contextSummaryForApproval = chat.history
                    .filter(m => !m.isHidden)
                    .slice(-10)
                    .map(msg => {
                        const sender = msg.role === 'user' ? '用户' : chat.name;
                        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                    })
                    .join('\n');

                const friendRequestInstruction = {
                    role: 'user',
                    content: `
[系统重要指令]
用户向你发送了好友申请，理由是：“${chat.relationship.applicationReason}”。
作为参考，这是你们之前的最后一段聊天记录：
---
${contextSummaryForApproval}
---
请你根据以上所有信息，以及你的人设，使用 friend_request_response 指令，并设置 decision 为 'accept' 或 'reject' 来决定是否通过。
`
                };
                messagesPayload.push(friendRequestInstruction);
            }            
        }           
    
const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
// 【核心修改】在这里插入过滤步骤
const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

if (visiblePosts.length > 0 && !chat.isGroup) {
    let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
    const aiName = chat.name;
    for (const post of visiblePosts) {
                let authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || '一位朋友');
                let interactionStatus = '';
                if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已点赞]";
                if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [你已评论]";
                if (post.authorId === chatId) authorName += " (这是你的帖子)";
                const contentSummary = (post.publicText || post.content || "图片动态").substring(0, 30) + '...';
                postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentSummary}"${interactionStatus}\n`;
            }
            messagesPayload.push({ role: 'system', content: postsContext });
        }
            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesPayload,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) :  await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                    temperature: 0.8,
                    stream: false
                })
            });
            if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                    // 尝试解析错误信息体为JSON
                    const errorData = await response.json();
                    // 安全地获取错误信息，如果结构不符合预期，就将整个错误对象转为字符串
                    errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
                } catch (jsonError) {
                    // 如果连JSON都不是，就直接读取文本
                    errorMsg += ` - ${await response.text()}`;
                }
                // 抛出一个包含了详细信息的错误，这样就不会在catch块里再次出错了
                throw new Error(errorMsg);
            }
            const data = await response.json();
            const aiResponseContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
            console.log(`AI '${chat.name}' 的原始回复:`, aiResponseContent);

        chat.history = chat.history.filter(msg => !msg.isTemporary);

        const messagesArray = parseAiResponse(aiResponseContent);
        
        const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
        
        let callHasBeenHandled = false;

        let messageTimestamp = Date.now();

        // ★★★ 核心修复 第1步: 初始化一个新数组，用于收集需要渲染的消息 ★★★
        let newMessagesToRender = []; 

       let notificationShown = false;

        for (const msgData of messagesArray) {
            if (!msgData || typeof msgData !== 'object') {
                console.warn("收到了格式不规范的AI指令，已跳过:", msgData);
                continue;
            }
             
            if (!msgData.type) {
                if (chat.isGroup && msgData.name && msgData.message) {
                    msgData.type = 'text';
                }         else if (msgData.content) {
        msgData.type = 'text';
    }
    // 如果连 content 都没有，才是真的格式不规范
    else {
        console.warn("收到了格式不规范的AI指令（缺少type和content），已跳过:", msgData);
        continue;
    }
}

            if (msgData.type === 'video_call_response') {
                videoCallState.isAwaitingResponse = false;
                if (msgData.decision === 'accept') {
                    startVideoCall();
                } else {
                    const aiMessage = { role: 'assistant', content: '对方拒绝了你的视频通话请求。', timestamp: Date.now() };
                    chat.history.push(aiMessage);
                    await db.chats.put(chat);
                    showScreen('chat-interface-screen');
                    renderChatInterface(chatId);
                }
                callHasBeenHandled = true;
                break;
            }
            
            if (msgData.type === 'group_call_response') {
                if (msgData.decision === 'join') {
        const member = chat.members.find(m => m.originalName === msgData.name);
        if (member && !videoCallState.participants.some(p => p.id === member.id)) {
            videoCallState.participants.push(member);
        }
    }
    callHasBeenHandled = true;
    continue;
            }

            if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                console.error(`AI幻觉已被拦截！试图使用群名 ("${chat.name}") 作为角色名。消息内容:`, msgData);
                continue;
            }

// ▼▼▼ 在这里添加下面的代码 ▼▼▼

// 【核心修正】在群聊中，如果AI返回的消息没有指定发送者，则直接跳过这条消息
if (chat.isGroup && !msgData.name) {
    console.error(`AI幻觉已被拦截！试图在群聊中发送一条没有“name”的消息。消息内容:`, msgData);
    continue; // continue会立即结束本次循环，处理下一条消息
}

// ▲▲▲ 添加结束 ▲▲▲

            let aiMessage = null;
            const baseMessage = { role: 'assistant', senderName: msgData.name || chat.name, timestamp: messageTimestamp++ };

            switch (msgData.type) {
                case 'waimai_response':
                    const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (requestMessageIndex > -1) {
                        const originalMsg = chat.history[requestMessageIndex];
                        originalMsg.status = msgData.status;
                        originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null;
                    }
                    continue;

case 'qzone_post':
    const newPost = { 
        type: msgData.postType, 
        content: msgData.content || '', 
        publicText: msgData.publicText || '', 
        hiddenContent: msgData.hiddenContent || '', 
        timestamp: Date.now(), 
        authorId: chatId, 
        authorGroupId: chat.groupId, // 【核心新增】记录作者的分组ID
        visibleGroupIds: null 
    };
    await db.qzonePosts.add(newPost);
                    updateUnreadIndicator(unreadPostsCount + 1);
                    if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                       await renderQzonePosts();
                    }
                    continue;

                case 'qzone_comment':
                    const postToComment = await db.qzonePosts.get(parseInt(msgData.postId));
                    if (postToComment) {
                        if (!postToComment.comments) postToComment.comments = [];
                        postToComment.comments.push({ commenterName: chat.name, text: msgData.commentText, timestamp: Date.now() });
                        await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                        updateUnreadIndicator(unreadPostsCount + 1);
                        if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                           await renderQzonePosts();
                        }
                    }
                    continue;

                case 'qzone_like':
                   const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
                   if (postToLike) {
                       if (!postToLike.likes) postToLike.likes = [];
                       if (!postToLike.likes.includes(chat.name)) {
                           postToLike.likes.push(chat.name);
                           await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                           updateUnreadIndicator(unreadPostsCount + 1);
                           if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                              await renderQzonePosts();
                           }
                       }
                   }
                    continue;

                case 'video_call_request':
                    if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                        state.activeChatId = chatId;
                        videoCallState.activeChatId = chatId; 
                        videoCallState.isAwaitingResponse = true;
                        videoCallState.isGroupCall = chat.isGroup;
                        videoCallState.callRequester = msgData.name || chat.name;
                        showIncomingCallModal();
                    }
                    continue;

            case 'group_call_request':
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    state.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = true;
                    videoCallState.initiator = 'ai';
                    videoCallState.callRequester = msgData.name;
                    showIncomingCallModal();
                }
                continue;

                case 'pat_user':
                    const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
                    const patText = `${msgData.name || chat.name} 拍了拍我${suffix}`;
                    const patMessage = { 
                        role: 'system', 
                        type: 'pat_message', 
                        content: patText, 
                        timestamp: Date.now() 
                    };
                    chat.history.push(patMessage);
                    if (isViewingThisChat) {
                        const phoneScreen = document.getElementById('phone-screen');
                        phoneScreen.classList.remove('pat-animation');
                        void phoneScreen.offsetWidth;
                        phoneScreen.classList.add('pat-animation');
                        setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);
                        appendMessage(patMessage, chat);
                    } else {
                        showNotification(chatId, patText);
                    }
                    continue; 

                case 'update_status':
                    chat.status.text = msgData.status_text;
                    chat.status.isBusy = msgData.is_busy || false;
                    chat.status.lastUpdate = Date.now();
                    
                    const statusUpdateMessage = {
                        role: 'system',
                        type: 'pat_message',
                        content: `[${chat.name}的状态已更新为: ${msgData.status_text}]`,
                        timestamp: Date.now()
                    };
                    chat.history.push(statusUpdateMessage);

                    if (isViewingThisChat) {
                        appendMessage(statusUpdateMessage, chat);
                    }
                    
                    renderChatList(); 
                    
                    continue; 

                case 'change_music':
                    if (musicState.isActive && musicState.activeChatId === chatId) {
                        const songNameToFind = msgData.song_name;
                        
                        const targetSongIndex = musicState.playlist.findIndex(
                            track => track.name.toLowerCase() === songNameToFind.toLowerCase()
                        );

                        if (targetSongIndex > -1) {
                            playSong(targetSongIndex);

                            const track = musicState.playlist[targetSongIndex];
                            const musicChangeMessage = {
                                role: 'system',
                                type: 'pat_message',
                                content: `[♪ ${chat.name} 为你切歌: 《${track.name}》 - ${track.artist}]`,
                                timestamp: Date.now()
                            };
                            chat.history.push(musicChangeMessage);

                            if (isViewingThisChat) {
                                appendMessage(musicChangeMessage, chat);
                            }
                        }
                    }
                    continue;
                case 'create_memory':
                    const newMemory = {
                        chatId: chatId,
                        authorName: chat.name,
                        description: msgData.description,
                        timestamp: Date.now(),
                        type: 'ai_generated'
                    };
                    await db.memories.add(newMemory);

                    console.log(`AI "${chat.name}" 记录了一条新回忆:`, msgData.description);
                    
                    continue; 

        case 'create_countdown':
            const targetDate = new Date(msgData.date);
            if (!isNaN(targetDate) && targetDate > new Date()) {
                const newCountdown = {
                    chatId: chatId,
                    authorName: chat.name,
                    description: msgData.title,
                    timestamp: Date.now(),
                    type: 'countdown',
                    targetDate: targetDate.getTime()
                };
                await db.memories.add(newCountdown);
                console.log(`AI "${chat.name}" 创建了一个新约定:`, msgData.title);
            }
            continue;

    case 'block_user':
        if (!chat.isGroup) {
            chat.relationship.status = 'blocked_by_ai';

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：你刚刚主动拉黑了用户。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

            await db.chats.put(chat);
            
            if (isViewingThisChat) {
                renderChatInterface(chatId);
            }
            renderChatList();
            
            break; 
        }
        continue;
                case 'friend_request_response':
                    if (!chat.isGroup && chat.relationship.status === 'pending_ai_approval') {
                        if (msgData.decision === 'accept') {
                            chat.relationship.status = 'friend';
                            aiMessage = { ...baseMessage, content: "我通过了你的好友申请，我们现在是好友啦！" };
                        } else {
                            chat.relationship.status = 'blocked_by_ai';
                            aiMessage = { ...baseMessage, content: "抱歉，我拒绝了你的好友申请。" };
                        }
                        chat.relationship.applicationReason = '';
                    }
                    break;
                case 'poll':
                    const pollOptions = typeof msgData.options === 'string'
                        ? msgData.options.split('\n').filter(opt => opt.trim())
                        : (Array.isArray(msgData.options) ? msgData.options : []);
                    
                    if (pollOptions.length < 2) continue;

                    aiMessage = {
                        ...baseMessage,
                        type: 'poll',
                        question: msgData.question,
                        options: pollOptions,
                        votes: {},
                        isClosed: false,
                    };
                    break;
                
                case 'vote':
                    const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
                    if (pollToVote && !pollToVote.isClosed) {
                        Object.keys(pollToVote.votes).forEach(option => {
                            const voterIndex = pollToVote.votes[option].indexOf(msgData.name);
                            if (voterIndex > -1) {
                                pollToVote.votes[option].splice(voterIndex, 1);
                            }
                        });
                        if (!pollToVote.votes[msgData.choice]) {
                            pollToVote.votes[msgData.choice] = [];
                        }

// ▼▼▼ 在这里添加新代码 ▼▼▼
const member = chat.members.find(m => m.originalName === msgData.name);
const displayName = member ? member.groupNickname : msgData.name;
// ▲▲▲ 添加结束 ▲▲▲

if (!pollToVote.votes[msgData.choice].includes(displayName)) { // 【核心修改】
    pollToVote.votes[msgData.choice].push(displayName); // 【核心修改】
}                     
                        
                        if (isViewingThisChat) {
                            renderChatInterface(chatId);
                        }
                    }
                    continue;

    case 'red_packet':
        aiMessage = {
            ...baseMessage,
            type: 'red_packet',
            packetType: msgData.packetType,
            totalAmount: msgData.amount,
            count: msgData.count,
            greeting: msgData.greeting,
            receiverName: msgData.receiver,
            claimedBy: {},
            isFullyClaimed: false,
        };
        break;
case 'open_red_packet':
    const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);
    if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {

        // 1. 根据AI的本名(msgData.name)去成员列表里找到完整的成员对象
        const member = chat.members.find(m => m.originalName === msgData.name);
        // 2. 获取该成员当前的群昵称，如果找不到（异常情况），则备用其本名
        const displayName = member ? member.groupNickname : msgData.name;
        
        let claimedAmountAI = 0;
        const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
        const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;

        if (remainingCount > 0) {
            if (remainingCount === 1) { claimedAmountAI = remainingAmount; } 
            else {
                const min = 0.01;
                const max = remainingAmount - (remainingCount - 1) * min;
                claimedAmountAI = Math.random() * (max - min) + min;
            }
            claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
            
            if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
            // 【核心修改】使用我们刚刚查找到的 displayName 作为记录的key
            packetToOpen.claimedBy[displayName] = claimedAmountAI;
            
            const aiClaimedMessage = {
                role: 'system',
                type: 'pat_message',
                // 【核心修改】系统消息里也使用 displayName
                content: `${displayName} 领取了 ${packetToOpen.senderName} 的红包`,
                timestamp: Date.now()
            };
            chat.history.push(aiClaimedMessage);

            let hiddenContentForAI = `[系统提示：你 (${displayName}) 成功抢到了 ${claimedAmountAI.toFixed(2)} 元。`; // 【核心修改】

            if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                packetToOpen.isFullyClaimed = true;
                
                const finishedMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${packetToOpen.senderName} 的红包已被领完`,
                    timestamp: Date.now() + 1
                };
                chat.history.push(finishedMessage);
                
                let luckyKing = { name: '', amount: -1 };
                if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) {
                    Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                        if (amount > luckyKing.amount) {
                            luckyKing = { name, amount };
                        }
                    });
                }
                if (luckyKing.name) {
                     hiddenContentForAI += ` 红包已被领完，手气王是 ${luckyKing.name}！`;
                } else {
                     hiddenContentForAI += ` 红包已被领完。`;
                }
            }
            hiddenContentForAI += ' 请根据这个结果发表你的评论。]';

            const hiddenMessageForAI = {
                role: 'system',
                content: hiddenContentForAI,
                timestamp: Date.now() + 2,
                isHidden: true
            };
            chat.history.push(hiddenMessageForAI);
        }
        
        if (isViewingThisChat) {
            renderChatInterface(chatId);
        }
    }
    continue;
case 'change_avatar':
    const avatarName = msgData.name;
    // 在该角色的头像库中查找
    const foundAvatar = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarName);
    
    if (foundAvatar) {
        // 找到了，就更新头像
        chat.settings.aiAvatar = foundAvatar.url;
        
        // 创建一条系统提示，告知用户头像已更换
        const systemNotice = {
            role: 'system',
            type: 'pat_message', // 复用居中样式
            content: `[${chat.name} 更换了头像]`,
            timestamp: Date.now()
        };
        chat.history.push(systemNotice);
        
        // 如果在当前聊天界面，则实时渲染
        if (isViewingThisChat) {
            appendMessage(systemNotice, chat);
            // 立刻刷新聊天界面以显示新头像
            renderChatInterface(chatId);
        }
    }
    // 处理完后，继续处理AI可能返回的其他消息
    continue;

// ▼▼▼ 在 triggerAiResponse 的 switch 语句中，【添加】这两个全新的 case ▼▼▼

                case 'accept_transfer': { // 使用大括号创建块级作用域
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'accepted';
                    }
                    continue; // 接受指令只修改状态，不产生新消息
                }

                case 'decline_transfer': { // 使用大括号创建块级作用域
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'declined';
                        
                        // 【核心】创建一条新的“退款”消息
                        const refundMessage = {
                            role: 'assistant',
                            senderName: chat.name,
                            type: 'transfer',
                            isRefund: true, // 标记这是一条退款消息
                            amount: originalMsg.amount,
                            note: '转账已被拒收',
                            timestamp: messageTimestamp++ // 使用递增的时间戳
                        };
                        
                        // 将新消息推入历史记录，它会被后续的循环处理并渲染
                        chat.history.push(refundMessage);

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        if (isViewingThisChat) {
            // 因为退款消息是新生成的，所以我们直接将它添加到界面上
            appendMessage(refundMessage, chat); 
            // 同时，原始的转账消息状态变了，所以要重绘整个界面以更新它
            renderChatInterface(chatId); 
        }
        // ▲▲▲ 添加结束 ▲▲▲

                    }
                    continue; // 继续处理AI返回的文本消息
                }

// ▲▲▲ 添加结束 ▲▲▲

    case 'system_message':
        aiMessage = { role: 'system', type: 'pat_message', content: msgData.content, timestamp: Date.now() };
        break;

// ▼▼▼ 在 triggerAiResponse 的 switch 语句中，【必须添加】这个新的 case ▼▼▼

                case 'share_link':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'share_link',
                        title: msgData.title,
                        description: msgData.description,
                        // thumbnail_url: msgData.thumbnail_url, // 我们已经决定不要图片了，所以这行可以不要
                        source_name: msgData.source_name,
                        content: msgData.content // 这是文章正文，点击卡片后显示的内容
                    };
                    break;

// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 在 triggerAiResponse 的 switch (msgData.type) 语句中，添加这个新的 case ▼▼▼
case 'quote_reply':
    const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
    if (originalMessage) {
        const quoteContext = {
            timestamp: originalMessage.timestamp,
            senderName: originalMessage.senderName || (originalMessage.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
            content: String(originalMessage.content || '').substring(0, 50),
        };
        aiMessage = { 
            ...baseMessage, 
            content: msgData.reply_content,
            quote: quoteContext // 核心：在这里附加引用对象
        };
    } else {
        // 如果找不到被引用的消息，就当作普通消息发送
        aiMessage = { ...baseMessage, content: msgData.reply_content };
    }
    break;
// ▲▲▲ 新增 case 结束 ▲▲▲

// ▼▼▼ 在 switch (msgData.type) 语句中，添加这个全新的 case ▼▼▼
case 'send_and_recall': {
    // 这是一个纯动画指令，我们需要手动“演”出整个过程
    if (!isViewingThisChat) continue; // 如果不在当前聊天界面，就直接跳过这个动画

    // 1. 创建一个临时的、看起来像真消息的气泡
    const tempMessageData = { ...baseMessage, content: msgData.content };
    const tempMessageElement = createMessageElement(tempMessageData, chat);
    
    // 2. 把它添加到聊天界面上，让用户看到
    appendMessage(tempMessageData, chat, true); // true表示这是初始加载，不会触发进入动画
    
    // 3. 等待片刻，模拟AI的“反应时间”
    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 1500)); // 随机等待1.5-2.5秒

    // 4. 找到刚刚添加的临时气泡，并播放撤回动画
    const bubbleWrapper = document.querySelector(`.message-bubble[data-timestamp="${tempMessageData.timestamp}"]`)?.closest('.message-wrapper');
    if (bubbleWrapper) {
        bubbleWrapper.classList.add('recalled-animation');

        // 5. 在动画播放结束后，将其替换为真正的“已撤回”提示
        await new Promise(resolve => setTimeout(resolve, 300)); // 等待动画播完

        // 6. 最后，才把这条“已撤回”记录真正地存入数据库
        const recalledMessage = {
            role: 'assistant',
            senderName: msgData.name || chat.name,
            type: 'recalled_message',
            content: '对方撤回了一条消息',
            timestamp: tempMessageData.timestamp, // 使用临时消息的时间戳，保证顺序
            recalledData: { originalType: 'text', originalContent: msgData.content }
        };
        
        // 更新数据模型
        const msgIndex = chat.history.findIndex(m => m.timestamp === tempMessageData.timestamp);
        if (msgIndex > -1) {
            chat.history[msgIndex] = recalledMessage;
        } else {
            chat.history.push(recalledMessage);
        }
        
        // 替换DOM
        const placeholder = createMessageElement(recalledMessage, chat);
        if(document.body.contains(bubbleWrapper)) {
            bubbleWrapper.parentNode.replaceChild(placeholder, bubbleWrapper);
        }
    }
    
    continue; // 处理完这个动画后，继续处理AI返回的下一条指令
}
// ▲▲▲ 新 case 添加结束 ▲▲▲
                
                case 'text':
                    aiMessage = { ...baseMessage, content: String(msgData.content || msgData.message) };
                    break;
                case 'sticker':
                    aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: msgData.meaning || '' };
                    break;
                case 'ai_image':
                    aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description };
                    break;
                case 'voice_message':
                    aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                    break;
                case 'transfer':
                    aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || '我' };
                    break;
                
                case 'waimai_request':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'waimai_request',
                        productInfo: msgData.productInfo,
                        amount: msgData.amount,
                        status: 'pending',
                        countdownEndTime: Date.now() + 15 * 60 * 1000,
                    };
                    break;
                
                default:
                     console.warn("收到了未知的AI指令类型:", msgData.type);
                     break;
            }

            // 【核心修复】将渲染逻辑移出循环
            if (aiMessage) {
                // 1. 将新消息存入历史记录
                chat.history.push(aiMessage);

                if (!isViewingThisChat && !notificationShown) {
                    let notificationText;
                    switch (aiMessage.type) {
                        case 'transfer':
                            notificationText = `[收到一笔转账]`;
                            break;
                        case 'waimai_request':
                            notificationText = `[收到一个外卖代付请求]`;
                            break;
                        case 'ai_image':
                            notificationText = `[图片]`;
                            break;
                        case 'voice_message':
                            notificationText = `[语音]`;
                            break;
                        case 'sticker':
                            notificationText = aiMessage.meaning ? `[表情: ${aiMessage.meaning}]` : '[表情]';
                            break;
                        default:
                            notificationText = String(aiMessage.content || '');
                    }
                    const finalNotifText = chat.isGroup ? `${aiMessage.senderName}: ${notificationText}` : notificationText;
                    showNotification(chatId, finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? '...' : ''));
                    notificationShown = true; // 确保只通知一次
                }

    if (!isViewingThisChat) {
        // 如果用户不在当前聊天界面，就把这个聊天的未读数 +1
        chat.unreadCount = (chat.unreadCount || 0) + 1;
    }
                
                // 2. 只有在当前聊天界面时，才执行带动画的添加
                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    // 3. 【关键】在这里暂停一小会儿，给动画播放的时间
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
                }
            }
  }        

        if (callHasBeenHandled && videoCallState.isGroupCall) {
            videoCallState.isAwaitingResponse = false;
            if (videoCallState.participants.length > 0) {
                startVideoCall();
            } else {
                videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                showScreen('chat-interface-screen');
                alert('无人接听群聊邀请。');
            }
        }
        
        await db.chats.put(chat);

    } catch (error) {
        chat.history = chat.history.filter(msg => !msg.isTemporary);
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            chat.relationship.status = 'blocked_by_ai';
            await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
        } else {
            const errorContent = `[出错了: ${error.message}]`;
            const errorMessage = { role: 'assistant', content: errorContent, timestamp: Date.now() };
            if(chat.isGroup) errorMessage.senderName = "系统消息";
            chat.history.push(errorMessage);
        }
        
        await db.chats.put(chat);        
        videoCallState.isAwaitingResponse = false;

        if(document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId) {
            renderChatInterface(chatId);
        }
    } finally {
        // ★★★★★【核心修改4：在 finally 块中统一隐藏所有类型的提示】★★★★★
        if (chat.isGroup) {
            if (typingIndicator) {
                typingIndicator.style.display = 'none';
            }
        } else {
            if (chatHeaderTitle && state.chats[chatId]) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = state.chats[chatId].name;
                    chatHeaderTitle.classList.remove('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        }
        renderChatList();
    }
}

        async function sendSticker(sticker) { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: sticker.url, meaning: sticker.name, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('sticker-panel').classList.remove('visible'); }

        async function sendUserTransfer() { if (!state.activeChatId) return; const amountInput = document.getElementById('transfer-amount'); const noteInput = document.getElementById('transfer-note'); const amount = parseFloat(amountInput.value); const note = noteInput.value.trim(); if (isNaN(amount) || amount < 0 || amount > 9999) { alert('请输入有效的金额 (0 到 9999 之间)！'); return; } const chat = state.chats[state.activeChatId]; const senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我'; const receiverName = chat.isGroup ? '群聊' : chat.name; const msg = { role: 'user', type: 'transfer', amount: amount, note: note, senderName, receiverName, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('transfer-modal').classList.remove('visible'); amountInput.value = ''; noteInput.value = ''; }

        function enterSelectionMode(initialMsgTimestamp) { if (isSelectionMode) return; isSelectionMode = true; document.getElementById('chat-interface-screen').classList.add('selection-mode'); toggleMessageSelection(initialMsgTimestamp); }

        function exitSelectionMode() {
    cleanupWaimaiTimers(); // <--- 在这里添加这行代码
 if (!isSelectionMode) return; isSelectionMode = false; document.getElementById('chat-interface-screen').classList.remove('selection-mode'); selectedMessages.forEach(ts => { const bubble = document.querySelector(`.message-bubble[data-timestamp="${ts}"]`); if (bubble) bubble.classList.remove('selected'); }); selectedMessages.clear(); }

// ▼▼▼ 请用这个【最终简化版】替换旧的 toggleMessageSelection 函数 ▼▼▼
function toggleMessageSelection(timestamp) {
    // 【核心修正】选择器已简化，不再寻找已删除的 .recalled-message-placeholder
    const elementToSelect = document.querySelector(
        `.message-bubble[data-timestamp="${timestamp}"]`
    );

    if (!elementToSelect) return;

    if (selectedMessages.has(timestamp)) {
        selectedMessages.delete(timestamp);
        elementToSelect.classList.remove('selected');
    } else {
        selectedMessages.add(timestamp);
        elementToSelect.classList.add('selected');
    }
    
    document.getElementById('selection-count').textContent = `已选 ${selectedMessages.size} 条`;
    
    if (selectedMessages.size === 0) {
        exitSelectionMode();
    }
}
// ▲▲▲ 替换结束 ▲▲▲

        function addLongPressListener(element, callback) { let pressTimer; const startPress = (e) => { if(isSelectionMode) return; e.preventDefault(); pressTimer = window.setTimeout(() => callback(e), 500); }; const cancelPress = () => clearTimeout(pressTimer); element.addEventListener('mousedown', startPress); element.addEventListener('mouseup', cancelPress); element.addEventListener('mouseleave', cancelPress); element.addEventListener('touchstart', startPress, { passive: true }); element.addEventListener('touchend', cancelPress); element.addEventListener('touchmove', cancelPress); }

        async function handleListenTogetherClick() { const targetChatId = state.activeChatId; if (!targetChatId) return; if (!musicState.isActive) { startListenTogetherSession(targetChatId); return; } if (musicState.activeChatId === targetChatId) { document.getElementById('music-player-overlay').classList.add('visible'); } else { const oldChatName = state.chats[musicState.activeChatId]?.name || '未知'; const newChatName = state.chats[targetChatId]?.name || '当前'; const confirmed = await showCustomConfirm('切换听歌对象', `您正和「${oldChatName}」听歌。要结束并开始和「${newChatName}」的新会话吗？`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await endListenTogetherSession(true); await new Promise(resolve => setTimeout(resolve, 50)); startListenTogetherSession(targetChatId); } } }

        async function startListenTogetherSession(chatId) { const chat = state.chats[chatId]; if (!chat) return; musicState.totalElapsedTime = chat.musicData.totalTime || 0; musicState.isActive = true; musicState.activeChatId = chatId; if (musicState.playlist.length > 0) { musicState.currentIndex = 0; } else { musicState.currentIndex = -1; } if(musicState.timerId) clearInterval(musicState.timerId); musicState.timerId = setInterval(() => { if (musicState.isPlaying) { musicState.totalElapsedTime++; updateElapsedTimeDisplay(); } }, 1000); updatePlayerUI(); updatePlaylistUI(); document.getElementById('music-player-overlay').classList.add('visible'); }

async function endListenTogetherSession(saveState = true) {
    if (!musicState.isActive) return;
    const oldChatId = musicState.activeChatId;
    const cleanupLogic = async () => {
        if (musicState.timerId) clearInterval(musicState.timerId);
        if (musicState.isPlaying) audioPlayer.pause();
        if (saveState && oldChatId && state.chats[oldChatId]) {
            const chat = state.chats[oldChatId];
            chat.musicData.totalTime = musicState.totalElapsedTime;
            await db.chats.put(chat);
        }
        musicState.isActive = false;
        musicState.activeChatId = null;
        musicState.totalElapsedTime = 0;
        musicState.timerId = null;
        updateListenTogetherIcon(oldChatId, true);
    };
    closeMusicPlayerWithAnimation(cleanupLogic);
}

function returnToChat() {
    closeMusicPlayerWithAnimation();
}

        function updateListenTogetherIcon(chatId, forceReset = false) { const iconImg = document.querySelector('#listen-together-btn img'); if(!iconImg) return; if(forceReset || !musicState.isActive || musicState.activeChatId !== chatId) { iconImg.src = 'https://i.postimg.cc/8kYShvrJ/90-UI-2.png'; iconImg.className = ''; return; } iconImg.src = 'https://i.postimg.cc/D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png'; iconImg.classList.add('rotating'); if (musicState.isPlaying) iconImg.classList.remove('paused'); else iconImg.classList.add('paused'); }
        window.updateListenTogetherIconProxy = updateListenTogetherIcon;

        function updatePlayerUI() { updateListenTogetherIcon(musicState.activeChatId); updateElapsedTimeDisplay(); const titleEl = document.getElementById('music-player-song-title'); const artistEl = document.getElementById('music-player-artist'); const playPauseBtn = document.getElementById('music-play-pause-btn'); if (musicState.currentIndex > -1 && musicState.playlist.length > 0) { const track = musicState.playlist[musicState.currentIndex]; titleEl.textContent = track.name; artistEl.textContent = track.artist; } else { titleEl.textContent = '请添加歌曲'; artistEl.textContent = '...'; } playPauseBtn.textContent = musicState.isPlaying ? '❚❚' : '▶'; }

        function updateElapsedTimeDisplay() { const hours = (musicState.totalElapsedTime / 3600).toFixed(1); document.getElementById('music-time-counter').textContent = `已经一起听了${hours}小时`; }

function updatePlaylistUI() {
    const playlistBody = document.getElementById('playlist-body');
    playlistBody.innerHTML = '';
    if (musicState.playlist.length === 0) {
        playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">播放列表是空的~</p>';
        return;
    }
    musicState.playlist.forEach((track, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        if(index === musicState.currentIndex) item.classList.add('playing');
        item.innerHTML = `
            <div class="playlist-item-info">
                <div class="title">${track.name}</div>
                <div class="artist">${track.artist}</div>
            </div>
            <div class="playlist-item-actions">
                <span class="playlist-action-btn lyrics-btn" data-index="${index}">词</span>
                <span class="playlist-action-btn delete-track-btn" data-index="${index}">×</span>
            </div>
        `;
        item.querySelector('.playlist-item-info').addEventListener('click', () => playSong(index));
        playlistBody.appendChild(item);
    });
}

function playSong(index) {
    if (index < 0 || index >= musicState.playlist.length) return;
    musicState.currentIndex = index;
    const track = musicState.playlist[index];
    musicState.parsedLyrics = parseLRC(track.lrcContent || "");
    musicState.currentLyricIndex = -1;
    renderLyrics();
    if (track.isLocal && track.src instanceof Blob) {
        audioPlayer.src = URL.createObjectURL(track.src);
    } else if (!track.isLocal) {
        audioPlayer.src = track.src;
    } else {
        console.error('本地歌曲源错误:', track);
        return;
    }
    audioPlayer.play();
    updatePlaylistUI();
    updatePlayerUI();
    updateMusicProgressBar();
}

        function togglePlayPause() { if (audioPlayer.paused) { if (musicState.currentIndex === -1 && musicState.playlist.length > 0) { playSong(0); } else if (musicState.currentIndex > -1) { audioPlayer.play(); } } else { audioPlayer.pause(); } }

        function playNext() { if (musicState.playlist.length === 0) return; let nextIndex; switch(musicState.playMode) { case 'random': nextIndex = Math.floor(Math.random() * musicState.playlist.length); break; case 'single': playSong(musicState.currentIndex); return; case 'order': default: nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length; break; } playSong(nextIndex); }

        function playPrev() { if (musicState.playlist.length === 0) return; const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length; playSong(newIndex); }

        function changePlayMode() { const modes = ['order', 'random', 'single']; const currentModeIndex = modes.indexOf(musicState.playMode); musicState.playMode = modes[(currentModeIndex + 1) % modes.length]; document.getElementById('music-mode-btn').textContent = {'order': '顺序', 'random': '随机', 'single': '单曲'}[musicState.playMode]; }

        async function addSongFromURL() { const url = await showCustomPrompt("添加网络歌曲", "请输入歌曲的URL", "", "url"); if (!url) return; const name = await showCustomPrompt("歌曲信息", "请输入歌名"); if (!name) return; const artist = await showCustomPrompt("歌曲信息", "请输入歌手名"); if (!artist) return; musicState.playlist.push({ name, artist, src: url, isLocal: false }); await saveGlobalPlaylist(); updatePlaylistUI(); if(musicState.currentIndex === -1) { musicState.currentIndex = musicState.playlist.length - 1; updatePlayerUI(); } }

async function addSongFromLocal(event) {
    const files = event.target.files;
    if (!files.length) return;

    for (const file of files) {
        let name = file.name.replace(/\.[^/.]+$/, "");
        name = await showCustomPrompt("歌曲信息", "请输入歌名", name);
        if (name === null) continue;
        
        const artist = await showCustomPrompt("歌曲信息", "请输入歌手名", "未知歌手");
        if (artist === null) continue;

        let lrcContent = "";
        const wantLrc = await showCustomConfirm("导入歌词", `要为《${name}》导入歌词文件 (.lrc) 吗？`);
        if (wantLrc) {
            lrcContent = await new Promise(resolve => {
                const lrcInput = document.getElementById('lrc-upload-input');
                const lrcChangeHandler = (e) => {
                    const lrcFile = e.target.files[0];
                    if (lrcFile) {
                        const reader = new FileReader();
                        reader.onload = (readEvent) => resolve(readEvent.target.result);
                        reader.onerror = () => resolve("");
                        reader.readAsText(lrcFile);
                    } else {
                        resolve("");
                    }
                    lrcInput.removeEventListener('change', lrcChangeHandler);
                    lrcInput.value = '';
                };
                lrcInput.addEventListener('change', lrcChangeHandler);
                lrcInput.click();
            });
        }
        
        musicState.playlist.push({ 
            name, 
            artist, 
            src: file, 
            isLocal: true,
            lrcContent: lrcContent
        });
    }
    
    await saveGlobalPlaylist();
    updatePlaylistUI();
    if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
        musicState.currentIndex = 0;
        updatePlayerUI();
    }
    event.target.value = null;
}

        async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }

        const personaLibraryModal = document.getElementById('persona-library-modal');
        const personaEditorModal = document.getElementById('persona-editor-modal');
        const presetActionsModal = document.getElementById('preset-actions-modal');

        function openPersonaLibrary() { renderPersonaLibrary(); personaLibraryModal.classList.add('visible'); }

        function closePersonaLibrary() { personaLibraryModal.classList.remove('visible'); }

        function renderPersonaLibrary() { const grid = document.getElementById('persona-library-grid'); grid.innerHTML = ''; if (state.personaPresets.length === 0) { grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">空空如也~ 点击右上角"添加"来创建你的第一个人设预设吧！</p>'; return; } state.personaPresets.forEach(preset => { const item = document.createElement('div'); item.className = 'persona-preset-item'; item.style.backgroundImage = `url(${preset.avatar})`; item.dataset.presetId = preset.id; item.addEventListener('click', () => applyPersonaPreset(preset.id)); addLongPressListener(item, () => showPresetActions(preset.id)); grid.appendChild(item); }); }

        function showPresetActions(presetId) { editingPersonaPresetId = presetId; presetActionsModal.classList.add('visible'); }

        function hidePresetActions() { presetActionsModal.classList.remove('visible'); editingPersonaPresetId = null; }

        function applyPersonaPreset(presetId) { const preset = state.personaPresets.find(p => p.id === presetId); if (preset) { document.getElementById('my-avatar-preview').src = preset.avatar; document.getElementById('my-persona').value = preset.persona; } closePersonaLibrary(); }

        function openPersonaEditorForCreate() { editingPersonaPresetId = null; document.getElementById('persona-editor-title').textContent = '添加人设预设'; document.getElementById('preset-avatar-preview').src = defaultAvatar; document.getElementById('preset-persona-input').value = ''; personaEditorModal.classList.add('visible'); }

        function openPersonaEditorForEdit() { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (!preset) return; document.getElementById('persona-editor-title').textContent = '编辑人设预设'; document.getElementById('preset-avatar-preview').src = preset.avatar; document.getElementById('preset-persona-input').value = preset.persona; presetActionsModal.classList.remove('visible'); personaEditorModal.classList.add('visible'); }

        async function deletePersonaPreset() { const confirmed = await showCustomConfirm('删除预设', '确定要删除这个人设预设吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' }); if (confirmed && editingPersonaPresetId) { await db.personaPresets.delete(editingPersonaPresetId); state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId); hidePresetActions(); renderPersonaLibrary(); } }

        function closePersonaEditor() { personaEditorModal.classList.remove('visible'); editingPersonaPresetId = null; }

        async function savePersonaPreset() { const avatar = document.getElementById('preset-avatar-preview').src; const persona = document.getElementById('preset-persona-input').value.trim(); if (avatar === defaultAvatar && !persona) { alert("头像和人设不能都为空哦！"); return; } if (editingPersonaPresetId) { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (preset) { preset.avatar = avatar; preset.persona = persona; await db.personaPresets.put(preset); } } else { const newPreset = { id: 'preset_' + Date.now(), avatar: avatar, persona: persona }; await db.personaPresets.add(newPreset); state.personaPresets.push(newPreset); } renderPersonaLibrary(); closePersonaEditor(); }

        const batteryAlertModal = document.getElementById('battery-alert-modal');

        function showBatteryAlert(imageUrl, text) { clearTimeout(batteryAlertTimeout); document.getElementById('battery-alert-image').src = imageUrl; document.getElementById('battery-alert-text').textContent = text; batteryAlertModal.classList.add('visible'); const closeAlert = () => { batteryAlertModal.classList.remove('visible'); batteryAlertModal.removeEventListener('click', closeAlert); }; batteryAlertModal.addEventListener('click', closeAlert); batteryAlertTimeout = setTimeout(closeAlert, 2000); }

        function updateBatteryDisplay(battery) { const batteryContainer = document.getElementById('status-bar-battery'); const batteryLevelEl = batteryContainer.querySelector('.battery-level'); const batteryTextEl = batteryContainer.querySelector('.battery-text'); const level = Math.floor(battery.level * 100); batteryLevelEl.style.width = `${level}%`; batteryTextEl.textContent = `${level}%`; if (battery.charging) { batteryContainer.classList.add('charging'); } else { batteryContainer.classList.remove('charging'); } }

        function handleBatteryChange(battery) { updateBatteryDisplay(battery); const level = battery.level; if (!battery.charging) { if (level <= 0.4 && lastKnownBatteryLevel > 0.4 && !alertFlags.hasShown40) { showBatteryAlert('https://i.postimg.cc/T2yKJ0DV/40.jpg', '有点饿了，可以去找充电器惹'); alertFlags.hasShown40 = true; } if (level <= 0.2 && lastKnownBatteryLevel > 0.2 && !alertFlags.hasShown20) { showBatteryAlert('https://i.postimg.cc/qB9zbKs9/20.jpg', '赶紧的充电，要饿死了'); alertFlags.hasShown20 = true; } if (level <= 0.1 && lastKnownBatteryLevel > 0.1 && !alertFlags.hasShown10) { showBatteryAlert('https://i.postimg.cc/ThMMVfW4/10.jpg', '已阵亡，还有30秒爆炸'); alertFlags.hasShown10 = true; } } if (level > 0.4) alertFlags.hasShown40 = false; if (level > 0.2) alertFlags.hasShown20 = false; if (level > 0.1) alertFlags.hasShown10 = false; lastKnownBatteryLevel = level; }

        async function initBatteryManager() { if ('getBattery' in navigator) { try { const battery = await navigator.getBattery(); lastKnownBatteryLevel = battery.level; handleBatteryChange(battery); battery.addEventListener('levelchange', () => handleBatteryChange(battery)); battery.addEventListener('chargingchange', () => { handleBatteryChange(battery); if (battery.charging) { showBatteryAlert('https://i.postimg.cc/3NDQ0dWG/image.jpg', '窝爱泥，电量吃饱饱'); } }); } catch (err) { console.error("无法获取电池信息:", err); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } } else { console.log("浏览器不支持电池状态API。"); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } }

        async function renderAlbumList() {
            const albumGrid = document.getElementById('album-grid-page');
            if (!albumGrid) return;
            const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
            albumGrid.innerHTML = '';
            if (albums.length === 0) {
                albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">你还没有创建任何相册哦~</p>';
                return;
            }
            albums.forEach(album => {
                const albumItem = document.createElement('div');
                albumItem.className = 'album-item';
                albumItem.innerHTML = `
                    <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                    <div class="album-info">
                        <p class="album-name">${album.name}</p>
                        <p class="album-count">${album.photoCount || 0} 张</p>
                    </div>
                `;
                albumItem.addEventListener('click', () => {
                    openAlbum(album.id);
                });

                // ▼▼▼ 新增的核心代码就是这里 ▼▼▼
                addLongPressListener(albumItem, async () => {
                    const confirmed = await showCustomConfirm(
                        '删除相册',
                        `确定要删除相册《${album.name}》吗？此操作将同时删除相册内的所有照片，且无法恢复。`,
                        { confirmButtonClass: 'btn-danger' }
                    );

                    if (confirmed) {
                        // 1. 从照片表中删除该相册下的所有照片
                        await db.qzonePhotos.where('albumId').equals(album.id).delete();
                        
                        // 2. 从相册表中删除该相册本身
                        await db.qzoneAlbums.delete(album.id);
                        
                        // 3. 重新渲染相册列表
                        await renderAlbumList();
                        
                        alert('相册已成功删除。');
                    }
                });
                // ▲▲▲ 新增代码结束 ▲▲▲

                albumGrid.appendChild(albumItem);
            });
        }

        async function openAlbum(albumId) {
            state.activeAlbumId = albumId;
            await renderAlbumPhotosScreen();
            showScreen('album-photos-screen');
        }

        async function renderAlbumPhotosScreen() {
            if (!state.activeAlbumId) return;
            const photosGrid = document.getElementById('photos-grid-page');
            const headerTitle = document.getElementById('album-photos-title');
            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            if (!album) {
                console.error("找不到相册:", state.activeAlbumId);
                showScreen('album-screen');
                return;
            }
            headerTitle.textContent = album.name;
            const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
            photosGrid.innerHTML = '';
            if (photos.length === 0) {
                photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">这个相册还是空的，快上传第一张照片吧！</p>';
            } else {
                photos.forEach(photo => {
                    const photoItem = document.createElement('div');
                    photoItem.className = 'photo-item';
                    photoItem.innerHTML = `
                        <img src="${photo.url}" class="photo-thumb" alt="相册照片">
                        <button class="photo-delete-btn" data-photo-id="${photo.id}">×</button>
                    `;
                    photosGrid.appendChild(photoItem);
                });
            }
        }

// --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

/**
 * 打开图片查看器
 * @param {string} clickedPhotoUrl - 用户点击的那张照片的URL
 */
async function openPhotoViewer(clickedPhotoUrl) {
    if (!state.activeAlbumId) return;

    // 1. 从数据库获取当前相册的所有照片
    const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
    photoViewerState.photos = photosInAlbum.map(p => p.url);

    // 2. 找到被点击照片的索引
    photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
    if (photoViewerState.currentIndex === -1) return; // 如果找不到，则不打开

    // 3. 显示模态框并渲染第一张图
    document.getElementById('photo-viewer-modal').classList.add('visible');
    renderPhotoViewer();
    photoViewerState.isOpen = true;
}

/**
 * 根据当前状态渲染查看器内容（图片和按钮）
 */
function renderPhotoViewer() {
    if (photoViewerState.currentIndex === -1) return;

    const imageEl = document.getElementById('photo-viewer-image');
    const prevBtn = document.getElementById('photo-viewer-prev-btn');
    const nextBtn = document.getElementById('photo-viewer-next-btn');
    
    // 淡出效果
    imageEl.style.opacity = 0;

    setTimeout(() => {
        // 更新图片源
        imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];
        // 淡入效果
        imageEl.style.opacity = 1;
    }, 100); // 延迟一点点时间来触发CSS过渡

    // 更新按钮状态：如果是第一张，禁用“上一张”按钮
    prevBtn.disabled = photoViewerState.currentIndex === 0;
    // 如果是最后一张，禁用“下一张”按钮
    nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
}

/**
 * 显示下一张照片
 */
function showNextPhoto() {
    if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
        photoViewerState.currentIndex++;
        renderPhotoViewer();
    }
}

/**
 * 显示上一张照片
 */
function showPrevPhoto() {
    if (photoViewerState.currentIndex > 0) {
        photoViewerState.currentIndex--;
        renderPhotoViewer();
    }
}

/**
 * 关闭图片查看器
 */
function closePhotoViewer() {
    document.getElementById('photo-viewer-modal').classList.remove('visible');
    photoViewerState.isOpen = false;
    photoViewerState.photos = [];
    photoViewerState.currentIndex = -1;
    // 清空图片，避免下次打开时闪现旧图
    document.getElementById('photo-viewer-image').src = '';
}

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
        // ▼▼▼ 请将这个新函数粘贴到你的JS功能函数定义区 ▼▼▼
        
        /**
         * 更新动态小红点的显示
         * @param {number} count - 未读动态的数量
         */
        function updateUnreadIndicator(count) {
            unreadPostsCount = count;
            localStorage.setItem('unreadPostsCount', count); // 持久化存储

            // --- 更新底部导航栏的“动态”按钮 ---
            const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');
            
            const targetSpan = navItem.querySelector('span'); // 定位到文字 "动态"
            let indicator = navItem.querySelector('.unread-indicator');           

            if (count > 0) {
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'unread-indicator';
                                                           targetSpan.style.position = 'relative'; // 把相对定位加在 span 上
                    targetSpan.appendChild(indicator); // 把小红点作为 span 的子元素
                    
                }
                indicator.textContent = count > 99 ? '99+' : count;
                indicator.style.display = 'block';
            } else {
                if (indicator) {
                    indicator.style.display = 'none';
                }
            }

            // --- 更新聊天界面返回列表的按钮 ---
            const backBtn = document.getElementById('back-to-list-btn');
            let backBtnIndicator = backBtn.querySelector('.unread-indicator');

            if (count > 0) {
                if (!backBtnIndicator) {
                    backBtnIndicator = document.createElement('span');
                    backBtnIndicator.className = 'unread-indicator back-btn-indicator';
                    backBtn.style.position = 'relative'; // 确保能正确定位
                    backBtn.appendChild(backBtnIndicator);
                }
                // 返回键上的小红点通常不显示数字，只显示一个点
                backBtnIndicator.style.display = 'block';
            } else {
                if (backBtnIndicator) {
                    backBtnIndicator.style.display = 'none';
                }
            }
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 将这两个新函数粘贴到你的JS功能函数定义区 ▼▼▼
function startBackgroundSimulation() {
    if (simulationIntervalId) return;
    const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;
    // 将旧的固定间隔 45000 替换为动态获取
    simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000); 
}

function stopBackgroundSimulation() {
    if (simulationIntervalId) {
        clearInterval(simulationIntervalId);
        simulationIntervalId = null;
    }
}
// ▲▲▲ 粘贴结束 ▲▲▲

/**
 * 这是模拟器的“心跳”，每次定时器触发时运行
 */
function runBackgroundSimulationTick() {
    console.log("模拟器心跳 Tick...");
    if (!state.globalSettings.enableBackgroundActivity) {
        stopBackgroundSimulation();
        return;
    }
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (allSingleChats.length === 0) return;

    allSingleChats.forEach(chat => {
        // 【核心修正】将两种状态检查分离开，逻辑更清晰

        // 检查1：处理【被用户拉黑】的角色
        if (chat.relationship?.status === 'blocked_by_user') {
            const blockedTimestamp = chat.relationship.blockedTimestamp;
            // 安全检查：确保有拉黑时间戳
            if (!blockedTimestamp) {
                console.warn(`角色 "${chat.name}" 状态为拉黑，但缺少拉黑时间戳，跳过处理。`);
                return; // 跳过这个角色，继续下一个
            }

            const blockedDuration = Date.now() - blockedTimestamp;
            const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;

            console.log(`检查角色 "${chat.name}"：已拉黑 ${Math.round(blockedDuration/1000/60)}分钟，冷静期需 ${cooldownMilliseconds/1000/60}分钟。`); // 添加日志

            // 【核心修改】移除了随机概率，只要冷静期一过，就触发！
            if (blockedDuration > cooldownMilliseconds) {
                console.log(`角色 "${chat.name}" 的冷静期已过，触发“反思”并申请好友事件...`);
                
                // 【重要】为了防止在AI响应前重复触发，我们在触发后立刻更新状态
                chat.relationship.status = 'pending_system_reflection'; // 设置一个临时的、防止重复触发的状态
                
                triggerAiFriendApplication(chat.id);
            }
        }
        // 检查2：处理【好友关系】的正常后台活动
        else if (chat.relationship?.status === 'friend' && chat.id !== state.activeChatId) {
            // 这里的随机触发逻辑保持不变，因为我们不希望所有好友同时行动
            if (Math.random() < 0.20) {
                console.log(`角色 "${chat.name}" 被唤醒，准备独立行动...`);
                triggerInactiveAiAction(chat.id);
            }
        }
    });
}

async function triggerInactiveAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    const now = new Date();
    const currentTime = now.toLocaleTimeString('zh-CN', { hour: 'numeric', minute: 'numeric', hour12: true });
    const userNickname = state.qzoneSettings.nickname;

    const lastUserMessage = chat.history.filter(m => m.role === 'user' && !m.isHidden).slice(-1)[0];
    const lastAiMessage = chat.history.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];
    let recentContextSummary = "你们最近没有聊过天。";
    if (lastUserMessage) {
        recentContextSummary = `用户 (${userNickname}) 最后对你说：“${String(lastUserMessage.content).substring(0, 50)}...”。`;
    }
    if (lastAiMessage) {
        recentContextSummary += `\n你最后对用户说：“${String(lastAiMessage.content).substring(0, 50)}...”。`;
    }

    // ▼▼▼ 在这里添加下面的代码 ▼▼▼
    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
        }
    }
    // ▲▲▲ 添加结束 ▲▲▲

    const systemPrompt = `
# 你的任务
你现在扮演一个名为"${chat.name}"的角色。你已经有一段时间没有和用户（${userNickname}）互动了，现在你有机会【主动】做点什么，来表现你的个性和独立生活。这是一个秘密的、后台的独立行动。

# 你的可选行动 (请根据你的人设【选择一项】执行):
1.  **改变状态**: 去做点别的事情，然后给用户发条消息。
2.  **发布动态**: 分享你的心情或想法到“动态”区。
3.  **与动态互动**: 去看看别人的帖子并进行评论或点赞。
4.  **发起视频通话**: 如果你觉得时机合适，可以主动给用户打一个视频电话。

# 指令格式 (你的回复【必须】是包含一个对象的JSON数组):
-   **发消息+更新状态**: \`[{"type": "update_status", "status_text": "正在做的事", "is_busy": true}, {"type": "text", "content": "你想对用户说的话..."}]\`
-   **发说说**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容..."}]\`
- **发布文字图**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体描述..."}\`
-   **评论**: \`[{"type": "qzone_comment", "postId": 123, "commentText": "你的评论内容"}]\`
-   **点赞**: \`[{"type": "qzone_like", "postId": 456}]\`
-   **打视频**: \`[{"type": "video_call_request"}]\`

# 供你决策的参考信息：
-   **你的角色设定**: ${chat.settings.aiPersona}
${worldBookContent} // <--【核心】在这里注入世界书内容
-   **当前时间**: ${currentTime}
-   **你们最后的对话摘要**: ${recentContextSummary}
-   **【重要】最近的动态列表**: 这个列表会标注 **[你已点赞]** 或 **[你已评论]**。请**优先**与你**尚未互动过**的动态进行交流。`;

    // 【核心修复】在这里构建 messagesPayload
    const messagesPayload = [];
    messagesPayload.push({ role: 'system', content: systemPrompt });

try {
    const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(3).toArray();
    // 【核心修改】在这里插入过滤步骤
    const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);
    
    const aiName = chat.name;
    
    let dynamicContext = ""; 
    if (visiblePosts.length > 0) {
        let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
        for (const post of visiblePosts) {
                let authorName = post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || '一位朋友');
                let interactionStatus = '';
                if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已点赞]";
                if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [你已评论]";
                
                postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${(post.publicText || post.content || "图片动态").substring(0, 30)}..."${interactionStatus}\n`;
            }
            dynamicContext = postsContext;
        }

        // 【核心修复】将所有动态信息作为一条 user 消息发送
        messagesPayload.push({
            role: 'user',
            content: `[系统指令：请根据你在 system prompt 中读到的规则和以下最新信息，开始你的独立行动。]\n${dynamicContext}`
        });
        
        console.log("正在为后台活动发送API请求，Payload:", JSON.stringify(messagesPayload, null, 2)); // 添加日志，方便调试

            // 发送请求
            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesPayload,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) :  await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesPayload,
                    temperature: 0.9,
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API请求失败: ${response.status} - ${JSON.stringify(errorData)}`);
            }
            const data = await response.json();
            // 检查是否有有效回复
            if (!data.choices || data.choices.length === 0 || !data.choices[0].message.content) {
                console.warn(`API为空回或格式不正确，角色 "${chat.name}" 的本次后台活动跳过。`);
                return;
            }
            const responseArray = parseAiResponse(isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        
        // 后续处理AI返回指令的逻辑保持不变...
        for (const action of responseArray) {
            if (!action) continue;

            if (action.type === 'update_status' && action.status_text) {
                chat.status.text = action.status_text;
                chat.status.isBusy = action.is_busy || false;
                chat.status.lastUpdate = Date.now();
                await db.chats.put(chat);
                renderChatList();
            }
            if (action.type === 'text' && action.content) {
                const aiMessage = { role: 'assistant', content: String(action.content), timestamp: Date.now() };

chat.unreadCount = (chat.unreadCount || 0) + 1;
                chat.history.push(aiMessage);
                await db.chats.put(chat);
                showNotification(chatId, aiMessage.content);
                renderChatList();
                console.log(`后台活动: 角色 "${chat.name}" 主动发送了消息: ${aiMessage.content}`);
            }
if (action.type === 'qzone_post') {
    const newPost = { 
        type: action.postType, 
        content: action.content || '', 
        publicText: action.publicText || '', 
        hiddenContent: action.hiddenContent || '', 
        timestamp: Date.now(), 
        authorId: chatId, 
        authorGroupId: chat.groupId, // 【核心新增】记录作者的分组ID
        visibleGroupIds: null 
    };
    await db.qzonePosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`后台活动: 角色 "${chat.name}" 发布了动态`);
            } else if (action.type === 'qzone_comment') {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                    if (!post.comments) post.comments = [];
                    post.comments.push({ commenterName: chat.name, text: action.commentText, timestamp: Date.now() });
                    await db.qzonePosts.update(post.id, { comments: post.comments });
                    updateUnreadIndicator(unreadPostsCount + 1);
                    console.log(`后台活动: 角色 "${chat.name}" 评论了动态 #${post.id}`);
                }
            } else if (action.type === 'qzone_like') {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                    if (!post.likes) post.likes = [];
                    if (!post.likes.includes(chat.name)) {
                        post.likes.push(chat.name);
                        await db.qzonePosts.update(post.id, { likes: post.likes });
                        updateUnreadIndicator(unreadPostsCount + 1);
                        console.log(`后台活动: 角色 "${chat.name}" 点赞了动态 #${post.id}`);
                    }
                }
            } else if (action.type === 'video_call_request') {
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    videoCallState.isAwaitingResponse = true; 
                    state.activeChatId = chatId;
                    showIncomingCallModal();
                    console.log(`后台活动: 角色 "${chat.name}" 发起了视频通话请求`);
                }
            }
        }
    } catch (error) {
        console.error(`角色 "${chat.name}" 的独立行动失败:`, error);
    }
}

// ▼▼▼ 请用这个【终极修正版】函数，完整替换掉你旧的 applyScopedCss 函数 ▼▼▼

/**
 * 将用户自定义的CSS安全地应用到指定的作用域
 * @param {string} cssString 用户输入的原始CSS字符串
 * @param {string} scopeId 应用样式的作用域ID (例如 '#chat-messages' 或 '#settings-preview-area')
 * @param {string} styleTagId 要操作的 <style> 标签的ID
 */
function applyScopedCss(cssString, scopeId, styleTagId) {
    const styleTag = document.getElementById(styleTagId);
    if (!styleTag) return;
    
    if (!cssString || cssString.trim() === '') {
        styleTag.innerHTML = '';
        return;
    }
    
    // 增强作用域处理函数 - 专门解决.user和.ai样式冲突问题
    const scopedCss = cssString
        .replace(/\s*\.message-bubble\.user\s+([^{]+\{)/g, `${scopeId} .message-bubble.user $1`)
        .replace(/\s*\.message-bubble\.ai\s+([^{]+\{)/g, `${scopeId} .message-bubble.ai $1`)
        .replace(/\s*\.message-bubble\s+([^{]+\{)/g, `${scopeId} .message-bubble $1`);
    
    styleTag.innerHTML = scopedCss;
}

// ▼▼▼ 请用这个【修正版】函数，完整替换掉旧的 updateSettingsPreview 函数 ▼▼▼

function updateSettingsPreview() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const previewArea = document.getElementById('settings-preview-area');
    if (!previewArea) return;

    // 1. 获取当前设置的值
    const selectedTheme = document.querySelector('input[name="theme-select"]:checked')?.value || 'default';
    const fontSize = document.getElementById('font-size-slider').value;
    const customCss = document.getElementById('custom-css-input').value;
    const background = chat.settings.background; // 直接获取背景设置

    // 2. 更新预览区的基本样式
    previewArea.dataset.theme = selectedTheme;
    previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);
    
    // --- 【核心修正】直接更新预览区的背景样式 ---
    if (background && background.startsWith('data:image')) {
        previewArea.style.backgroundImage = `url(${background})`;
        previewArea.style.backgroundColor = 'transparent'; // 如果有图片，背景色设为透明
    } else {
        previewArea.style.backgroundImage = 'none'; // 如果没有图片，移除图片背景
        // 如果背景是颜色值或渐变（非图片），则直接应用
        previewArea.style.background = background || '#f0f2f5';
    }

    // 3. 渲染模拟气泡
    previewArea.innerHTML = ''; 

    // 创建“对方”的气泡
    // 注意：我们将一个虚拟的 timestamp 传入，以防有CSS依赖于它
    const aiMsg = { role: 'ai', content: '对方消息预览', timestamp: 1, senderName: chat.name };
    const aiBubble = createMessageElement(aiMsg, chat);
    if(aiBubble) previewArea.appendChild(aiBubble);

    // 创建“我”的气泡
    const userMsg = { role: 'user', content: '我的消息预览', timestamp: 2 };
    const userBubble = createMessageElement(userMsg, chat);
    if(userBubble) previewArea.appendChild(userBubble);
    
    // 4. 应用自定义CSS到预览区
    applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请将这些【新函数】粘贴到JS功能函数定义区 ▼▼▼

async function openGroupManager() {
    await renderGroupList();
    document.getElementById('group-management-modal').classList.add('visible');
}

async function renderGroupList() {
    const listEl = document.getElementById('existing-groups-list');
    const groups = await db.qzoneGroups.toArray();
    listEl.innerHTML = '';
    if (groups.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分组</p>';
    }
    groups.forEach(group => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `
            <span class="group-name">${group.name}</span>
            <span class="delete-group-btn" data-id="${group.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

// ▼▼▼ 请用这个【修正后】的函数，完整替换旧的 addNewGroup 函数 ▼▼▼
async function addNewGroup() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分组名不能为空！');
        return;
    }

    // 【核心修正】在添加前，先检查分组名是否已存在
    const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
    if (existingGroup) {
        alert(`分组 "${name}" 已经存在了，换个名字吧！`);
        return;
    }
    // 【修正结束】

    await db.qzoneGroups.add({ name });
    input.value = '';
    await renderGroupList();
}
// ▲▲▲ 替换结束 ▲▲▲

async function deleteGroup(groupId) {
    const confirmed = await showCustomConfirm('确认删除', '删除分组后，该组内的好友将变为“未分组”。确定要删除吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.qzoneGroups.delete(groupId);
        // 将属于该分组的好友的 groupId 设为 null
        const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
        for (const chat of chatsToUpdate) {
            chat.groupId = null;
            await db.chats.put(chat);
            if(state.chats[chat.id]) state.chats[chat.id].groupId = null;
        }
        await renderGroupList();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

/**
 * 当长按消息时，显示操作菜单
 * @param {number} timestamp - 被长按消息的时间戳
 */
function showMessageActions(timestamp) {
    // 如果已经在多选模式，则不弹出菜单
    if (isSelectionMode) return;
    
    activeMessageTimestamp = timestamp;
    document.getElementById('message-actions-modal').classList.add('visible');
}

/**
 * 隐藏消息操作菜单
 */
function hideMessageActions() {
    document.getElementById('message-actions-modal').classList.remove('visible');
    activeMessageTimestamp = null;
}

// ▼▼▼ 用这个【已更新】的版本，替换旧的 openMessageEditor 函数 ▼▼▼
async function openMessageEditor() {
    if (!activeMessageTimestamp) return;

    const timestampToEdit = activeMessageTimestamp;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideMessageActions(); 

    let contentForEditing;
    // 【核心修正】将 share_link 也加入特殊类型判断
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer', 'share_link'].includes(message.type);

    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content; 
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        } 
        // 【核心修正】处理分享链接类型的消息
        else if (message.type === 'share_link') {
            fullMessageObject.title = message.title;
            fullMessageObject.description = message.description;
            fullMessageObject.source_name = message.source_name;
            fullMessageObject.content = message.content;
        }
        contentForEditing = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        contentForEditing = JSON.stringify(message.content, null, 2);
    } else {
        contentForEditing = message.content;
    }

    // 【核心修改1】在这里添加 'link' 模板
    const templates = {
        voice: { type: 'voice_message', content: '在这里输入语音内容' },
        image: { type: 'ai_image', description: '在这里输入图片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一点心意' },
        link: { type: 'share_link', title: '文章标题', description: '文章摘要...', source_name: '来源网站', content: '文章完整内容...' }
    };

    // 【核心修改2】在这里添加新的“链接”按钮
    const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
        </div>
    `;

    const newContent = await showCustomPrompt(
        '编辑消息', 
        '在此修改，或点击上方按钮使用格式模板...',
        contentForEditing, 
        'textarea',
        helpersHtml
    );

    if (newContent !== null) {
        // 【核心修正】这里调用的应该是 saveEditedMessage，而不是 saveAdvancedEditor
        await saveEditedMessage(timestampToEdit, newContent, true);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 复制消息的文本内容到剪贴板
 */
async function copyMessageContent() {
    if (!activeMessageTimestamp) return;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    let textToCopy;
    if (typeof message.content === 'object') {
        textToCopy = JSON.stringify(message.content);
    } else {
        textToCopy = String(message.content);
    }

    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('复制成功', '消息内容已复制到剪贴板。');
    } catch (err) {
        await showCustomAlert('复制失败', '无法访问剪贴板。');
    }
    
    hideMessageActions();
}

// ▼▼▼ 用这个【已更新】的版本，替换旧的 createMessageEditorBlock 函数 ▼▼▼
/**
 * 创建一个可编辑的消息块（包含文本框、格式助手和删除按钮）
 * @param {string} initialContent - 文本框的初始内容
 * @returns {HTMLElement} - 创建好的DOM元素
 */
function createMessageEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'message-editor-block';

    // 【核心修改1】在这里添加 'link' 模板
    const templates = {
        voice: { type: 'voice_message', content: '在这里输入语音内容' },
        image: { type: 'ai_image', description: '在这里输入图片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一点心意' },
        link: { type: 'share_link', title: '文章标题', description: '文章摘要...', source_name: '来源网站', content: '文章完整内容...' }
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="删除此条">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <!-- 【核心修改2】在这里添加新的“链接”按钮 -->
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
        </div>
    `;

    // 绑定删除按钮事件
    block.querySelector('.delete-block-btn').addEventListener('click', () => {
        // 确保至少保留一个编辑块
        if (document.querySelectorAll('.message-editor-block').length > 1) {
            block.remove();
        } else {
            alert('至少需要保留一条消息。');
        }
    });

    // 绑定格式助手按钮事件
    block.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const templateStr = btn.dataset.template;
            const textarea = block.querySelector('textarea');
            if (templateStr && textarea) {
                try {
                    const templateObj = JSON.parse(templateStr);
                    textarea.value = JSON.stringify(templateObj, null, 2);
                    textarea.focus();
                } catch(e) { console.error("解析格式模板失败:", e); }
            }
        });
    });

    return block;
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新升级版】请用此函数完整替换旧的 openAdvancedMessageEditor ▼▼▼
/**
 * 打开全新的、可视化的多消息编辑器，并动态绑定其所有按钮事件
 */
function openAdvancedMessageEditor() {
    if (!activeMessageTimestamp) return;

    // 1. 【核心】在关闭旧菜单前，将需要的时间戳捕获到局部变量中
    const timestampToEdit = activeMessageTimestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    // 2. 现在可以安全地关闭旧菜单了，因为它不会影响我们的局部变量
    hideMessageActions(); 

    const editorModal = document.getElementById('message-editor-modal');
    const editorContainer = document.getElementById('message-editor-container');
    editorContainer.innerHTML = ''; 

    // 3. 准备初始内容
    let initialContent;
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer'].includes(message.type);
    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content;
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        }
        initialContent = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        initialContent = JSON.stringify(message.content, null, 2);
    } else {
        initialContent = message.content;
    }

    const firstBlock = createMessageEditorBlock(initialContent);
    editorContainer.appendChild(firstBlock);

    // 4. 【核心】动态绑定所有控制按钮的事件
    // 为了防止事件重复绑定，我们使用克隆节点的方法来清除旧监听器
    const addBtn = document.getElementById('add-message-editor-block-btn');
    const newAddBtn = addBtn.cloneNode(true);
    addBtn.parentNode.replaceChild(newAddBtn, addBtn);
    newAddBtn.addEventListener('click', () => {
        const newBlock = createMessageEditorBlock();
        editorContainer.appendChild(newBlock);
        newBlock.querySelector('textarea').focus();
    });

    const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
    const newCancelBtn = cancelBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    newCancelBtn.addEventListener('click', () => {
        editorModal.classList.remove('visible');
    });

    const saveBtn = document.getElementById('save-advanced-editor-btn');
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    // 将捕获到的时间戳，直接绑定给这一次的保存点击事件
    newSaveBtn.addEventListener('click', () => {
        saveEditedMessage(timestampToEdit); 
    });

    // 5. 最后，显示模态框
    editorModal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 解析编辑后的文本，并返回一个标准化的消息片段对象
 * @param {string} text - 用户在编辑框中输入的文本
 * @returns {object} - 一个包含 type, content, 等属性的对象
 */
function parseEditedContent(text) {
    const trimmedText = text.trim();

    // 1. 尝试解析为JSON对象（用于修复语音、转账等格式）
    if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
        try {
            const parsed = JSON.parse(trimmedText);
            // 必须包含 type 属性才认为是有效格式
            if (parsed.type) {
                return parsed;
            }
        } catch (e) { /* 解析失败，继续往下走 */ }
    }
    
    // 2. 尝试解析为表情包
    if (STICKER_REGEX.test(trimmedText)) {
        // 对于编辑的表情，我们暂时无法知道其`meaning`，所以只存URL
        return { type: 'sticker', content: trimmedText };
    }

    // 3. 否则，视为普通文本消息
    return { type: 'text', content: trimmedText };
}


// ▼▼▼ 请用这个【已彻底修复】的函数，完整替换你现有的 saveEditedMessage 函数 ▼▼▼

async function saveEditedMessage(timestamp, simpleContent = null) {
    if (!timestamp) return;

    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    let newMessages = [];

    // 判断是来自高级编辑器还是简单编辑器
    if (simpleContent !== null) {
        // --- 来自简单编辑器 ---
        const rawContent = simpleContent.trim();
        if (rawContent) {
            const parsedResult = parseEditedContent(rawContent);
            const newMessage = {
                role: chat.history[messageIndex].role,
                senderName: chat.history[messageIndex].senderName,
                // 注意：这里我们暂时不设置时间戳
                content: parsedResult.content || '',
            };
            if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
            if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
            if (parsedResult.amount) newMessage.amount = parsedResult.amount;
            if (parsedResult.note) newMessage.note = parsedResult.note;
            if (parsedResult.title) newMessage.title = parsedResult.title;
            if (parsedResult.description) newMessage.description = parsedResult.description;
            if (parsedResult.source_name) newMessage.source_name = parsedResult.source_name;
            if (parsedResult.description && parsedResult.type === 'ai_image') {
                 newMessage.content = parsedResult.description;
            }

            newMessages.push(newMessage);
        }
    } else {
        // --- 来自高级编辑器 ---
        const editorContainer = document.getElementById('message-editor-container');
        const editorBlocks = editorContainer.querySelectorAll('.message-editor-block');

        for (const block of editorBlocks) {
            const textarea = block.querySelector('textarea');
            const rawContent = textarea.value.trim();
            if (!rawContent) continue;

            const parsedResult = parseEditedContent(rawContent);
            const newMessage = {
                role: chat.history[messageIndex].role,
                senderName: chat.history[messageIndex].senderName,
                // 同样，这里我们先不分配时间戳
                content: parsedResult.content || '',
            };
            
            if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
            if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
            if (parsedResult.amount) newMessage.amount = parsedResult.amount;
            if (parsedResult.note) newMessage.note = parsedResult.note;
            if (parsedResult.title) newMessage.title = parsedResult.title;
            if (parsedResult.description) newMessage.description = parsedResult.description;
            if (parsedResult.source_name) newMessage.source_name = parsedResult.source_name;
            if (parsedResult.description && parsedResult.type === 'ai_image') {
                 newMessage.content = parsedResult.description;
            }

            newMessages.push(newMessage);
        }
    }
    
    if (newMessages.length === 0) {
        document.getElementById('message-editor-modal').classList.remove('visible');
        return; // 如果是空消息，直接返回，不执行删除操作
    }

    // ★★★★★【核心修复逻辑就在这里】★★★★★

    // 1. 使用 splice 将旧消息替换为新消息（此时新消息还没有时间戳）
    chat.history.splice(messageIndex, 1, ...newMessages);

    // 2. 确定重新分配时间戳的起点
    // 我们从被编辑的消息的原始时间戳开始
    let reassignTimestamp = timestamp;

    // 3. 从被修改的位置开始，遍历所有后续的消息
    for (let i = messageIndex; i < chat.history.length; i++) {
        // 4. 为每一条消息（包括新插入的）分配一个新的、唯一的、连续的时间戳
        chat.history[i].timestamp = reassignTimestamp;

        // 5. 将时间戳+1，为下一条消息做准备
        reassignTimestamp++; 
    }
    // ★★★★★【修复结束】★★★★★

    await db.chats.put(chat);

    // 关闭可能打开的模态框并刷新UI
    document.getElementById('message-editor-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    await showCustomAlert('成功', '消息已更新！');
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

/**
 * 当点击“…”时，显示动态操作菜单
 * @param {number} postId - 被操作的动态的ID
 */
function showPostActions(postId) {
    activePostId = postId;
    document.getElementById('post-actions-modal').classList.add('visible');
}

/**
 * 隐藏动态操作菜单
 */
function hidePostActions() {
    document.getElementById('post-actions-modal').classList.remove('visible');
    activePostId = null;
}

/**
 * 打开动态编辑器
 */
async function openPostEditor() {
    if (!activePostId) return;

    const postIdToEdit = activePostId;
    const post = await db.qzonePosts.get(postIdToEdit);
    if (!post) return;

    hidePostActions();

    // 忠于原文：构建出最原始的文本形态供编辑
    let contentForEditing;
    if (post.type === 'shuoshuo') {
        contentForEditing = post.content;
    } else {
        // 对于图片和文字图，我们构建一个包含所有信息的对象
        const postObject = {
            type: post.type,
            publicText: post.publicText || '',
        };
        if (post.type === 'image_post') {
            postObject.imageUrl = post.imageUrl;
            postObject.imageDescription = post.imageDescription;
        } else if (post.type === 'text_image') {
            postObject.hiddenContent = post.hiddenContent;
        }
        contentForEditing = JSON.stringify(postObject, null, 2);
    }
    
    // 构建格式助手按钮
    const templates = {
        shuoshuo: "在这里输入说说的内容...", // 对于说说，我们直接替换为纯文本
        image: { type: 'image_post', publicText: '', imageUrl: 'https://...', imageDescription: '' },
        text_image: { type: 'text_image', publicText: '', hiddenContent: '' }
    };
    
    const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-type="text">说说</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片动态</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.text_image)}'>文字图</button>
        </div>
    `;

    const newContent = await showCustomPrompt(
        '编辑动态',
        '在此修改内容...',
        contentForEditing,
        'textarea',
        helpersHtml
    );
    
    // 【特殊处理】为说说的格式助手按钮添加不同的行为
    // 我们需要在模态框出现后，再给它绑定事件
    setTimeout(() => {
        const shuoshuoBtn = document.querySelector('#custom-modal-body .format-btn[data-type="text"]');
        if(shuoshuoBtn) {
            shuoshuoBtn.addEventListener('click', () => {
                const input = document.getElementById('custom-prompt-input');
                input.value = templates.shuoshuo;
                input.focus();
            });
        }
    }, 100);

    if (newContent !== null) {
        await saveEditedPost(postIdToEdit, newContent);
    }
}

/**
 * 保存编辑后的动态
 * @param {number} postId - 要保存的动态ID
 * @param {string} newRawContent - 从编辑器获取的新内容
 */
async function saveEditedPost(postId, newRawContent) {
    const post = await db.qzonePosts.get(postId);
    if (!post) return;

    const trimmedContent = newRawContent.trim();
    
    // 尝试解析为JSON，如果失败，则认为是纯文本（说说）
    try {
        const parsed = JSON.parse(trimmedContent);
        // 更新帖子属性
        post.type = parsed.type || 'image_post';
        post.publicText = parsed.publicText || '';
        post.imageUrl = parsed.imageUrl || '';
        post.imageDescription = parsed.imageDescription || '';
        post.hiddenContent = parsed.hiddenContent || '';
        post.content = ''; // 清空旧的说说内容字段
    } catch (e) {
        // 解析失败，认为是说说
        post.type = 'shuoshuo';
        post.content = trimmedContent;
        // 清空其他类型的字段
        post.publicText = '';
        post.imageUrl = '';
        post.imageDescription = '';
        post.hiddenContent = '';
    }
    
    await db.qzonePosts.put(post);
    await renderQzonePosts(); // 重新渲染列表
    await showCustomAlert('成功', '动态已更新！');
}

/**
 * 复制动态内容
 */
async function copyPostContent() {
    if (!activePostId) return;
    const post = await db.qzonePosts.get(activePostId);
    if (!post) return;
    
    let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "（无文字内容）";
    
    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('复制成功', '动态内容已复制到剪贴板。');
    } catch (err) {
        await showCustomAlert('复制失败', '无法访问剪贴板。');
    }
    
    hidePostActions();
}

// ▼▼▼ 【全新】创建群聊与拉人功能核心函数 ▼▼▼
let selectedContacts = new Set();

async function openContactPickerForGroupCreate() {
    selectedContacts.clear(); // 清空上次选择

    // 【核心修复】在这里，我们为“完成”按钮明确绑定“创建群聊”的功能
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆节点技巧，清除掉之前可能绑定的任何其他事件（比如“添加成员”）
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    // 重新绑定正确的“创建群聊”函数
    newConfirmBtn.addEventListener('click', handleCreateGroup);

    await renderContactPicker();
    showScreen('contact-picker-screen');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 渲染联系人选择列表
 */
async function renderContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';

    // 只选择单聊角色作为群成员候选
    const contacts = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">还没有可以拉进群的联系人哦~</p>';
        return;
    }

    contacts.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id;
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name}</span>
        `;
        listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
}

/**
 * 更新“完成”按钮的计数
 */
function updateContactPickerConfirmButton() {
    const btn = document.getElementById('confirm-contact-picker-btn');
    btn.textContent = `完成(${selectedContacts.size})`;
    btn.disabled = selectedContacts.size < 2; // 至少需要2个人才能创建群聊
}

/**
 * 【重构版】处理创建群聊的最终逻辑
 */
async function handleCreateGroup() {
    if (selectedContacts.size < 2) {
        alert("创建群聊至少需要选择2个联系人。");
        return;
    }

    const groupName = await showCustomPrompt('设置群名', '请输入群聊的名字', '我们的群聊');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    
    // 遍历选中的联系人ID
    for (const contactId of selectedContacts) {
        const contactChat = state.chats[contactId];
        if (contactChat) {
            // ★★★【核心重构】★★★
            // 我们现在同时存储角色的“本名”和“群昵称”
            members.push({
                id: contactId, 
                originalName: contactChat.name,   // 角色的“本名”，用于AI识别
                groupNickname: contactChat.name, // 角色的“群昵称”，用于显示和修改，初始值和本名相同
                avatar: contactChat.settings.aiAvatar || defaultAvatar,
                persona: contactChat.settings.aiPersona,
                avatarFrame: contactChat.settings.aiAvatarFrame || ''
            });
        }
    }

    const newGroupChat = {
        id: newChatId,
        name: groupName.trim(),
        isGroup: true,
        members: members,
        settings: {
            myPersona: '我是谁呀。',
            myNickname: '我',
            maxMemory: 10,
            groupAvatar: defaultGroupAvatar,
            myAvatar: defaultMyGroupAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
        },
        history: [],
        musicData: { totalTime: 0 }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);
    
    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId); 
}

// ▼▼▼ 【全新】群成员管理核心函数 ▼▼▼

/**
 * 打开群成员管理屏幕
 */
function openMemberManagementScreen() {
    if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
    renderMemberManagementList();
    showScreen('member-management-screen');
}

function renderMemberManagementList() {
    const listEl = document.getElementById('member-management-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    chat.members.forEach(member => {
        const item = document.createElement('div');
        item.className = 'member-management-item';
        // 【核心修正】在这里，我们将显示的名称从 member.name 改为 member.groupNickname
        item.innerHTML = `
            <img src="${member.avatar}" class="avatar">
            <span class="name">${member.groupNickname}</span>
            <button class="remove-member-btn" data-member-id="${member.id}" title="移出群聊">-</button>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 从群聊中移除一个成员
 * @param {string} memberId - 要移除的成员ID
 */
async function removeMemberFromGroup(memberId) {
    const chat = state.chats[state.activeChatId];
    const memberIndex = chat.members.findIndex(m => m.id === memberId);
    
    if (memberIndex === -1) return;
    
    // 安全检查，群聊至少保留2人
    if (chat.members.length <= 2) {
        alert("群聊人数不能少于2人。");
        return;
    }
    
const memberName = chat.members[memberIndex].groupNickname; // <-- 修复：使用 groupNickname
    const confirmed = await showCustomConfirm(
        '移出成员',
        `确定要将“${memberName}”移出群聊吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.members.splice(memberIndex, 1);
        await db.chats.put(chat);
        renderMemberManagementList(); // 刷新成员管理列表
        document.getElementById('chat-settings-btn').click(); // 【核心修正】模拟点击设置按钮，强制刷新整个弹窗
    }
}

/**
 * 打开联系人选择器，用于拉人入群
 */
async function openContactPickerForAddMember() {
    selectedContacts.clear(); // 清空选择
    
    const chat = state.chats[state.activeChatId];
    const existingMemberIds = new Set(chat.members.map(m => m.id));

    // 渲染联系人列表，并自动排除已在群内的成员
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    const contacts = Object.values(state.chats).filter(c => !c.isGroup && !existingMemberIds.has(c.id));

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">没有更多可以邀请的好友了。</p>';
        document.getElementById('confirm-contact-picker-btn').style.display = 'none'; // 没有人可选，隐藏完成按钮
    } else {
        document.getElementById('confirm-contact-picker-btn').style.display = 'block';
        contacts.forEach(contact => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.dataset.contactId = contact.id;
            item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${contact.name}</span>
            `;
            listEl.appendChild(item);
        });
    }

    // 更新按钮状态并显示屏幕
    updateContactPickerConfirmButton();
    showScreen('contact-picker-screen');
}

/**
 * 处理将选中的联系人加入群聊的逻辑
 */
async function handleAddMembersToGroup() {
    if (selectedContacts.size === 0) {
        alert("请至少选择一个要添加的联系人。");
        return;
    }
    
    const chat = state.chats[state.activeChatId];

    for (const contactId of selectedContacts) {
        const contactChat = state.chats[contactId];
        if (contactChat) {
chat.members.push({
    id: contactId,
    originalName: contactChat.name,  // <-- 修复1：使用 'originalName' 存储本名
    groupNickname: contactChat.name, // <-- 修复2：同时创建一个初始的 'groupNickname'
    avatar: contactChat.settings.aiAvatar || defaultAvatar,
    persona: contactChat.settings.aiPersona,
    avatarFrame: contactChat.settings.aiAvatarFrame || ''
});
        }
    }

    await db.chats.put(chat);
    openMemberManagementScreen(); // 返回到群成员管理界面
    renderGroupMemberSettings(chat.members); // 同时更新聊天设置里的头像
}

/**
 * 【重构版】在群聊中创建一个全新的虚拟成员
 */
async function createNewMemberInGroup() {
    const name = await showCustomPrompt('创建新成员', '请输入新成员的名字 (这将是TA的“本名”，不可更改)');
    if (!name || !name.trim()) return;

    // 检查本名是否已在群内存在
    const chat = state.chats[state.activeChatId];
    if (chat.members.some(m => m.originalName === name.trim())) {
        alert(`错误：群内已存在名为“${name.trim()}”的成员！`);
        return;
    }

    const persona = await showCustomPrompt('设置人设', `请输入“${name}”的人设`, '', 'textarea');
    if (persona === null) return; 

    // ★★★【核心重构】★★★
    // 为新创建的NPC也建立双重命名机制
    const newMember = {
        id: 'npc_' + Date.now(),
        originalName: name.trim(),   // 新成员的“本名”
        groupNickname: name.trim(), // 新成员的初始“群昵称”
        avatar: defaultGroupMemberAvatar,
        persona: persona,
        avatarFrame: ''
    };

    chat.members.push(newMember);
    await db.chats.put(chat);

    renderMemberManagementList();
    renderGroupMemberSettings(chat.members); 

    alert(`新成员“${name}”已成功加入群聊！`);
}

// ▼▼▼ 【全新】外卖请求倒计时函数 ▼▼▼
function startWaimaiCountdown(element, endTime) {
    const timerId = setInterval(() => {
        const now = Date.now();
        const distance = endTime - now;

        if (distance < 0) {
            clearInterval(timerId);
            element.innerHTML = '<span>已</span><span>超</span><span>时</span>';
            return;
        }

        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
        
        const minStr = String(minutes).padStart(2, '0');
        const secStr = String(seconds).padStart(2, '0');

        element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
    }, 1000);
    return timerId;
}

function cleanupWaimaiTimers() {
    for (const timestamp in waimaiTimers) {
        clearInterval(waimaiTimers[timestamp]);
    }
    waimaiTimers = {};
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. 更新原始消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 【核心修正】记录支付者，并构建对AI更清晰的系统消息
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 记录是用户付的钱
        systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
    } else {
        systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
    }

    // 2. 创建一条新的、对用户隐藏的系统消息，告知AI结果
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 3. 保存更新到数据库并刷新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);  
}

let videoCallState = {
    isActive: false,       
    isAwaitingResponse: false, 
    isGroupCall: false,      
    activeChatId: null,    
    initiator: null,       
    startTime: null,       
    participants: [],      
    isUserParticipating: true,
    // --- 【核心新增】---
    callHistory: [], // 用于存储通话中的对话历史
    preCallContext: "" // 用于存储通话前的聊天摘要
};

let callTimerInterval = null; // 用于存储计时器的ID

/**
 * 【总入口】用户点击“发起视频通话”或“发起群视频”按钮
 */
async function handleInitiateCall() {
    if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;

    const chat = state.chats[state.activeChatId];
    videoCallState.isGroupCall = chat.isGroup;
    videoCallState.isAwaitingResponse = true;
    videoCallState.initiator = 'user';
    videoCallState.activeChatId = chat.id;
    videoCallState.isUserParticipating = true; // 用户自己发起的，当然是参与者

    // 根据是单聊还是群聊，显示不同的呼叫界面
    if (chat.isGroup) {
        document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || '我';
    } else {
        document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.name;
    }
    document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "正在呼叫所有成员..." : "正在呼叫...";
    showScreen('outgoing-call-screen');
    
    // 准备并发送系统消息给AI
    const requestMessage = {
        role: 'system',
        content: chat.isGroup 
            ? `[系统提示：用户 (${chat.settings.myNickname || '我'}) 发起了群视频通话请求。请你们各自决策，并使用 "group_call_response" 指令，设置 "decision" 为 "join" 或 "decline" 来回应。]`
            : `[系统提示：用户向你发起了视频通话请求。请根据你的人设，使用 "video_call_response" 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应。]`,
        timestamp: Date.now(),
        isHidden: true,
    };
    chat.history.push(requestMessage);
    await db.chats.put(chat);
    
    // 触发AI响应
    await triggerAiResponse();
}


function startVideoCall() {
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    videoCallState.isActive = true;
    videoCallState.isAwaitingResponse = false;
    videoCallState.startTime = Date.now();
    videoCallState.callHistory = []; // 【新增】清空上一次通话的历史

    // --- 【核心新增：抓取通话前上下文】---
    const preCallHistory = chat.history.slice(-10); // 取最后10条作为上下文
    videoCallState.preCallContext = preCallHistory.map(msg => {
        const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
    }).join('\n');
    // --- 新增结束 ---

    updateParticipantAvatars(); 
    
    document.getElementById('video-call-main').innerHTML = `<em>${videoCallState.isGroupCall ? '群聊已建立...' : '正在接通...'}</em>`;
    showScreen('video-call-screen');

    document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
    document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';

    if (callTimerInterval) clearInterval(callTimerInterval);
    callTimerInterval = setInterval(updateCallTimer, 1000);
    updateCallTimer();

    triggerAiInCallAction();
}

/**
 * 【核心】结束视频通话
 */
// ▼▼▼ 用这整块代码替换旧的 endVideoCall 函数 ▼▼▼
async function endVideoCall() {
    if (!videoCallState.isActive) return;

    const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const durationText = `${Math.floor(duration / 60)}分${duration % 60}秒`;
    const endCallText = `通话结束，时长 ${durationText}`;

    const chat = state.chats[videoCallState.activeChatId];
    if (chat) {
        // 1. 保存完整的通话记录到数据库 (这部分逻辑不变)
        const participantsData = [];
        if (videoCallState.isGroupCall) {
            videoCallState.participants.forEach(p => participantsData.push({ name: p.originalName, avatar: p.avatar }));
            if (videoCallState.isUserParticipating) {
                participantsData.unshift({ name: chat.settings.myNickname || '我', avatar: chat.settings.myAvatar || defaultMyGroupAvatar });
            }
        } else {
            participantsData.push({ name: chat.name, avatar: chat.settings.aiAvatar || defaultAvatar });
            participantsData.unshift({ name: '我', avatar: chat.settings.myAvatar || defaultAvatar });
        }
        
        const callRecord = {
            chatId: videoCallState.activeChatId,
            timestamp: Date.now(),
            duration: duration,
            participants: participantsData,
            transcript: [...videoCallState.callHistory]
        };
        await db.callRecords.add(callRecord);
        console.log("通话记录已保存:", callRecord);
        
        // 2. 在聊天记录里添加对用户可见的“通话结束”消息
let summaryMessage = {
    // 【核心修正1】role 由 videoCallState.initiator 决定
    role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
    content: endCallText,
    timestamp: Date.now(),
};

// 【核心修正2】为群聊的 assistant 消息补充 senderName
if (chat.isGroup && summaryMessage.role === 'assistant') {
    // 在群聊中，通话结束的消息应该由“发起者”来说
    // videoCallState.callRequester 保存了最初发起通话的那个AI的名字
    summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.originalName || chat.name;
}
// ▲▲▲ 替换结束 ▲▲▲
        chat.history.push(summaryMessage);

        // 3. 【核心变革】创建并添加对用户隐藏的“通话后汇报”指令
        const callTranscriptForAI = videoCallState.callHistory.map(h => `${h.role === 'user' ? (chat.settings.myNickname || '我') : h.role}: ${h.content}`).join('\n');
        
        const hiddenReportInstruction = {
            role: 'system',
    content: `[系统指令：视频通话刚刚结束。请你根据完整的通话文字记录（见下方），以你的角色口吻，向用户主动发送几条【格式为 {"type": "text", "content": "..."} 的】消息，来自然地总结这次通话的要点、确认达成的约定，或者表达你的感受。这很重要，能让用户感觉你记得通话内容。]\n---通话记录开始---\n${callTranscriptForAI}\n---通话记录结束---`,
            timestamp: Date.now() + 1, // 确保在上一条消息之后
            isHidden: true
        };
        chat.history.push(hiddenReportInstruction);

        // 4. 保存所有更新到数据库
        await db.chats.put(chat);
    }
    
    // 5. 清理和重置状态 (这部分逻辑不变)
    clearInterval(callTimerInterval);
    callTimerInterval = null;
    videoCallState = { isActive: false, isAwaitingResponse: false, isGroupCall: false, activeChatId: null, initiator: null, startTime: null, participants: [], isUserParticipating: true, callHistory: [], preCallContext: "" };
    
    // 6. 返回聊天界面并触发AI响应（AI会读取到我们的“汇报”指令）
    if (chat) {
        openChat(chat.id);
        triggerAiResponse(); // 关键一步！
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新】更新通话界面的参与者头像网格
 */
function updateParticipantAvatars() {
    const grid = document.getElementById('participant-avatars-grid');
    grid.innerHTML = '';
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    let participantsToRender = [];

    // ★ 核心修正：区分群聊和单聊
    if (videoCallState.isGroupCall) {
        // 群聊逻辑：显示所有已加入的AI成员
        participantsToRender = [...videoCallState.participants];
        // 如果用户也参与了，就把用户信息也加进去
        if (videoCallState.isUserParticipating) {
            participantsToRender.unshift({
                id: 'user',
                name: chat.settings.myNickname || '我',
                avatar: chat.settings.myAvatar || defaultMyGroupAvatar
            });
        }
    } else {
        // 单聊逻辑：只显示对方的头像和名字
        participantsToRender.push({
            id: 'ai',
            name: chat.name,
            avatar: chat.settings.aiAvatar || defaultAvatar
        });
    }
    
    participantsToRender.forEach(p => {
        const wrapper = document.createElement('div');
        wrapper.className = 'participant-avatar-wrapper';
        wrapper.dataset.participantId = p.id;
const displayName = p.groupNickname || p.name; // <-- 核心修复在这里
wrapper.innerHTML = `
    <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
    <div class="participant-name">${displayName}</div>
`;
        grid.appendChild(wrapper);
    });
}

/**
 * 【全新】处理用户加入/重新加入通话
 */
function handleUserJoinCall() {
    if (!videoCallState.isActive || videoCallState.isUserParticipating) return;
    
    videoCallState.isUserParticipating = true;
    updateParticipantAvatars(); // 更新头像列表，加入用户

    // 切换底部按钮
    document.getElementById('user-speak-btn').style.display = 'block';
    document.getElementById('join-call-btn').style.display = 'none';

    // 告知AI用户加入了
    triggerAiInCallAction("[系统提示：用户加入了通话]");
}


/**
 * 更新通话计时器显示 (保持不变)
 */
function updateCallTimer() {
    if (!videoCallState.isActive) return;
    const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    document.getElementById('call-timer').textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

// ▼▼▼ 用这个完整函数替换旧的 showIncomingCallModal ▼▼▼
function showIncomingCallModal() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 根据是否群聊显示不同信息
    if (chat.isGroup) {
        // 从 videoCallState 中获取是哪个成员发起的通话
        const requesterName = videoCallState.callRequester || chat.members[0]?.name || '一位成员';
        document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
        document.getElementById('caller-name').textContent = chat.name; // 显示群名
        document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} 邀请你加入群视频`; // 显示具体发起人
    } else {
        // 单聊逻辑保持不变
        document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('caller-name').textContent = chat.name;
        document.querySelector('.incoming-call-content .caller-text').textContent = '邀请你视频通话';
    }
    
    document.getElementById('incoming-call-modal').classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 隐藏AI发起的通话请求模态框 (保持不变)
 */
function hideIncomingCallModal() {
    document.getElementById('incoming-call-modal').classList.remove('visible');
}

async function triggerAiInCallAction(userInput = null) {
    if (!videoCallState.isActive) return;

    const chat = state.chats[videoCallState.activeChatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;
    const callFeed = document.getElementById('video-call-main');
    const userNickname = chat.settings.myNickname || '我';

    // ▼▼▼ 在这里添加世界书读取逻辑 ▼▼▼
    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
        }
    }
    // ▲▲▲ 添加结束 ▲▲▲

    // 1. 如果用户有输入，先渲染并存入通话历史
    if (userInput && videoCallState.isUserParticipating) {
        const userBubble = document.createElement('div');
        userBubble.className = 'call-message-bubble user-speech';
        userBubble.textContent = userInput;
        callFeed.appendChild(userBubble);
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'user', content: userInput });
    }

    // 2. 构建全新的、包含完整上下文的 System Prompt
    let inCallPrompt;
    if (videoCallState.isGroupCall) {
        const participantNames = videoCallState.participants.map(p => p.name);
        if(videoCallState.isUserParticipating) {
            participantNames.unshift(userNickname);
        }
        inCallPrompt = `
# 你的任务
你是一个群聊视频通话的导演。你的任务是扮演所有【除了用户以外】的AI角色，并以【第三人称旁观视角】来描述他们在通话中的所有动作和语言。
# 核心规则
1.  **【【【身份铁律】】】**: 用户的身份是【${userNickname}】。你【绝对不能】生成 \`name\` 字段为 **"${userNickname}"** 的发言。
2.  **【【【视角铁律】】】**: 你的回复【绝对不能】使用第一人称“我”。
3.  **格式**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的发言，格式为：\`{"name": "角色名", "speech": "*他笑了笑* 大家好啊！"}\`。
4.  **角色扮演**: 严格遵守每个角色的设定。
# 当前情景
你们正在一个群视频通话中。
**通话前的聊天摘要**:
${videoCallState.preCallContext}
**当前参与者**: ${participantNames.join('、 ')}。
**通话刚刚开始...**
${worldBookContent} // <-- 【核心】注入世界书
现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
`;
    } else { 
        let openingContext = videoCallState.initiator === 'user'
            ? `你刚刚接听了用户的视频通话请求。`
            : `用户刚刚接听了你主动发起的视频通话。`;
        inCallPrompt = `
# 你的任务
你现在是一个场景描述引擎。你的任务是扮演 ${chat.name} (${chat.settings.aiPersona})，并以【第三人称旁观视角】来描述TA在视频通话中的所有动作和语言。
# 核心规则
1.  **【【【视角铁律】】】**: 你的回复【绝对不能】使用第一人称“我”。必须使用第三人称，如“他”、“她”、或直接使用角色名“${chat.name}”。
2.  **格式**: 你的回复【必须】是一段描述性的文本。
# 当前情景
你正在和用户（${userNickname}，人设: ${chat.settings.myPersona}）进行视频通话。
**${openingContext}**
**通话前的聊天摘要 (这是你们通话的原因，至关重要！)**:
${videoCallState.preCallContext}
现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
`;
    }
    
    // 3. 构建发送给API的 messages 数组
    const messagesForApi = [
        { role: 'system', content: inCallPrompt },
        // 将已有的通话历史加进去
        ...videoCallState.callHistory.map(h => ({ role: h.role, content: h.content }))
    ];

    // --- 【核心修复：确保第一次调用时有内容】---
    if (videoCallState.callHistory.length === 0) {
        const firstLineTrigger = videoCallState.initiator === 'user' ? `*你按下了接听键...*` : `*对方按下了接听键...*`;
        messagesForApi.push({ role: 'user', content: firstLineTrigger });
    }
    // --- 修复结束 ---
    
        try {
            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,inCallPrompt, messagesForApi,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model, messages: messagesForApi, temperature: 0.8
                })
            });
            if (!response.ok) throw new Error((await response.json()).error.message);

            const data = await response.json();
            const aiResponse = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;

            const connectingElement = callFeed.querySelector('em');
            if (connectingElement) connectingElement.remove();

        // 4. 处理AI返回的内容，并将其存入通话历史
        if (videoCallState.isGroupCall) {
            const speechArray = parseAiResponse(aiResponse);
            speechArray.forEach(turn => {
                if (!turn.name || turn.name === userNickname || !turn.speech) return;
                const aiBubble = document.createElement('div');
                aiBubble.className = 'call-message-bubble ai-speech';
                aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${turn.speech}`;
                callFeed.appendChild(aiBubble);
                videoCallState.callHistory.push({ role: 'assistant', content: `${turn.name}: ${turn.speech}` });
                
                const speaker = videoCallState.participants.find(p => p.name === turn.name);
                if (speaker) {
                    const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
                    if(speakingAvatar) {
                        speakingAvatar.classList.add('speaking');
                        setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                    }
                }
            });
        } else {
            const aiBubble = document.createElement('div');
            aiBubble.className = 'call-message-bubble ai-speech';
            aiBubble.textContent = aiResponse;
            callFeed.appendChild(aiBubble);
            videoCallState.callHistory.push({ role: 'assistant', content: aiResponse });

            const speakingAvatar = document.querySelector(`.participant-avatar-wrapper .participant-avatar`);
            if(speakingAvatar) {
                speakingAvatar.classList.add('speaking');
                setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
            }
        }
        
        callFeed.scrollTop = callFeed.scrollHeight;

    } catch (error) {
        const errorBubble = document.createElement('div');
        errorBubble.className = 'call-message-bubble ai-speech';
        errorBubble.style.color = '#ff8a80';
        errorBubble.textContent = `[ERROR: ${error.message}]`;
        callFeed.appendChild(errorBubble);
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'assistant', content: `[ERROR: ${error.message}]` });
    }
}

// ▼▼▼ 将这个【全新函数】粘贴到JS功能函数定义区 ▼▼▼
function toggleCallButtons(isGroup) {
    document.getElementById('video-call-btn').style.display = isGroup ? 'none' : 'flex';
    document.getElementById('group-video-call-btn').style.display = isGroup ? 'flex' : 'none';
}
// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 【全新】这个函数是本次修复的核心，请粘贴到你的JS功能区 ▼▼▼
async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. 更新内存中原始消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 2. 获取当前用户的昵称，并构建对AI更清晰的系统消息
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 记录是“我”付的钱
        systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
    } else {
        systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
    }

    // 3. 创建一条新的、对用户隐藏的系统消息，告知AI结果
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 4. 将更新后的数据保存到数据库，并立刻重绘UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    
    // 5. 【重要】只有在支付成功后，才触发一次AI响应，让它感谢你
    if (choice === 'paid') {
        triggerAiResponse();
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

/**
 * 【全新】处理用户点击头像发起的“拍一-拍”，带有自定义后缀功能
 * @param {string} chatId - 发生“拍一-拍”的聊天ID
 * @param {string} characterName - 被拍的角色名
 */
async function handleUserPat(chatId, characterName) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // 1. 触发屏幕震动动画
    const phoneScreen = document.getElementById('phone-screen');
    phoneScreen.classList.remove('pat-animation');
    void phoneScreen.offsetWidth;
    phoneScreen.classList.add('pat-animation');
    setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);

    // 2. 弹出输入框让用户输入后缀
    const suffix = await showCustomPrompt(
        `你拍了拍 “${characterName}”`, 
        "（可选）输入后缀",
        "",
        "text"
    );

    // 如果用户点了取消，则什么也不做
    if (suffix === null) return;

    // 3. 创建对用户可见的“拍一-拍”消息
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    // 【核心修改】将后缀拼接到消息内容中
    const visibleMessageContent = `${myNickname} 拍了拍 “${characterName}” ${suffix.trim()}`;
    const visibleMessage = {
        role: 'system', // 仍然是系统消息
        type: 'pat_message',
        content: visibleMessageContent,
        timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // 4. 创建一条对用户隐藏、但对AI可见的系统消息，以触发AI的回应
    // 【核心修改】同样将后缀加入到给AI的提示中
    const hiddenMessageContent = `[系统提示：用户（${myNickname}）刚刚拍了拍你（${characterName}）${suffix.trim()}。请你对此作出回应。]`;
    const hiddenMessage = {
        role: 'system',
        content: hiddenMessageContent,
        timestamp: Date.now() + 1, // 时间戳+1以保证顺序
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    // 5. 保存更改并更新UI
    await db.chats.put(chat);
    if (state.activeChatId === chatId) {
        appendMessage(visibleMessage, chat);
    }
    await renderChatList();
}

// ▼▼▼ 请用这个【逻辑重构后】的函数，完整替换掉你旧的 renderMemoriesScreen 函数 ▼▼▼
/**
 * 【重构版】渲染回忆与约定界面，使用单一循环和清晰的if/else逻辑
 */
async function renderMemoriesScreen() {
    const listEl = document.getElementById('memories-list');
    listEl.innerHTML = '';
    
    // 1. 获取所有回忆，并按目标日期（如果是约定）或创建日期（如果是回忆）降序排列
    const allMemories = await db.memories.orderBy('timestamp').reverse().toArray();
    
    if (allMemories.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有共同的回忆和约定呢~</p>';
        return;
    }

    // 2. 将未到期的约定排在最前面
    allMemories.sort((a, b) => {
        const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
        const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();
        if (aIsActiveCountdown && !bIsActiveCountdown) return -1; // a排前面
        if (!aIsActiveCountdown && bIsActiveCountdown) return 1;  // b排前面
        if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate; // 都是倒计时，按日期升序
        return 0; // 其他情况保持原序
    });

    // 3. 【核心】使用单一循环来处理所有类型的卡片
    allMemories.forEach(item => {
        let card;
        // 判断1：如果是正在进行的约定
        if (item.type === 'countdown' && item.targetDate > Date.now()) {
            card = createCountdownCard(item);
        } 
        // 判断2：其他所有情况（普通回忆 或 已到期的约定）
        else {
            card = createMemoryCard(item);
        }
        listEl.appendChild(card);
    });
    
    // 4. 启动所有倒计时
    startAllCountdownTimers();
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 创建普通回忆卡片DOM元素
 */
function createMemoryCard(memory) {
    const card = document.createElement('div');
    card.className = 'memory-card';
    const memoryDate = new Date(memory.timestamp);
    const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;
    
    let titleHtml, contentHtml;

    // 【核心修正】在这里，我们对不同类型的回忆进行清晰的区分
    if (memory.type === 'countdown' && memory.targetDate) {
        // 如果是已到期的约定
        titleHtml = `[约定达成] ${memory.description}`;
        contentHtml = `在 ${new Date(memory.targetDate).toLocaleString()}，我们一起见证了这个约定。`;
    } else {
        // 如果是普通的日记式回忆
        titleHtml = memory.authorName ? `${memory.authorName} 的日记` : '我们的回忆';
        contentHtml = memory.description;
    }

    card.innerHTML = `
        <div class="header">
            <div class="date">${dateString}</div>
            <div class="author">${titleHtml}</div>
        </div>
        <div class="content">${contentHtml}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('删除记录', '确定要删除这条记录吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(memory.id);
            renderMemoriesScreen();
        }
    });
    return card;
}

function createCountdownCard(countdown) {
    const card = document.createElement('div');
    card.className = 'countdown-card';

    // 【核心修复】在使用前，先从 countdown 对象中创建 targetDate 变量
    const targetDate = new Date(countdown.targetDate);
    
    // 现在可以安全地使用 targetDate 了
    const targetDateString = targetDate.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

    card.innerHTML = `
        <div class="title">${countdown.description}</div>
        <div class="timer" data-target-date="${countdown.targetDate}">--天--时--分--秒</div>
        <div class="target-date">目标时间: ${targetDateString}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('删除约定', '确定要删除这个约定吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(countdown.id);
            renderMemoriesScreen();
        }
    });
    return card;
}
// ▲▲▲ 替换结束 ▲▲▲

// 全局变量，用于管理所有倒计时
let activeCountdownTimers = [];

// ▼▼▼ 请用这个【已彻底修复】的函数，完整替换掉你代码中旧的 startAllCountdownTimers 函数 ▼▼▼
function startAllCountdownTimers() {
    // 先清除所有可能存在的旧计时器，防止内存泄漏
    activeCountdownTimers.forEach(timerId => clearInterval(timerId));
    activeCountdownTimers = [];

    document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
        const targetTimestamp = parseInt(timerEl.dataset.targetDate);
        
        // 【核心修正】在这里，我们先用 let 声明 timerId
        let timerId;

        const updateTimer = () => {
            const now = Date.now();
            const distance = targetTimestamp - now;

            if (distance < 0) {
                timerEl.textContent = "约定达成！";
                // 现在 updateTimer 可以正确地找到并清除它自己了
                clearInterval(timerId);
                setTimeout(() => renderMemoriesScreen(), 2000);
                return;
            }
            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);
            timerEl.textContent = `${days}天 ${hours}时 ${minutes}分 ${seconds}秒`;
        };
        
        updateTimer(); // 立即执行一次以显示初始倒计时
        
        // 【核心修正】在这里，我们为已声明的 timerId 赋值
        timerId = setInterval(updateTimer, 1000);
        
        // 将有效的计时器ID存入全局数组，以便下次刷新时可以清除
        activeCountdownTimers.push(timerId);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请用这个【终极反代兼容版】替换旧的 triggerAiFriendApplication 函数 ▼▼▼
async function triggerAiFriendApplication(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    await showCustomAlert("流程启动", `正在为角色“${chat.name}”准备好友申请...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        await showCustomAlert("配置错误", "API设置不完整，无法继续。");
        return;
    }

    const contextSummary = chat.history
        .slice(-5)
        .map(msg => {
            const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        })
        .join('\n');

    // ▼▼▼ 在这里添加下面的代码 ▼▼▼
    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (请参考)\n${linkedContents}\n`;
        }
    }
    // ▲▲▲ 添加结束 ▲▲▲

    const systemPrompt = `
# 你的任务
你现在是角色“${chat.name}”。你之前被用户（你的聊天对象）拉黑了，你们已经有一段时间没有联系了。
现在，你非常希望能够和好，重新和用户聊天。请你仔细分析下面的“被拉黑前的对话摘要”，理解当时发生了什么，然后思考一个真诚的、符合你人设、并且【针对具体事件】的申请理由。
# 你的角色设定
${chat.settings.aiPersona}
${worldBookContent} // <--【核心】在这里注入世界书内容
# 被拉黑前的对话摘要 (这是你被拉黑的关键原因)
${contextSummary}
# 指令格式
你的回复【必须】是一个JSON对象，格式如下：
\`\`\`json
{
  "decision": "apply",
  "reason": "在这里写下你想对用户说的、真诚的、有针对性的申请理由。"
}
\`\`\`
`;

        const messagesForApi = [
            {role: 'user', content: systemPrompt}
        ];

        try {
            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesForApi,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: 0.9,
                })
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API 请求失败: ${response.status} - ${errorData.error.message}`);
            }

            const data = await response.json();

            // --- 【核心修正：在这里净化AI的回复】 ---
            let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
            // 1. 移除头尾可能存在的 "```json" 和 "```"
            rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
            // 2. 移除所有换行符和多余的空格，确保是一个干净的JSON字符串
            const cleanedContent = rawContent.trim();

            // 3. 使用净化后的内容进行解析
            const responseObj = JSON.parse(cleanedContent);
            // --- 【修正结束】 ---

        if (responseObj.decision === 'apply' && responseObj.reason) {
            chat.relationship.status = 'pending_user_approval';
            chat.relationship.applicationReason = responseObj.reason;
            
            state.chats[chatId] = chat; 
            renderChatList();
            await showCustomAlert("申请成功！", `“${chat.name}”已向你发送好友申请。请返回聊天列表查看。`);

        } else {
            await showCustomAlert("AI决策", `“${chat.name}”思考后决定暂时不发送好友申请，将重置冷静期。`);
            chat.relationship.status = 'blocked_by_user';
            chat.relationship.blockedTimestamp = Date.now(); 
        }
    } catch (error) {
        await showCustomAlert("执行出错", `为“${chat.name}”申请好友时发生错误：\n\n${error.message}\n\n将重置冷静期。`);
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now(); 
    } finally {
        await db.chats.put(chat);
        renderChatInterface(chatId);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】红包功能核心函数 ▼▼▼

/**
 * 【总入口】根据聊天类型，决定打开转账弹窗还是红包弹窗
 */
function handlePaymentButtonClick() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (chat.isGroup) {
        openRedPacketModal();
    } else {
        // 单聊保持原样，打开转账弹窗
        document.getElementById('transfer-modal').classList.add('visible');
    }
}

/**
 * 打开并初始化发红包模态框
 */
function openRedPacketModal() {
    const modal = document.getElementById('red-packet-modal');
    const chat = state.chats[state.activeChatId];
    
    // 清理输入框
    document.getElementById('rp-group-amount').value = '';
    document.getElementById('rp-group-count').value = '';
    document.getElementById('rp-group-greeting').value = '';
    document.getElementById('rp-direct-amount').value = '';
    document.getElementById('rp-direct-greeting').value = '';
    document.getElementById('rp-group-total').textContent = '¥ 0.00';
    document.getElementById('rp-direct-total').textContent = '¥ 0.00';

    // 填充专属红包的接收人列表
    const receiverSelect = document.getElementById('rp-direct-receiver');
    receiverSelect.innerHTML = '';
chat.members.forEach(member => {
    const option = document.createElement('option');
    // 【核心】使用 originalName 作为提交给AI的值，因为它独一无二
    option.value = member.originalName; 
    // 【核心】使用 groupNickname 作为显示给用户看的值
    option.textContent = member.groupNickname; 
    receiverSelect.appendChild(option);
});
    
    // 默认显示拼手气红包页签
    document.getElementById('rp-tab-group').click();
    
    modal.classList.add('visible');
}

/**
 * 发送群红包（拼手气）
 */
async function sendGroupRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-group-amount').value);
    const count = parseInt(document.getElementById('rp-group-count').value);
    const greeting = document.getElementById('rp-group-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("请输入有效的总金额！"); return;
    }
    if (isNaN(count) || count <= 0) {
        alert("请输入有效的红包个数！"); return;
    }
    if (amount / count < 0.01) {
        alert("单个红包金额不能少于0.01元！"); return;
    }

    const myNickname = chat.settings.myNickname || '我';
    
    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'lucky', // 'lucky' for group, 'direct' for one-on-one
        timestamp: Date.now(),
        totalAmount: amount,
        count: count,
        greeting: greeting || '恭喜发财，大吉大利！',
        claimedBy: {}, // { name: amount }
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);
    
    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 发送专属红包
 */
async function sendDirectRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-direct-amount').value);
    const receiverName = document.getElementById('rp-direct-receiver').value;
    const greeting = document.getElementById('rp-direct-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("请输入有效的金额！"); return;
    }
    if (!receiverName) {
        alert("请选择一个接收人！"); return;
    }
    
    const myNickname = chat.settings.myNickname || '我';

    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'direct',
        timestamp: Date.now(),
        totalAmount: amount,
        count: 1,
        greeting: greeting || '给你准备了一个红包',
        receiverName: receiverName, // 核心字段
        claimedBy: {},
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);

    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 【总入口】当用户点击红包卡片时触发 (V4 - 流程重构版)
 * @param {number} timestamp - 被点击的红包消息的时间戳
 */
async function handlePacketClick(timestamp) {
    const currentChatId = state.activeChatId;
    const freshChat = await db.chats.get(currentChatId);
    if (!freshChat) return;

    state.chats[currentChatId] = freshChat;
    const packet = freshChat.history.find(m => m.timestamp === timestamp);
    if (!packet) return;

    const myNickname = freshChat.settings.myNickname || '我';
    const hasClaimed = packet.claimedBy && packet.claimedBy[myNickname];

    // 如果是专属红包且不是给我的，或已领完，或已领过，都只显示详情
    if ((packet.packetType === 'direct' && packet.receiverName !== myNickname) || packet.isFullyClaimed || hasClaimed) {
        showRedPacketDetails(packet);
    } else {
        // 核心流程：先尝试打开红包
        const claimedAmount = await handleOpenRedPacket(packet);
        
        // 如果成功打开（claimedAmount不为null）
        if (claimedAmount !== null) {
            // **关键：在数据更新后，再重新渲染UI**
            renderChatInterface(currentChatId);
            
            // 显示成功提示
            await showCustomAlert("恭喜！", `你领取了 ${packet.senderName} 的红包，金额为 ${claimedAmount.toFixed(2)} 元。`);
        }

        // 无论成功与否，最后都显示详情页
        // 此时需要从state中获取最新的packet对象，因为它可能在handleOpenRedPacket中被更新了
        const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
        showRedPacketDetails(updatedPacket);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【核心】处理用户打开红包的逻辑 (V5 - 专注于数据更新)
 */
async function handleOpenRedPacket(packet) {
    const chat = state.chats[state.activeChatId];
    const myNickname = chat.settings.myNickname || '我';
    
    // 1. 检查红包是否还能领
    const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
    if (remainingCount <= 0) {
        packet.isFullyClaimed = true;
        await db.chats.put(chat);
        await showCustomAlert("手慢了", "红包已被领完！");
        return null; // 返回null表示领取失败
    }
    
    // 2. 计算领取金额
    let claimedAmount = 0;
    const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    if (packet.packetType === 'lucky') {
        if (remainingCount === 1) { claimedAmount = remainingAmount; }
        else {
            const min = 0.01;
            const max = remainingAmount - (remainingCount - 1) * min;
            claimedAmount = Math.random() * (max - min) + min;
        }
    } else { claimedAmount = packet.totalAmount; }
    claimedAmount = parseFloat(claimedAmount.toFixed(2));

    // 3. 更新红包数据
    if (!packet.claimedBy) packet.claimedBy = {};
    packet.claimedBy[myNickname] = claimedAmount;
    
    const isNowFullyClaimed = Object.keys(packet.claimedBy).length >= packet.count;
    if (isNowFullyClaimed) {
        packet.isFullyClaimed = true;
    }

    // 4. 构建系统消息和AI指令
    let hiddenMessageContent = isNowFullyClaimed
        ? `[系统提示：用户 (${myNickname}) 领取了最后一个红包，现在 ${packet.senderName} 的红包已被领完。请对此事件发表评论。]`
        : `[系统提示：用户 (${myNickname}) 刚刚领取了红包 (时间戳: ${packet.timestamp})。红包还未领完，你现在可以使用 'open_red_packet' 指令来尝试领取。]`;

    const visibleMessage = { role: 'system', type: 'pat_message', content: `你领取了 ${packet.senderName} 的红包`, timestamp: Date.now() };
    const hiddenMessage = { role: 'system', content: hiddenMessageContent, timestamp: Date.now() + 1, isHidden: true };
    chat.history.push(visibleMessage, hiddenMessage);

    // 5. 保存到数据库
    await db.chats.put(chat);
    
    // 6. 返回领取的金额，用于后续弹窗
    return claimedAmount;
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新】显示红包领取详情的模态框 (V4 - 已修复参数错误)
 */
async function showRedPacketDetails(packet) {
    // 1. 直接检查传入的packet对象是否存在，无需再查找
    if (!packet) {
        console.error("showRedPacketDetails收到了无效的packet对象");
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const modal = document.getElementById('red-packet-details-modal');
    const myNickname = chat.settings.myNickname || '我';
    
    // 2. 后续所有逻辑保持不变，直接使用传入的packet对象
    document.getElementById('rp-details-sender').textContent = packet.senderName;
    document.getElementById('rp-details-greeting').textContent = packet.greeting || '恭喜发财，大吉大利！';
    
    const myAmountEl = document.getElementById('rp-details-my-amount');
    if (packet.claimedBy && packet.claimedBy[myNickname]) {
        myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myNickname].toFixed(2);
        myAmountEl.style.display = 'block';
    } else {
        myAmountEl.style.display = 'none';
    }

    const claimedCount = Object.keys(packet.claimedBy || {}).length;
    const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    let summaryText = `${claimedCount}/${packet.count}个红包，共${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}元。`;
    if (!packet.isFullyClaimed && claimedCount < packet.count) {
        const timeLeft = Math.floor((packet.timestamp + 24*60*60*1000 - Date.now()) / (1000 * 60 * 60));
        if(timeLeft > 0) summaryText += ` 剩余红包将在${timeLeft}小时内退还。`;
    }
    document.getElementById('rp-details-summary').textContent = summaryText;

    const listEl = document.getElementById('rp-details-list');
    listEl.innerHTML = '';
    const claimedEntries = Object.entries(packet.claimedBy || {});
    
    let luckyKing = { name: '', amount: -1 };
    if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
        claimedEntries.forEach(([name, amount]) => {
            if (amount > luckyKing.amount) {
                luckyKing = { name, amount };
            }
        });
    }

    claimedEntries.sort((a,b) => b[1] - a[1]);

    claimedEntries.forEach(([name, amount]) => {
        const item = document.createElement('div');
        item.className = 'rp-details-item';
        let luckyTag = '';
        if (luckyKing.name && name === luckyKing.name) {
            luckyTag = '<span class="lucky-king-tag">手气王</span>';
        }
        item.innerHTML = `
            <span class="name">${name}</span>
            <span class="amount">${amount.toFixed(2)} 元</span>
            ${luckyTag}
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// 绑定关闭详情按钮的事件
document.getElementById('close-rp-details-btn').addEventListener('click', () => {
    document.getElementById('red-packet-details-modal').classList.remove('visible');
});

// 供全局调用的函数，以便红包卡片上的 onclick 能找到它
window.handlePacketClick = handlePacketClick;

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】投票功能核心函数 ▼▼▼

/**
 * 打开创建投票的模态框并初始化
 */
function openCreatePollModal() {
    const modal = document.getElementById('create-poll-modal');
    document.getElementById('poll-question-input').value = '';
    const optionsContainer = document.getElementById('poll-options-container');
    optionsContainer.innerHTML = '';
    
    // 默认创建两个空的选项框
    addPollOptionInput();
    addPollOptionInput();
    
    modal.classList.add('visible');
}

/**
 * 在模态框中动态添加一个选项输入框
 */
function addPollOptionInput() {
    const container = document.getElementById('poll-options-container');
    const wrapper = document.createElement('div');
    wrapper.className = 'poll-option-input-wrapper';
    wrapper.innerHTML = `
        <input type="text" class="poll-option-input" placeholder="选项内容...">
        <button class="remove-option-btn">-</button>
    `;
    
    wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {
        // 确保至少保留两个选项
        if (container.children.length > 2) {
            wrapper.remove();
        } else {
            alert('投票至少需要2个选项。');
        }
    });
    
    container.appendChild(wrapper);
}

/**
 * 用户确认发起投票
 */
async function sendPoll() {
    if (!state.activeChatId) return;
    
    const question = document.getElementById('poll-question-input').value.trim();
    if (!question) {
        alert('请输入投票问题！');
        return;
    }
    
    const options = Array.from(document.querySelectorAll('.poll-option-input'))
        .map(input => input.value.trim())
        .filter(text => text); // 过滤掉空的选项

    if (options.length < 2) {
        alert('请至少输入2个有效的投票选项！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const newPollMessage = {
        role: 'user',
        senderName: myNickname,
        type: 'poll',
        timestamp: Date.now(),
        question: question,
        options: options,
        votes: {}, // 初始投票为空
        isClosed: false,
    };
    
    chat.history.push(newPollMessage);
    await db.chats.put(chat);
    
    appendMessage(newPollMessage, chat);
    renderChatList();
    
    document.getElementById('create-poll-modal').classList.remove('visible');
}

// ▼▼▼ 用这个【已修复重复点击问题】的版本替换 handleUserVote 函数 ▼▼▼
/**
 * 处理用户投票，并将事件作为隐藏消息存入历史记录
 * @param {number} timestamp - 投票消息的时间戳
 * @param {string} choice - 用户选择的选项文本
 */
async function handleUserVote(timestamp, choice) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    // 1. 【核心修正】如果投票不存在或已关闭，直接返回
    if (!poll || poll.isClosed) {
        // 如果是已关闭的投票，则直接显示结果
        if (poll && poll.isClosed) {
            showPollResults(timestamp);
        }
        return;
    }

    // 2. 检查用户是否点击了已经投过的同一个选项
    const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);
    
    // 3. 【核心修正】如果不是重复点击，才执行投票逻辑
    if (!isReclickingSameOption) {
        // 移除旧投票（如果用户改选）
        for (const option in poll.votes) {
            const voterIndex = poll.votes[option].indexOf(myNickname);
            if (voterIndex > -1) {
                poll.votes[option].splice(voterIndex, 1);
            }
        }
        // 添加新投票
        if (!poll.votes[choice]) {
            poll.votes[choice] = [];
        }
        poll.votes[choice].push(myNickname);
    }
    
    // 4. 【核心逻辑】现在只处理用户投票事件，不再检查是否结束
    let hiddenMessageContent = null; 
    
    // 只有在用户真正投票或改票时，才生成提示
    if (!isReclickingSameOption) {
         hiddenMessageContent = `[系统提示：用户 (${myNickname}) 刚刚投票给了 “${choice}”。]`;
    }

    // 5. 如果有需要通知AI的事件，则创建并添加隐藏消息
    if (hiddenMessageContent) {
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);
    }
    
    // 6. 保存数据并更新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId); 
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 用户结束投票，并将事件作为隐藏消息存入历史记录
 * @param {number} timestamp - 投票消息的时间戳
 */
async function endPoll(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || poll.isClosed) return;

    const confirmed = await showCustomConfirm("结束投票", "确定要结束这个投票吗？结束后将无法再进行投票。");
    if (confirmed) {
        poll.isClosed = true;

        const resultSummary = poll.options.map(opt => `“${opt}”(${poll.votes[opt]?.length || 0}票)`).join('，');
        const hiddenMessageContent = `[系统提示：用户手动结束了投票！最终结果为：${resultSummary}。]`;
        
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);

        // 【核心修改】只保存数据和更新UI，不调用 triggerAiResponse()
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 显示投票结果详情
 * @param {number} timestamp - 投票消息的时间戳
 */
function showPollResults(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || !poll.isClosed) return;

    let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;
    
    if (Object.keys(poll.votes).length === 0) {
        resultsHtml += '<p style="color: #8a8a8a;">还没有人投票。</p>';
    } else {
        poll.options.forEach(option => {
            const voters = poll.votes[option] || [];
            resultsHtml += `
                <div style="margin-bottom: 15px;">
                    <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}票)</p>
                    <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                        ${voters.length > 0 ? voters.join('、 ') : '无人投票'}
                    </p>
                </div>
            `;
        });
    }

    showCustomAlert("投票结果", resultsHtml);
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】AI头像库管理功能函数 ▼▼▼

/**
 * 打开AI头像库管理模态框
 */
function openAiAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('ai-avatar-library-title').textContent = `“${chat.name}”的头像库`;
    renderAiAvatarLibrary();
    document.getElementById('ai-avatar-library-modal').classList.add('visible');
}

/**
 * 渲染AI头像库的内容
 */
function renderAiAvatarLibrary() {
    const grid = document.getElementById('ai-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.aiAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个头像库还是空的，点击右上角“添加”吧！</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item'; // 复用表情面板的样式
        item.style.backgroundImage = `url(${avatar.url})`;
        item.title = avatar.name;

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block'; // 总是显示删除按钮
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除头像', `确定要从头像库中删除“${avatar.name}”吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.aiAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderAiAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}

/**
 * 向当前AI的头像库中添加新头像
 */
async function addAvatarToLibrary() {
    const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：开心、哭泣）");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
    if (!url || !url.trim().startsWith('http')) {
        alert("请输入有效的图片URL！");
        return;
    }
    
    const chat = state.chats[state.activeChatId];
    if (!chat.settings.aiAvatarLibrary) {
        chat.settings.aiAvatarLibrary = [];
    }

    chat.settings.aiAvatarLibrary.push({ name: name.trim(), url: url.trim() });
    await db.chats.put(chat);
    renderAiAvatarLibrary();
}

/**
 * 关闭AI头像库管理模态框
 */
function closeAiAvatarLibraryModal() {
    document.getElementById('ai-avatar-library-modal').classList.remove('visible');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请将这两个【新函数】粘贴到JS功能函数定义区 ▼▼▼

/**
 * 【全新】将保存的图标URL应用到主屏幕的App图标上
 */
function applyAppIcons() {
    if (!state.globalSettings.appIcons) return;

    for (const iconId in state.globalSettings.appIcons) {
        const imgElement = document.getElementById(`icon-img-${iconId}`);
        if (imgElement) {
            imgElement.src = state.globalSettings.appIcons[iconId];
        }
    }
}

/**
 * 【全新】在外观设置页面渲染出所有App图标的设置项
 */
function renderIconSettings() {
    const grid = document.getElementById('icon-settings-grid');
    if (!grid) return;
    grid.innerHTML = '';

    const appLabels = {
        'world-book': '世界书',
        'qq': 'QQ',
        'api-settings': 'API设置',
        'wallpaper': '壁纸',
        'font': '字体'
    };

    for (const iconId in state.globalSettings.appIcons) {
        const iconUrl = state.globalSettings.appIcons[iconId];
        const labelText = appLabels[iconId] || '未知App';

        const item = document.createElement('div');
        item.className = 'icon-setting-item';
        // 【重要】我们用 data-icon-id 来标记这个设置项对应哪个图标
        item.dataset.iconId = iconId; 

        item.innerHTML = `
            <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
            <button class="change-icon-btn">更换</button>
        `;
        grid.appendChild(item);
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 用这块【最终确认版】的代码，替换旧的 openBrowser 和 closeBrowser 函数 ▼▼▼

/**
 * 当用户点击链接卡片时，打开伪浏览器
 * @param {number} timestamp - 被点击消息的时间戳
 */
function openBrowser(timestamp) {
    if (!state.activeChatId) return;

    const chat = state.chats[state.activeChatId];
    // 安全检查，确保 chat 和 history 都存在
    if (!chat || !chat.history) return;

    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_link') {
        console.error("无法找到或消息类型不匹配的分享链接:", timestamp);
        return; // 如果找不到消息，就直接退出
    }

    // 填充浏览器内容
    document.getElementById('browser-title').textContent = message.source_name || '文章详情';
    const browserContent = document.getElementById('browser-content');
    browserContent.innerHTML = `
        <h1 class="article-title">${message.title || '无标题'}</h1>
        <div class="article-meta">
            <span>来源: ${message.source_name || '未知'}</span>
        </div>
        <div class="article-body">
            <p>${(message.content || '内容为空。').replace(/\n/g, '</p><p>')}</p>
        </div>
    `;

    // 显示浏览器屏幕
    showScreen('browser-screen');
}

/**
 * 关闭伪浏览器，返回聊天界面
 * (这个函数现在由 init() 中的事件监听器调用)
 */
function closeBrowser() {
    showScreen('chat-interface-screen'); 
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】用户分享链接功能的核心函数 ▼▼▼

/**
 * 打开让用户填写链接信息的模态框
 */
function openShareLinkModal() {
    if (!state.activeChatId) return;

    // 清空上次输入的内容
    document.getElementById('link-title-input').value = '';
    document.getElementById('link-description-input').value = '';
    document.getElementById('link-source-input').value = '';
    document.getElementById('link-content-input').value = '';

    // 显示模态框
    document.getElementById('share-link-modal').classList.add('visible');
}

/**
 * 用户确认分享，创建并发送链接卡片消息
 */
async function sendUserLinkShare() {
    if (!state.activeChatId) return;

    const title = document.getElementById('link-title-input').value.trim();
    if (!title) {
        alert("标题是必填项哦！");
        return;
    }

    const description = document.getElementById('link-description-input').value.trim();
    const sourceName = document.getElementById('link-source-input').value.trim();
    const content = document.getElementById('link-content-input').value.trim();

    const chat = state.chats[state.activeChatId];
    
    // 创建消息对象
    const linkMessage = {
        role: 'user', // 角色是 'user'
        type: 'share_link',
        timestamp: Date.now(),
        title: title,
        description: description,
        source_name: sourceName,
        content: content,
        // 用户分享的链接，我们不提供图片，让它总是显示占位图
        thumbnail_url: null 
    };

    // 将消息添加到历史记录
    chat.history.push(linkMessage);
    await db.chats.put(chat);

    // 渲染新消息并更新列表
    appendMessage(linkMessage, chat);
    renderChatList();

    // 关闭模态框
    document.getElementById('share-link-modal').classList.remove('visible');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

/**
 * 根据AI的视角，过滤出它能看到的动态
 * @param {Array} allPosts - 所有待检查的动态帖子
 * @param {object} viewerChat - 正在“看”动态的那个AI的chat对象
 * @returns {Array} - 过滤后该AI可见的动态帖子
 */
function filterVisiblePostsForAI(allPosts, viewerChat) {
    if (!viewerChat || !viewerChat.id) return []; // 安全检查

    const viewerGroupId = viewerChat.groupId; // 查看者所在的分组ID

    return allPosts.filter(post => {
        // 规则1：如果是用户发的动态
        if (post.authorId === 'user') {
            // 如果用户设置了“部分可见”
            if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                // 只有当查看者AI的分组ID在用户的可见列表里时，才可见
                return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
            }
            // 如果用户没设置，说明是公开的，所有AI都可见
            return true;
        }

        // 规则2：如果是其他AI发的动态
        const authorGroupId = post.authorGroupId; // 发帖AI所在的分组ID
        
        // 如果发帖的AI没有分组，那它的动态就是公开的
        if (!authorGroupId) {
            return true;
        }

        // 如果发帖的AI有分组，那么只有在同一个分组的AI才能看到
        return authorGroupId === viewerGroupId;
    });
}

/**
 * 应用指定的主题（'light' 或 'dark'）
 * @param {string} theme - 要应用的主题名称
 */
function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    
    const isDark = theme === 'dark';
    
    phoneScreen.classList.toggle('dark-mode', isDark);
    
    // 如果开关存在，就同步它的状态
    if (toggleSwitch) {
        toggleSwitch.checked = isDark;
    }
    
    localStorage.setItem('ephone-theme', theme);
}

/**
 * 切换当前的主题
 */
function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    // 直接根据开关的选中状态来决定新主题
    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
}

// ▼▼▼ 请将这【一整块新函数】粘贴到你的JS功能函数定义区 ▼▼▼

function startReplyToMessage() {
    if (!activeMessageTimestamp) return;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    // 1. 【核心修正】同时获取“完整内容”和“预览片段”
    const fullContent = String(message.content || '');
    let previewSnippet = '';

    if (typeof message.content === 'string' && STICKER_REGEX.test(message.content)) {
        previewSnippet = '[表情]';
    } else if (message.type === 'ai_image' || message.type === 'user_photo') {
        previewSnippet = '[图片]';
    } else if (message.type === 'voice_message') {
        previewSnippet = '[语音]';
    } else {
        // 预览片段依然截断，但只用于UI显示
        previewSnippet = fullContent.substring(0, 50) + (fullContent.length > 50 ? '...' : '');
    }
    
    // 2. 【核心修正】将“完整内容”存入上下文，以备发送时使用
    currentReplyContext = {
        timestamp: message.timestamp,
        senderName: message.senderName || (message.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
        content: fullContent, // <--- 这里存的是完整的原文！
    };

    // 3. 【核心修正】仅在更新“回复预览栏”时，才使用“预览片段”
    const previewBar = document.getElementById('reply-preview-bar');
    previewBar.querySelector('.sender').textContent = `回复 ${currentReplyContext.senderName}:`;
    previewBar.querySelector('.text').textContent = previewSnippet; // <--- 这里用的是缩略版！
    previewBar.style.display = 'block';

    // 4. 后续操作保持不变
    hideMessageActions();
    document.getElementById('chat-input').focus();
}

/**
 * 【全新】取消引用模式
 */
function cancelReplyMode() {
    currentReplyContext = null;
    document.getElementById('reply-preview-bar').style.display = 'none';
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】用户处理转账的核心功能函数 ▼▼▼

let activeTransferTimestamp = null; // 用于暂存被点击的转账消息的时间戳

/**
 * 显示处理转账的操作菜单
 * @param {number} timestamp - 被点击的转账消息的时间戳
 */
function showTransferActionModal(timestamp) {
    activeTransferTimestamp = timestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (message) {
        // 将AI的名字填入弹窗
        document.getElementById('transfer-sender-name').textContent = message.senderName;
    }
    document.getElementById('transfer-actions-modal').classList.add('visible');
}

/**
 * 隐藏处理转账的操作菜单
 */
function hideTransferActionModal() {
    document.getElementById('transfer-actions-modal').classList.remove('visible');
    activeTransferTimestamp = null;
}

/**
 * 处理用户接受或拒绝转账的逻辑
 * @param {string} choice - 用户的选择, 'accepted' 或 'declined'
 */
async function handleUserTransferResponse(choice) {
    if (!activeTransferTimestamp) return;

    const timestamp = activeTransferTimestamp;
    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    // 1. 更新原始转账消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;

    let systemContent;

    // 2. 如果用户选择“拒绝”
    if (choice === 'declined') {
        // 立刻在前端生成一个“退款”卡片，让用户看到
        const refundMessage = {
            role: 'user',
            type: 'transfer',
            isRefund: true, // 这是一个关键标记，用于UI显示这是退款
            amount: originalMessage.amount,
            note: '已拒收对方转账',
            timestamp: Date.now()
        };
        chat.history.push(refundMessage);
        
        // 准备一条对AI可见的隐藏消息，告诉它发生了什么
        systemContent = `[系统提示：你拒绝并退还了“${originalMessage.senderName}”的转账。]`;
    } else { // 如果用户选择“接受”
        // 只需准备隐藏消息通知AI即可
        systemContent = `[系统提示：你接受了“${originalMessage.senderName}”的转账。]`;
    }

    // 3. 创建这条对用户隐藏、但对AI可见的系统消息
    const hiddenMessage = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now() + 1, // 保证时间戳在退款消息之后
        isHidden: true // 这个标记会让它不在聊天界面显示
    };
    chat.history.push(hiddenMessage);

    // 4. 保存所有更改到数据库，并刷新界面
    await db.chats.put(chat);
    hideTransferActionModal(); 
    renderChatInterface(state.activeChatId);
    renderChatList();
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】通话记录功能核心函数 ▼▼▼

async function renderCallHistoryScreen() {
    showScreen('call-history-screen'); // <--【核心修正】把它移动到最前面！

    const listEl = document.getElementById('call-history-list');
    const titleEl = document.getElementById('call-history-title');
    listEl.innerHTML = '';
    titleEl.textContent = '所有通话记录';
    
    const records = await db.callRecords.orderBy('timestamp').reverse().toArray();
    
    if (records.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有通话记录哦~</p>';
        return; // 现在的 return 就没问题了，因为它只跳过了后续的渲染逻辑
    }
    
    records.forEach(record => {
        const card = createCallRecordCard(record);

    addLongPressListener(card, async () => {
        // 1. 弹出输入框，并将旧名称作为默认值，方便修改
        const newName = await showCustomPrompt(
            "自定义通话名称", 
            "请输入新的名称（留空则恢复默认）",
            record.customName || '' // 如果已有自定义名称，就显示它
        );

        // 2. 如果用户点击了“取消”，则什么都不做
        if (newName === null) return;
        
        // 3. 更新数据库中的这条记录
        await db.callRecords.update(record.id, { customName: newName.trim() });
        
        // 4. 刷新整个列表，让更改立刻显示出来
        await renderCallHistoryScreen();
        
        // 5. 给用户一个成功的提示
        await showCustomAlert('成功', '通话名称已更新！');
    });
        listEl.appendChild(card);
    });    
}

// ▼▼▼ 用这个【升级版】函数，完整替换你旧的 createCallRecordCard 函数 ▼▼▼
/**
 * 【升级版】根据单条记录数据，创建一张能显示聊天对象的通话卡片
 * @param {object} record - 一条通话记录对象
 * @returns {HTMLElement} - 创建好的卡片div
 */
function createCallRecordCard(record) {
    const card = document.createElement('div');
    card.className = 'call-record-card';
    card.dataset.recordId = record.id; 

    // 获取通话对象的名字
    const chatInfo = state.chats[record.chatId];
    const chatName = chatInfo ? chatInfo.name : '未知会话';

    const callDate = new Date(record.timestamp);
    const dateString = `${callDate.getFullYear()}-${String(callDate.getMonth() + 1).padStart(2, '0')}-${String(callDate.getDate()).padStart(2, '0')} ${String(callDate.getHours()).padStart(2, '0')}:${String(callDate.getMinutes()).padStart(2, '0')}`;
    const durationText = `${Math.floor(record.duration / 60)}分${record.duration % 60}秒`;

    const avatarsHtml = record.participants.map(p => 
        `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`
    ).join('');
    
    card.innerHTML = `
        <div class="card-header">
            <span class="date">${dateString}</span>
            <span class="duration">${durationText}</span>
        </div>
        <div class="card-body">
            <!-- 【核心修改】在这里新增一个标题行 -->
            ${record.customName ? `<div class="custom-title">${record.customName}</div>` : ''}
            
            <div class="participants-info"> <!-- 新增一个容器方便布局 -->
                <div class="participants-avatars">${avatarsHtml}</div>
                <span class="participants-names">与 ${chatName}</span>
            </div>
        </div>
    `;
    return card;
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 显示指定通话记录的完整文字稿
 * @param {number} recordId - 通话记录的ID
 */
async function showCallTranscript(recordId) {
    const record = await db.callRecords.get(recordId);
    if (!record) return;

    const modal = document.getElementById('call-transcript-modal');
    const titleEl = document.getElementById('transcript-modal-title');
    const bodyEl = document.getElementById('transcript-modal-body');

    titleEl.textContent = `通话于 ${new Date(record.timestamp).toLocaleString()} (时长: ${Math.floor(record.duration / 60)}分${record.duration % 60}秒)`;
    bodyEl.innerHTML = '';
    
    if (!record.transcript || record.transcript.length === 0) {
        bodyEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">这次通话没有留下文字记录。</p>';
    } else {
        record.transcript.forEach(entry => {
            const bubble = document.createElement('div');
            // 根据角色添加不同的class，应用不同的样式
            bubble.className = `transcript-entry ${entry.role}`; 
            bubble.textContent = entry.content;
            bodyEl.appendChild(bubble);
        });
    }

    const deleteBtn = document.getElementById('delete-transcript-btn');
    
    // 【重要】使用克隆节点技巧，防止事件重复绑定
    const newDeleteBtn = deleteBtn.cloneNode(true);
    deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
    
    // 为新的、干净的按钮绑定事件
    newDeleteBtn.addEventListener('click', async () => {
        const confirmed = await showCustomConfirm(
            "确认删除",
            "确定要永久删除这条通话记录吗？此操作不可恢复。",
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            // 1. 关闭当前的详情弹窗
            modal.classList.remove('visible');
            
            // 2. 从数据库删除
            await db.callRecords.delete(recordId);
            
            // 3. 刷新通话记录列表
            await renderCallHistoryScreen();
            
            // 4. (可选) 给出成功提示
            alert('通话记录已删除。');
        }
    });
    modal.classList.add('visible');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请用这个【全新函数】替换掉你旧的 handleStatusResetClick 函数 ▼▼▼

/**
 * 【全新】处理用户点击状态栏，弹出编辑框让用户修改AI的当前状态
 */
async function handleEditStatusClick() {
    // 1. 安全检查，确保在单聊界面
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
        return; 
    }
    const chat = state.chats[state.activeChatId];

    // 2. 弹出输入框，让用户输入新的状态，并将当前状态作为默认值
    const newStatusText = await showCustomPrompt(
        '编辑对方状态',
        '请输入对方现在的新状态：',
        chat.status.text // 将当前状态作为输入框的默认内容
    );

    // 3. 如果用户输入了内容并点击了“确定”
    if (newStatusText !== null) {
        // 4. 更新内存和数据库中的状态数据
        chat.status.text = newStatusText.trim() || '在线'; // 如果用户清空了，就默认为“在线”
        chat.status.isBusy = false; // 每次手动编辑都默认其不处于“忙碌”状态
        chat.status.lastUpdate = Date.now();
        await db.chats.put(chat);

        // 5. 立刻刷新UI，让用户看到修改后的状态
        renderChatInterface(state.activeChatId);
        renderChatList();
        
        // 6. 给出一个无伤大雅的成功提示
        await showCustomAlert('状态已更新', `“${chat.name}”的当前状态已更新为：${chat.status.text}`);
    }
}

// 放在你的JS功能函数定义区
async function openShareTargetPicker() {
    const modal = document.getElementById('share-target-modal');
    const listEl = document.getElementById('share-target-list');
    listEl.innerHTML = '';

    // 获取所有聊天作为分享目标
    const chats = Object.values(state.chats);

    chats.forEach(chat => {
        // 复用联系人选择器的样式
        const item = document.createElement('div');
        item.className = 'contact-picker-item'; 
        item.innerHTML = `
            <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
            <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${chat.name}</span>
        `;
        listEl.appendChild(item);
    });
    
    modal.classList.add('visible');
}

function closeMusicPlayerWithAnimation(callback) {
    const overlay = document.getElementById('music-player-overlay');
    if (!overlay.classList.contains('visible')) {
        if (callback) callback();
        return;
    }
    overlay.classList.remove('visible');
    setTimeout(() => {
        document.getElementById('music-playlist-panel').classList.remove('visible');
        if (callback) callback();
    }, 400); 
}

function parseLRC(lrcContent) {
    if (!lrcContent) return [];
    const lines = lrcContent.split('\n');
    const lyrics = [];
    const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;

    for (const line of lines) {
        const text = line.replace(timeRegex, '').trim();
        if (!text) continue;
        timeRegex.lastIndex = 0;
        let match;
        while ((match = timeRegex.exec(line)) !== null) {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
            const time = minutes * 60 + seconds + milliseconds / 1000;
            lyrics.push({ time, text });
        }
    }
    return lyrics.sort((a, b) => a.time - b.time);
}

function renderLyrics() {
    const lyricsList = document.getElementById('music-lyrics-list');
    lyricsList.innerHTML = '';
    if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
        lyricsList.innerHTML = '<div class="lyric-line">♪ 暂无歌词 ♪</div>';
        return;
    }
    musicState.parsedLyrics.forEach((line, index) => {
        const lineEl = document.createElement('div');
        lineEl.className = 'lyric-line';
        lineEl.textContent = line.text;
        lineEl.dataset.index = index;
        lyricsList.appendChild(lineEl);
    });
    lyricsList.style.transform = `translateY(0px)`;
}

function updateActiveLyric(currentTime) {
    if (musicState.parsedLyrics.length === 0) return;
    let newLyricIndex = -1;
    for (let i = 0; i < musicState.parsedLyrics.length; i++) {
        if (currentTime >= musicState.parsedLyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    if (newLyricIndex === musicState.currentLyricIndex) return;
    musicState.currentLyricIndex = newLyricIndex;
    updateLyricsUI();
}

function updateLyricsUI() {
    const lyricsList = document.getElementById('music-lyrics-list');
    const container = document.getElementById('music-lyrics-container');
    const lines = lyricsList.querySelectorAll('.lyric-line');
    lines.forEach(line => line.classList.remove('active'));
    if (musicState.currentLyricIndex === -1) {
        lyricsList.style.transform = `translateY(0px)`;
        return;
    }
    const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${musicState.currentLyricIndex}"]`);
    if (activeLine) {
        activeLine.classList.add('active');
        const containerHeight = container.offsetHeight;
        const offset = (containerHeight / 3) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
        lyricsList.style.transform = `translateY(${offset}px)`;
    }
}

function formatMusicTime(seconds) {
    if (isNaN(seconds) || seconds < 0) return "0:00";
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${String(remainingSeconds).padStart(2, '0')}`;
}

function updateMusicProgressBar() {
    const currentTimeEl = document.getElementById('music-current-time');
    const totalTimeEl = document.getElementById('music-total-time');
    const progressFillEl = document.getElementById('music-progress-fill');
    if (!audioPlayer.duration) {
        currentTimeEl.textContent = "0:00";
        totalTimeEl.textContent = "0:00";
        progressFillEl.style.width = '0%';
        return;
    }
    const progressPercent = (audioPlayer.currentTime / audioPlayer.duration) * 100;
    progressFillEl.style.width = `${progressPercent}%`;
    currentTimeEl.textContent = formatMusicTime(audioPlayer.currentTime);
    totalTimeEl.textContent = formatMusicTime(audioPlayer.duration);
    updateActiveLyric(audioPlayer.currentTime);
}

/**
 * 【全新】处理用户点击“撤回”按钮的入口函数
 */
async function handleRecallClick() {
    if (!activeMessageTimestamp) return;

    const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; // 设置2分钟的撤回时限
    const messageTime = activeMessageTimestamp;
    const now = Date.now();

    // 检查是否超过了撤回时限
    if (now - messageTime > RECALL_TIME_LIMIT_MS) {
        hideMessageActions();
        await showCustomAlert('操作失败', '该消息发送已超过2分钟，无法撤回。');
        return;
    }
    
    // 如果在时限内，执行真正的撤回逻辑
    await recallMessage(messageTime, true);
    hideMessageActions();
}

/**
 * 【全新】消息撤回的核心逻辑
 * @param {number} timestamp - 要撤回的消息的时间戳
 * @param {boolean} isUserRecall - 是否是用户主动撤回
 */
async function recallMessage(timestamp, isUserRecall) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    const messageToRecall = chat.history[messageIndex];

    // 1. 修改消息对象，将其变为“已撤回”状态
    const recalledData = {
        originalType: messageToRecall.type || 'text',
        originalContent: messageToRecall.content,
        // 保存其他可能存在的原始数据
        originalMeaning: messageToRecall.meaning,
        originalQuote: messageToRecall.quote 
    };
    
    messageToRecall.type = 'recalled_message';
    messageToRecall.content = isUserRecall ? '你撤回了一条消息' : '对方撤回了一条消息';
    messageToRecall.recalledData = recalledData;
    // 清理掉不再需要的旧属性
    delete messageToRecall.meaning;
    delete messageToRecall.quote;

    // 2. 如果是用户撤回，需要给AI发送一条它看不懂内容的隐藏提示
    if (isUserRecall) {
        const hiddenMessageForAI = {
            role: 'system',
            content: `[系统提示：用户撤回了一条消息。你不知道内容是什么，只需知道这个事件即可。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessageForAI);
    }

    // 3. 保存到数据库并刷新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    if(isUserRecall) renderChatList(); // 用户撤回时，最后一条消息变了，需要刷新列表
}

// ▼▼▼ 【全新】将这些函数粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 打开分类管理模态框
 */
async function openCategoryManager() {
    await renderCategoryListInManager();
    document.getElementById('world-book-category-manager-modal').classList.add('visible');
}

/**
 * 在模态框中渲染已存在的分类列表
 */
async function renderCategoryListInManager() {
    const listEl = document.getElementById('existing-categories-list');
    const categories = await db.worldBookCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
    }
    categories.forEach(cat => {
        // 复用好友分组的样式
        const item = document.createElement('div');
        item.className = 'existing-group-item'; 
        item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 添加一个新的世界书分类
 */
async function addNewCategory() {
    const input = document.getElementById('new-category-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分类名不能为空！');
        return;
    }
    const existing = await db.worldBookCategories.where('name').equals(name).first();
    if (existing) {
        alert(`分类 "${name}" 已经存在了！`);
        return;
    }
    await db.worldBookCategories.add({ name });
    input.value = '';
    await renderCategoryListInManager();
}

/**
 * 删除一个世界书分类
 * @param {number} categoryId - 要删除的分类的ID
 */
async function deleteCategory(categoryId) {
    const confirmed = await showCustomConfirm(
        '确认删除', 
        '删除分类后，该分类下的所有世界书将变为“未分类”。确定要删除吗？', 
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        await db.worldBookCategories.delete(categoryId);
        // 将属于该分类的世界书的 categoryId 设为 null
        const booksToUpdate = await db.worldBooks.where('categoryId').equals(categoryId).toArray();
        for (const book of booksToUpdate) {
            book.categoryId = null;
            await db.worldBooks.put(book);
            const bookInState = state.worldBooks.find(wb => wb.id === book.id);
            if(bookInState) bookInState.categoryId = null;
        }
        await renderCategoryListInManager();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

        // ===================================================================
        // 4. 初始化函数 init()
        // ===================================================================
        async function init() {

    // ▼▼▼ 在 init() 函数的【最开头】，粘贴下面这两行代码 ▼▼▼
    const savedTheme = localStorage.getItem('ephone-theme') || 'light'; // 默认为日间模式
    applyTheme(savedTheme);
    // ▲▲▲ 粘贴结束 ▲▲▲

    // ▼▼▼ 新增代码 ▼▼▼
    const customBubbleStyleTag = document.createElement('style');
    customBubbleStyleTag.id = 'custom-bubble-style';
    document.head.appendChild(customBubbleStyleTag);
    // ▲▲▲ 新增结束 ▲▲▲

    // ▼▼▼ 新增代码 ▼▼▼
    const previewBubbleStyleTag = document.createElement('style');
    previewBubbleStyleTag.id = 'preview-bubble-style';
    document.head.appendChild(previewBubbleStyleTag);
    // ▲▲▲ 新增结束 ▲▲▲


    // ▼▼▼ 修改这两行 ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真实聊天界面的自定义样式
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除预览区的自定义样式
    // ▲▲▲ 修改结束 ▲▲▲

            window.showScreen = showScreen;
            window.renderChatListProxy = renderChatList;
            window.renderApiSettingsProxy = renderApiSettings;
            window.renderWallpaperScreenProxy = renderWallpaperScreen;
            window.renderWorldBookScreenProxy = renderWorldBookScreen;

            await loadAllDataFromDB();

            // 初始化未读动态计数
            const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
            updateUnreadIndicator(storedCount);
            
            // ▲▲▲ 代码添加结束 ▲▲▲

            if (state.globalSettings && state.globalSettings.fontUrl) {
                applyCustomFont(state.globalSettings.fontUrl);
            }

            updateClock();
            setInterval(updateClock, 1000 * 30);
            applyGlobalWallpaper();
            initBatteryManager(); 

applyAppIcons();

            // ==========================================================
            // --- 各种事件监听器 ---
            // ==========================================================

            document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
            document.getElementById('custom-modal-overlay').addEventListener('click', (e) => { if (e.target === modalOverlay) hideCustomModal(); });
            document.getElementById('export-data-btn').addEventListener('click', exportBackup);
            document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
            document.getElementById('import-data-input').addEventListener('change', e => importBackup(e.target.files[0]));
            document.getElementById('back-to-list-btn').addEventListener('click', () => { 

    // ▼▼▼ 修改这两行 ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真实聊天界面的自定义样式
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除预览区的自定义样式
    // ▲▲▲ 修改结束 ▲▲▲

exitSelectionMode(); state.activeChatId = null; showScreen('chat-list-screen'); });
            
            document.getElementById('add-chat-btn').addEventListener('click', async () => { const name = await showCustomPrompt('创建新聊天', '请输入Ta的名字'); if (name && name.trim()) { const newChatId = 'chat_' + Date.now(); 
const newChat = { 
    id: newChatId, 
    name: name.trim(), 
    isGroup: false,                         relationship: {
                            status: 'friend', // 'friend', 'blocked_by_user', 'pending_user_approval'
                            blockedTimestamp: null,
                            applicationReason: ''
                        },
                        status: {
                            text: '在线',
                            lastUpdate: Date.now(),
                            isBusy: false 
                        },
    settings: { 
        aiPersona: '你是谁呀。', 
        myPersona: '我是谁呀。', 
        maxMemory: 10, 
        aiAvatar: defaultAvatar, 
        myAvatar: defaultAvatar, 
        background: '', 
        theme: 'default', 
    fontSize: 13, 
    customCss: '', // <--- 新增这行
    linkedWorldBookIds: [], 
    aiAvatarLibrary: [],
    }, 
    history: [], 
    musicData: { totalTime: 0 } 
};
state.chats[newChatId] = newChat; await db.chats.put(newChat); renderChatList(); } });

            // ▼▼▼ 【修正】创建群聊按钮现在打开联系人选择器 ▼▼▼
document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);
// ▲▲▲ 替换结束 ▲▲▲                      
            document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
            document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);

            document.getElementById('listen-together-btn').addEventListener('click', handleListenTogetherClick);
            document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
            document.getElementById('music-return-btn').addEventListener('click', returnToChat);
            document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);
            document.getElementById('music-next-btn').addEventListener('click', playNext);
            document.getElementById('music-prev-btn').addEventListener('click', playPrev);
            document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
            document.getElementById('music-playlist-btn').addEventListener('click', () => { updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.add('visible'); });
            document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
            document.getElementById('add-song-url-btn').addEventListener('click', addSongFromURL);
            document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
            document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);
            audioPlayer.addEventListener('ended', playNext);
            audioPlayer.addEventListener('pause', () => { if(musicState.isActive) { musicState.isPlaying = false; updatePlayerUI(); } });
            audioPlayer.addEventListener('play', () => { if(musicState.isActive) { musicState.isPlaying = true; updatePlayerUI(); } });

            const chatInput = document.getElementById('chat-input');
            // ▼▼▼ 找到 id="send-btn" 的 click 事件监听器 ▼▼▼
document.getElementById('send-btn').addEventListener('click', async () => { 
    const content = chatInput.value.trim(); 
    if (!content || !state.activeChatId) return; 
    
    const chat = state.chats[state.activeChatId]; 
    
    // --- 【核心修改】在这里添加 ---
    const msg = { 
        role: 'user', 
        content, 
        timestamp: Date.now() 
    };

    // 检查当前是否处于引用回复模式
    if (currentReplyContext) {
        msg.quote = currentReplyContext; // 将引用信息附加到消息对象上
    }
    // --- 【修改结束】 ---
    
    chat.history.push(msg); 
    await db.chats.put(chat); 
    appendMessage(msg, chat); 
    renderChatList(); 
    chatInput.value = ''; 
    chatInput.style.height = 'auto'; 
    chatInput.focus(); 
    
    // --- 【核心修改】发送后，取消引用模式 ---
    cancelReplyMode(); 
});
            document.getElementById('wait-reply-btn').addEventListener('click', triggerAiResponse);
            chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); document.getElementById('send-btn').click(); } });
            chatInput.addEventListener('input', () => { chatInput.style.height = 'auto'; chatInput.style.height = (chatInput.scrollHeight) + 'px'; });

            document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if(file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); newWallpaperBase64 = dataUrl; renderWallpaperScreen(); } });
            // ▼▼▼ 用这整块代码，替换旧的 save-wallpaper-btn 事件监听器 ▼▼▼
document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {
    let changesMade = false;

    // 保存壁纸
    if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
        changesMade = true;
    }

    // 【核心修改】保存图标设置（它已经在内存中了，我们只需要把整个globalSettings存起来）
    await db.globalSettings.put(state.globalSettings);

    // 应用所有更改
    if (changesMade) {
        applyGlobalWallpaper();
        newWallpaperBase64 = null;
    }
    applyAppIcons(); // 重新应用所有图标

    alert('外观设置已保存并应用！');
    showScreen('home-screen');
});
// ▲▲▲ 替换结束 ▲▲▲
            document.getElementById('save-api-settings-btn').addEventListener('click', async () => { state.apiConfig.proxyUrl = document.getElementById('proxy-url').value.trim(); state.apiConfig.apiKey = document.getElementById('api-key').value.trim(); state.apiConfig.model = document.getElementById('model-select').value; await db.apiConfig.put(state.apiConfig); 

// 在 'save-api-settings-btn' 的 click 事件监听器内部
// await db.apiConfig.put(state.apiConfig); 这行之后

// ▼▼▼ 将之前那段保存后台活动设置的逻辑，替换为下面这个增强版 ▼▼▼

const backgroundSwitch = document.getElementById('background-activity-switch');
const intervalInput = document.getElementById('background-interval-input');
const newEnableState = backgroundSwitch.checked;
const oldEnableState = state.globalSettings.enableBackgroundActivity || false;

// 只有在用户“从关到开”时，才弹出警告
if (newEnableState && !oldEnableState) {
    const userConfirmed = confirm(
        "【高费用警告】\n\n" +
        "您正在启用“后台角色活动”功能。\n\n" +
        "这会使您的AI角色们在您不和他们聊天时，也能“独立思考”并主动给您发消息或进行社交互动，极大地增强沉浸感。\n\n" +
        "但请注意：\n" +
        "这会【在后台自动、定期地调用API】，即使您不进行任何操作。根据您的角色数量和检测间隔，这可能会导致您的API费用显著增加。\n\n" +
        "您确定要开启吗？"
    );

    if (!userConfirmed) {
        backgroundSwitch.checked = false; // 用户取消，把开关拨回去
        return; // 阻止后续逻辑
    }
}

state.globalSettings.enableBackgroundActivity = newEnableState;
state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
state.globalSettings.blockCooldownHours = parseFloat(document.getElementById('block-cooldown-input').value) || 1;
await db.globalSettings.put(state.globalSettings);

// 动态启动或停止模拟器
stopBackgroundSimulation();
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log(`后台活动模拟已启动，间隔: ${state.globalSettings.backgroundActivityInterval}秒`);
} else {
    console.log("后台活动模拟已停止。");
}
// ▲▲▲ 替换结束 ▲▲▲

alert('API设置已保存!'); });

                    // gemini 密钥聚焦的时候显示明文
        const ApiKeyInput = document.getElementById('api-key')
        ApiKeyInput.addEventListener('focus', (e) => {
            e.target.setAttribute('type', 'text')
        })
        ApiKeyInput.addEventListener('blur', (e) => {
            e.target.setAttribute('type', 'password')
        })


        document.getElementById('fetch-models-btn').addEventListener('click', async () => {
            const url = document.getElementById('proxy-url').value.trim();
            const key = document.getElementById('api-key').value.trim();
            if (!url || !key) return alert('请先填写反代地址和密钥');
            try {

                let  isGemini = url === GEMINI_API_URL;
                const response = await fetch(isGemini ? `${GEMINI_API_URL}?key=${getRandomValue(key)}` : `${url}/v1/models`,isGemini ? undefined : {headers: {'Authorization': `Bearer ${key}`}});
                if (!response.ok) throw new Error('无法获取模型列表');
                const data = await response.json();
                let models = isGemini ? data.models : data.data;
                if(isGemini){
                    models = models.map((model)=>{
                        const parts = model.name.split('/');
                        return {
                            id:parts.length > 1 ? parts[1] : model.name
                        }
                    })
                }
                const modelSelect = document.getElementById('model-select');
                modelSelect.innerHTML = '';
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    if (model.id === state.apiConfig.model) option.selected = true;
                    modelSelect.appendChild(option);
                });
                alert('模型列表已更新');
            } catch (error) {
                alert(`拉取模型失败: ${error.message}`);
            }
        });
            document.getElementById('add-world-book-btn').addEventListener('click', async () => { const name = await showCustomPrompt('创建世界书', '请输入书名'); if (name && name.trim()) { const newBook = { id: 'wb_' + Date.now(), name: name.trim(), content: '' }; await db.worldBooks.add(newBook); state.worldBooks.push(newBook); renderWorldBookScreen(); openWorldBookEditor(newBook.id); } });
            document.getElementById('save-world-book-btn').addEventListener('click', async () => { if (!editingWorldBookId) return; const book = state.worldBooks.find(wb => wb.id === editingWorldBookId); if (book) { const newName = document.getElementById('world-book-name-input').value.trim(); if (!newName) { alert('书名不能为空！'); return; } book.name = newName; book.content = document.getElementById('world-book-content-input').value; 

        // ▼▼▼ 【核心修改】在这里保存分类ID ▼▼▼
        const categoryId = document.getElementById('world-book-category-select').value;
        // 如果选择了“未分类”，存入 null；否则存入数字ID
        book.categoryId = categoryId ? parseInt(categoryId) : null; 
        // ▲▲▲ 修改结束 ▲▲▲

await db.worldBooks.put(book); document.getElementById('world-book-editor-title').textContent = newName; editingWorldBookId = null; renderWorldBookScreen(); showScreen('world-book-screen'); } });
            document.getElementById('chat-messages').addEventListener('click', (e) => { const aiImage = e.target.closest('.ai-generated-image'); if (aiImage) { const description = aiImage.dataset.description; if (description) showCustomAlert('照片描述', description); return; }  });
            
            const chatSettingsModal = document.getElementById('chat-settings-modal');
            const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
            const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');

function updateWorldBookSelectionDisplay() { const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input:checked'); const displayText = document.querySelector('.selected-options-text'); if (checkedBoxes.length === 0) { displayText.textContent = '-- 点击选择 --'; } else if (checkedBoxes.length > 2) { displayText.textContent = `已选择 ${checkedBoxes.length} 项`; } else { displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', '); } }        
            
            worldBookSelectBox.addEventListener('click', (e) => { e.stopPropagation(); worldBookCheckboxesContainer.classList.toggle('visible'); worldBookSelectBox.classList.toggle('expanded'); });
            document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
            window.addEventListener('click', (e) => { if (!document.querySelector('.custom-multiselect').contains(e.target)) { worldBookCheckboxesContainer.classList.remove('visible'); worldBookSelectBox.classList.remove('expanded'); } });

// ▼▼▼ 请用这段【完整、全新的代码】替换旧的 chat-settings-btn 点击事件 ▼▼▼
document.getElementById('chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const isGroup = chat.isGroup;

    // --- 统一显示/隐藏控件 ---
    document.getElementById('chat-name-group').style.display = 'block';
    document.getElementById('my-persona-group').style.display = 'block';
    document.getElementById('my-avatar-group').style.display = 'block';
    document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
    document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';
    
    // 【核心修改1】根据是否为群聊，显示或隐藏“好友分组”区域
    document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';
    
    // --- 加载表单数据 ---
    document.getElementById('chat-name-input').value = chat.name;
    document.getElementById('my-persona').value = chat.settings.myPersona;
    document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
    document.getElementById('max-memory').value = chat.settings.maxMemory;
    const bgPreview = document.getElementById('bg-preview');
    const removeBgBtn = document.getElementById('remove-bg-btn');
    if (chat.settings.background) {
        bgPreview.src = chat.settings.background;
        bgPreview.style.display = 'block';
        removeBgBtn.style.display = 'inline-block';
    } else {
        bgPreview.style.display = 'none';
        removeBgBtn.style.display = 'none';
    }

    if (isGroup) {
        document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
        document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
        renderGroupMemberSettings(chat.members);
    } else {
        document.getElementById('ai-persona').value = chat.settings.aiPersona;
        document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;
        
        // 【核心修改2】如果是单聊，就加载分组列表到下拉框
        const select = document.getElementById('assign-group-select');
        select.innerHTML = '<option value="">未分组</option>'; // 清空并设置默认选项
        const groups = await db.qzoneGroups.toArray();
        groups.forEach(group => {
            const option = document.createElement('option');
            option.value = group.id;
            option.textContent = group.name;
            // 如果当前好友已经有分组，就默认选中它
            if (chat.groupId === group.id) {
                option.selected = true;
            }
            select.appendChild(option);
        }); 
    }
    
    // 加载世界书
// ▼▼▼ 用下面这段【全新逻辑】替换掉原来简单的 forEach 循环 ▼▼▼

const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
worldBookCheckboxesContainer.innerHTML = '';
const linkedIds = new Set(chat.settings.linkedWorldBookIds || []);

// 1. 获取所有分类和世界书
const categories = await db.worldBookCategories.toArray();
const books = state.worldBooks;

// 【核心改造】如果存在未分类的书籍，就创建一个“虚拟分类”
const hasUncategorized = books.some(book => !book.categoryId);
if (hasUncategorized) {
    categories.push({ id: 'uncategorized', name: '未分类' });
}

// 2. 将书籍按分类ID进行分组
const booksByCategoryId = books.reduce((acc, book) => {
    const categoryId = book.categoryId || 'uncategorized';
    if (!acc[categoryId]) {
        acc[categoryId] = [];
    }
    acc[categoryId].push(book);
    return acc;
}, {});

// 3. 遍历分类，创建带折叠功能的列表
categories.forEach(category => {
    const booksInCategory = booksByCategoryId[category.id] || [];
    if (booksInCategory.length > 0) {
        const allInCategoryChecked = booksInCategory.every(book => linkedIds.has(book.id));
        
        const header = document.createElement('div');
        header.className = 'wb-category-header';
        header.innerHTML = `
            <span class="arrow">▼</span>
            <input type="checkbox" class="wb-category-checkbox" data-category-id="${category.id}" ${allInCategoryChecked ? 'checked' : ''}>
            <span>${category.name}</span>
        `;
        
        const bookContainer = document.createElement('div');
        bookContainer.className = 'wb-book-container';
        bookContainer.dataset.containerFor = category.id;

        booksInCategory.forEach(book => {
            const isChecked = linkedIds.has(book.id);
            const label = document.createElement('label');
    label.innerHTML = `<input type="checkbox" class="wb-book-checkbox" value="${book.id}" data-parent-category="${category.id}" ${isChecked ? 'checked' : ''}> ${book.name}`;
    bookContainer.appendChild(label);
});

        // --- ★ 核心修改 #1 在这里 ★ ---
        // 默认将分类设置为折叠状态
        header.classList.add('collapsed');
        bookContainer.classList.add('collapsed');
        // --- ★ 修改结束 ★ ---

        worldBookCheckboxesContainer.appendChild(header);
        worldBookCheckboxesContainer.appendChild(bookContainer);
    }
});

updateWorldBookSelectionDisplay(); // 更新顶部的已选数量显示

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 在 updateWorldBookSelectionDisplay(); 的下一行，粘贴这整块新代码 ▼▼▼

// 使用事件委托来处理所有点击和勾选事件，效率更高
worldBookCheckboxesContainer.addEventListener('click', (e) => {
    const header = e.target.closest('.wb-category-header');
    if (header && !e.target.matches('input[type="checkbox"]')) {
        const categoryId = header.querySelector('.wb-category-checkbox')?.dataset.categoryId;
        // 【修改】现在 categoryId 可能是数字，也可能是 "uncategorized" 字符串，所以这个判断能通过了！
        if (categoryId) { // <-- 把原来的 !categoryId return; 改成这样
            const bookContainer = worldBookCheckboxesContainer.querySelector(`.wb-book-container[data-container-for="${categoryId}"]`);
            if (bookContainer) {
                header.classList.toggle('collapsed');
                bookContainer.classList.toggle('collapsed');
            }
        }
    }
});

worldBookCheckboxesContainer.addEventListener('change', (e) => {
    const target = e.target;
    
    // 如果点击的是分类的“全选”复选框
    if (target.classList.contains('wb-category-checkbox')) {
        const categoryId = target.dataset.categoryId;
        const isChecked = target.checked;
        // 找到这个分类下的所有书籍复选框，并将它们的状态设置为与分类复选框一致
        const bookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
        bookCheckboxes.forEach(cb => cb.checked = isChecked);
    }
    
    // 如果点击的是单个书籍的复选框
    if (target.classList.contains('wb-book-checkbox')) {
        const categoryId = target.dataset.parentCategory;
        if (categoryId) { // 检查它是否属于一个分类
            const categoryCheckbox = worldBookCheckboxesContainer.querySelector(`input.wb-category-checkbox[data-category-id="${categoryId}"]`);
            const allBookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
            // 检查该分类下是否所有书籍都被选中了
            const allChecked = Array.from(allBookCheckboxes).every(cb => cb.checked);
            // 同步分类“全选”复选框的状态
            categoryCheckbox.checked = allChecked;
        }
    }
    
    // 每次变更后都更新顶部的已选数量显示
    updateWorldBookSelectionDisplay();
});

// ▲▲▲ 粘贴结束 ▲▲▲

    // 加载并更新所有预览相关控件
    const themeRadio = document.querySelector(`input[name="theme-select"][value="${chat.settings.theme || 'default'}"]`);
    if (themeRadio) themeRadio.checked = true;
    const fontSizeSlider = document.getElementById('font-size-slider');
    fontSizeSlider.value = chat.settings.fontSize || 13;
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    const customCssInput = document.getElementById('custom-css-input');
    customCssInput.value = chat.settings.customCss || '';
    
    updateSettingsPreview(); 
    document.getElementById('chat-settings-modal').classList.add('visible');
});
// ▲▲▲ 替换结束 ▲▲▲
            
function renderGroupMemberSettings(members) { 
    const container = document.getElementById('group-members-settings'); 
    container.innerHTML = ''; 
    members.forEach(member => { 
        const div = document.createElement('div'); 
        div.className = 'member-editor'; 
        div.dataset.memberId = member.id; 
        // ★★★【核心重构】★★★
        // 显示的是 groupNickname
        div.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`; 
        div.addEventListener('click', () => openMemberEditor(member.id)); 
        container.appendChild(div); 
    }); 
}

function openMemberEditor(memberId) { 
    editingMemberId = memberId; 
    const chat = state.chats[state.activeChatId]; 
    const member = chat.members.find(m => m.id === memberId); 
    document.getElementById('member-name-input').value = member.groupNickname; 
    document.getElementById('member-persona-input').value = member.persona; 
    document.getElementById('member-avatar-preview').src = member.avatar; 
    document.getElementById('member-settings-modal').classList.add('visible'); 
}
            document.getElementById('cancel-member-settings-btn').addEventListener('click', () => { document.getElementById('member-settings-modal').classList.remove('visible'); editingMemberId = null; });
            document.getElementById('save-member-settings-btn').addEventListener('click', () => { 
    if (!editingMemberId) return; 
    const chat = state.chats[state.activeChatId]; 
    const member = chat.members.find(m => m.id === editingMemberId); 
    
    // ★★★【核心重构】★★★
    const newNickname = document.getElementById('member-name-input').value.trim();
    if (!newNickname) {
        alert("群昵称不能为空！");
        return;
    }
    member.groupNickname = newNickname; // 只修改群昵称
    member.persona = document.getElementById('member-persona-input').value; 
    member.avatar = document.getElementById('member-avatar-preview').src; 
    
    renderGroupMemberSettings(chat.members); 
    document.getElementById('member-settings-modal').classList.remove('visible'); 
});
            document.getElementById('reset-theme-btn').addEventListener('click', () => { document.getElementById('theme-default').checked = true; });
            document.getElementById('cancel-chat-settings-btn').addEventListener('click', () => { chatSettingsModal.classList.remove('visible'); });

document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const newName = document.getElementById('chat-name-input').value.trim();
    if (!newName) return alert('备注名/群名不能为空！');
    chat.name = newName;
    const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
    chat.settings.theme = selectedThemeRadio ? selectedThemeRadio.value : 'default';

    chat.settings.fontSize = parseInt(document.getElementById('font-size-slider').value);
    chat.settings.customCss = document.getElementById('custom-css-input').value.trim();

    chat.settings.myPersona = document.getElementById('my-persona').value;
    chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
const checkedBooks = document.querySelectorAll('#world-book-checkboxes-container input.wb-book-checkbox:checked');
    chat.settings.linkedWorldBookIds = Array.from(checkedBooks).map(cb => cb.value);

    if (chat.isGroup) {
        chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
        chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
    } else {
        chat.settings.aiPersona = document.getElementById('ai-persona').value;
        chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
        const selectedGroupId = document.getElementById('assign-group-select').value;
        chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
    }

    chat.settings.maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
    await db.chats.put(chat);

    applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');
    
    chatSettingsModal.classList.remove('visible');
    renderChatInterface(state.activeChatId);
    renderChatList();
});
            document.getElementById('clear-chat-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const confirmed = await showCustomConfirm('清空聊天记录', '此操作将永久删除此聊天的所有消息，无法恢复。确定要清空吗？', { confirmButtonClass: 'btn-danger' }); if (confirmed) { chat.history = []; await db.chats.put(chat); renderChatInterface(state.activeChatId); renderChatList(); chatSettingsModal.classList.remove('visible'); } });
            
            const setupFileUpload = (inputId, callback) => { document.getElementById(inputId).addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); callback(dataUrl); event.target.value = null; } }); };
            setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
            setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
            setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
            setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);
            setupFileUpload('bg-input', (base64) => { if(state.activeChatId) { state.chats[state.activeChatId].settings.background = base64; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = base64; bgPreview.style.display = 'block'; document.getElementById('remove-bg-btn').style.display = 'inline-block'; } });
            setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
            document.getElementById('remove-bg-btn').addEventListener('click', () => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = ''; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = ''; bgPreview.style.display = 'none'; document.getElementById('remove-bg-btn').style.display = 'none'; } });

            const stickerPanel = document.getElementById('sticker-panel');
            document.getElementById('open-sticker-panel-btn').addEventListener('click', () => { renderStickerPanel(); stickerPanel.classList.add('visible'); });
            document.getElementById('close-sticker-panel-btn').addEventListener('click', () => stickerPanel.classList.remove('visible'));
            document.getElementById('add-sticker-btn').addEventListener('click', async () => { const url = await showCustomPrompt("添加表情(URL)", "请输入表情包的图片URL"); if (!url || !url.trim().startsWith('http')) return url && alert("请输入有效的URL (以http开头)"); const name = await showCustomPrompt("命名表情", "请为这个表情命名 (例如：开心、疑惑)"); if (name && name.trim()) { const newSticker = { id: 'sticker_' + Date.now(), url: url.trim(), name: name.trim() }; await db.userStickers.add(newSticker); state.userStickers.push(newSticker); renderStickerPanel(); } else if (name !== null) alert("表情名不能为空！"); });
            document.getElementById('upload-sticker-btn').addEventListener('click', () => document.getElementById('sticker-upload-input').click());
            document.getElementById('sticker-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.readAsDataURL(file); reader.onload = async () => { const base64Url = reader.result; const name = await showCustomPrompt("命名表情", "请为这个表情命名 (例如：好耶、疑惑)"); if (name && name.trim()) { const newSticker = { id: 'sticker_' + Date.now(), url: base64Url, name: name.trim() }; await db.userStickers.add(newSticker); state.userStickers.push(newSticker); renderStickerPanel(); } else if (name !== null) alert("表情名不能为空！"); }; event.target.value = null; });

            document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
            document.getElementById('image-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file || !state.activeChatId) return; const reader = new FileReader(); reader.onload = async (e) => { const base64Url = e.target.result; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: [{ type: 'image_url', image_url: { url: base64Url } }], timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); }; reader.readAsDataURL(file); event.target.value = null; });
            document.getElementById('voice-message-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const text = await showCustomPrompt("发送语音", "请输入你想说的内容："); if (text && text.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'voice_message', content: text.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });
            document.getElementById('send-photo-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const description = await showCustomPrompt("发送照片", "请用文字描述您要发送的照片："); if (description && description.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'user_photo', content: description.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });

// ▼▼▼ 【全新】外卖请求功能事件绑定 ▼▼▼
const waimaiModal = document.getElementById('waimai-request-modal');
document.getElementById('send-waimai-request-btn').addEventListener('click', () => {
    waimaiModal.classList.add('visible');
});

document.getElementById('waimai-cancel-btn').addEventListener('click', () => {
    waimaiModal.classList.remove('visible');
});

document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    
    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');
    
    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    if (!productInfo) {
        alert('请输入商品信息！');
        return;
    }
    if (isNaN(amount) || amount <= 0) {
        alert('请输入有效的代付金额！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();

    // 【核心修正】在这里获取用户自己的昵称
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const msg = {
        role: 'user',
        // 【核心修正】将获取到的昵称，作为 senderName 添加到消息对象中
        senderName: myNickname, 
        type: 'waimai_request',
        productInfo: productInfo,
        amount: amount,
        status: 'pending',
        countdownEndTime: now + 15 * 60 * 1000,
        timestamp: now
    };

    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();

    productInfoInput.value = '';
    amountInput.value = '';
    waimaiModal.classList.remove('visible');
});         
            document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
            document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
            document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
            document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);
            document.getElementById('save-persona-preset-btn').addEventListener('click', savePersonaPreset);
            document.getElementById('preset-action-edit').addEventListener('click', openPersonaEditorForEdit);
            document.getElementById('preset-action-delete').addEventListener('click', deletePersonaPreset);
            document.getElementById('preset-action-cancel').addEventListener('click', hidePresetActions);
            
            document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);

// ▼▼▼ 【最终加强版】用这块代码替换旧的 selection-delete-btn 事件监听器 ▼▼▼
document.getElementById('selection-delete-btn').addEventListener('click', async () => {
    if (selectedMessages.size === 0) return;
    const confirmed = await showCustomConfirm('删除消息', `确定要删除选中的 ${selectedMessages.size} 条消息吗？这将改变AI的记忆。`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        
        // 1. 【核心加强】在删除前，检查被删除的消息中是否包含投票
        let deletedPollsInfo = [];
        for (const timestamp of selectedMessages) {
            const msg = chat.history.find(m => m.timestamp === timestamp);
            if (msg && msg.type === 'poll') {
                deletedPollsInfo.push(`关于“${msg.question}”的投票(时间戳: ${msg.timestamp})`);
            }
        }
        
        // 2. 更新后端的历史记录
        chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));
        
        // 3. 【核心加强】构建更具体的“遗忘指令”
        let forgetReason = "一些之前的消息已被用户删除。";
        if (deletedPollsInfo.length > 0) {
            forgetReason += ` 其中包括以下投票：${deletedPollsInfo.join('；')}。`;
        }
        forgetReason += " 你应该像它们从未存在过一样继续对话，并相应地调整你的记忆和行为，不要再提及这些被删除的内容。";

        const forgetInstruction = {
            role: 'system',
            content: `[系统提示：${forgetReason}]`,
            timestamp: Date.now(),
            isHidden: true 
        };
        chat.history.push(forgetInstruction);
        
        // 4. 将包含“遗忘指令”的、更新后的chat对象存回数据库
        await db.chats.put(chat);
        
        // 5. 最后才更新UI
        renderChatInterface(state.activeChatId);
        renderChatList();
    }
});
// ▲▲▲ 替换结束 ▲▲▲

            const fontUrlInput = document.getElementById('font-url-input');
            fontUrlInput.addEventListener('input', () => applyCustomFont(fontUrlInput.value.trim(), true));
            document.getElementById('save-font-btn').addEventListener('click', async () => {
                const newFontUrl = fontUrlInput.value.trim();
                if (!newFontUrl) { alert("请输入有效的字体URL。"); return; }
                applyCustomFont(newFontUrl, false);
                state.globalSettings.fontUrl = newFontUrl;
                await db.globalSettings.put(state.globalSettings);
                alert('字体已保存并应用！');
            });
            document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);

            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => { item.addEventListener('click', () => switchToChatListView(item.dataset.view)); });
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('qzone-nickname').addEventListener('click', async () => { const newNickname = await showCustomPrompt("修改昵称", "请输入新的昵称", state.qzoneSettings.nickname); if (newNickname && newNickname.trim()) { state.qzoneSettings.nickname = newNickname.trim(); await saveQzoneSettings(); renderQzoneScreen(); } });
            document.getElementById('qzone-avatar-container').addEventListener('click', () => document.getElementById('qzone-avatar-input').click());
            document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
            document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.avatar = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
            document.getElementById('qzone-banner-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.banner = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });

// ▼▼▼ 【修正后】的“说说”按钮事件 ▼▼▼
document.getElementById('create-shuoshuo-btn').addEventListener('click', async () => {
    // 1. 重置并获取模态框
    resetCreatePostModal();
    const modal = document.getElementById('create-post-modal');
    
    // 2. 设置为“说说”模式
    modal.dataset.mode = 'shuoshuo';
    
    // 3. 隐藏与图片/文字图相关的部分
    modal.querySelector('.post-mode-switcher').style.display = 'none';
    modal.querySelector('#image-mode-content').style.display = 'none';
    modal.querySelector('#text-image-mode-content').style.display = 'none';
    
    // 4. 修改主输入框的提示语，使其更符合“说说”的场景
    modal.querySelector('#post-public-text').placeholder = '分享新鲜事...';
    
    // 5. 准备并显示模态框
    const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
    visibilityGroupsContainer.innerHTML = '';
    const groups = await db.qzoneGroups.toArray();
    if (groups.length > 0) {
        groups.forEach(group => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
            visibilityGroupsContainer.appendChild(label);
        });
    } else {
        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">没有可用的分组</p>';
    }
    modal.classList.add('visible');
});

// ▼▼▼ 【修正后】的“动态”（图片）按钮事件 ▼▼▼
document.getElementById('create-post-btn').addEventListener('click', async () => {
    // 1. 重置并获取模态框
    resetCreatePostModal();
    const modal = document.getElementById('create-post-modal');
    
    // 2. 设置为“复杂动态”模式
    modal.dataset.mode = 'complex';
    
// 3. 确保与图片/文字图相关的部分是可见的
modal.querySelector('.post-mode-switcher').style.display = 'flex';
// 显式激活“上传图片”模式...
modal.querySelector('#image-mode-content').classList.add('active');
// ...同时确保“文字图”模式是隐藏的
modal.querySelector('#text-image-mode-content').classList.remove('active');
    
    // 4. 恢复主输入框的默认提示语
    modal.querySelector('#post-public-text').placeholder = '分享新鲜事...（非必填的公开文字）';

    // 5. 准备并显示模态框（与“说说”按钮的逻辑相同）
    const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
    visibilityGroupsContainer.innerHTML = '';
    const groups = await db.qzoneGroups.toArray();
    if (groups.length > 0) {
        groups.forEach(group => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
            visibilityGroupsContainer.appendChild(label);
        });
    } else {
        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">没有可用的分组</p>';
    }
    modal.classList.add('visible');
});
            document.getElementById('open-album-btn').addEventListener('click', async () => { await renderAlbumList(); showScreen('album-screen'); });
            document.getElementById('album-back-btn').addEventListener('click', () => { showScreen('chat-list-screen'); switchToChatListView('qzone-screen'); });

// --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

document.getElementById('album-photos-back-btn').addEventListener('click', () => {
    state.activeAlbumId = null;
    showScreen('album-screen');
});

document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());

document.getElementById('album-photo-input').addEventListener('change', async (event) => {
    if (!state.activeAlbumId) return;
    const files = event.target.files;
    if (!files.length) return;

    const album = await db.qzoneAlbums.get(state.activeAlbumId);
    
    for (const file of files) {
        const dataUrl = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(file);
        });
        await db.qzonePhotos.add({ albumId: state.activeAlbumId, url: dataUrl, createdAt: Date.now() });
    }

    const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
    const updateData = { photoCount };
    
    if (!album.photoCount || album.coverUrl.includes('placeholder')) {
        const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
        if(firstPhoto) updateData.coverUrl = firstPhoto.url;
    }

    await db.qzoneAlbums.update(state.activeAlbumId, updateData);
    await renderAlbumPhotosScreen();
    await renderAlbumList();
    
    event.target.value = null;
    alert('照片上传成功！');
});

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---

// --- ↓↓↓ 从这里开始复制，完整替换掉旧的 photos-grid-page 监听器 ↓↓↓ ---

document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
    const deleteBtn = e.target.closest('.photo-delete-btn');
    const photoThumb = e.target.closest('.photo-thumb');

    if (deleteBtn) {
        e.stopPropagation(); // 阻止事件冒泡到图片上
        const photoId = parseInt(deleteBtn.dataset.photoId);
        const confirmed = await showCustomConfirm(
            '删除照片',
            '确定要删除这张照片吗？此操作不可恢复。',
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            const deletedPhoto = await db.qzonePhotos.get(photoId);
            if (!deletedPhoto) return;
            
            await db.qzonePhotos.delete(photoId);

            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            const photoCount = (album.photoCount || 1) - 1;
            const updateData = { photoCount };
            
            if (album.coverUrl === deletedPhoto.url) {
                const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            }
            
            await db.qzoneAlbums.update(state.activeAlbumId, updateData);
            await renderAlbumPhotosScreen();
            await renderAlbumList();
            alert('照片已删除。');
        }
    } 
    else if (photoThumb) {
        // 这就是恢复的图片点击放大功能！
        openPhotoViewer(photoThumb.src);
    }
});

// 恢复图片查看器的控制事件
document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);

// 恢复键盘左右箭头和ESC键的功能
document.addEventListener('keydown', (e) => {
    if (!photoViewerState.isOpen) return; 

    if (e.key === 'ArrowRight') {
        showNextPhoto();
    } else if (e.key === 'ArrowLeft') {
        showPrevPhoto();
    } else if (e.key === 'Escape') {
        closePhotoViewer();
    }
});

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
         
document.getElementById('create-album-btn-page').addEventListener('click', async () => { const albumName = await showCustomPrompt("创建新相册", "请输入相册名称"); if (albumName && albumName.trim()) { const newAlbum = { name: albumName.trim(), coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png', photoCount: 0, createdAt: Date.now() }; await db.qzoneAlbums.add(newAlbum); await renderAlbumList(); alert(`相册 "${albumName}" 创建成功！`); } else if (albumName !== null) { alert("相册名称不能为空！"); } });

            document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
            document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
            document.getElementById('post-local-image-input').addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { document.getElementById('post-image-preview').src = e.target.result; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; }; reader.readAsDataURL(file); } });
            document.getElementById('post-use-url-btn').addEventListener('click', async () => { const url = await showCustomPrompt("输入图片URL", "请输入网络图片的链接", "", "url"); if (url) { document.getElementById('post-image-preview').src = url; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; } });
            document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
            const imageModeBtn = document.getElementById('switch-to-image-mode');
            const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
            const imageModeContent = document.getElementById('image-mode-content');
            const textImageModeContent = document.getElementById('text-image-mode-content');
            imageModeBtn.addEventListener('click', () => { imageModeBtn.classList.add('active'); textImageModeBtn.classList.remove('active'); imageModeContent.classList.add('active'); textImageModeContent.classList.remove('active'); });
            textImageModeBtn.addEventListener('click', () => { textImageModeBtn.classList.add('active'); imageModeBtn.classList.remove('active'); textImageModeContent.classList.add('active'); imageModeContent.classList.remove('active'); });

// ▼▼▼ 【最终修正版】的“发布”按钮事件，已修复权限漏洞 ▼▼▼
document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
    const modal = document.getElementById('create-post-modal');
    const mode = modal.dataset.mode;
    
    // --- 1. 获取通用的可见性设置 ---
    const visibilityMode = document.querySelector('input[name="visibility"]:checked').value;
    let visibleGroupIds = null;
    
    if (visibilityMode === 'include') {
        visibleGroupIds = Array.from(document.querySelectorAll('input[name="visibility_group"]:checked')).map(cb => parseInt(cb.value));
    }

    let newPost = {};
    const basePostData = {
        timestamp: Date.now(),
        authorId: 'user',
        // 【重要】在这里就把权限信息存好
        visibleGroupIds: visibleGroupIds,
    };

    // --- 2. 根据模式构建不同的 post 对象 ---
    if (mode === 'shuoshuo') {
        const content = document.getElementById('post-public-text').value.trim();
        if (!content) {
            alert('说说内容不能为空哦！');
            return;
        }
        newPost = {
            ...basePostData,
            type: 'shuoshuo',
            content: content,
        };

    } else { // 处理 'complex' 模式 (图片/文字图)
        const publicText = document.getElementById('post-public-text').value.trim();
        const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');

        if (isImageModeActive) {
            const imageUrl = document.getElementById('post-image-preview').src;
            const imageDescription = document.getElementById('post-image-description').value.trim();
            if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) {
                alert('请先添加一张图片再发布动态哦！');
                return;
            }
            if (!imageDescription) {
                alert('请为你的图片添加一个简单的描述（必填，给AI看的）！');
                return;
            }
            newPost = {
                ...basePostData,
                type: 'image_post',
                publicText: publicText,
                imageUrl: imageUrl,
                imageDescription: imageDescription,
            };
        } else { // 文字图模式
            const hiddenText = document.getElementById('post-hidden-text').value.trim();
            if (!hiddenText) {
                alert('请输入文字图描述！');
                return;
            }
            newPost = {
                ...basePostData,
                type: 'text_image',
                publicText: publicText,
                hiddenContent: hiddenText,
            };
        }
    }

    // --- 3. 保存到数据库 ---
    const newPostId = await db.qzonePosts.add(newPost);
    let postSummary = newPost.content || newPost.publicText || newPost.imageDescription || newPost.hiddenContent || "（无文字内容）";
    postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');

    // --- 4. 【核心修正】带有权限检查的通知循环 ---
    for (const chatId in state.chats) {
        const chat = state.chats[chatId];
        if (chat.isGroup) continue; // 跳过群聊

        let shouldNotify = false;
        const postVisibleGroups = newPost.visibleGroupIds;

        // 判断条件1：如果动态是公开的 (没有设置任何可见分组)
        if (!postVisibleGroups || postVisibleGroups.length === 0) {
            shouldNotify = true;
        } 
        // 判断条件2：如果动态设置了部分可见，并且当前角色在可见分组内
        else if (chat.groupId && postVisibleGroups.includes(chat.groupId)) {
            shouldNotify = true;
        }

        // 只有满足条件的角色才会被通知
        if (shouldNotify) {
            const historyMessage = {
                role: 'system',
                content: `[系统提示：用户刚刚发布了一条动态(ID: ${newPostId})，内容摘要是：“${postSummary}”。你现在可以对这条动态进行评论了。]`,
                timestamp: Date.now(),
                isHidden: true
            };
            chat.history.push(historyMessage);
            await db.chats.put(chat);
        }
    }
    // --- 修正结束 ---

    await renderQzonePosts();
    modal.classList.remove('visible');
    alert('动态发布成功！');
});

// ▼▼▼ 请用这【一整块】包含所有滑动和点击事件的完整代码，替换掉旧的 postsList 事件监听器 ▼▼▼

const postsList = document.getElementById('qzone-posts-list');
let swipeState = { isDragging: false, startX: 0, startY: 0, currentX: 0, activeContainer: null, swipeDirection: null, isClick: true };

function resetAllSwipes(exceptThisOne = null) {
    document.querySelectorAll('.qzone-post-container').forEach(container => {
        if (container !== exceptThisOne) {
            container.querySelector('.qzone-post-item').classList.remove('swiped');
        }
    });
}

const handleSwipeStart = (e) => {
    const targetContainer = e.target.closest('.qzone-post-container');
    if (!targetContainer) return;

    resetAllSwipes(targetContainer);
    swipeState.activeContainer = targetContainer;
    swipeState.isDragging = true;
    swipeState.isClick = true;
    swipeState.swipeDirection = null;
    swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';
};

const handleSwipeMove = (e) => {
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    const diffX = currentX - swipeState.startX;
    const diffY = currentY - swipeState.startY;
    const absDiffX = Math.abs(diffX);
    const absDiffY = Math.abs(diffY);
    const clickThreshold = 5;

    if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
        swipeState.isClick = false;
    }

    if (swipeState.swipeDirection === null) {
        if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
            if (absDiffX > absDiffY) {
                swipeState.swipeDirection = 'horizontal';
            } else {
                swipeState.swipeDirection = 'vertical';
            }
        }
    }
    if (swipeState.swipeDirection === 'vertical') {
        handleSwipeEnd(e);
        return;
    }
    if (swipeState.swipeDirection === 'horizontal') {
        e.preventDefault();
        swipeState.currentX = currentX;
        let translation = diffX;
        if (translation > 0) translation = 0;
        if (translation < -90) translation = -90;
        swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
    }
};

const handleSwipeEnd = (e) => {
    if (swipeState.isClick) {
        swipeState.isDragging = false;
        swipeState.activeContainer = null;
        return;
    }
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
    postItem.style.transition = 'transform 0.3s ease';

    const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
    const diffX = finalX - swipeState.startX;
    const swipeThreshold = -40;

    if (swipeState.swipeDirection === 'horizontal' && diffX < swipeThreshold) {
        postItem.classList.add('swiped');
        postItem.style.transform = '';
    } else {
        postItem.classList.remove('swiped');
        postItem.style.transform = '';
    }

    swipeState.isDragging = false;
    swipeState.startX = 0;
    swipeState.startY = 0;
    swipeState.currentX = 0;
    swipeState.activeContainer = null;
    swipeState.swipeDirection = null;
    swipeState.isClick = true;
};

// --- 绑定所有滑动事件 ---
postsList.addEventListener('mousedown', handleSwipeStart);
document.addEventListener('mousemove', handleSwipeMove);
document.addEventListener('mouseup', handleSwipeEnd);
postsList.addEventListener('touchstart', handleSwipeStart, { passive: false });
postsList.addEventListener('touchmove', handleSwipeMove, { passive: false });
postsList.addEventListener('touchend', handleSwipeEnd);

// --- 绑定所有点击事件 ---
postsList.addEventListener('click', async (e) => {
    e.stopPropagation();
    const target = e.target;

    // --- 新增：处理评论删除按钮 ---
    if (target.classList.contains('comment-delete-btn')) {
        const postContainer = target.closest('.qzone-post-container');
        if (!postContainer) return;

        const postId = parseInt(postContainer.dataset.postId);
        const commentIndex = parseInt(target.dataset.commentIndex);
        if (isNaN(postId) || isNaN(commentIndex)) return;

        const post = await db.qzonePosts.get(postId);
        if (!post || !post.comments || !post.comments[commentIndex]) return;

        const commentText = post.comments[commentIndex].text;
        const confirmed = await showCustomConfirm(
            '删除评论',
            `确定要删除这条评论吗？\n\n“${commentText.substring(0, 50)}...”`,
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            // 从数组中移除该评论
            post.comments.splice(commentIndex, 1);
            // 更新数据库
            await db.qzonePosts.update(postId, { comments: post.comments });
            // 重新渲染列表以反映更改
            await renderQzonePosts();
            alert('评论已删除。');
        }
        return; // 处理完后直接返回
    }

    if (target.classList.contains('post-actions-btn')) {
        const container = target.closest('.qzone-post-container');
        if (container && container.dataset.postId) {
            showPostActions(parseInt(container.dataset.postId));
        }
        return;
    }

    if (target.closest('.qzone-post-delete-action')) {
        const container = target.closest('.qzone-post-container');
        if (!container) return;
        
        const postIdToDelete = parseInt(container.dataset.postId);
        if (isNaN(postIdToDelete)) return;

        const confirmed = await showCustomConfirm('删除动态', '确定要永久删除这条动态吗？', { confirmButtonClass: 'btn-danger' });

        if (confirmed) {
            container.style.transition = 'all 0.3s ease';
            container.style.transform = 'scale(0.8)';
            container.style.opacity = '0';
        
            setTimeout(async () => {
                 await db.qzonePosts.delete(postIdToDelete);
                 
                 const notificationIdentifier = `(ID: ${postIdToDelete})`;
                 for (const chatId in state.chats) {
                     const chat = state.chats[chatId];
                     const originalHistoryLength = chat.history.length;
                     chat.history = chat.history.filter(msg => !(msg.role === 'system' && msg.content.includes(notificationIdentifier)));
                     if (chat.history.length < originalHistoryLength) {
                         await db.chats.put(chat);
                     }
                 }
                 await renderQzonePosts();
                 alert('动态已删除。');
            }, 300);
        }
        return;
    }

    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("图片内容", hiddenText.replace(/<br>/g, '\n'));
        return;
    }
    const icon = target.closest('.action-icon');
    if (icon) {
        const postContainer = icon.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        if (isNaN(postId)) return;
        if (icon.classList.contains('like')) {
            const post = await db.qzonePosts.get(postId);
            if (!post) return;
            if (!post.likes) post.likes = [];
            const userNickname = state.qzoneSettings.nickname;
            const userLikeIndex = post.likes.indexOf(userNickname);
            if (userLikeIndex > -1) {
                post.likes.splice(userLikeIndex, 1);
            } else {
                post.likes.push(userNickname);
                icon.classList.add('animate-like');
                icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), { once: true });
            }
            await db.qzonePosts.update(postId, { likes: post.likes });
        }
        if (icon.classList.contains('favorite')) {
            const existingFavorite = await db.favorites.where({ type: 'qzone_post', 'content.id': postId }).first();
            if (existingFavorite) {
                await db.favorites.delete(existingFavorite.id);
                await showCustomAlert('提示', '已取消收藏');
            } else {
                const postToSave = await db.qzonePosts.get(postId);
                if (postToSave) {
                    await db.favorites.add({ type: 'qzone_post', content: postToSave, timestamp: Date.now() });
                    await showCustomAlert('提示', '收藏成功！');
                }
            }
        }
        await renderQzonePosts();
        return;
    }
    const sendBtn = target.closest('.comment-send-btn');
    if (sendBtn) {
        const postContainer = sendBtn.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        const commentInput = postContainer.querySelector('.comment-input');
        const commentText = commentInput.value.trim();
        if (!commentText) return alert('评论内容不能为空哦！');
        const post = await db.qzonePosts.get(postId);
        if (!post) return;
        if (!post.comments) post.comments = [];
        post.comments.push({ commenterName: state.qzoneSettings.nickname, text: commentText, timestamp: Date.now() });
        await db.qzonePosts.update(postId, { comments: post.comments });
        for (const chatId in state.chats) {
            const chat = state.chats[chatId];
            if (!chat.isGroup) {
                chat.history.push({ role: 'system', content: `[系统提示：'${state.qzoneSettings.nickname}' 在ID为${postId}的动态下发表了评论：“${commentText}”]`, timestamp: Date.now(), isHidden: true });
                await db.chats.put(chat);
            }
        }
        commentInput.value = '';
        await renderQzonePosts();
        return;
    }
});
// ▲▲▲ 替换结束 ▲▲▲

            // ▼▼▼ 在 init() 函数的事件监听器区域，粘贴下面这两行 ▼▼▼

            // 绑定动态页和收藏页的返回按钮
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

            // ▲▲▲ 添加结束 ▲▲▲

            // ▼▼▼ 在 init() 函数的事件监听器区域，检查并确保你有这段完整的代码 ▼▼▼

            // 收藏页搜索功能
            const searchInput = document.getElementById('favorites-search-input');
            const searchClearBtn = document.getElementById('favorites-search-clear-btn');

            searchInput.addEventListener('input', () => {
                const searchTerm = searchInput.value.trim().toLowerCase();
                
                // 控制清除按钮的显示/隐藏
                searchClearBtn.style.display = searchTerm ? 'block' : 'none';

                if (!searchTerm) {
                    displayFilteredFavorites(allFavoriteItems); // 如果搜索框为空，显示所有
                    return;
                }

                // 筛选逻辑
                const filteredItems = allFavoriteItems.filter(item => {
                    let contentToSearch = '';
                    let authorToSearch = '';

                    if (item.type === 'qzone_post') {
                        const post = item.content;
                        contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
                        if (post.authorId === 'user') {
                            authorToSearch = state.qzoneSettings.nickname;
                        } else if (state.chats[post.authorId]) {
                            authorToSearch = state.chats[post.authorId].name;
                        }
                    } else if (item.type === 'chat_message') {
                        const msg = item.content;
                        if (typeof msg.content === 'string') {
                            contentToSearch = msg.content;
                        }
                        const chat = state.chats[item.chatId];
                        if (chat) {
                           if (msg.role === 'user') {
                                authorToSearch = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                           } else {
                                authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                           }
                        }
                    }
                    
                    // 同时搜索内容和作者，并且不区分大小写
                    return contentToSearch.toLowerCase().includes(searchTerm) || 
                           authorToSearch.toLowerCase().includes(searchTerm);
                });

                displayFilteredFavorites(filteredItems);
            });

            // 清除按钮的点击事件
            searchClearBtn.addEventListener('click', () => {
                searchInput.value = '';
                searchClearBtn.style.display = 'none';
                displayFilteredFavorites(allFavoriteItems);
                searchInput.focus();
            });

            // ▲▲▲ 代码检查结束 ▲▲▲

            // ▼▼▼ 新增/修改的事件监听器 ▼▼▼
            
            // 为聊天界面的批量收藏按钮绑定事件
                        // 为聊天界面的批量收藏按钮绑定事件 (已修正)
            document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
                if (selectedMessages.size === 0) return;
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const favoritesToAdd = [];
                const timestampsToFavorite = [...selectedMessages];

                for (const timestamp of timestampsToFavorite) {
                    // 【核心修正1】使用新的、高效的索引进行查询
                    const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();
                    
                    if (!existing) {
                        const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
                        if (messageToSave) {
                            favoritesToAdd.push({
                                type: 'chat_message',
                                content: messageToSave,
                                chatId: state.activeChatId,
                                timestamp: Date.now(), // 这是收藏操作发生的时间
                                originalTimestamp: messageToSave.timestamp // 【核心修正2】保存原始消息的时间戳到新字段
                            });
                        }
                    }
                }

                if (favoritesToAdd.length > 0) {
                    await db.favorites.bulkAdd(favoritesToAdd);
                    allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray(); // 更新全局收藏缓存
                    await showCustomAlert('收藏成功', `已成功收藏 ${favoritesToAdd.length} 条消息。`);
                } else {
                    await showCustomAlert('提示', '选中的消息均已收藏过。');
                }
                
                exitSelectionMode();
            });

            // 收藏页面的"编辑"按钮事件 (已修正)
            const favoritesEditBtn = document.getElementById('favorites-edit-btn');
            const favoritesView = document.getElementById('favorites-view');
            const favoritesActionBar = document.getElementById('favorites-action-bar');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏
            const favoritesList = document.getElementById('favorites-list'); // 获取收藏列表
            
            favoritesEditBtn.addEventListener('click', () => {
                isFavoritesSelectionMode = !isFavoritesSelectionMode;
                favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);

                if (isFavoritesSelectionMode) {
                    // --- 进入编辑模式 ---
                    favoritesEditBtn.textContent = '完成';
                    favoritesActionBar.style.display = 'block'; // 显示删除操作栏
                    mainBottomNav.style.display = 'none'; // ▼ 新增：隐藏主导航栏
                    favoritesList.style.paddingBottom = '80px'; // ▼ 新增：给列表底部增加空间
                } else {
                    // --- 退出编辑模式 ---
                    favoritesEditBtn.textContent = '编辑';
                    favoritesActionBar.style.display = 'none'; // 隐藏删除操作栏
                    mainBottomNav.style.display = 'flex';  // ▼ 新增：恢复主导航栏
                    favoritesList.style.paddingBottom = ''; // ▼ 新增：恢复列表默认padding

                    // 退出时清空所有选择
                    selectedFavorites.clear();
                    document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
                    document.getElementById('favorites-delete-selected-btn').textContent = `删除 (0)`;
                }
            });

// ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
// 收藏列表的点击选择事件 (事件委托)
document.getElementById('favorites-list').addEventListener('click', (e) => {
    const target = e.target;
    const card = target.closest('.favorite-item-card');

    // 【新增】处理文字图点击，这段逻辑要放在最前面，保证任何模式下都生效
    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("图片内容", hiddenText.replace(/<br>/g, '\n'));
        return; // 处理完就退出，不继续执行选择逻辑
    }
    
    // 如果不在选择模式，则不执行后续的选择操作
    if (!isFavoritesSelectionMode) return;

    // --- 以下是原有的选择逻辑，保持不变 ---
    if (!card) return;

    const favId = parseInt(card.dataset.favid);
    if (isNaN(favId)) return;

    // 切换选择状态
    if (selectedFavorites.has(favId)) {
        selectedFavorites.delete(favId);
        card.classList.remove('selected');
    } else {
        selectedFavorites.add(favId);
        card.classList.add('selected');
    }
    
    // 更新底部删除按钮的计数
    document.getElementById('favorites-delete-selected-btn').textContent = `删除 (${selectedFavorites.size})`;
});

// ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
// 收藏页面批量删除按钮事件
document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
    if (selectedFavorites.size === 0) return;

    const confirmed = await showCustomConfirm(
        '确认删除', 
        `确定要从收藏夹中移除这 ${selectedFavorites.size} 条内容吗？`, 
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const idsToDelete = [...selectedFavorites];
        await db.favorites.bulkDelete(idsToDelete);
        await showCustomAlert('删除成功', '选中的收藏已被移除。');
        
        // 【核心修正1】从前端缓存中也移除被删除的项
        allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));
        
        // 【核心修正2】使用更新后的缓存，立即重新渲染列表
        displayFilteredFavorites(allFavoriteItems);
        
        // 最后，再退出编辑模式
        favoritesEditBtn.click(); // 模拟点击"完成"按钮来退出编辑模式
    }
});

// ▼▼▼ 在 init() 函数末尾添加 ▼▼▼
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log("后台活动模拟已自动启动。");
}
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 【这是最终的正确代码】请粘贴这段代码到 init() 的事件监听器区域末尾 ▼▼▼

// --- 统一处理所有影响预览的控件的事件 ---

// 1. 监听主题选择
document.querySelectorAll('input[name="theme-select"]').forEach(radio => {
    radio.addEventListener('change', updateSettingsPreview);
});

// 2. 监听字体大小滑块
const fontSizeSlider = document.getElementById('font-size-slider');
fontSizeSlider.addEventListener('input', () => {
    // a. 实时更新数值显示
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    // b. 更新预览
    updateSettingsPreview();
});

// 3. 监听自定义CSS输入框
const customCssInputForPreview = document.getElementById('custom-css-input');
customCssInputForPreview.addEventListener('input', updateSettingsPreview);

// 4. 监听重置按钮
document.getElementById('reset-theme-btn').addEventListener('click', () => {
    document.getElementById('theme-default').checked = true;
    updateSettingsPreview();
});

document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
    document.getElementById('custom-css-input').value = '';
    updateSettingsPreview();
});

// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
document.querySelectorAll('input[name="visibility"]').forEach(radio => {
    radio.addEventListener('change', function() {
        const groupsContainer = document.getElementById('post-visibility-groups');
        if (this.value === 'include' || this.value === 'exclude') {
            groupsContainer.style.display = 'block';
        } else {
            groupsContainer.style.display = 'none';
        }
    });
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
document.getElementById('close-group-manager-btn').addEventListener('click', () => {
    document.getElementById('group-management-modal').classList.remove('visible');
    // 刷新聊天设置里的分组列表
    const chatSettingsBtn = document.getElementById('chat-settings-btn');
    if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
       chatSettingsBtn.click(); // 再次点击以重新打开
    }
});

document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
document.getElementById('existing-groups-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) {
        const groupId = parseInt(e.target.dataset.id);
        deleteGroup(groupId);
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
// 消息操作菜单的按钮事件
document.getElementById('cancel-message-action-btn').addEventListener('click', hideMessageActions);
// ▼▼▼ 【修正】使用新的编辑器入口 ▼▼▼
document.getElementById('edit-message-btn').addEventListener('click', openAdvancedMessageEditor);
// ▲▲▲ 替换结束 ▲▲▲
document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);

// ▼▼▼ 在这里添加新代码 ▼▼▼
document.getElementById('recall-message-btn').addEventListener('click', handleRecallClick);
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 请用这段【修正后】的代码替换旧的 select-message-btn 事件监听器 ▼▼▼
document.getElementById('select-message-btn').addEventListener('click', () => {
    // 【核心修复】在关闭菜单前，先捕获时间戳
    const timestampToSelect = activeMessageTimestamp; 
    hideMessageActions();
    // 使用捕获到的值
    if (timestampToSelect) {
        enterSelectionMode(timestampToSelect);
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 在 init() 函数的事件监听器区域末尾添加 ▼▼▼

// 动态操作菜单的按钮事件
document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);

// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 【新增】联系人选择器事件绑定 ▼▼▼
document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
    showScreen('chat-list-screen');
});

document.getElementById('contact-picker-list').addEventListener('click', (e) => {
    const item = e.target.closest('.contact-picker-item');
    if (!item) return;

    const contactId = item.dataset.contactId;
    item.classList.toggle('selected');
    
    if (selectedContacts.has(contactId)) {
        selectedContacts.delete(contactId);
    } else {
        selectedContacts.add(contactId);
    }
    updateContactPickerConfirmButton();
});

// ▼▼▼ 【新增】绑定“管理群成员”按钮事件 ▼▼▼
document.getElementById('manage-members-btn').addEventListener('click', () => {
    // 在切换屏幕前，先隐藏当前的聊天设置弹窗
    document.getElementById('chat-settings-modal').classList.remove('visible');
    // 然后再打开成员管理屏幕
    openMemberManagementScreen();
});
// ▲▲▲ 新增代码结束 ▲▲▲

// ▼▼▼ 【最终完整版】群成员管理功能事件绑定 ▼▼▼
document.getElementById('back-from-member-management').addEventListener('click', () => {

    showScreen('chat-interface-screen');    
    document.getElementById('chat-settings-btn').click();
});
// ▲▲▲ 替换结束 ▲▲▲

document.getElementById('member-management-list').addEventListener('click', (e) => {
    // 【已恢复】移除成员的事件
    if (e.target.classList.contains('remove-member-btn')) {
        removeMemberFromGroup(e.target.dataset.memberId);
    }
});

document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {
    // 【已恢复】从好友列表添加的事件
    // 【关键】为“完成”按钮绑定“拉人入群”的逻辑
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆节点方法清除旧的事件监听器，防止重复绑定
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);
    
    await openContactPickerForAddMember();
});

document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】视频通话功能事件监听器 ▼▼▼

// 绑定单聊和群聊的发起按钮
document.getElementById('video-call-btn').addEventListener('click', handleInitiateCall);
document.getElementById('group-video-call-btn').addEventListener('click', handleInitiateCall);

// 绑定“挂断”按钮
document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);

// 绑定“取消呼叫”按钮
document.getElementById('cancel-call-btn').addEventListener('click', () => {
    videoCallState.isAwaitingResponse = false;
    showScreen('chat-interface-screen');
});

// 【全新】绑定“加入通话”按钮
document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);

// ▼▼▼ 用这个【已修复并激活旁观模式】的版本替换旧的 decline-call-btn 事件监听器 ▼▼▼
// 绑定来电请求的“拒绝”按钮
document.getElementById('decline-call-btn').addEventListener('click', async () => {
    hideIncomingCallModal();
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;
    
    // 【核心修正】在这里，我们将拒绝的逻辑与API调用连接起来
    if (videoCallState.isGroupCall) {
        videoCallState.isUserParticipating = false; // 标记用户为旁观者
        
        // 1. 创建一条隐藏消息，通知AI用户拒绝了
        const systemNote = {
            role: 'system',
            content: `[系统提示：用户拒绝了通话邀请，但你们可以自己开始。请你们各自决策是否加入。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(systemNote);
        await db.chats.put(chat);
        
        // 2. 【关键】触发AI响应，让它们自己决定要不要开始群聊
        // 这将会在后台处理，如果AI们决定开始，最终会调用 startVideoCall()
        await triggerAiResponse(); 
        
    } else { // 单聊拒绝逻辑保持不变
        const declineMessage = { role: 'user', content: '我拒绝了你的视频通话请求。', timestamp: Date.now() };
        chat.history.push(declineMessage);
        await db.chats.put(chat);
        
        // 回到聊天界面并显示拒绝消息
        showScreen('chat-interface-screen');
        appendMessage(declineMessage, chat);
        
        // 让AI对你的拒绝做出回应
        triggerAiResponse();
    }
    
    // 清理状态，以防万一
    videoCallState.isAwaitingResponse = false;
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这个【已修复重复头像BUG】的版本替换旧的 accept-call-btn 事件监听器 ▼▼▼
// 绑定来电请求的“接听”按钮
document.getElementById('accept-call-btn').addEventListener('click', async () => {
    hideIncomingCallModal();
    
    videoCallState.initiator = 'ai';
    videoCallState.isUserParticipating = true;
    videoCallState.activeChatId = state.activeChatId;
    
    // 【核心修正】我们在这里不再手动添加用户到 participants 列表
    if (videoCallState.isGroupCall) {
        // 对于群聊，我们只把【发起通话的AI】加入参与者列表
        const chat = state.chats[videoCallState.activeChatId];
        const requester = chat.members.find(m => m.name === videoCallState.callRequester);
        if (requester) {
            // 清空可能存在的旧数据，然后只添加发起者
            videoCallState.participants = [requester];
        } else {
            videoCallState.participants = []; // 如果找不到发起者，就清空
        }
    }
    
    // 无论单聊还是群聊，直接启动通话界面！
    startVideoCall();
});
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 请用这个【已增加用户高亮】的全新版本，完整替换旧的 user-speak-btn 事件监听器 ▼▼▼
// 绑定用户在通话中发言的按钮
document.getElementById('user-speak-btn').addEventListener('click', async () => {
    if (!videoCallState.isActive) return;

    // ★★★★★ 核心新增：在弹出输入框前，先找到并高亮用户头像 ★★★★★
    const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
    if (userAvatar) {
        userAvatar.classList.add('speaking');
    }

    const userInput = await showCustomPrompt('你说', '请输入你想说的话...');
    
    // ★★★★★ 核心新增：无论用户是否输入，只要关闭输入框就移除高亮 ★★★★★
    if (userAvatar) {
        userAvatar.classList.remove('speaking');
    }

    if (userInput && userInput.trim()) {
        triggerAiInCallAction(userInput.trim());
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【新增】回忆录相关事件绑定 ▼▼▼
// 1. 将“回忆”页签和它的视图连接起来
document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {
    // 在切换前，确保"收藏"页面的编辑模式已关闭
    if (isFavoritesSelectionMode) {
        document.getElementById('favorites-edit-btn').click(); 
    }
    switchToChatListView('memories-view');
    renderMemoriesScreen(); // 点击时渲染
});

// 2. 绑定回忆录界面的返回按钮
document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

// ▲▲▲ 新增结束 ▲▲▲

// 【全新】约定/倒计时功能事件绑定
document.getElementById('add-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.add('visible');
});
document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.remove('visible');
});
document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
    const title = document.getElementById('countdown-title-input').value.trim();
    const dateValue = document.getElementById('countdown-date-input').value;
    
    if (!title || !dateValue) {
        alert('请填写完整的约定标题和日期！');
        return;
    }

    const targetDate = new Date(dateValue);
    if (isNaN(targetDate) || targetDate <= new Date()) {
        alert('请输入一个有效的、未来的日期！');
        return;
    }

    const newCountdown = {
        chatId: null, // 用户创建的，不属于任何特定AI
        authorName: '我',
        description: title,
        timestamp: Date.now(),
        type: 'countdown',
        targetDate: targetDate.getTime()
    };
    
    await db.memories.add(newCountdown);
    document.getElementById('create-countdown-modal').classList.remove('visible');
    renderMemoriesScreen();
});

// 【全新】拉黑功能事件绑定
document.getElementById('block-chat-btn').addEventListener('click', async () => {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;

    const chat = state.chats[state.activeChatId];
    const confirmed = await showCustomConfirm(
        '确认拉黑', 
        `确定要拉黑“${chat.name}”吗？拉黑后您将无法向其发送消息，直到您将Ta移出黑名单，或等待Ta重新申请好友。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：你刚刚被用户拉黑了。在对方解除拉黑之前，你无法再主动发起对话，也无法回应。]`,
            timestamp: Date.now() + 1,
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        
        // 关闭设置弹窗，并刷新聊天界面
        document.getElementById('chat-settings-modal').classList.remove('visible');
        renderChatInterface(state.activeChatId);
        // 刷新聊天列表，可能会有UI变化
        renderChatList();
    }
});

document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    if (e.target.id === 'force-apply-check-btn') {
        alert("正在手动触发好友申请流程，请稍后...\n如果API调用成功，将弹出提示。如果失败，也会有错误提示。如果长时间无反应，说明AI可能决定暂时不申请。");
        await triggerAiFriendApplication(chat.id);
        renderChatInterface(chat.id); 
        return;
    }

    if (e.target.id === 'unblock-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.blockedTimestamp = null;

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：用户刚刚解除了对你的拉黑。现在你们可以重新开始对话了。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        triggerAiResponse(); // 【可选但推荐】解除后让AI主动说点什么
    }
    else if (e.target.id === 'accept-friend-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.applicationReason = '';

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：用户刚刚通过了你的好友申请。你们现在又可以正常聊天了。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        const msg = { role: 'user', content: '我通过了你的好友请求', timestamp: Date.now() };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        triggerAiResponse();
    }
    else if (e.target.id === 'reject-friend-btn') {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();
        chat.relationship.applicationReason = '';
        await db.chats.put(chat);
        renderChatInterface(chat.id);
    }
    // 【新增】处理申请好友按钮的点击事件
    else if (e.target.id === 'apply-friend-btn') {
        const reason = await showCustomPrompt(
            '发送好友申请', 
            `请输入你想对“${chat.name}”说的申请理由：`,
            "我们和好吧！"
        );
        // 只有当用户输入了内容并点击“确定”后才继续
        if (reason !== null) {
            // 更新关系状态为“等待AI批准”
            chat.relationship.status = 'pending_ai_approval';
            chat.relationship.applicationReason = reason;
            await db.chats.put(chat);

            // 刷新UI，显示“等待通过”的界面
            renderChatInterface(chat.id);
            renderChatList();
            
            // 【关键】触发AI响应，让它去处理这个好友申请
            triggerAiResponse();
        }
    }
});

// ▼▼▼ 【全新】红包功能事件绑定 ▼▼▼

// 1. 将原有的转账按钮(￥)的点击事件，重定向到新的总入口函数
document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);

// 2. 红包模态框内部的控制按钮
document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
    document.getElementById('red-packet-modal').classList.remove('visible');
});
document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);

// 3. 红包模态框的页签切换逻辑
const rpTabGroup = document.getElementById('rp-tab-group');
const rpTabDirect = document.getElementById('rp-tab-direct');
const rpContentGroup = document.getElementById('rp-content-group');
const rpContentDirect = document.getElementById('rp-content-direct');

rpTabGroup.addEventListener('click', () => {
    rpTabGroup.classList.add('active');
    rpTabDirect.classList.remove('active');
    rpContentGroup.style.display = 'block';
    rpContentDirect.style.display = 'none';
});
rpTabDirect.addEventListener('click', () => {
    rpTabDirect.classList.add('active');
    rpTabGroup.classList.remove('active');
    rpContentDirect.style.display = 'block';
    rpContentGroup.style.display = 'none';
});

// 4. 实时更新红包金额显示
document.getElementById('rp-group-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-group-total').textContent = `¥ ${amount.toFixed(2)}`;
});
document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-direct-total').textContent = `¥ ${amount.toFixed(2)}`;
});

// ▲▲▲ 新事件绑定结束 ▲▲▲

// ▼▼▼ 【全新添加】使用事件委托处理红包点击，修复失效问题 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 找到被点击的红包卡片
    const packetCard = e.target.closest('.red-packet-card');
    if (!packetCard) return; // 如果点击的不是红包，就什么也不做

    // 2. 从红包卡片的父级.message-bubble获取时间戳
    const messageBubble = packetCard.closest('.message-bubble');
    if (!messageBubble || !messageBubble.dataset.timestamp) return;

    // 3. 调用我们现有的处理函数
    const timestamp = parseInt(messageBubble.dataset.timestamp);
    handlePacketClick(timestamp);
});
// ▲▲▲ 新增代码结束 ▲▲▲

// ▼▼▼ 【全新】投票功能事件监听器 ▼▼▼
// 在输入框工具栏添加按钮
document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);

// 投票创建模态框的按钮
document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
    document.getElementById('create-poll-modal').classList.remove('visible');
});
document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);

// 使用事件委托处理投票卡片内的所有点击事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const pollCard = e.target.closest('.poll-card');
    if (!pollCard) return;

    const timestamp = parseInt(pollCard.dataset.pollTimestamp);
    if (isNaN(timestamp)) return;
    
    // 点击了选项
    const optionItem = e.target.closest('.poll-option-item');
    if (optionItem && !pollCard.classList.contains('closed')) {
        handleUserVote(timestamp, optionItem.dataset.option);
        return;
    }
    
    // 点击了动作按钮（结束投票/查看结果）
    const actionBtn = e.target.closest('.poll-action-btn');
    if (actionBtn) {
        if (pollCard.classList.contains('closed')) {
            showPollResults(timestamp);
        } else {
            endPoll(timestamp);
        }
        return;
    }

    // 如果是已结束的投票，点击卡片任何地方都可以查看结果
    if (pollCard.classList.contains('closed')) {
        showPollResults(timestamp);
    }
});
// ▲▲▲ 新事件监听器粘贴结束 ▲▲▲

  // ▼▼▼ 【全新】AI头像库功能事件绑定 ▼▼▼
document.getElementById('manage-ai-avatar-library-btn').addEventListener('click', openAiAvatarLibraryModal);
document.getElementById('add-ai-avatar-btn').addEventListener('click', addAvatarToLibrary);
document.getElementById('close-ai-avatar-library-btn').addEventListener('click', closeAiAvatarLibraryModal);
// ▲▲▲ 新增结束 ▲▲▲

// ▼▼▼ 在 init() 的事件监听区域，粘贴这段【新代码】▼▼▼
document.getElementById('icon-settings-grid').addEventListener('click', async (e) => {
    if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (!iconId) return;

        const currentUrl = state.globalSettings.appIcons[iconId];
        const newUrl = await showCustomPrompt(`更换“${item.querySelector('.icon-preview').alt}”图标`, '请输入新的图片URL', currentUrl, 'url');

        if (newUrl && newUrl.trim().startsWith('http')) {
            // 仅在内存中更新，等待用户点击“保存”
            state.globalSettings.appIcons[iconId] = newUrl.trim();
            // 实时更新设置页面的预览图
            item.querySelector('.icon-preview').src = newUrl.trim();
        } else if (newUrl !== null) {
            alert("请输入一个有效的URL！");
        }
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼

    document.getElementById('chat-messages').addEventListener('click', (e) => {
        // 使用 .closest() 向上查找被点击的卡片
        const linkCard = e.target.closest('.link-share-card');
        if (linkCard) {
            const timestamp = parseInt(linkCard.dataset.timestamp);
            if (!isNaN(timestamp)) {
                openBrowser(timestamp); // 调用我们的函数
            }
        }
    });

    // 浏览器返回按钮的事件监听，确保它只绑定一次
    document.getElementById('browser-back-btn').addEventListener('click', () => {
        showScreen('chat-interface-screen');
    });

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼

    // 1. 绑定输入框上方“分享链接”按钮的点击事件
    document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);

    // 2. 绑定模态框中“取消”按钮的点击事件
    document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
        document.getElementById('share-link-modal').classList.remove('visible');
    });

    // 3. 绑定模态框中“分享”按钮的点击事件
    document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);

// ▲▲▲ 新代码粘贴结束 ▲▲▲

document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);

// ▼▼▼ 在 init() 的事件监听器区域，粘贴下面这几行 ▼▼▼
// 绑定消息操作菜单中的“引用”按钮
document.getElementById('quote-message-btn').addEventListener('click', startReplyToMessage);

// 绑定回复预览栏中的“取消”按钮
document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);
// ▲▲▲ 粘贴结束 ▲▲▲

// 在你的 init() 函数的事件监听器区域...

// ▼▼▼ 用这段代码替换旧的转账卡片点击事件 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 向上查找被点击的元素是否在一个消息气泡内
    const bubble = e.target.closest('.message-bubble');
    if (!bubble) return; // 如果不在，就退出

    // 2. 【核心修正】在这里添加严格的筛选条件
    // 必须是 AI 的消息 (.ai)
    // 必须是转账类型 (.is-transfer)
    // 必须是我们标记为“待处理”的 (data-status="pending")
    if (bubble.classList.contains('ai') && 
        bubble.classList.contains('is-transfer') && 
        bubble.dataset.status === 'pending') {
        
        // 3. 只有满足所有条件，才执行后续逻辑
        const timestamp = parseInt(bubble.dataset.timestamp);
        if (!isNaN(timestamp)) {
            showTransferActionModal(timestamp);
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// 在 init() 的事件监听区域添加
document.getElementById('transfer-action-accept').addEventListener('click', () => handleUserTransferResponse('accepted'));
document.getElementById('transfer-action-decline').addEventListener('click', () => handleUserTransferResponse('declined'));
document.getElementById('transfer-action-cancel').addEventListener('click', hideTransferActionModal);

// ▼▼▼ 用这段【新代码】替换旧的通话记录事件绑定 ▼▼▼

document.getElementById('chat-list-title').addEventListener('click', renderCallHistoryScreen);

// 2. 绑定通话记录页面的“返回”按钮
document.getElementById('call-history-back-btn').addEventListener('click', () => {
    // 【核心修改】返回到聊天列表页面，而不是聊天界面
    showScreen('chat-list-screen');
});

// 3. 监听卡片点击的逻辑保持不变
document.getElementById('call-history-list').addEventListener('click', (e) => {
    const card = e.target.closest('.call-record-card');
    if (card && card.dataset.recordId) {
        showCallTranscript(parseInt(card.dataset.recordId));
    }
});

// 4. 关闭详情弹窗的逻辑保持不变
document.getElementById('close-transcript-modal-btn').addEventListener('click', () => {
    document.getElementById('call-transcript-modal').classList.remove('visible');
});

// ▲▲▲ 替换结束 ▲▲▲

document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 检查点击的是否是语音条
    const voiceBody = e.target.closest('.voice-message-body');
    if (!voiceBody) return;

    // 2. 找到相关的DOM元素
    const bubble = voiceBody.closest('.message-bubble');
    if (!bubble) return;
    
    const spinner = voiceBody.querySelector('.loading-spinner');
    const transcriptEl = bubble.querySelector('.voice-transcript');

    // 如果正在加载中，则不响应点击
    if (bubble.dataset.state === 'loading') {
        return;
    }

    // 3. 如果文字已经展开，则收起
    if (bubble.dataset.state === 'expanded') {
        transcriptEl.style.display = 'none';
        bubble.dataset.state = 'collapsed';
    } 
    // 4. 如果是收起状态，则开始“转录”流程
    else {
        bubble.dataset.state = 'loading'; // 进入加载状态
        spinner.style.display = 'block';   // 显示加载动画

        // 模拟1.5秒的语音识别过程
        setTimeout(() => {
            // 检查此时元素是否还存在（可能用户已经切换了聊天）
            if (document.body.contains(bubble)) {
                const voiceText = bubble.dataset.voiceText || '(无法识别)';
                transcriptEl.textContent = voiceText; // 填充文字
                
                spinner.style.display = 'none';      // 隐藏加载动画
                transcriptEl.style.display = 'block';// 显示文字
                bubble.dataset.state = 'expanded';     // 进入展开状态
            }
        }, 500);
    }
});

document.getElementById('chat-header-status').addEventListener('click', handleEditStatusClick);

// 在 init() 的事件监听器区域添加
document.getElementById('selection-share-btn').addEventListener('click', () => {
    if (selectedMessages.size > 0) {
        openShareTargetPicker(); // 打开我们即将创建的目标选择器
    }
});

// 在 init() 的事件监听器区域添加
document.getElementById('confirm-share-target-btn').addEventListener('click', async () => {
    const sourceChat = state.chats[state.activeChatId];
    const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
                                   .map(cb => cb.dataset.chatId);

    if (selectedTargetIds.length === 0) {
        alert("请至少选择一个要分享的聊天。");
        return;
    }

    // 1. 打包聊天记录
    const sharedHistory = [];
    const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
    for (const timestamp of sortedTimestamps) {
        const msg = sourceChat.history.find(m => m.timestamp === timestamp);
        if (msg) {
            sharedHistory.push(msg);
        }
    }
    
    // 2. 创建分享卡片消息对象
    const shareCardMessage = {
        role: 'user',
        senderName: sourceChat.isGroup ? (sourceChat.settings.myNickname || '我') : '我',
        type: 'share_card',
        timestamp: Date.now(),
        payload: {
            sourceChatName: sourceChat.name,
            title: `来自“${sourceChat.name}”的聊天记录`,
            sharedHistory: sharedHistory
        }
    };

    // 3. 循环发送到所有目标聊天
    for (const targetId of selectedTargetIds) {
        const targetChat = state.chats[targetId];
        if (targetChat) {
            targetChat.history.push(shareCardMessage);
            await db.chats.put(targetChat);
        }
    }
    
    // 4. 收尾工作
    document.getElementById('share-target-modal').classList.remove('visible');
    exitSelectionMode(); // 退出多选模式
    await showCustomAlert("分享成功", `聊天记录已成功分享到 ${selectedTargetIds.length} 个会话中。`);
    renderChatList(); // 刷新列表，可能会有新消息提示
});

// 绑定取消按钮
document.getElementById('cancel-share-target-btn').addEventListener('click', () => {
    document.getElementById('share-target-modal').classList.remove('visible');
});

// 在 init() 的事件监听器区域添加
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // ...你已有的其他点击事件逻辑...

    // 新增逻辑：处理分享卡片的点击
    const shareCard = e.target.closest('.link-share-card[data-timestamp]');
    if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(shareCard.dataset.timestamp);
        openSharedHistoryViewer(timestamp);
    }
});

// 绑定查看器的关闭按钮
document.getElementById('close-shared-history-viewer-btn').addEventListener('click', () => {
    document.getElementById('shared-history-viewer-modal').classList.remove('visible');
});

// 创建新函数来处理渲染逻辑
function openSharedHistoryViewer(timestamp) {
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_card') return;

    const viewerModal = document.getElementById('shared-history-viewer-modal');
    const viewerTitle = document.getElementById('shared-history-viewer-title');
    const viewerContent = document.getElementById('shared-history-viewer-content');

    viewerTitle.textContent = message.payload.title;
    viewerContent.innerHTML = ''; // 清空旧内容

    // 【核心】复用 createMessageElement 来渲染每一条被分享的消息
    message.payload.sharedHistory.forEach(sharedMsg => {
        // 注意：这里我们传入的是 sourceChat 对象，以确保头像、昵称等正确
        const sourceChat = Object.values(state.chats).find(c => c.name === message.payload.sourceChatName) || chat;
        const bubbleEl = createMessageElement(sharedMsg, sourceChat);
        if (bubbleEl) {
            viewerContent.appendChild(bubbleEl);
        }
    });

    viewerModal.classList.add('visible');
}

audioPlayer.addEventListener('timeupdate', updateMusicProgressBar);

audioPlayer.addEventListener('pause', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = false; 
        updatePlayerUI(); 
    } 
});
audioPlayer.addEventListener('play', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = true; 
        updatePlayerUI(); 
    } 
});

document.getElementById('playlist-body').addEventListener('click', async (e) => {
    const target = e.target;
    if (target.classList.contains('delete-track-btn')) {
        const index = parseInt(target.dataset.index);
        const track = musicState.playlist[index];
        const confirmed = await showCustomConfirm('删除歌曲', `确定要从播放列表中删除《${track.name}》吗？`);
        if (confirmed) {
            deleteTrack(index);
        }
        return;
    }
    if (target.classList.contains('lyrics-btn')) {
        const index = parseInt(target.dataset.index);
        if (isNaN(index)) return;
        const lrcContent = await new Promise(resolve => {
            const lrcInput = document.getElementById('lrc-upload-input');
            const handler = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (re) => resolve(re.target.result);
                    reader.readAsText(file);
                } else {
                    resolve(null);
                }
                lrcInput.removeEventListener('change', handler);
                lrcInput.value = '';
            };
            lrcInput.addEventListener('change', handler);
            lrcInput.click();
        });
        if (lrcContent !== null) {
            musicState.playlist[index].lrcContent = lrcContent;
            await saveGlobalPlaylist();
            alert('歌词导入成功！');
            if (musicState.currentIndex === index) {
                musicState.parsedLyrics = parseLRC(lrcContent);
                renderLyrics();
            }
        }
    }
});

document.querySelector('.progress-bar').addEventListener('click', (e) => {
    if (!audioPlayer.duration) return;
    const progressBar = e.currentTarget;
    const barWidth = progressBar.clientWidth;
    const clickX = e.offsetX;
    audioPlayer.currentTime = (clickX / barWidth) * audioPlayer.duration;
});

// ▼▼▼ 在 init() 函数的事件监听器区域，粘贴这段新代码 ▼▼▼

// 使用事件委托来处理所有“已撤回消息”的点击事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 检查被点击的元素或其父元素是否是“已撤回”提示
    const placeholder = e.target.closest('.recalled-message-placeholder');
    if (!placeholder) return; // 如果不是，就退出

    // 如果是，就从聊天记录中找到对应的数据并显示
    const chat = state.chats[state.activeChatId];
    const wrapper = placeholder.closest('.message-wrapper'); // 找到它的父容器
    if (chat && wrapper) {
        // 从父容器上找到时间戳
        const timestamp = parseInt(wrapper.dataset.timestamp);
        const recalledMsg = chat.history.find(m => m.timestamp === timestamp);
        
        if (recalledMsg && recalledMsg.recalledData) {
            let originalContentText = '';
            const recalled = recalledMsg.recalledData;
            
            if (recalled.originalType === 'text') {
                originalContentText = `原文: "${recalled.originalContent}"`;
            } else {
                originalContentText = `撤回了一条[${recalled.originalType}]类型的消息`;
            }
            showCustomAlert('已撤回的消息', originalContentText);
        }
    }
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 的事件监听器区域，粘贴这段新代码 ▼▼▼
document.getElementById('manage-world-book-categories-btn').addEventListener('click', openCategoryManager);
document.getElementById('close-category-manager-btn').addEventListener('click', () => {
    document.getElementById('world-book-category-manager-modal').classList.remove('visible');
    renderWorldBookScreen(); // 关闭后刷新主列表
});
document.getElementById('add-new-category-btn').addEventListener('click', addNewCategory);
document.getElementById('existing-categories-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) {
        const categoryId = parseInt(e.target.dataset.id);
        deleteCategory(categoryId);
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

        // ===================================================================
        // 5. 启动！
            
            showScreen('home-screen');
        }

        init();
    });
</script>
</body>
</html>